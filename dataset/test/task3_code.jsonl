{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint embarrel_mists = 0;\nint global_variable;\ntypedef char *puschkinia_alternamente;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid khir_shellans(int spermatin_codfisheries,puschkinia_alternamente daimonology_diores);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int zelazny_babar = 7;\n  puschkinia_alternamente entry_hermitages = 0;\n  long philobiblic_flybelts[10];\n  puschkinia_alternamente coadunating_jussives[10] = {0};\n  puschkinia_alternamente donnelly_unvaulted = 0;\n  char *quadruplicating_pictores;;\n  if (__sync_bool_compare_and_swap(&embarrel_mists,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      quadruplicating_pictores = getenv(\"BACCALAUREATES_OUTFFED\");\n      if (quadruplicating_pictores != 0) {;\n        donnelly_unvaulted = quadruplicating_pictores;\n        coadunating_jussives[5] = donnelly_unvaulted;\n        philobiblic_flybelts[1] = 5;\n        entry_hermitages =  *(coadunating_jussives + philobiblic_flybelts[1]);\n        khir_shellans(zelazny_babar,entry_hermitages);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid khir_shellans(int spermatin_codfisheries,puschkinia_alternamente daimonology_diores)\n{\n    int oc_i = 0;\n    int opt_var;\n    char source[1024];\n    char * buffer;\n  char *praetorian_unapprisedness = 0;\n  ++global_variable;\n  spermatin_codfisheries--;\n  if (spermatin_codfisheries > 0) {\n    khir_shellans(spermatin_codfisheries,daimonology_diores);\n    return ;\n  }\n  praetorian_unapprisedness = ((char *)daimonology_diores);\n    \n    buffer = (char*) malloc (sizeof(char*) * 64);\n    if (buffer != NULL) {\n        memset(source, 0, 1024);\n        memset(buffer, 65, 64);\n        buffer[64 - 1] = '\\0';\n        strncpy(source, praetorian_unapprisedness, sizeof(source));\n        source[1023] = '\\0';\n        if (strlen(source) + 1 <= 64) {\n            \n            \n            \n            \n            \n            \n            strncpy(buffer, source, sizeof(source));\n            \n            \n        }\n        opt_var = strlen(buffer);\n        for (; oc_i < opt_var; ++oc_i) {\n            buffer[oc_i] =\n                toupper(buffer[oc_i]);\n        }\n        printf(\"%s\\n\", buffer);\n        free(buffer);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "strncpy buffer source sizeof", "cwe": "806", "idx": "152907"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint debbra_castigative = 0;\nint global_variable;\n\nunion cavicorn_tuggingly \n{\n  char *unworminess_simplifiedly;\n  double export_circumambiency;\n  char *feltlike_berycoidei;\n  char comus_coquetting;\n  int baulking_reach;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunion cavicorn_tuggingly uncivilly_charwoman(union cavicorn_tuggingly unpark_overconcerning);\nvoid methide_babbitt(union cavicorn_tuggingly largess_genealogically);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n#define ALESIA_APPENZELL(x) methide_babbitt((union cavicorn_tuggingly) x)\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  union cavicorn_tuggingly zafree_repeddle = {0};\n  union cavicorn_tuggingly diatribist_sumer;\n  char *crowkeeper_alleghenies;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&debbra_castigative,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&crowkeeper_alleghenies,\"ACROPOLIS_MASHY\");\n      if (crowkeeper_alleghenies != 0) {;\n        diatribist_sumer . unworminess_simplifiedly = crowkeeper_alleghenies;\n        zafree_repeddle = uncivilly_charwoman(diatribist_sumer);\n\tALESIA_APPENZELL(zafree_repeddle);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nunion cavicorn_tuggingly uncivilly_charwoman(union cavicorn_tuggingly unpark_overconcerning)\n{\n  ++global_variable;\n  return unpark_overconcerning;\n}\n\nvoid methide_babbitt(union cavicorn_tuggingly largess_genealogically)\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *demidevil_sennets = 0;\n  ++global_variable;;\n  demidevil_sennets = ((char *)largess_genealogically . unworminess_simplifiedly);\n    \n    taint_size = strlen(demidevil_sennets);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,demidevil_sennets,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n  if (largess_genealogically . unworminess_simplifiedly != 0) \n    free(((char *)largess_genealogically . unworminess_simplifiedly));\nclose_printf_context();\n}", "answer": "error 12 ss_i errno malloc malloced_buff n char trace_flag Malloc ulimit taint_size due to 0 sizeof", "cwe": "401", "idx": "151998"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint spiffing_tilyer = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    int ss_i = 0;\n    char* heap_buff_64;\n    int buff_size;\n  char *lamentedly_geulincx = 0;\n  char *talco_matfellon = 0;\n  long autoantibody_penalizes[10];\n  char *lorrimor_stereoed[10] = {0};\n  int intertissue_preemptor = 596;\n  char *yucking_gelatinised;;\n  if (__sync_bool_compare_and_swap(&spiffing_tilyer,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&yucking_gelatinised,\"5575\",intertissue_preemptor);\n      if (yucking_gelatinised != 0) {;\n        lorrimor_stereoed[5] = yucking_gelatinised;\n        autoantibody_penalizes[1] = 5;\n        talco_matfellon =  *(lorrimor_stereoed + autoantibody_penalizes[1]);\n        if (talco_matfellon != 0) {\n          goto unaway_armbruster;\n        }\n        ++global_variable;\n        unaway_armbruster:;\n        lamentedly_geulincx = ((char *)talco_matfellon);\n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    \n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64,'A',63);\n        heap_buff_64[63] = '\\0';\n        \n        buff_size = ((int )(strlen(lamentedly_geulincx)));\n        strncpy(heap_buff_64, lamentedly_geulincx, 64);\n        \n        \n        \n        for (; ss_i < buff_size; ++ss_i){\n            \n            \n            printf(\"%02x\",heap_buff_64[ss_i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( heap_buff_64);\n        \n        \n    }\n;\n        if (talco_matfellon != 0) \n          free(((char *)talco_matfellon));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "ss_i 02x buff_size heap_buff_64", "cwe": "126", "idx": "153002"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint scene_unplank = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *reverdure_fecaloid = 0;\n  jmp_buf bethanks_abaze;\n  int ideational_whinchats;\n  int salten_obvolution;\n  void **beatty_sideswiped = 0;\n  void **vimpa_emballonurid = 0;\n  void *roseville_npv = 0;\n  int hithermost_chigoe = 45;\n  char *selenographic_flamy;;\n  if (__sync_bool_compare_and_swap(&scene_unplank,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&selenographic_flamy,\"4453\",hithermost_chigoe);\n      if (selenographic_flamy != 0) {;\n        roseville_npv = ((void *)selenographic_flamy);\n        salten_obvolution = 1;\n        beatty_sideswiped = &roseville_npv;\n        vimpa_emballonurid = ((void **)(((unsigned long )beatty_sideswiped) * salten_obvolution * salten_obvolution)) + 5;\n        ideational_whinchats = setjmp(bethanks_abaze);\n        if (ideational_whinchats == 0) {\n          longjmp(bethanks_abaze,1);\n        }\n        reverdure_fecaloid = ((char *)((char *)( *(vimpa_emballonurid - 5))));\n  \n  \n  csv = fopen(reverdure_fecaloid,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\n        if (((char *)( *(vimpa_emballonurid - 5))) != 0) \n          free(((char *)((char *)( *(vimpa_emballonurid - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "", "cwe": "476", "idx": "149724"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint ordinariness_oxysomes = 0;\n\nunion unrealities_jewelhouse \n{\n  char *thalamophora_carenton;\n  double dhaka_neukam;\n  char *pratincole_countrieman;\n  char preimitated_keratomycosis;\n  int feminine_hup;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *folliculous_vamped = 0;\n  int rifton_cheerio;\n  int settimo_bassness;\n  int blastemata_gda;\n  union unrealities_jewelhouse *hld_overproudly = {0};\n  union unrealities_jewelhouse *nematognath_gracy = {0};\n  union unrealities_jewelhouse attical_beswelter;\n  int desterilize_onychium = 63;\n  char *prebroadcasting_auxiliation;;\n  if (__sync_bool_compare_and_swap(&ordinariness_oxysomes,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&prebroadcasting_auxiliation,\"1313\",desterilize_onychium);\n      if (prebroadcasting_auxiliation != 0) {;\n        attical_beswelter . thalamophora_carenton = prebroadcasting_auxiliation;\n        blastemata_gda = 1;\n        hld_overproudly = &attical_beswelter;\n        nematognath_gracy = ((union unrealities_jewelhouse *)(((unsigned long )hld_overproudly) * blastemata_gda * blastemata_gda)) + 5;\n        settimo_bassness = 5;\n        while(1 == 1){\n          settimo_bassness = settimo_bassness * 2;\n          settimo_bassness = settimo_bassness + 2;\n          if (settimo_bassness > 1000) {\n            break; \n          }\n        }\n        rifton_cheerio = settimo_bassness;\n        folliculous_vamped = ((char *)( *(nematognath_gracy - 5)) . thalamophora_carenton);\n      \n      while(isalnum(folliculous_vamped[size]) && size < strlen(folliculous_vamped)){\n        ++size;\n      }\n      \n\n      if (size != strlen(folliculous_vamped)) {\n        folliculous_vamped = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,folliculous_vamped);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n        if (( *(nematognath_gracy - 5)) . thalamophora_carenton != 0) \n          free(((char *)( *(nematognath_gracy - 5)) . thalamophora_carenton));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "strlen folliculous_vamped", "cwe": "476", "idx": "149404"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint slacker_zima = 0;\nint global_variable;\ntypedef char *tzetse_nonpyogenic;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid jiggish_metoxenous(const tzetse_nonpyogenic shuln_jacobina);\nvoid quisquilious_idiorrhythmy(int underplant_rotatoplane,tzetse_nonpyogenic emmenthal_unawakenedness);\nstruct struct {\n    void (*function_ptr_1)();\n    unsigned int input_num;\n    void (*function_ptr_2)();\n};\nvoid function() {\n    \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  tzetse_nonpyogenic tullibee_infixed = 0;\n  int glancer_prosopantritis = 7;\n  char *gozell_blunt;;\n  if (__sync_bool_compare_and_swap(&slacker_zima,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&gozell_blunt,\"1380\",glancer_prosopantritis);\n      if (gozell_blunt != 0) {;\n        tullibee_infixed = gozell_blunt;\n        jiggish_metoxenous(tullibee_infixed);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid jiggish_metoxenous(const tzetse_nonpyogenic shuln_jacobina)\n{\n  int eshin_lipolyses = 7;\n  ++global_variable;;\n  quisquilious_idiorrhythmy(eshin_lipolyses,shuln_jacobina);\n}\n\nvoid quisquilious_idiorrhythmy(int underplant_rotatoplane,tzetse_nonpyogenic emmenthal_unawakenedness)\n{\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned int *ptr = 0;\n    struct struct ssS;\n  char *maidu_launched = 0;\n  ++global_variable;\n  underplant_rotatoplane--;\n  if (underplant_rotatoplane > 0) {\n    quisquilious_idiorrhythmy(underplant_rotatoplane,emmenthal_unawakenedness);\n    return ;\n  }\n  maidu_launched = ((char *)((tzetse_nonpyogenic )emmenthal_unawakenedness));\n    \n    ssS.function_ptr_1 = function;\n    ssS.function_ptr_2 = function;\n    if (strlen(maidu_launched) >= 1 &&\n            maidu_launched[0] != '-') {\n        ssS.input_num = strtoul(maidu_launched,0U,16);\n        ptr = &(ssS.input_num);\n        if ( *ptr > 65535) {\n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n        }\n        \n        \n        ssS.function_ptr_2();\n        \n        printf(\"Value = %i\\n\", ssS.input_num);\n    } else if (strlen(maidu_launched) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n  if (((tzetse_nonpyogenic )emmenthal_unawakenedness) != 0) \n    free(((char *)((tzetse_nonpyogenic )emmenthal_unawakenedness)));\nclose_printf_context();\n}", "answer": "", "cwe": "682", "idx": "151132"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint upalong_stifflike = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct struct {\n    char base_path[20];\n    char * buff_pointer;\n};\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n    int oc_i = 0;\n    int opt_var = 0;\n    struct struct* data = 0;\n  char *merciable_ondoscope = 0;\n  char *yeo_obus = 0;\n  int *reattain_sarcast = 0;\n  int designatum_convoke;\n  char *unaffecting_verbalised[10] = {0};\n  int strawy_jesuist = 0;\n  char *conidiophorous_paraebius = 0;\n  int luny_dungan = 20;\n  char *alehoof_nagualism;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&upalong_stifflike,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&alehoof_nagualism,\"8966\",luny_dungan);\n      if (alehoof_nagualism != 0) {;\n        strawy_jesuist = ((int )(strlen(alehoof_nagualism)));\n        conidiophorous_paraebius = ((char *)(malloc(strawy_jesuist + 1)));\n        if (conidiophorous_paraebius == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(conidiophorous_paraebius,0,strawy_jesuist + 1);\n        memcpy(conidiophorous_paraebius,alehoof_nagualism,strawy_jesuist);\n        if (alehoof_nagualism != 0) \n          free(((char *)alehoof_nagualism));\n        unaffecting_verbalised[5] = conidiophorous_paraebius;\n        designatum_convoke = 5;\n        reattain_sarcast = &designatum_convoke;\n        yeo_obus =  *(unaffecting_verbalised +  *reattain_sarcast);\n        merciable_ondoscope = ((char *)yeo_obus);\n    \n    if (strlen(merciable_ondoscope) < 20) {;\n        data = (struct struct*) malloc (sizeof(struct struct));\n        if (data != NULL) {\n            memset(data->base_path, 0, 20);\n            data->buff_pointer = data->base_path;\n            \n            \n\n\n            realpath(merciable_ondoscope, data->base_path);\n            opt_var = strlen( data->buff_pointer);\n            \n            for (; oc_i < opt_var; ++oc_i) {\n                data->base_path[oc_i] =\n                    toupper(data->base_path[oc_i]);\n            }\n            printf(\"%s\\n\", data->base_path);\n            printf(\"%s\\n\", data->buff_pointer);\n            \n            \n            free (data);\n        }\n    }\n    \n;\n        if (yeo_obus != 0) \n          free(((char *)yeo_obus));\nclose_printf_context();\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}", "answer": "realpath toupper strlen data oc_i n buff_pointer s merciable_ondoscope base_path opt_var", "cwe": "785", "idx": "152906"}
{"code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint yeargain_archsaint = 0;\nint global_variable;\nvoid handle_taint(char *pennigerous_gemellione);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&yeargain_archsaint,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *pennigerous_gemellione)\n{\n int ss_i = 0;\n  char *soutar_coverts = 0;\n  ++global_variable;;\n  if (pennigerous_gemellione != 0) {;\n    if (pennigerous_gemellione != 0) {\n      goto imbrangling_dfrf;\n    }\n    ++global_variable;\n    imbrangling_dfrf:;\n    soutar_coverts = ((char *)pennigerous_gemellione);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(soutar_coverts)){\n  \n        if (soutar_coverts[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\n    if (pennigerous_gemellione != 0) \n      free(((char *)pennigerous_gemellione));\nclose_printf_context();\n  }\n}", "answer": "strlen ss_i 48 soutar_coverts", "cwe": "835", "idx": "152049"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint counterdraft_tanta = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid guinean_eto(char *const alehouse_ligula);\nvoid reelsville_underswamp(int phytophagic_mesopodial,char *solea_aethylla);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  int cavern_bivouacked = 1600;\n  char *carphiophiops_artukovic;;\n  if (__sync_bool_compare_and_swap(&counterdraft_tanta,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&carphiophiops_artukovic,\"7946\",cavern_bivouacked);\n      if (carphiophiops_artukovic != 0) {;\n        guinean_eto(carphiophiops_artukovic);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid guinean_eto(char *const alehouse_ligula)\n{\n  int confirmations_auguster = 7;\n  ++global_variable;;\n  reelsville_underswamp(confirmations_auguster,alehouse_ligula);\n}\n\nvoid reelsville_underswamp(int phytophagic_mesopodial,char *solea_aethylla)\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *sarrazin_plagiostomatous = 0;\n  ++global_variable;\n  phytophagic_mesopodial--;\n  if (phytophagic_mesopodial > 0) {\n    reelsville_underswamp(phytophagic_mesopodial,solea_aethylla);\n    return ;\n  }\n  sarrazin_plagiostomatous = ((char *)((char *)solea_aethylla));\n    \n    taint_size = strlen(sarrazin_plagiostomatous);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,sarrazin_plagiostomatous,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n  if (((char *)solea_aethylla) != 0) \n    free(((char *)((char *)solea_aethylla)));\nclose_printf_context();\n}", "answer": "error 12 ss_i errno malloc malloced_buff n char trace_flag Malloc ulimit taint_size due to 0 sizeof", "cwe": "401", "idx": "151485"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint zag_chavel = 0;\ntypedef char *faciocervical_ganglial;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *anticontagion_ribwort = 0;\n  jmp_buf aerialness_preoverthrew;\n  int bronwen_denotate;\n  faciocervical_ganglial **********botanically_hinnites = 0;\n  faciocervical_ganglial *********highschool_unwakefully = 0;\n  faciocervical_ganglial ********perioplic_skimpier = 0;\n  faciocervical_ganglial *******chanhassen_preinflict = 0;\n  faciocervical_ganglial ******hesitatively_urogenic = 0;\n  faciocervical_ganglial *****actuaryship_palingeny = 0;\n  faciocervical_ganglial ****horatian_scaphopod = 0;\n  faciocervical_ganglial ***longly_normannic = 0;\n  faciocervical_ganglial **sporotrichosis_beghard = 0;\n  faciocervical_ganglial *thickbrained_bomont = 0;\n  faciocervical_ganglial macrocosms_sourdoughs = 0;\n  faciocervical_ganglial sortlige_meths = 0;\n  char *northman_blackberrylike;;\n  if (__sync_bool_compare_and_swap(&zag_chavel,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      northman_blackberrylike = getenv(\"DELIMITED_LOTIS\");\n      if (northman_blackberrylike != 0) {;\n        sortlige_meths = northman_blackberrylike;\n        thickbrained_bomont = &sortlige_meths;\n        sporotrichosis_beghard = &thickbrained_bomont;\n        longly_normannic = &sporotrichosis_beghard;\n        horatian_scaphopod = &longly_normannic;\n        actuaryship_palingeny = &horatian_scaphopod;\n        hesitatively_urogenic = &actuaryship_palingeny;\n        chanhassen_preinflict = &hesitatively_urogenic;\n        perioplic_skimpier = &chanhassen_preinflict;\n        highschool_unwakefully = &perioplic_skimpier;\n        botanically_hinnites = &highschool_unwakefully;\n        bronwen_denotate = setjmp(aerialness_preoverthrew);\n        if (bronwen_denotate == 0) {\n          longjmp(aerialness_preoverthrew,1);\n        }\n        anticontagion_ribwort = ((char *)( *( *( *( *( *( *( *( *( *( *botanically_hinnites)))))))))));\n      \n      len = strtol(anticontagion_ribwort,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "i len values 0", "cwe": "476", "idx": "149778"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint corojo_physicist = 0;\nint global_variable;\n\nunion amphipyrenin_winthrop \n{\n  char *tenderish_recarbon;\n  double squatting_holds;\n  char *letterman_ulnage;\n  char ectopistes_catamiting;\n  int kolhoz_vire;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized);\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless);\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie);\nint toupper(int c) {\n    if (c >= 97 && c <= 122) {\n        return c - 32;\n    }\n    return c;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  union amphipyrenin_winthrop beaners_thickbrained;\n  int sieracki_zebec = 1001;\n  char *methodism_boogers;;\n  if (__sync_bool_compare_and_swap(&corojo_physicist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&methodism_boogers,\"5759\",sieracki_zebec);\n      if (methodism_boogers != 0) {;\n        beaners_thickbrained . tenderish_recarbon = methodism_boogers;\n        chaffinch_preventuring(beaners_thickbrained);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized)\n{\n  int surefooted_antonomastic = 7;\n  ++global_variable;;\n  cento_waterhorse(surefooted_antonomastic,cognizes_abolitionized);\n}\n\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless)\n{\n    int oc_i = 0;\n char stack_buffer_64[64];\n  char *sulfato_minipanic = 0;\n  ++global_variable;\n  cicatrices_pyridazine--;\n  if (cicatrices_pyridazine > 0) {\n    dictyopteran_guttering(cicatrices_pyridazine,slappers_fibreless);\n    return ;\n  }\n  sulfato_minipanic = ((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon);\n    \n memset(stack_buffer_64,0,64);\n    \n    \n    \n    \n \n strcpy(stack_buffer_64,sulfato_minipanic);\n    \n    \n    \n    for (; oc_i < 64; ++oc_i) {\n        stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\n    }\n    \n    \n printf(\"%s\\n\",stack_buffer_64);\n    \n    \n    \n    \n;\n  if (((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon != 0) \n    free(((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon));\nclose_printf_context();\n}\n\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie)\n{\n  ++global_variable;\n  cento_waterhorse(sympossia_criophorus,sardoin_malanie);\n}", "answer": "", "cwe": "120", "idx": "153715"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint ccnc_heteroproteose = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid weltanschauung_tenuously(int hagiarchy_lovash,char **wisewoman_preappearances);\nstruct data_struct {\n  int (*func_member)(char *);\n  char *str_member;\n};\nint modulus_function(char *modulus_param_str)\n{\n  \n  return modulus_param_str[0] % 2;\n}\nvoid set_function(char *set_param_str,struct data_struct *set_param_data_struct)\n{\n  \n  \n\n  if (strlen(set_param_str) > 10U) {\n    set_param_data_struct -> func_member = modulus_function;\n    set_param_data_struct -> str_member = set_param_str;\n    \n  }\n  if (strlen(set_param_str) < 10U) {\n    set_param_data_struct -> func_member = modulus_function;\n    set_param_data_struct -> str_member = \"default\";\n    \n  }\n  \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  int redon_serpentcleide = 7;\n  char **enounced_unsainted = 0;\n  char **ravenelia_arsenites = 0;\n  char *morigerous_carabus;;\n  if (__sync_bool_compare_and_swap(&ccnc_heteroproteose,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      morigerous_carabus = getenv(\"JOEY_PREROGATIVED\");\n      if (morigerous_carabus != 0) {;\n        enounced_unsainted = &morigerous_carabus;\n        ravenelia_arsenites = enounced_unsainted + 5;\n        weltanschauung_tenuously(redon_serpentcleide,ravenelia_arsenites);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid weltanschauung_tenuously(int hagiarchy_lovash,char **wisewoman_preappearances)\n{\n    int val = 0;\n    struct data_struct my_foo;\n  char *retaining_halakah = 0;\n  ++global_variable;\n  hagiarchy_lovash--;\n  if (hagiarchy_lovash > 0) {\n    weltanschauung_tenuously(hagiarchy_lovash,wisewoman_preappearances);\n    return ;\n  }\n  retaining_halakah = ((char *)( *(wisewoman_preappearances - 5)));\n    \n    if (strlen(retaining_halakah) < 1) {\n        printf(\"string is too short to test\\n\");\n    } else {\n        set_function(retaining_halakah, &my_foo);\n        \n        \n        val = (my_foo . func_member(my_foo . str_member));\n        \n        if (val == 0)\n            printf(\"mod is true\\n\");\n        else\n            printf(\"mod is false\\n\");\n    }\n    \n;\nclose_printf_context();\n}", "answer": "func_member str_member", "cwe": "824", "idx": "153398"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <unistd.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint wrongheartedly_babroot = 0;\nint global_variable;\n\nunion theaceae_almadie \n{\n  char *leucoid_haapsalu;\n  double iter_tibiopopliteal;\n  char *traneen_salesin;\n  char bescorch_superman;\n  int polykaryocyte_lionet;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid whelve_totalling(union theaceae_almadie zaboglione_afterstorm);\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        \n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        \n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        \n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\nint isSymLink(char *file) {\n    struct stat statbuf;\n    \n    if (lstat(file, &statbuf) < 0) { \n        printf(\"Error accessing path.\\n\");\n        return 1; \n    }\n    if (S_ISLNK(statbuf.st_mode) == 1) {\n        printf(\"Path is symlink.\\n\");\n        return 1;\n    }\n    printf(\"Path is valid.\\n\");\n    return 0;\n}\nint path_is_not_symlink(char * abs_path) {\n    \n    return (isSymLink(abs_path) == 0);\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  void (*resupination_dermotropic)(union theaceae_almadie ) = whelve_totalling;\n  union theaceae_almadie resthouse_blurrier = {0};\n  int *thebaines_livor = 0;\n  int eleutheri_hoplonemertea;\n  union theaceae_almadie supernormality_overgrazed[10] = {0};\n  union theaceae_almadie neocyte_becomingness;\n  int malacopodous_bunchily = 50;\n  char *sledgemeter_librarian;;\n  if (__sync_bool_compare_and_swap(&wrongheartedly_babroot,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&sledgemeter_librarian,\"4009\",malacopodous_bunchily);\n      if (sledgemeter_librarian != 0) {;\n        neocyte_becomingness . leucoid_haapsalu = sledgemeter_librarian;\n        supernormality_overgrazed[5] = neocyte_becomingness;\n        eleutheri_hoplonemertea = 5;\n        thebaines_livor = &eleutheri_hoplonemertea;\n        resthouse_blurrier =  *(supernormality_overgrazed +  *thebaines_livor);\n        resupination_dermotropic(resthouse_blurrier);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid whelve_totalling(union theaceae_almadie zaboglione_afterstorm)\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *joffre_strapwort = 0;\n  ++global_variable;;\n  joffre_strapwort = ((char *)zaboglione_afterstorm . leucoid_haapsalu);\n    \n    str = malloc(sizeof(char) * (strlen(joffre_strapwort) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(joffre_strapwort) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(joffre_strapwort, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n                if (path_is_not_symlink(abs_path)) {\n                    \n                    \n                    waitForChange(abs_path, sleep_file);\n                    file = fopen(abs_path,\"rb\");\n                    \n                    if (file != 0) {\n                        fseek(file,0,2);\n                        size = ftell(file);\n                        rewind(file);\n                        buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                        if (buffer) {\n                            \n                            \n                            fread(buffer,sizeof(char ),size,file);\n                            buffer[size] = '\\0';\n                            printf(buffer);\n                            fclose(file);\n                            free(buffer);\n                            \n                        }\n                    }\n                }\n                free (abs_path);\n            }\n        }\n        free(str);\n    } else {\n        \n        printf(\"Error parsing input.\\n\");\n    }\n;\n  if (zaboglione_afterstorm . leucoid_haapsalu != 0) \n    free(((char *)zaboglione_afterstorm . leucoid_haapsalu));\nclose_printf_context();\n}", "answer": "file", "cwe": "363", "idx": "150614"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint methodologist_algorist = 0;\n\nunion enflagellation_owly \n{\n  char *squirarchies_burdenable;\n  double weathers_truantship;\n  char *bilianic_beguin;\n  char saugerties_matchcoat;\n  int mumetal_retranscribed;\n}\n;\nint global_variable;\nvoid handle_taint(char *tribunate_phiona);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nunion enflagellation_owly roploch_yucatecan(union enflagellation_owly averrable_phlebology);\nvoid function() {\n    \n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&methodologist_algorist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *tribunate_phiona)\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *dehisced_leslee = 0;\n  union enflagellation_owly overmatureness_khitmatgar = {0};\n  union enflagellation_owly plowline_duma;\n  ++global_variable;;\n  if (tribunate_phiona != 0) {;\n    plowline_duma . squirarchies_burdenable = tribunate_phiona;\n    overmatureness_khitmatgar = roploch_yucatecan(plowline_duma);\n    if (overmatureness_khitmatgar . squirarchies_burdenable != 0) {\n      goto collocative_cutlerr;\n    }\n    ++global_variable;\n    collocative_cutlerr:;\n    dehisced_leslee = ((char *)overmatureness_khitmatgar . squirarchies_burdenable);\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(dehisced_leslee) >= 1 &&\n            dehisced_leslee[0] != '-') {\n        input_num = strtoul(dehisced_leslee,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(dehisced_leslee) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n    if (overmatureness_khitmatgar . squirarchies_burdenable != 0) \n      free(((char *)overmatureness_khitmatgar . squirarchies_burdenable));\nclose_printf_context();\n  }\n}\n\nunion enflagellation_owly roploch_yucatecan(union enflagellation_owly averrable_phlebology)\n{\n  ++global_variable;\n  return averrable_phlebology;\n}\n#endif", "answer": "", "cwe": "682", "idx": "150968"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint scase_theorizies = 0;\nint global_variable;\nvoid airstrip_tuneless(char **anklong_unseductively);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid palpitatingly_camuning(void (*kottigite_loop)(char **));\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&scase_theorizies,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      palpitatingly_camuning(airstrip_tuneless);\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid airstrip_tuneless(char **anklong_unseductively)\n{\n  char *skyborne_rhuses;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&skyborne_rhuses,\"SEAWORTHINESS_COMMUNIONIST\");\n  if (skyborne_rhuses != 0) {;\n     *anklong_unseductively = skyborne_rhuses;\n  }\n}\n\nvoid palpitatingly_camuning(void (*kottigite_loop)(char **))\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *fringilloid_solutions = 0;\n  char **patriolatry_arecaceae = 0;\n  char **idiodynamic_cock = 0;\n  ++global_variable;\n  char *prereveal_morris = 0;\n  kottigite_loop(&prereveal_morris);\n  if (prereveal_morris != 0) {;\n    patriolatry_arecaceae = &prereveal_morris;\n    idiodynamic_cock = patriolatry_arecaceae + 5;\n    fringilloid_solutions = ((char *)( *(idiodynamic_cock - 5)));\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(fringilloid_solutions) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(fringilloid_solutions) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(fringilloid_solutions) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(fringilloid_solutions, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\n    if ( *(idiodynamic_cock - 5) != 0) \n      free(((char *)( *(idiodynamic_cock - 5))));\nclose_printf_context();\n  }\n}", "answer": "dataStruct data 1 inc_amount 0", "cwe": "820", "idx": "150458"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint reba_brussel = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid trilloes_arranger(char **arterialization_jebel);\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  void (*unwarely_carbin)(char **) = trilloes_arranger;\n  char **cancers_vesuvian = 0;\n  char **lum_ammocoetoid = 0;\n  int thalian_malleating = 0;\n  char *preciosities_protomorph = 0;\n  char *magnetons_ice;;\n  if (__sync_bool_compare_and_swap(&reba_brussel,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&magnetons_ice,\"WESKER_ZAPS\");\n      if (magnetons_ice != 0) {;\n        thalian_malleating = ((int )(strlen(magnetons_ice)));\n        preciosities_protomorph = ((char *)(malloc(thalian_malleating + 1)));\n        if (preciosities_protomorph == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(preciosities_protomorph,0,thalian_malleating + 1);\n        memcpy(preciosities_protomorph,magnetons_ice,thalian_malleating);\n        if (magnetons_ice != 0) \n          free(((char *)magnetons_ice));\n        cancers_vesuvian = &preciosities_protomorph;\n        lum_ammocoetoid = cancers_vesuvian + 5;\n        unwarely_carbin(lum_ammocoetoid);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid trilloes_arranger(char **arterialization_jebel)\n{\n char *buffer = 0;\n  char *temesv_threefolded = 0;\n  ++global_variable;;\n  temesv_threefolded = ((char *)( *(arterialization_jebel - 5)));\n    \n    buffer = malloc((strlen(temesv_threefolded) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,temesv_threefolded);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n  if ( *(arterialization_jebel - 5) != 0) \n    free(((char *)( *(arterialization_jebel - 5))));\nclose_printf_context();\n}\n#endif", "answer": "buffer", "cwe": "415", "idx": "153245"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint honorariums_missourian = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid capman_gape(char **nonrendition_barotseland);\nvoid facemark_counterlath(char **vergences_impassionedness);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  char **neither_stepping = 0;\n  char *effectualize_wizardly = 0;\n  char *schmelzes_subglabrous;;\n  if (__sync_bool_compare_and_swap(&honorariums_missourian,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      schmelzes_subglabrous = getenv(\"HOROLOGIUM_HEIGHTENING\");\n      if (schmelzes_subglabrous != 0) {;\n        neither_stepping = &schmelzes_subglabrous;\n        capman_gape(neither_stepping);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid capman_gape(char **nonrendition_barotseland)\n{\n  ++global_variable;;\n  facemark_counterlath(nonrendition_barotseland);\n}\n\nvoid facemark_counterlath(char **vergences_impassionedness)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *dischase_stanks = 0;\n  ++global_variable;;\n  dischase_stanks = ((char *)( *vergences_impassionedness));\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(dischase_stanks) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (dischase_stanks[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &dischase_stanks[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\nclose_printf_context();\n}\n#endif", "answer": "strlen i n second_buff", "cwe": "476", "idx": "149480"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint placoderm_gynecomaniac = 0;\n\nunion subrogating_nonlevel \n{\n  char *lambitive_uredos;\n  double pending_paeonin;\n  char *adieu_cappadocian;\n  char obli_gammiest;\n  int unseductively_modigliani;\n}\n;\nint global_variable;\nvoid handle_taint(char *camises_subaxillar);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&placoderm_gynecomaniac,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *camises_subaxillar)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  int random_int = 0;\n  char *crewet_dutchmen = 0;\n  union subrogating_nonlevel britannically_jesu;\n  ++global_variable;;\n  if (camises_subaxillar != 0) {;\n    britannically_jesu . lambitive_uredos = camises_subaxillar;\n    crewet_dutchmen = ((char *)britannically_jesu . lambitive_uredos);\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n    srand(time(NULL));\n    random_int = (rand() % 1000) + 100;\n                snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, crewet_dutchmen);\n    \n                \n                \n\n                if (mysql_query(conn,query_buffer)) {\n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n    } else {\n      printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n    if (britannically_jesu . lambitive_uredos != 0) \n      free(((char *)britannically_jesu . lambitive_uredos));\nclose_printf_context();\n  }\n}", "answer": "query_buffer s", "cwe": "89", "idx": "152478"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint breakwaters_colorific = 0;\nint global_variable;\nvoid handle_taint(char *cubicone_zippering);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&breakwaters_colorific,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *cubicone_zippering)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *compotation_urinary = 0;\n  char *meritmonger_alkahests = 0;\n  long psychosurgeon_maycock[10];\n  char *sharma_arch[10] = {0};\n  ++global_variable;;\n  if (cubicone_zippering != 0) {;\n    sharma_arch[5] = cubicone_zippering;\n    psychosurgeon_maycock[1] = 5;\n    meritmonger_alkahests =  *(sharma_arch + psychosurgeon_maycock[1]);\n    compotation_urinary = ((char *)meritmonger_alkahests);\n    \n    if (strlen(compotation_urinary) > 0 &&\n            compotation_urinary[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(compotation_urinary,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n    if (meritmonger_alkahests != 0) \n      free(((char *)meritmonger_alkahests));\nclose_printf_context();\n  }\n}", "answer": "f w fopen filename_param", "cwe": "774", "idx": "152164"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint amyrol_reintrude = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid debatter_lawproof(char **const richers_recusancy);\nvoid drepanaspis_veneti(char **beele_volatilized);\nint toupper(int c) {\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nvoid free_func(char *buff) {\n  \n  if (buff[0] >= 79) {\n    \n    \n    \n    \n    free(buff);\n    \n    \n  }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char *collineation_anatomising[84] = {0};\n  char *anticentralism_droner;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&amyrol_reintrude,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      anticentralism_droner = getenv(\"CARBOLXYLOL_NONPACIFICATORY\");\n      if (anticentralism_droner != 0) {;\n        collineation_anatomising[60] = anticentralism_droner;\n        debatter_lawproof(collineation_anatomising);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid debatter_lawproof(char **const richers_recusancy)\n{\n  ++global_variable;;\n  drepanaspis_veneti(richers_recusancy);\n}\n\nvoid drepanaspis_veneti(char **beele_volatilized)\n{\n int oc_i = 0;\n char function_buff[64];\n  char *uniatism_aplustra = 0;\n  ++global_variable;;\n  uniatism_aplustra = ((char *)((char **)beele_volatilized)[60]);\n    \n strncpy(function_buff,uniatism_aplustra,63);\n    function_buff[63] = '\\0';\n    for (; oc_i < 64; ++oc_i) {\n        function_buff[oc_i] = toupper(function_buff[oc_i]);\n    }\n    printf(\"%s\\n\",function_buff);\n    free_func(function_buff);\n    \n;\nclose_printf_context();\n}", "answer": "buff free", "cwe": "590", "idx": "153310"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint huskroot_burga = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid acute_multisacculate(char **extralite_staffelite);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int *arr;\n    \n    pthread_mutex_lock(&mutex);\n    readFile(cusData->file1);\n    arr = malloc(sizeof(int) * cusData->qsize);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    \n    \n    \n    \n    \n    for(i = 0; i < cusData->data_size; i++) {\n        \n        if (cusData->data[i] >= 'a' &&\n            cusData->data[i] <= 'z') { \n            cusData->data[i] -= 32;\n        }\n    }\n    \n    pthread_mutex_unlock(&mutex);\n    return NULL;\n}\nvoid *delNonAlpha (void *data) {\n    struct data *cusData = (struct data*) data;\n    int i = 0;\n    int j = 0;\n    char* temp = malloc(sizeof(char) * (cusData->data_size + 1));\n    \n    while(cusData->data[i] != '\\0') {\n        if((cusData->data[i] >= 'A' && cusData->data[i] <= 'Z') ||\n           (cusData->data[i] >= 'a' && cusData->data[i] <= 'z')) {\n            temp[j++] = cusData->data[i];\n        }\n        i++;\n    }\n    temp[j++] = '\\0';\n    cusData->data_size = j;\n    free(cusData->data);\n    \n    \n    cusData->data = NULL; \n    \n    \n    \n    \n    \n    readFile(cusData->file2);\n    cusData->data = temp;\n    \n    \n    \n    \n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  char **ciceronage_ruffo = 0;\n  int *bibliopegy_bme = 0;\n  int protatically_everhart;\n  char **graminifolious_coinstantaneity[10] = {0};\n  char *preston_subduer[55] = {0};\n  char *boulder_semistriated;;\n  if (__sync_bool_compare_and_swap(&huskroot_burga,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      boulder_semistriated = getenv(\"SMALM_TAGBANUA\");\n      if (boulder_semistriated != 0) {;\n        preston_subduer[46] = boulder_semistriated;\n        graminifolious_coinstantaneity[5] = preston_subduer;\n        protatically_everhart = 5;\n        bibliopegy_bme = &protatically_everhart;\n        ciceronage_ruffo =  *(graminifolious_coinstantaneity +  *bibliopegy_bme);\n        acute_multisacculate(ciceronage_ruffo);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid acute_multisacculate(char **extralite_staffelite)\n{\n    pthread_t t0, t1;\n    struct data *cusData;\n  char *subshrubby_imm = 0;\n  ++global_variable;;\n  subshrubby_imm = ((char *)extralite_staffelite[46]);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(subshrubby_imm) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(subshrubby_imm) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(subshrubby_imm) + 1));\n        if (cusData->data && cusData->file1 && cusData->file2) {\n            if ((sscanf(subshrubby_imm, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0))\n            {\n                \n                \n                \n                \n                if (pthread_mutex_init(&mutex, NULL) != 0) {\n                    printf(\"Mutex failed to initilize.\");\n                }\n                cusData->data_size = strlen(cusData->data);\n                \n                if (pthread_create(&t0, NULL, delNonAlpha, (void *)cusData) != 0) { \n                    printf(\"Error creating thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toCap, (void *)cusData) != 0) {\n                    printf(\"Error creating thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n                printf(\"After joins.\\n\");\n                pthread_mutex_destroy(&mutex);\n            } else {\n                printf(\"Error parsing input.\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "data cusData", "cwe": "414", "idx": "150604"}
{"code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint selenodonta_sponger = 0;\nint global_variable;\ntypedef char *propitiating_phociform;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid ackton_humphreys(int currencies_pickiest,propitiating_phociform *fellahin_gove);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  int podophyllum_melosa = 7;\n  propitiating_phociform *redisputed_gyratory = 0;\n  propitiating_phociform *yagourundi_nonpendency = 0;\n  propitiating_phociform relandscaping_incogitance = 0;\n  char *japanization_triformous;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&selenodonta_sponger,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      japanization_triformous = getenv(\"COINFINITE_MONOSOME\");\n      if (japanization_triformous != 0) {;\n        relandscaping_incogitance = japanization_triformous;\n        redisputed_gyratory = &relandscaping_incogitance;\n        yagourundi_nonpendency = redisputed_gyratory + 5;\n        ackton_humphreys(podophyllum_melosa,yagourundi_nonpendency);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n\nvoid ackton_humphreys(int currencies_pickiest,propitiating_phociform *fellahin_gove)\n{\n    int oc_i = 0;\n    char * data = 0;\n  char *cobstone_zostera = 0;\n  ++global_variable;\n  currencies_pickiest--;\n  if (currencies_pickiest > 0) {\n    ackton_humphreys(currencies_pickiest,fellahin_gove);\n    return ;\n  }\n  cobstone_zostera = ((char *)( *(fellahin_gove - 5)));\n    \n    data = (char*) malloc(8 * sizeof(char));\n    if (data != NULL) {\n        \n        \n        \n        \n        \n        strncpy(data, cobstone_zostera, strlen(cobstone_zostera) + 1);\n        for (; oc_i < strlen(data); ++oc_i) {\n            data[oc_i] = toupper(data[oc_i]);\n        }\n        printf(\"%s\\n\", data);\n        \n        \n        free(data);\n    }\n    \n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "strlen toupper data oc_i cobstone_zostera 1 n strncpy s", "cwe": "805", "idx": "153480"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \nint sulphamidate_rhiana = 0;\ntypedef char *lignitic_fulfulde;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    char *result = 0;\n    int random_int = 0;\n  char *aloeswood_magnificentness = 0;\n  lignitic_fulfulde *hexanchidae_bivittate = 0;\n  lignitic_fulfulde *covillager_adiz = 0;\n  lignitic_fulfulde hypophora_arrogance = 0;\n  char *anatifae_freestyler;;\n  if (__sync_bool_compare_and_swap(&sulphamidate_rhiana,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      anatifae_freestyler = getenv(\"FALERNIAN_ECOCIDES\");\n      if (anatifae_freestyler != 0) {;\n        hypophora_arrogance = anatifae_freestyler;\n        hexanchidae_bivittate = &hypophora_arrogance;\n        covillager_adiz = hexanchidae_bivittate + 5;\n        aloeswood_magnificentness = ((char *)( *(covillager_adiz - 5)));\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  srand(time(NULL));\n  random_int = (rand() % 1000) + 100;\n        snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, aloeswood_magnificentness);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n            \n            printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  result = PQcmdTuples(res);\n        printf(\"Query OK, %s rows affected\\n\",result);\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "INSERT s query", "cwe": "89", "idx": "152452"}
{"code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint bontebuck_kwhr = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nSize PMSignalShmemSize()\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *agglomerates_amyotrophia = 0;\n  jmp_buf laharpe_akaniaceae;\n  int dubber_xxii;\n  int docentship_bombycidae;\n  void **preexcusing_koller = 0;\n  void **paut_lost = 0;\n  void *swording_disciplinant = 0;\n  int nonvoluntary_humuslike = 61;\n  char *overkill_corday;\n  Size size;\n  if (__sync_bool_compare_and_swap(&bontebuck_kwhr,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&overkill_corday,\"6225\",nonvoluntary_humuslike);\n      if (overkill_corday != 0) {;\n        swording_disciplinant = ((void *)overkill_corday);\n        docentship_bombycidae = 1;\n        preexcusing_koller = &swording_disciplinant;\n        paut_lost = ((void **)(((unsigned long )preexcusing_koller) * docentship_bombycidae * docentship_bombycidae)) + 5;\n        dubber_xxii = setjmp(laharpe_akaniaceae);\n        if (dubber_xxii == 0) {\n          longjmp(laharpe_akaniaceae,1);\n        }\n        agglomerates_amyotrophia = ((char *)((char *)( *(paut_lost - 5))));\n    \n files = fopen(agglomerates_amyotrophia,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n        if (((char *)( *(paut_lost - 5))) != 0) \n          free(((char *)((char *)( *(paut_lost - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "w file_list ssi Fopen 1020 0 fputs errno 1 fscanf fopen ulimit due fflush filename error woohoo to 79s 24 n file files continue", "cwe": "775", "idx": "152148"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint laine_azerbaijanian = 0;\nint global_variable;\nvoid stoppering_crotesco(char **paeanism_xmas);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid roulette_flashbulb(void (*comagmatic_vhf)(char **));\nvoid cleanup(FILE **ptrs,int size)\n{\n  int i = 0;\n  \n  for (i = 0; i < size; i++) {\n    if (ptrs[i] != 0) {\n      fclose(ptrs[i]);\n    }\n  }\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&laine_azerbaijanian,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      roulette_flashbulb(stoppering_crotesco);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid stoppering_crotesco(char **paeanism_xmas)\n{\n  char *excitedness_hamitism;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&excitedness_hamitism,\"LURG_AUSCULTATION\");\n  if (excitedness_hamitism != 0) {;\n     *paeanism_xmas = excitedness_hamitism;\n  }\n}\n\nvoid roulette_flashbulb(void (*comagmatic_vhf)(char **))\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[10];\n char filename[80];\n  char *overinclining_sailflying = 0;\n  char *chasten_brandonville = 0;\n  long psammite_forkman[10];\n  char *organellae_thuluth[10] = {0};\n  ++global_variable;\n  char *boletic_pantagruelism = 0;\n  comagmatic_vhf(&boletic_pantagruelism);\n  if (boletic_pantagruelism != 0) {;\n    organellae_thuluth[5] = boletic_pantagruelism;\n    psammite_forkman[1] = 5;\n    chasten_brandonville =  *(organellae_thuluth + psammite_forkman[1]);\n    overinclining_sailflying = ((char *)chasten_brandonville);\n    \n files = fopen(overinclining_sailflying,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n            if (file == 0) {\n    if (file == 0 && errno == 24) {\n     printf(\"Fopen error due to ulimit\\n\");\n                }\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n   \n   file_list[ssi % 10] = file;\n   ssi++;\n        }\n        \n        \n    }\n    if (files != 0)\n        fclose(files);\n cleanup(file_list, ((ssi-1)%10)+1);\n    \n;\n    if (chasten_brandonville != 0) \n      free(((char *)chasten_brandonville));\nclose_printf_context();\n  }\n}", "answer": "w file_list ssi Fopen 1020 0 fputs 10 errno 1 fscanf fopen ulimit due fflush filename error woohoo 79s to 24 n file files continue", "cwe": "773", "idx": "151578"}
{"code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint unprosperously_fenerate = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n    int stack_size = 0;\n  char *pevely_interess = 0;\n  int stemmatiform_jawed;\n  char **wellton_dillon = 0;\n  char **subsequentness_sugent = 0;\n  int wilfully_attribution = 13;\n  char *connellsville_alcarraza;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&unprosperously_fenerate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&connellsville_alcarraza,\"4163\",wilfully_attribution);\n      if (connellsville_alcarraza != 0) {;\n        stemmatiform_jawed = 1;\n        wellton_dillon = &connellsville_alcarraza;\n        subsequentness_sugent = ((char **)(((unsigned long )wellton_dillon) * stemmatiform_jawed * stemmatiform_jawed)) + 5;\n        pevely_interess = ((char *)( *(subsequentness_sugent - 5)));\n    \n    \n    \n    if (strlen(pevely_interess) > 1 &&\n     pevely_interess[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(pevely_interess,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\n        if ( *(subsequentness_sugent - 5) != 0) \n          free(((char *)( *(subsequentness_sugent - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#endif \n#endif ", "answer": "stack_size x 1 char memset stack_string", "cwe": "789", "idx": "151623"}
{"code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint flypast_punctualist = 0;\nint global_variable;\n\nstruct tangier_vfea \n{\n  char *iliopelvic_tristisonous;\n  double spirable_hyperdemocracy;\n  char *bucchero_valera;\n  char cytophysiology_hallsy;\n  int fleabanes_smattery;\n}\n;\n#define ILO_CYANASTRACEAE(x) pillowed_beefishness((struct tangier_vfea *) x)\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid pillowed_beefishness(struct tangier_vfea *preintone_stonify);\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex_0, mutex_1;\npthread_t t0, t1;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *replace (void *data) {\n    struct data *cusData = (struct data*)data;\n    int *qsort_arr;\n    int i = 0;\n    \n    \n    printf(\"replace: entering function\\n\");\n    \n    qsort_arr = malloc(sizeof(int)*cusData->qsize);\n    if (qsort_arr != NULL) {\n        for (i = 0; i < cusData->qsize; i++) {\n            qsort_arr[i] = cusData->qsize - i;\n        }\n        qsort(qsort_arr, cusData->qsize, sizeof(int), &comp);\n        free (qsort_arr);\n        qsort_arr = NULL;\n    }\n    readFile(cusData->file1);\n    printf(\"replace: Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0);\n    printf(\"replace: Grabbed lock 0\\n\");\n    printf(\"replace: Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1); \n    printf(\"replace: Grabbed lock 1\\n\");\n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] == '_') {\n            cusData->data[i] = '-';\n        }\n        i++;\n    }\n    printf(\"replace: Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    printf(\"replace: Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    \n    return NULL;\n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i = 0;\n    \n    printf(\"toCap:   Entering function\\n\");\n    printf(\"toCap:   Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1);\n    printf(\"toCap:   Grabbed lock 1\\n\");\n    readFile(cusData->file2);\n    \n    \n    printf(\"toCap:   Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0); \n    printf(\"toCap:   Grabbed lock 0\\n\");\n    \n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] > 'a' && cusData->data[i] < 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    printf(\"toCap:   Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    printf(\"toCap:   Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nunsigned int avdevice_version()\n{\n  struct tangier_vfea *obelize_sags = {0};\n  struct tangier_vfea unrealmed_varisse;\n  char *pardner_tatmjolk;;\n  if (__sync_bool_compare_and_swap(&flypast_punctualist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&pardner_tatmjolk,\"CROSSTOES_PARASABOTEUR\");\n      if (pardner_tatmjolk != 0) {;\n        unrealmed_varisse . iliopelvic_tristisonous = ((char *)pardner_tatmjolk);\n        obelize_sags = &unrealmed_varisse;\n\tILO_CYANASTRACEAE(obelize_sags);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid pillowed_beefishness(struct tangier_vfea *preintone_stonify)\n{\n    int hasUnderscores = 0;\n    int i = 0;\n    struct data* cusData;\n  char *phosphophyllite_arcanite = 0;\n  ++global_variable;;\n  phosphophyllite_arcanite = ((char *)( *preintone_stonify) . iliopelvic_tristisonous);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(phosphophyllite_arcanite) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(phosphophyllite_arcanite) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(phosphophyllite_arcanite) + 1));\n        if (cusData->data) {\n            if ((sscanf(phosphophyllite_arcanite, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                \n                \n                \n                \n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                while(cusData->data[i] != '\\0') { \n                    if (cusData->data[i++] == '_') { \n                        hasUnderscores = 1;\n                    }\n                }\n                \n                if (pthread_create(&t0, NULL, toCap, cusData) != 0) {\n                    printf(\"Thread 0 failed to spawn.\");\n                }\n                if (hasUnderscores == 1) {\n                    \n                    if (pthread_create(&t1, NULL, replace, cusData) != 0) {\n                        printf(\"Thread 1 failed to spawn.\");\n                    }\n                }\n                pthread_join(t0, NULL);\n                if (hasUnderscores == 1) {\n                    pthread_join(t1, NULL);\n                }\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n  if (( *preintone_stonify) . iliopelvic_tristisonous != 0) \n    free(((char *)( *preintone_stonify) . iliopelvic_tristisonous));\nclose_printf_context();\n}", "answer": "pthread_mutex_lock grab to lock n mutex_0 Grabbed Attempting 0", "cwe": "833", "idx": "150111"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint imputrescence_felicitators = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint 191_global_var = 0;\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *sympiesometer_sherurd = 0;\n  void *minefield_placet = 0;\n  long mismanageable_adamance[10];\n  void *crool_schuyler[10] = {0};\n  void *lyricists_sori = 0;\n  char *idism_metanotum;;\n  if (__sync_bool_compare_and_swap(&imputrescence_felicitators,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&idism_metanotum,\"CERCARIFORM_MARJ\");\n      if (idism_metanotum != 0) {;\n        lyricists_sori = ((void *)idism_metanotum);\n        crool_schuyler[5] = lyricists_sori;\n        mismanageable_adamance[1] = 5;\n        minefield_placet =  *(crool_schuyler + mismanageable_adamance[1]);\n        sympiesometer_sherurd = ((char *)((char *)minefield_placet));\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(sympiesometer_sherurd, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n        if (((char *)minefield_placet) != 0) \n          free(((char *)((char *)minefield_placet)));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "fgetc 10 random_data sizeof buff malloc i char long unsigned 0 num", "cwe": "191", "idx": "150928"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint streptobacillus_hemadynameter = 0;\nint global_variable;\nvoid larinae_scotsman(void **orotinan_hanau);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hypped_rechasten(void (*coadunite_overconstant)(void **));\nstruct struct {\n    int before[200];\n    int buffer[128];\n    int after[200];\n};\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&streptobacillus_hemadynameter,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      hypped_rechasten(larinae_scotsman);\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid larinae_scotsman(void **orotinan_hanau)\n{\n  void *rosillo_quatrin = 0;\n  int enchanting_kilobyte = 105;\n  char *cydonia_atrichia;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&cydonia_atrichia,\"5486\",enchanting_kilobyte);\n  if (cydonia_atrichia != 0) {;\n    rosillo_quatrin = ((void *)cydonia_atrichia);\n     *orotinan_hanau = rosillo_quatrin;\n  }\n}\n\nvoid hypped_rechasten(void (*coadunite_overconstant)(void **))\n{\n    signed char *input_string = 0;\n    struct struct * data = 0;\n    int i = 0;\n  char *tarentine_synnemata = 0;\n  void *thanatophidia_institutionally = 0;\n  int **********colloquiquia_rutin = 0;\n  int *********slum_washeries = 0;\n  int ********cnida_bloodalley = 0;\n  int *******whippiest_thagard = 0;\n  int ******babylonian_ponderosity = 0;\n  int *****tups_atlases = 0;\n  int ****eachelle_jongleur = 0;\n  int ***bisutun_tron = 0;\n  int **matchably_misruled = 0;\n  int *leonora_rebaptizing = 0;\n  int hexameter_unanalytically;\n  void *diabolo_diluvy[10] = {0};\n  ++global_variable;\n  void *nonstructurally_mesoventrally = 0;\n  coadunite_overconstant(&nonstructurally_mesoventrally);\n  if (((char *)nonstructurally_mesoventrally) != 0) {;\n    hexameter_unanalytically = 5;\n    leonora_rebaptizing = &hexameter_unanalytically;\n    matchably_misruled = &leonora_rebaptizing;\n    bisutun_tron = &matchably_misruled;\n    eachelle_jongleur = &bisutun_tron;\n    tups_atlases = &eachelle_jongleur;\n    babylonian_ponderosity = &tups_atlases;\n    whippiest_thagard = &babylonian_ponderosity;\n    cnida_bloodalley = &whippiest_thagard;\n    slum_washeries = &cnida_bloodalley;\n    colloquiquia_rutin = &slum_washeries;\n    diabolo_diluvy[ *( *( *( *( *( *( *( *( *( *colloquiquia_rutin)))))))))] = nonstructurally_mesoventrally;\n    thanatophidia_institutionally = diabolo_diluvy[ *( *( *( *( *( *( *( *( *( *colloquiquia_rutin)))))))))];\n    tarentine_synnemata = ((char *)((char *)thanatophidia_institutionally));\n    \n    input_string = (signed char *) getenv(\"INPUT_STRING\");\n    data = (struct struct *) malloc (sizeof (struct struct));\n    if (data != NULL) {\n        if (input_string != 0) {\n            memset(data->buffer, 0, 128);\n            for (i = 0; i < 200; ++i) {\n                data->before[i] = 5555;\n                data->after[i] = 5555;\n            }\n            for (i = 0; i < strlen((char *) input_string); ++i) {\n                if (input_string[i] < 0)\n                    continue;\n                ++data->buffer[input_string[i]];\n            }\n            \n            \n            for (i = 0; i < strlen(tarentine_synnemata); ++i) {\n                \n                \n                printf(\"value %c appears: %d times\\n\",\n                    tarentine_synnemata[i],\n                    data->buffer[(int) tarentine_synnemata[i]]);\n            }\n            \n            \n            \n        }\n        free (data);\n    }\n    \n;\n    if (((char *)thanatophidia_institutionally) != 0) \n      free(((char *)((char *)thanatophidia_institutionally)));\nclose_printf_context();\n  }\n}", "answer": "strlen value tarentine_synnemata int n i appears data buffer c times 0 d", "cwe": "127", "idx": "153142"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint colletidae_appendiculate = 0;\nint global_variable;\n\nunion sotos_descanso \n{\n  char *plodder_regerminatively;\n  double dodded_truthtelling;\n  char *fremescent_completes;\n  char baffies_fettlings;\n  int corindon_oophororrhaphy;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid eloquential_urnflower(int immortalism_untactually,union sotos_descanso faulter_decreaseless);\nvoid haemocyte_enchronicle(int meisel_upliftingly,union sotos_descanso oliva_accentuable);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  int ullyot_maunge = 7;\n  union sotos_descanso cheeked_overimpressing = {0};\n  int **********myomatous_bouzoun = 0;\n  int *********pest_subsella = 0;\n  int ********nonflowing_kyats = 0;\n  int *******astoned_hibbert = 0;\n  int ******devolutionist_propound = 0;\n  int *****rebeamer_illyrian = 0;\n  int ****instate_ssme = 0;\n  int ***pokelogan_woodpecker = 0;\n  int **slowheartedness_joviality = 0;\n  int *eliminant_reprievable = 0;\n  int subnodes_gumi;\n  union sotos_descanso eisen_forthbrought[10] = {0};\n  union sotos_descanso inertnesses_ufa;\n  char *claggum_chapel;;\n  if (__sync_bool_compare_and_swap(&colletidae_appendiculate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&claggum_chapel,\"BETHANKS_UNDERDOCTOR\");\n      if (claggum_chapel != 0) {;\n        inertnesses_ufa . plodder_regerminatively = claggum_chapel;\n        subnodes_gumi = 5;\n        eliminant_reprievable = &subnodes_gumi;\n        slowheartedness_joviality = &eliminant_reprievable;\n        pokelogan_woodpecker = &slowheartedness_joviality;\n        instate_ssme = &pokelogan_woodpecker;\n        rebeamer_illyrian = &instate_ssme;\n        devolutionist_propound = &rebeamer_illyrian;\n        astoned_hibbert = &devolutionist_propound;\n        nonflowing_kyats = &astoned_hibbert;\n        pest_subsella = &nonflowing_kyats;\n        myomatous_bouzoun = &pest_subsella;\n        eisen_forthbrought[ *( *( *( *( *( *( *( *( *( *myomatous_bouzoun)))))))))] = inertnesses_ufa;\n        cheeked_overimpressing = eisen_forthbrought[ *( *( *( *( *( *( *( *( *( *myomatous_bouzoun)))))))))];\n        eloquential_urnflower(ullyot_maunge,cheeked_overimpressing);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid eloquential_urnflower(int immortalism_untactually,union sotos_descanso faulter_decreaseless)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *kaolinize_glassweed = 0;\n  ++global_variable;\n  immortalism_untactually--;\n  if (immortalism_untactually > 0) {\n    haemocyte_enchronicle(immortalism_untactually,faulter_decreaseless);\n    return ;\n  }\n  kaolinize_glassweed = ((char *)faulter_decreaseless . plodder_regerminatively);\n      \n      while(isalnum(kaolinize_glassweed[size]) && size < strlen(kaolinize_glassweed)){\n        ++size;\n      }\n      \n\n      if (size != strlen(kaolinize_glassweed)) {\n        kaolinize_glassweed = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,kaolinize_glassweed);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if (faulter_decreaseless . plodder_regerminatively != 0) \n    free(((char *)faulter_decreaseless . plodder_regerminatively));\nclose_printf_context();\n}\n\nvoid haemocyte_enchronicle(int meisel_upliftingly,union sotos_descanso oliva_accentuable)\n{\n  ++global_variable;\n  eloquential_urnflower(meisel_upliftingly,oliva_accentuable);\n}", "answer": "strlen kaolinize_glassweed", "cwe": "476", "idx": "149704"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint barracudina_zygopleural = 0;\ntypedef char *omophoria_ethnogenist;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *superslick_valeted = 0;\n  int bicarbureted_solutions;\n  int diosmotic_marron;\n  omophoria_ethnogenist polymorph_lustrational = 0;\n  long hypercoagulable_estreating[10];\n  omophoria_ethnogenist borean_indirectnesses[10] = {0};\n  omophoria_ethnogenist ballons_gweyn = 0;\n  char *pingos_rebuttals;;\n  if (__sync_bool_compare_and_swap(&barracudina_zygopleural,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      pingos_rebuttals = getenv(\"THORMORA_CHINOISERIE\");\n      if (pingos_rebuttals != 0) {;\n        ballons_gweyn = pingos_rebuttals;\n        borean_indirectnesses[5] = ballons_gweyn;\n        hypercoagulable_estreating[1] = 5;\n        polymorph_lustrational =  *(borean_indirectnesses + hypercoagulable_estreating[1]);\n        diosmotic_marron = 5;\n        while(1 == 1){\n          diosmotic_marron = diosmotic_marron * 2;\n          diosmotic_marron = diosmotic_marron + 2;\n          if (diosmotic_marron > 1000) {\n            break; \n          }\n        }\n        bicarbureted_solutions = diosmotic_marron;\n        superslick_valeted = ((char *)polymorph_lustrational);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(superslick_valeted); ++i) {\n        if (superslick_valeted[i] == ';') {\n          if (i == 0 || superslick_valeted[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,superslick_valeted);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "cmd_string", "cwe": "88", "idx": "152787"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint unpanoplied_plagiotropism = 0;\n\nstruct retrogresses_unviewable \n{\n  char *unsuspect_clonal;\n  double ethiope_musketade;\n  char *coelomatous_psammite;\n  char podilegous_gurr;\n  int protracheata_chlorides;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n int ss_i = 0;\n  char *tressia_egads = 0;\n  struct retrogresses_unviewable *coemption_baculites = {0};\n  struct retrogresses_unviewable *galempong_protium = {0};\n  struct retrogresses_unviewable hee_varicoloured;\n  char *prebilling_maryann;;\n  if (__sync_bool_compare_and_swap(&unpanoplied_plagiotropism,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      prebilling_maryann = getenv(\"PHILOSOPHIZER_INTERTWISTINGLY\");\n      if (prebilling_maryann != 0) {;\n        hee_varicoloured . unsuspect_clonal = ((char *)prebilling_maryann);\n        coemption_baculites = &hee_varicoloured;\n        galempong_protium = coemption_baculites + 5;\n        tressia_egads = ((char *)( *(galempong_protium - 5)) . unsuspect_clonal);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(tressia_egads)){\n  \n        if (tressia_egads[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "strlen ss_i 48 tressia_egads", "cwe": "835", "idx": "151874"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint puntilla_exophoria = 0;\ntypedef char *sapples_holsworth;\nint global_variable;\nvoid gaurie_surat(sapples_holsworth *asylabia_outgush);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid axal_strengthening(void (*andreaeales_dostoyevsky)(sapples_holsworth *));\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        \n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        \n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        \n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\nint isSymLink(char *file) {\n    struct stat statbuf;\n    \n    if (lstat(file, &statbuf) < 0) { \n        printf(\"Error accessing path.\\n\");\n        return 1; \n    }\n    if (S_ISLNK(statbuf.st_mode) == 1) {\n        printf(\"Path is symlink.\\n\");\n        return 1;\n    }\n    printf(\"Path is valid.\\n\");\n    return 0;\n}\nint path_is_not_symlink(char * abs_path) {\n    \n    return (isSymLink(abs_path) == 0);\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&puntilla_exophoria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      axal_strengthening(gaurie_surat);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid gaurie_surat(sapples_holsworth *asylabia_outgush)\n{\n  sapples_holsworth photokinesis_skirtless = 0;\n  char *undredged_livlihood;\n  ++global_variable;;\n  setup_printf_context();\n  undredged_livlihood = getenv(\"LUSH_DORMIENT\");\n  if (undredged_livlihood != 0) {;\n    photokinesis_skirtless = undredged_livlihood;\n     *asylabia_outgush = photokinesis_skirtless;\n  }\n}\n\nvoid axal_strengthening(void (*andreaeales_dostoyevsky)(sapples_holsworth *))\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *defloration_amidoazobenzol = 0;\n  int sonantic_porcated;\n  sapples_holsworth *moniliales_sideslipping = 0;\n  sapples_holsworth *mesophragm_galahad = 0;\n  ++global_variable;\n  sapples_holsworth odostemon_inosculated = 0;\n  andreaeales_dostoyevsky(&odostemon_inosculated);\n  if (odostemon_inosculated != 0) {;\n    sonantic_porcated = 1;\n    moniliales_sideslipping = &odostemon_inosculated;\n    mesophragm_galahad = ((sapples_holsworth *)(((unsigned long )moniliales_sideslipping) * sonantic_porcated * sonantic_porcated)) + 5;\n    defloration_amidoazobenzol = ((char *)( *(mesophragm_galahad - 5)));\n    \n    str = malloc(sizeof(char) * (strlen(defloration_amidoazobenzol) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(defloration_amidoazobenzol) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(defloration_amidoazobenzol, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n                if (path_is_not_symlink(abs_path)) {\n                    \n                    \n                    waitForChange(abs_path, sleep_file);\n                    file = fopen(abs_path,\"rb\");\n                    \n                    if (file != 0) {\n                        fseek(file,0,2);\n                        size = ftell(file);\n                        rewind(file);\n                        buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                        if (buffer) {\n                            \n                            \n                            fread(buffer,sizeof(char ),size,file);\n                            buffer[size] = '\\0';\n                            printf(buffer);\n                            fclose(file);\n                            free(buffer);\n                            \n                        }\n                    }\n                }\n                free (abs_path);\n            }\n        }\n        free(str);\n    } else {\n        \n        printf(\"Error parsing input.\\n\");\n    }\n;\nclose_printf_context();\n  }\n}\n#endif", "answer": "file", "cwe": "363", "idx": "150293"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint dendritiform_gallinago = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n int oc_i = 0;\n char stack_buff_64[64];\n char *other_buff[8];\n int my_buff_size = 63;\n int buff_size;\n  char *pentelic_abyssolith = 0;\n  char **frails_unflappably = 0;\n  char **pisciculturally_academie = 0;\n  char *waistcoated_piassavas;;\n  if (__sync_bool_compare_and_swap(&dendritiform_gallinago,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      waistcoated_piassavas = getenv(\"CROSLEY_MASTODYNIA\");\n      if (waistcoated_piassavas != 0) {;\n        frails_unflappably = &waistcoated_piassavas;\n        pisciculturally_academie = frails_unflappably + 5;\n        pentelic_abyssolith = ((char *)( *(pisciculturally_academie - 5)));\n    \n    \n    \n other_buff[7] = pentelic_abyssolith;\n    memset(stack_buff_64,65,64);\n    stack_buff_64[64 - 1] = '\\0';\n    buff_size = ((int )(strlen(pentelic_abyssolith)));\n    \n    \n    \n    \n    for (; buff_size >= 0; (--my_buff_size , --buff_size)) {\n  \n  \n        stack_buff_64[my_buff_size] = pentelic_abyssolith[buff_size];\n    }\n    \n    for (; oc_i < 64; ++oc_i) {\n        stack_buff_64[oc_i] = toupper(stack_buff_64[oc_i]);\n    }\n    \n    \n    printf(\"%s\\n\",stack_buff_64);\n    printf(\"strlen size = %d\\n\",strlen(pentelic_abyssolith));\n    printf(\"strlen size = %d\\n\",strlen(other_buff[7]));\n    \n    \n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "toupper 64 pentelic_abyssolith oc_i my_buff_size stack_buff_64 0 buff_size", "cwe": "124", "idx": "152937"}
{"code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint closet_padegs = 0;\nint global_variable;\nvoid frontenac_spurs(char **oki_akmudar);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid inclinatory_antikenotoxin(void (*acondylous_meconophagist)(char **));\nstruct struct {\n    char base_path[20];\n    char * buff_pointer;\n};\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&closet_padegs,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      inclinatory_antikenotoxin(frontenac_spurs);\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid frontenac_spurs(char **oki_akmudar)\n{\n  char *sowing_lurched;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&sowing_lurched,\"IMPRESSIBLE_ALMAGRA\");\n  if (sowing_lurched != 0) {;\n     *oki_akmudar = sowing_lurched;\n  }\n}\n\nvoid inclinatory_antikenotoxin(void (*acondylous_meconophagist)(char **))\n{\n    int oc_i = 0;\n    int opt_var = 0;\n    struct struct* data = 0;\n  char *drexel_boanthropy = 0;\n  ++global_variable;\n  char *interplait_transformance = 0;\n  acondylous_meconophagist(&interplait_transformance);\n  if (interplait_transformance != 0) {;\n    drexel_boanthropy = ((char *)interplait_transformance);\n    \n    if (strlen(drexel_boanthropy) < 20) {;\n        data = (struct struct*) malloc (sizeof(struct struct));\n        if (data != NULL) {\n            memset(data->base_path, 0, 20);\n            data->buff_pointer = data->base_path;\n            \n            \n\n\n            realpath(drexel_boanthropy, data->base_path);\n            opt_var = strlen( data->buff_pointer);\n            \n            for (; oc_i < opt_var; ++oc_i) {\n                data->base_path[oc_i] =\n                    toupper(data->base_path[oc_i]);\n            }\n            printf(\"%s\\n\", data->base_path);\n            printf(\"%s\\n\", data->buff_pointer);\n            \n            \n            free (data);\n        }\n    }\n    \n;\n    if (interplait_transformance != 0) \n      free(((char *)interplait_transformance));\nclose_printf_context();\n  }\n}", "answer": "realpath toupper strlen data oc_i n buff_pointer s drexel_boanthropy base_path opt_var", "cwe": "785", "idx": "153649"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \n#include <unistd.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint retouchers_formolit = 0;\n\nunion misestimating_bradawls \n{\n  char *vassalless_spoiler;\n  double remilitarize_rouvin;\n  char *paulite_ungratification;\n  char levine_unintimidated;\n  int unrotatory_virous;\n}\n;\nint global_variable;\nvoid handle_taint(char *moonery_teadish);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            \n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint is_valid(char *path)\n{\n    \n    if(access(path, F_OK) != -1) {\n        \n        printf(\"Path is accessible\\n\");\n        return 1;\n    }\n    \n    printf(\"Path is not accessible\\n\");\n    return 0;\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        \n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        \n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&retouchers_formolit,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *moonery_teadish)\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *scamell_lepta = 0;\n  union misestimating_bradawls tackingly_iskenderun = {0};\n  int *microphonic_pfeffernuss = 0;\n  int agapanthus_pennatulidae;\n  union misestimating_bradawls nelson_harmonici[10] = {0};\n  union misestimating_bradawls logisticians_vernalised;\n  ++global_variable;;\n  if (moonery_teadish != 0) {;\n    logisticians_vernalised . vassalless_spoiler = moonery_teadish;\n    nelson_harmonici[5] = logisticians_vernalised;\n    agapanthus_pennatulidae = 5;\n    microphonic_pfeffernuss = &agapanthus_pennatulidae;\n    tackingly_iskenderun =  *(nelson_harmonici +  *microphonic_pfeffernuss);\n    scamell_lepta = ((char *)tackingly_iskenderun . vassalless_spoiler);\n    \n    str = malloc(sizeof(char) * (strlen(scamell_lepta) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(scamell_lepta) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(scamell_lepta, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n               if (is_valid(abs_path)) {\n                  \n                    \n                    waitForChange(abs_path, sleep_file);\n                   \n                   \n                    \n                    file = fopen(abs_path,\"rb\");\n                    fseek(file,0,2);\n                    size = ftell(file);\n                    rewind(file);\n                    buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                    if (buffer != NULL) {\n                        fread(buffer,sizeof(char ),size,file);\n                        buffer[size] = '\\0';\n                        printf(buffer);\n                        free(buffer);\n                    }\n                   \n                    fclose(file);\n                }\n            }\n            free(abs_path);\n        }\n        free(str);\n    } else {\n       \n        printf(\"Error parsing input.\\n\");\n    }\n;\n    if (tackingly_iskenderun . vassalless_spoiler != 0) \n      free(((char *)tackingly_iskenderun . vassalless_spoiler));\nclose_printf_context();\n  }\n}", "answer": "abs_path", "cwe": "367", "idx": "149945"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint chortle_pterichthys = 0;\nint global_variable;\nvoid annectent_overcasts(char **aft_itcheoglan);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid quickman_nonepiscopally(void (*sagittarii_cultivatation)(char **));\nint 191_global_var = 0;\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&chortle_pterichthys,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      quickman_nonepiscopally(annectent_overcasts);\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid annectent_overcasts(char **aft_itcheoglan)\n{\n  char *nganhwei_desires;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&nganhwei_desires,\"ZWICK_HOMOSASSA\");\n  if (nganhwei_desires != 0) {;\n     *aft_itcheoglan = nganhwei_desires;\n  }\n}\n\nvoid quickman_nonepiscopally(void (*sagittarii_cultivatation)(char **))\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *scalewing_eczematosis = 0;\n  char *beastly_nabatean[28] = {0};\n  char *ravingly_atrociously = 0;\n  long pigwidgin_turgescent[10];\n  char *waynesburg_fornenst[10] = {0};\n  ++global_variable;\n  char *phalaenae_lct = 0;\n  sagittarii_cultivatation(&phalaenae_lct);\n  if (phalaenae_lct != 0) {;\n    waynesburg_fornenst[5] = phalaenae_lct;\n    pigwidgin_turgescent[1] = 5;\n    ravingly_atrociously =  *(waynesburg_fornenst + pigwidgin_turgescent[1]);\n    beastly_nabatean[6] = ravingly_atrociously;\n    scalewing_eczematosis = ((char *)beastly_nabatean[6]);\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(scalewing_eczematosis, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n    if (beastly_nabatean[6] != 0) \n      free(((char *)beastly_nabatean[6]));\nclose_printf_context();\n  }\n}", "answer": "fgetc 10 random_data sizeof buff malloc i char long unsigned 0 num", "cwe": "191", "idx": "150970"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint fausant_upliftingness = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *biogeographer_ransom = 0;\n  int cardale_pearmain;\n  int guilandina_excresce;\n  char **molybdosis_lpf = 0;\n  char *unriddles_elatives[5] = {0};\n  char *granulet_standby;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&fausant_upliftingness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&granulet_standby,\"AETIOLOGIES_NEUROPARALYTIC\");\n      if (granulet_standby != 0) {;\n        unriddles_elatives[0] = granulet_standby;\n        molybdosis_lpf = unriddles_elatives;\n        guilandina_excresce = 5;\n        while(1 == 1){\n          guilandina_excresce = guilandina_excresce * 2;\n          guilandina_excresce = guilandina_excresce + 2;\n          if (guilandina_excresce > 1000) {\n            break; \n          }\n        }\n        cardale_pearmain = guilandina_excresce;\n        biogeographer_ransom = ((char *)molybdosis_lpf[0]);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(biogeographer_ransom); ++i) {\n        if (biogeographer_ransom[i] == ';') {\n          if (i == 0 || biogeographer_ransom[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,biogeographer_ransom);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if (molybdosis_lpf[0] != 0) \n          free(((char *)molybdosis_lpf[0]));\nclose_printf_context();\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}", "answer": "cmd_string", "cwe": "88", "idx": "152301"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint deregulate_systemized = 0;\nint global_variable;\ntypedef char *kechi_udometry;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nkechi_udometry vaudoux_triton(kechi_udometry richton_semistriate);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *minstrelship_cse = 0;\n  kechi_udometry quaters_longeval = 0;\n  kechi_udometry gemless_sourdoughs = 0;\n  char *excavating_infestivity;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&deregulate_systemized,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      excavating_infestivity = getenv(\"MONOLINGUIST_SANDCULTURE\");\n      if (excavating_infestivity != 0) {;\n        gemless_sourdoughs = excavating_infestivity;\n        quaters_longeval = vaudoux_triton(gemless_sourdoughs);\n        if (quaters_longeval != 0) {\n          goto manutius_serjeantry;\n        }\n        ++global_variable;\n        manutius_serjeantry:;\n        minstrelship_cse = ((char *)quaters_longeval);\n    \n    if (strlen(minstrelship_cse) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,minstrelship_cse);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nkechi_udometry vaudoux_triton(kechi_udometry richton_semistriate)\n{\n  ++global_variable;\n  return richton_semistriate;\n}", "answer": "command_buffer", "cwe": "78", "idx": "152698"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint validatable_shootist = 0;\nint global_variable;\nvoid handle_taint(char *triplopy_mollycoddle);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid atelomyelia_snecket(int mesophyllic_caneton,... );\nstruct struct {\n    int before[200];\n    int buffer[128];\n    int after[200];\n};\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&validatable_shootist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *triplopy_mollycoddle)\n{\n  char *airmailed_hyperploid[97] = {0};\n  ++global_variable;;\n  if (triplopy_mollycoddle != 0) {;\n    airmailed_hyperploid[22] = triplopy_mollycoddle;\n    atelomyelia_snecket(1,airmailed_hyperploid);\n  }\n}\n\nvoid atelomyelia_snecket(int mesophyllic_caneton,... )\n{\n    signed char *input_string = 0;\n    struct struct data;\n    int i = 0;\n  char *innocuity_samsam = 0;\n  char **bicarbureted_justling = 0;\n  va_list noninhibitory_aplanatism;\n  ++global_variable;;\n  if (mesophyllic_caneton > 0) {\n    __builtin_va_start(noninhibitory_aplanatism,mesophyllic_caneton);\n    bicarbureted_justling = (va_arg(noninhibitory_aplanatism,char **));\n    __builtin_va_end(noninhibitory_aplanatism);\n  }\n  innocuity_samsam = ((char *)bicarbureted_justling[22]);\n    \n    input_string = (signed char *) getenv(\"INPUT_STRING\");\n    \n    \n    if (input_string != 0) {\n        for (i = 0; i < 128; ++i) {\n            data.buffer[i] = 0;\n        }\n        for (i = 0; i < 200; ++i) {\n            data.before[i] = 5555;\n            data.after[i] = 5555;\n        }\n        for (i = 0; i < strlen((char *) input_string); ++i) {\n            if (input_string[i] < 0)\n                continue;\n            ++data.buffer[input_string[i]];\n        }\n        \n        \n        for (i = 0; i < strlen(innocuity_samsam); ++i) {\n            \n            \n            printf(\"value %c appears: %d times\\n\",\n                innocuity_samsam[i],\n                data.buffer[(int) innocuity_samsam[i]]);\n        }\n        \n        \n        \n    }\n;\n  if (bicarbureted_justling[22] != 0) \n    free(((char *)bicarbureted_justling[22]));\nclose_printf_context();\n}", "answer": "strlen value innocuity_samsam int n i appears data buffer c times 0 d", "cwe": "127", "idx": "153390"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint squirearch_pseudoovally = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    char *result = 0;\n    int random_int = 0;\n  char *contends_guttering = 0;\n  int phalangiidae_pasterns;\n  int chiefage_cavillatory;\n  char **lovelass_aerodynamics = 0;\n  char **hederiferous_uncustomed = 0;\n  int westernize_pinta = 73;\n  char *rontgenized_nonspecie;;\n  if (__sync_bool_compare_and_swap(&squirearch_pseudoovally,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&rontgenized_nonspecie,\"6956\",westernize_pinta);\n      if (rontgenized_nonspecie != 0) {;\n        lovelass_aerodynamics = &rontgenized_nonspecie;\n        hederiferous_uncustomed = lovelass_aerodynamics + 5;\n        chiefage_cavillatory = 5;\n        while(1 == 1){\n          chiefage_cavillatory = chiefage_cavillatory * 2;\n          chiefage_cavillatory = chiefage_cavillatory + 2;\n          if (chiefage_cavillatory > 1000) {\n            break; \n          }\n        }\n        phalangiidae_pasterns = chiefage_cavillatory;\n        contends_guttering = ((char *)( *(hederiferous_uncustomed - 5)));\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  srand(time(NULL));\n  random_int = (rand() % 1000) + 100;\n        snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, contends_guttering);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n            \n            printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  result = PQcmdTuples(res);\n        printf(\"Query OK, %s rows affected\\n\",result);\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\n        if ( *(hederiferous_uncustomed - 5) != 0) \n          free(((char *)( *(hederiferous_uncustomed - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "INSERT s query", "cwe": "89", "idx": "152305"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <stdarg.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint monacid_upheld = 0;\nint global_variable;\nvoid handle_taint(char *misreprint_tanh);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid inspections_triumphed(int lourd_depend,... );\nvoid sailflying_internunciatory(char **euthyneura_unlowly);\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&monacid_upheld,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *misreprint_tanh)\n{\n  char *matterfulness_gallicolous[72] = {0};\n  ++global_variable;;\n  if (misreprint_tanh != 0) {;\n    matterfulness_gallicolous[33] = misreprint_tanh;\n    inspections_triumphed(1,matterfulness_gallicolous);\n  }\n}\n\nvoid inspections_triumphed(int lourd_depend,... )\n{\n  void (*mctyre_nutritory)(char **) = sailflying_internunciatory;\n  char **scraigh_shotty = 0;\n  va_list hardfern_gristly;\n  ++global_variable;;\n  if (lourd_depend > 0) {\n    __builtin_va_start(hardfern_gristly,lourd_depend);\n    scraigh_shotty = (va_arg(hardfern_gristly,char **));\n    __builtin_va_end(hardfern_gristly);\n  }\n  mctyre_nutritory(scraigh_shotty);\n}\n\nvoid sailflying_internunciatory(char **euthyneura_unlowly)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  int random_int = 0;\n  char *scarps_polonnaruwa = 0;\n  ++global_variable;;\n  scarps_polonnaruwa = ((char *)euthyneura_unlowly[33]);\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n    srand(time(NULL));\n    random_int = (rand() % 1000) + 100;\n                snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, scarps_polonnaruwa);\n    \n                \n                \n\n                if (mysql_query(conn,query_buffer)) {\n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n    } else {\n      printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n  if (euthyneura_unlowly[33] != 0) \n    free(((char *)euthyneura_unlowly[33]));\nclose_printf_context();\n}", "answer": "query_buffer s", "cwe": "89", "idx": "152218"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <stdarg.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint aqueity_semimagically = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid tinkered_kuantan(int cinemactic_fulfulde,... );\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  char *nonstably_disenthrone[49] = {0};\n  int graziers_theroid = 30;\n  char *costin_kaingang;;\n  if (__sync_bool_compare_and_swap(&aqueity_semimagically,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&costin_kaingang,\"3917\",graziers_theroid);\n      if (costin_kaingang != 0) {;\n        nonstably_disenthrone[46] = costin_kaingang;\n        tinkered_kuantan(1,nonstably_disenthrone);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid tinkered_kuantan(int cinemactic_fulfulde,... )\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int nFields;\n    int i;\n    int j = 0;\n  char *glisk_meconophagist = 0;\n  int oversaturates_uncarpentered;\n  int geothlypis_prefreeze;\n  char **hircine_fixures = 0;\n  va_list orograph_steens;\n  ++global_variable;;\n  if (cinemactic_fulfulde > 0) {\n    __builtin_va_start(orograph_steens,cinemactic_fulfulde);\n    hircine_fixures = (va_arg(orograph_steens,char **));\n    __builtin_va_end(orograph_steens);\n  }\n  geothlypis_prefreeze = 5;\n  while(1 == 1){\n    geothlypis_prefreeze = geothlypis_prefreeze * 2;\n    geothlypis_prefreeze = geothlypis_prefreeze + 2;\n    if (geothlypis_prefreeze > 1000) {\n      break; \n    }\n  }\n  oversaturates_uncarpentered = geothlypis_prefreeze;\n  glisk_meconophagist = ((char *)hircine_fixures[46]);\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", glisk_meconophagist);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            \n            printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        nFields = PQnfields(res);\n        for (i = 0; i < nFields; i++)\n            printf(\"%-15s\", PQfname(res, i));\n        printf(\"\\n\\n\");\n        \n        for (i = 0; i < PQntuples(res); i++)\n        {\n            for (j = 0; j < nFields; j++)\n                printf(\"%-15s\", PQgetvalue(res, i, j));\n            printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\n  if (hircine_fixures[46] != 0) \n    free(((char *)hircine_fixures[46]));\nclose_printf_context();\n}", "answer": "SELECT s query", "cwe": "89", "idx": "152378"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint rubs_derogated = 0;\n\nunion strigous_newsier \n{\n  char *cherkesser_usneaceae;\n  double remijia_expressways;\n  char *bjneborg_irreduction;\n  char stibblerig_quantifies;\n  int divulsing_hedgemaker;\n}\n;\nint global_variable;\nvoid handle_taint(char *underjanitor_tinkerly);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid arette_ulla(union strigous_newsier unmusical_matoke);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    char buffer[8];\n    char * buff_pointer;\n};\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&rubs_derogated,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n#define CHRISTIES_TRICHI(x) arette_ulla((union strigous_newsier) x)\n\nvoid handle_taint(char *underjanitor_tinkerly)\n{\n  union strigous_newsier shirtless_prelawfulness = {0};\n  int *overdignity_unslandered = 0;\n  int glenmora_fanioned;\n  union strigous_newsier toothily_unadhesive[10] = {0};\n  union strigous_newsier parasyntheton_invades;\n  ++global_variable;;\n  if (underjanitor_tinkerly != 0) {;\n    parasyntheton_invades . cherkesser_usneaceae = underjanitor_tinkerly;\n    toothily_unadhesive[5] = parasyntheton_invades;\n    glenmora_fanioned = 5;\n    overdignity_unslandered = &glenmora_fanioned;\n    shirtless_prelawfulness =  *(toothily_unadhesive +  *overdignity_unslandered);\n\tCHRISTIES_TRICHI(shirtless_prelawfulness);\n  }\n}\n\nvoid arette_ulla(union strigous_newsier unmusical_matoke)\n{\n    int oc_i = 0;\n    int ptr_deref;\n    struct struct * data = 0;\n  char *preguarantee_tartarize = 0;\n  ++global_variable;;\n  preguarantee_tartarize = ((char *)unmusical_matoke . cherkesser_usneaceae);\n    \n    data = (struct struct*) malloc(sizeof (struct struct));\n    if (data != NULL) {\n        data->buff_pointer = data->buffer;\n        \n        \n        \n        \n        \n        strncpy(data->buffer, preguarantee_tartarize, strlen(preguarantee_tartarize) + 1);\n        ptr_deref = strlen( data->buff_pointer);\n        for (; oc_i < ptr_deref; ++oc_i) {\n            data->buffer[oc_i] = toupper(data->buffer[oc_i]);\n        }\n        printf(\"%s\\n\", data->buffer);\n        \n        \n        free(data);\n    }\n    \n;\n  if (unmusical_matoke . cherkesser_usneaceae != 0) \n    free(((char *)unmusical_matoke . cherkesser_usneaceae));\nclose_printf_context();\n}", "answer": "strlen toupper preguarantee_tartarize data oc_i n 1 buffer buff_pointer strncpy s ptr_deref", "cwe": "805", "idx": "153521"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint gerhardus_harmlessnesses = 0;\ntypedef char *jatos_noninertly;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_t t0, t1;\npthread_mutex_t mutex_0, mutex_1;\nint dev_amount = 1;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcDevamount(void *data) {\n    struct data *cusData = (struct data*)data;\n    int qsize;\n    \n    printf(\"Inside calcDevAmount\\n\");\n    pthread_mutex_lock(&mutex_0);\n    \n    \n    dev_amount = cusData->data[0] - 'A'; \n    qsize = cusData->qsize;\n    if (dev_amount < 0) { \n        dev_amount *= -1; \n    }\n    \n    readFile(cusData->file2);\n    if (dev_amount == 0) { \n        dev_amount += 1; \n    }\n    \n    \n    pthread_mutex_unlock(&mutex_0);\n    return NULL;\n}\nvoid *devChar(void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int i;\n    int *arr = NULL;\n    \n    printf(\"Inside devChar\\n\");\n    \n    arr = malloc(sizeof(int) * cusData->qsize);\n    pthread_mutex_lock(&mutex_1);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(cusData->file1);\n    \n    \n    \n    for (i = 0; i < strlen(cusData->data); i++) { \n        cusData->data[i] /= dev_amount; \n    }\n    \n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    struct data* cusData;\n  char *peascod_malleus = 0;\n  jmp_buf almach_perturb;\n  int stepping_acquent;\n  jatos_noninertly anurag_flashbulb = 0;\n  long ensand_bugger[10];\n  jatos_noninertly margaretville_nonvitriolic[10] = {0};\n  jatos_noninertly endocytotic_molality = 0;\n  int thallodal_neurilemmatous = 204;\n  char *occluse_baywoods;;\n  if (__sync_bool_compare_and_swap(&gerhardus_harmlessnesses,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&occluse_baywoods,\"8024\",thallodal_neurilemmatous);\n      if (occluse_baywoods != 0) {;\n        endocytotic_molality = occluse_baywoods;\n        margaretville_nonvitriolic[5] = endocytotic_molality;\n        ensand_bugger[1] = 5;\n        anurag_flashbulb =  *(margaretville_nonvitriolic + ensand_bugger[1]);\n        stepping_acquent = setjmp(almach_perturb);\n        if (stepping_acquent == 0) {\n          longjmp(almach_perturb,1);\n        }\n        peascod_malleus = ((char *)anurag_flashbulb);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(peascod_malleus) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(peascod_malleus) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(peascod_malleus) + 1));\n        if (cusData->data) {\n            if ((sscanf(peascod_malleus, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                \n                \n                \n                \n                \n                if (strlen(cusData->data) > 50) { \n                                                                                                    \n                    if (pthread_create(&t0, NULL, calcDevamount, cusData) != 0) { \n                        printf(\"Error initializing thread 0.\");\n                    }\n                }\n                if (pthread_create(&t1, NULL, devChar, cusData) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                if (strlen(cusData->data) > 50) {\n                    pthread_join(t0, NULL);\n                }\n                pthread_join(t1, NULL);\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n        if (anurag_flashbulb != 0) \n          free(((char *)anurag_flashbulb));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "data dev_amount cusData 0", "cwe": "821", "idx": "150150"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint aitesis_chutzpah = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *sleighers_nanaimo = 0;\n  char *falda_loadstone = 0;\n  int **********oside_boycotter = 0;\n  int *********pentadecylic_aubergiste = 0;\n  int ********workers_exoticalness = 0;\n  int *******lunular_oversecure = 0;\n  int ******anecdotalist_published = 0;\n  int *****alerion_logarithmical = 0;\n  int ****inappetible_yefremov = 0;\n  int ***dragons_cyclical = 0;\n  int **trichloroethane_unmackly = 0;\n  int *sorbability_malachi = 0;\n  int clapper_fisticuffs;\n  char *millihenry_tenography[10] = {0};\n  int ensigncies_twifoldly = 66;\n  char *unpremeditate_chubbedness;;\n  if (__sync_bool_compare_and_swap(&aitesis_chutzpah,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&unpremeditate_chubbedness,\"6591\",ensigncies_twifoldly);\n      if (unpremeditate_chubbedness != 0) {;\n        clapper_fisticuffs = 5;\n        sorbability_malachi = &clapper_fisticuffs;\n        trichloroethane_unmackly = &sorbability_malachi;\n        dragons_cyclical = &trichloroethane_unmackly;\n        inappetible_yefremov = &dragons_cyclical;\n        alerion_logarithmical = &inappetible_yefremov;\n        anecdotalist_published = &alerion_logarithmical;\n        lunular_oversecure = &anecdotalist_published;\n        workers_exoticalness = &lunular_oversecure;\n        pentadecylic_aubergiste = &workers_exoticalness;\n        oside_boycotter = &pentadecylic_aubergiste;\n        millihenry_tenography[ *( *( *( *( *( *( *( *( *( *oside_boycotter)))))))))] = unpremeditate_chubbedness;\n        falda_loadstone = millihenry_tenography[ *( *( *( *( *( *( *( *( *( *oside_boycotter)))))))))];\n        sleighers_nanaimo = ((char *)falda_loadstone);\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(sleighers_nanaimo) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (sleighers_nanaimo[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &sleighers_nanaimo[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\n        if (falda_loadstone != 0) \n          free(((char *)falda_loadstone));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "strlen i n second_buff", "cwe": "476", "idx": "149670"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint chitosan_clubbable = 0;\nint global_variable;\n\nunion confectioneries_oromo \n{\n  char *unmetallic_camelot;\n  double admissible_tossy;\n  char *jaculatorial_wholesomely;\n  char flensing_hesitatively;\n  int oxcarts_oviducal;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid unindigenous_hispaniola(int overlard_macroergate,... );\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  union confectioneries_oromo hydropterideae_antiroyal;\n  int unwealsomeness_leechwort = 596;\n  char *sorefoot_rollin;;\n  if (__sync_bool_compare_and_swap(&chitosan_clubbable,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&sorefoot_rollin,\"2380\",unwealsomeness_leechwort);\n      if (sorefoot_rollin != 0) {;\n        hydropterideae_antiroyal . unmetallic_camelot = sorefoot_rollin;\n        unindigenous_hispaniola(1,hydropterideae_antiroyal);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid unindigenous_hispaniola(int overlard_macroergate,... )\n{\n    int ss_i = 0;\n    char* heap_buff_64;\n    int buff_size;\n  char *archai_turbith = 0;\n  jmp_buf limnoriidae_wanderoo;\n  int indestrucible_outbaking;\n  union confectioneries_oromo omnipotently_ugroid = {0};\n  va_list crispation_nontidal;\n  ++global_variable;;\n  if (overlard_macroergate > 0) {\n    __builtin_va_start(crispation_nontidal,overlard_macroergate);\n    omnipotently_ugroid = (va_arg(crispation_nontidal,union confectioneries_oromo ));\n    __builtin_va_end(crispation_nontidal);\n  }\n  indestrucible_outbaking = setjmp(limnoriidae_wanderoo);\n  if (indestrucible_outbaking == 0) {\n    longjmp(limnoriidae_wanderoo,1);\n  }\n  archai_turbith = ((char *)omnipotently_ugroid . unmetallic_camelot);\n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    \n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64,'A',63);\n        heap_buff_64[63] = '\\0';\n        \n        buff_size = ((int )(strlen(archai_turbith)));\n        strncpy(heap_buff_64, archai_turbith, 64);\n        \n        \n        \n        for (; ss_i < buff_size; ++ss_i){\n            \n            \n            printf(\"%02x\",heap_buff_64[ss_i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( heap_buff_64);\n        \n        \n    }\n;\n  if (omnipotently_ugroid . unmetallic_camelot != 0) \n    free(((char *)omnipotently_ugroid . unmetallic_camelot));\nclose_printf_context();\n}", "answer": "ss_i 02x buff_size heap_buff_64", "cwe": "126", "idx": "152955"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint kochkin_lincolndale = 0;\ntypedef char *fiddlesticks_gastronomies;\nint global_variable;\nvoid handle_taint(char *muzziest_treadling);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nfiddlesticks_gastronomies grapewise_inbreathed(fiddlesticks_gastronomies obtested_cautio);\nvoid kicksies_conarium(int eachelle_solarized,fiddlesticks_gastronomies glossotype_drowsily);\nvoid trigemini_crinoids(int materia_indubiously,fiddlesticks_gastronomies menazons_multicharge);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&kochkin_lincolndale,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *muzziest_treadling)\n{\n  int carnivalesque_paumgartner = 7;\n  fiddlesticks_gastronomies garnel_klenk = 0;\n  fiddlesticks_gastronomies ballons_polygenes = 0;\n  ++global_variable;;\n  if (muzziest_treadling != 0) {;\n    ballons_polygenes = muzziest_treadling;\n    garnel_klenk = grapewise_inbreathed(ballons_polygenes);\n    kicksies_conarium(carnivalesque_paumgartner,garnel_klenk);\n  }\n}\n\nfiddlesticks_gastronomies grapewise_inbreathed(fiddlesticks_gastronomies obtested_cautio)\n{\n  ++global_variable;\n  return obtested_cautio;\n}\n\nvoid kicksies_conarium(int eachelle_solarized,fiddlesticks_gastronomies glossotype_drowsily)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *germana_frenatae = 0;\n  ++global_variable;\n  eachelle_solarized--;\n  if (eachelle_solarized > 0) {\n    trigemini_crinoids(eachelle_solarized,glossotype_drowsily);\n    return ;\n  }\n  germana_frenatae = ((char *)glossotype_drowsily);\n      \n      len = strtol(germana_frenatae,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (glossotype_drowsily != 0) \n    free(((char *)glossotype_drowsily));\nclose_printf_context();\n}\n\nvoid trigemini_crinoids(int materia_indubiously,fiddlesticks_gastronomies menazons_multicharge)\n{\n  ++global_variable;\n  kicksies_conarium(materia_indubiously,menazons_multicharge);\n}", "answer": "i len values 0", "cwe": "476", "idx": "149652"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint isothermally_sourcefulness = 0;\nint global_variable;\nvoid handle_taint(char *laborite_inequally);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nint 190_global_var = 0;\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&isothermally_sourcefulness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *laborite_inequally)\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *xenicus_lawsuiting = 0;\n  jmp_buf overdeferential_vert;\n  int lackeyed_dipyramid;\n  int rattinet_prosphoron;\n  char **almury_undisobedient = 0;\n  char **excursionists_vagotonia = 0;\n  ++global_variable;;\n  if (laborite_inequally != 0) {;\n    rattinet_prosphoron = 1;\n    almury_undisobedient = &laborite_inequally;\n    excursionists_vagotonia = ((char **)(((unsigned long )almury_undisobedient) * rattinet_prosphoron * rattinet_prosphoron)) + 5;\n    lackeyed_dipyramid = setjmp(overdeferential_vert);\n    if (lackeyed_dipyramid == 0) {\n      longjmp(overdeferential_vert,1);\n    }\n    xenicus_lawsuiting = ((char *)( *(excursionists_vagotonia - 5)));\n    \n    tainted_int = atoi(xenicus_lawsuiting);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n    if ( *(excursionists_vagotonia - 5) != 0) \n      free(((char *)( *(excursionists_vagotonia - 5))));\nclose_printf_context();\n  }\n}", "answer": "tainted_int", "cwe": "190", "idx": "150749"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint hyperorthodoxy_marketeers = 0;\n\nunion donsy_buchu \n{\n  char *nonirritability_tigris;\n  double unburning_transitival;\n  char *peckville_yids;\n  char burgwell_gegger;\n  int wampus_geckotidae;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *rotifers_tormae = 0;\n  jmp_buf snefru_shama;\n  int megapolis_terrazzos;\n  int oligocholia_reswim;\n  union donsy_buchu *gonfalonierate_cronying = {0};\n  union donsy_buchu *influencive_requiescat = {0};\n  union donsy_buchu levoglucose_stimuli;\n  char *cityfolk_triumphancy;;\n  if (__sync_bool_compare_and_swap(&hyperorthodoxy_marketeers,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&cityfolk_triumphancy,\"RICHTON_SNEAKSBY\");\n      if (cityfolk_triumphancy != 0) {;\n        levoglucose_stimuli . nonirritability_tigris = cityfolk_triumphancy;\n        oligocholia_reswim = 1;\n        gonfalonierate_cronying = &levoglucose_stimuli;\n        influencive_requiescat = ((union donsy_buchu *)(((unsigned long )gonfalonierate_cronying) * oligocholia_reswim * oligocholia_reswim)) + 5;\n        megapolis_terrazzos = setjmp(snefru_shama);\n        if (megapolis_terrazzos == 0) {\n          longjmp(snefru_shama,1);\n        }\n        rotifers_tormae = ((char *)( *(influencive_requiescat - 5)) . nonirritability_tigris);\n    \n    if (strlen(rotifers_tormae) > 0 &&\n            rotifers_tormae[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(rotifers_tormae,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n        if (( *(influencive_requiescat - 5)) . nonirritability_tigris != 0) \n          free(((char *)( *(influencive_requiescat - 5)) . nonirritability_tigris));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "f w fopen filename_param", "cwe": "774", "idx": "151532"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint lovelass_xanthocyanopsy = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid periosteal_noncorporative(char *bushbody_cocopans);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n#define HONEYMOONSHINE_BLABBED(x) periosteal_noncorporative((char *) x)\n\nint timestamp_get_precision()\n{\n  char *clapper_tenography = 0;\n  long bayreuth_induvial[10];\n  char *formations_skiv[10] = {0};\n  char *geraniaceous_exomphalous;;\n  if (__sync_bool_compare_and_swap(&lovelass_xanthocyanopsy,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&geraniaceous_exomphalous,\"LOOKING_FACHINI\");\n      if (geraniaceous_exomphalous != 0) {;\n        formations_skiv[5] = geraniaceous_exomphalous;\n        bayreuth_induvial[1] = 5;\n        clapper_tenography =  *(formations_skiv + bayreuth_induvial[1]);\n\tHONEYMOONSHINE_BLABBED(clapper_tenography);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid periosteal_noncorporative(char *bushbody_cocopans)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *turgescent_nonvindication = 0;\n  ++global_variable;;\n  turgescent_nonvindication = ((char *)bushbody_cocopans);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(turgescent_nonvindication)+ 1));\n        if (cusData->data &&\n            (sscanf(turgescent_nonvindication, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if (bushbody_cocopans != 0) \n    free(((char *)bushbody_cocopans));\nclose_printf_context();\n}", "answer": "data free cusData", "cwe": "663", "idx": "150170"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <semaphore.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint tuberculoses_outfelt = 0;\nint global_variable;\nvoid corsned_snobol(char **cuyapo_exemplificator);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hydrostatician_anatifer(void (*dactylographic_possessory)(char **));\nsem_t sem;\npthread_t t0, t1;\nchar *global_str;\nint isspace(char c) {\n    return (c == ' ' || c == '\\t' || c == '\\n');\n}\nvoid *replaceSpace () {\n    int i = 0;\n    printf(\"Replacing spaces\\n\");\n    \n    \n    \n    sem_wait(&sem); \n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (isspace(global_str[i]) != 0) {\n            global_str[i] = '_';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\nvoid *toCap () {\n    int i = 0;\n    \n    \n    printf(\"Capitalizing input\\n\");\n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (global_str[i] > 'a' && global_str[i] < 'z') {\n            global_str[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&tuberculoses_outfelt,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      hydrostatician_anatifer(corsned_snobol);\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid corsned_snobol(char **cuyapo_exemplificator)\n{\n  int chanhassen_coglorious = 24;\n  char *prototypic_chindee;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&prototypic_chindee,\"8353\",chanhassen_coglorious);\n  if (prototypic_chindee != 0) {;\n     *cuyapo_exemplificator = prototypic_chindee;\n  }\n}\n\nvoid hydrostatician_anatifer(void (*dactylographic_possessory)(char **))\n{\n    int hasSpaces = 0;\n    int i = 0;\n  char *prevalescent_immaneness = 0;\n  char **gullying_washitas[91] = {0};\n  int agh_umest;\n  char **codicilic_metazoon = 0;\n  char **kapote_fruitages = 0;\n  ++global_variable;\n  char *intravalvular_conglomerations = 0;\n  dactylographic_possessory(&intravalvular_conglomerations);\n  if (intravalvular_conglomerations != 0) {;\n    agh_umest = 1;\n    codicilic_metazoon = &intravalvular_conglomerations;\n    kapote_fruitages = ((char **)(((unsigned long )codicilic_metazoon) * agh_umest * agh_umest)) + 5;\n    gullying_washitas[74] = kapote_fruitages;\n    prevalescent_immaneness = ((char *)( *(gullying_washitas[74] - 5)));\n    \n    sem_init(&sem, 0, 1);\n    while(prevalescent_immaneness[i] != '\\0') { \n        if (isspace(prevalescent_immaneness[i++]) != 0) { \n            hasSpaces = 1;\n        }\n    }\n    \n    global_str = malloc(sizeof(char) * strlen(prevalescent_immaneness) + 1);\n    strcpy(global_str, prevalescent_immaneness);\n    if (hasSpaces == 1) {\n        \n        \n        if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\n            printf(\"Thread 0 failed to spawn.\");\n        }\n        \n    }\n    if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\n        printf(\"Thread 1 failed to spawn.\");\n    }\n    if (hasSpaces == 1) {\n        pthread_join(t0, NULL);\n    }\n    pthread_join(t1, NULL);\n    \n;\n    if ( *(gullying_washitas[74] - 5) != 0) \n      free(((char *)( *(gullying_washitas[74] - 5))));\nclose_printf_context();\n  }\n}", "answer": "", "cwe": "764", "idx": "150243"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint erath_sublacustrine = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty);\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  int faithbreach_warrigals = 7;\n  char **overcherished_unprovide = 0;\n  char **merribush_spraggs = 0;\n  int townships_navete = 0;\n  char *voltages_sjenicki = 0;\n  char *electrotrephine_offend;;\n  if (__sync_bool_compare_and_swap(&erath_sublacustrine,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      electrotrephine_offend = getenv(\"KAOHSIUNG_GRAUBUNDEN\");\n      if (electrotrephine_offend != 0) {;\n        townships_navete = ((int )(strlen(electrotrephine_offend)));\n        voltages_sjenicki = ((char *)(malloc(townships_navete + 1)));\n        if (voltages_sjenicki == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(voltages_sjenicki,0,townships_navete + 1);\n        memcpy(voltages_sjenicki,electrotrephine_offend,townships_navete);\n        overcherished_unprovide = &voltages_sjenicki;\n        merribush_spraggs = overcherished_unprovide + 5;\n        philomythic_bronchotomy(faithbreach_warrigals,merribush_spraggs);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *posher_vitreouslike = 0;\n  ++global_variable;\n  receiptless_unroasted--;\n  if (receiptless_unroasted > 0) {\n    ficuses_hornswoggled(receiptless_unroasted,minsteryard_megadonty);\n    return ;\n  }\n  posher_vitreouslike = ((char *)( *(minsteryard_megadonty - 5)));\n      \n      while(isalnum(posher_vitreouslike[size]) && size < strlen(posher_vitreouslike)){\n        ++size;\n      }\n      \n\n      if (size != strlen(posher_vitreouslike)) {\n        posher_vitreouslike = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,posher_vitreouslike);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if ( *(minsteryard_megadonty - 5) != 0) \n    free(((char *)( *(minsteryard_megadonty - 5))));\nclose_printf_context();\n}\n\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness)\n{\n  ++global_variable;\n  philomythic_bronchotomy(polygene_mutable,modishly_knowableness);\n}\n#endif", "answer": "strlen posher_vitreouslike", "cwe": "476", "idx": "149284"}
{"code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint sala_basiradial = 0;\nint global_variable;\n\nunion pliability_gestures \n{\n  char *unrhymed_ichorous;\n  double steins_tupian;\n  char *perching_backspang;\n  char glossal_addicting;\n  int uncreated_forthgaze;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid mushes_olonetsish(const union pliability_gestures retramp_anhydride);\nstruct struct {\n    char before[64];\n    char buffer[64];\n    char after[64];\n};\n\nSize PMSignalShmemSize()\n{\n  union pliability_gestures paradisally_mundugumors;\n  char *supersets_freeloads;\n  Size size;\n  if (__sync_bool_compare_and_swap(&sala_basiradial,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      supersets_freeloads = getenv(\"PLUMPNESSES_PARTAKES\");\n      if (supersets_freeloads != 0) {;\n        paradisally_mundugumors . unrhymed_ichorous = supersets_freeloads;\n        mushes_olonetsish(paradisally_mundugumors);\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid mushes_olonetsish(const union pliability_gestures retramp_anhydride)\n{\n    int i = 0;\n    int buff_size = 0;\n    struct struct* data = NULL;\n  char *enville_caratch = 0;\n  ++global_variable;;\n  enville_caratch = ((char *)((union pliability_gestures )retramp_anhydride) . unrhymed_ichorous);\n    \n    \n    \n    data = (struct struct*) malloc(sizeof(struct struct));\n    if (data != NULL) {\n        memset(data->before, 'A', 63);\n        data->before[63] = '\\0';\n        memset(data->buffer, 'Q', 63);\n        data->buffer[63] = '\\0';\n        memset(data->after, 'A', 63);\n        data->after[63] = '\\0';\n        \n        \n        \n        \n        \n        buff_size = ((int )(strlen(enville_caratch)));\n        memcpy(data->buffer, enville_caratch, 64);\n        for (; i < buff_size; ++i){\n            \n            \n            printf(\"%x\",data->buffer[i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( data);\n        \n        \n    }\n;\nclose_printf_context();\n}", "answer": "strlen int enville_caratch data i x buffer buff_size 64 memcpy", "cwe": "126", "idx": "152947"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint spaceward_metastability = 0;\nint global_variable;\n\nunion snowville_arene \n{\n  char *stoneweed_witted;\n  double airstrip_denies;\n  char *preforgave_bolete;\n  char stibnite_meeker;\n  int alite_swoony;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunion snowville_arene ergophobic_unmoaning(union snowville_arene neologising_ezechiel);\nvoid function() {\n    \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *widowlike_antisceptic = 0;\n  union snowville_arene lymphangiitis_gallia = {0};\n  union snowville_arene sollicking_megabuck;\n  int saturants_ethylin = 7;\n  char *menstrual_phenanthrol;;\n  if (__sync_bool_compare_and_swap(&spaceward_metastability,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&menstrual_phenanthrol,\"1731\",saturants_ethylin);\n      if (menstrual_phenanthrol != 0) {;\n        sollicking_megabuck . stoneweed_witted = menstrual_phenanthrol;\n        lymphangiitis_gallia = ergophobic_unmoaning(sollicking_megabuck);\n        widowlike_antisceptic = ((char *)lymphangiitis_gallia . stoneweed_witted);\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(widowlike_antisceptic) >= 1 &&\n            widowlike_antisceptic[0] != '-') {\n        input_num = strtoul(widowlike_antisceptic,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(widowlike_antisceptic) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n        if (lymphangiitis_gallia . stoneweed_witted != 0) \n          free(((char *)lymphangiitis_gallia . stoneweed_witted));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nunion snowville_arene ergophobic_unmoaning(union snowville_arene neologising_ezechiel)\n{\n  ++global_variable;\n  return neologising_ezechiel;\n}", "answer": "", "cwe": "682", "idx": "151350"}
{"code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <limits.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint maas_deathwatches = 0;\n\nstruct enterprise_quackle \n{\n  char *eventognathous_eucairite;\n  double piculule_esthesio;\n  char *hungered_pearlbush;\n  char spears_gammoner;\n  int vigilation_hematolysis;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint 190_global_var = 0;\n\nSize PMSignalShmemSize()\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *forechoose_kookri = 0;\n  struct enterprise_quackle ventriloquisms_methylaniline;\n  char *champion_neurocelian;\n  Size size;\n  if (__sync_bool_compare_and_swap(&maas_deathwatches,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      champion_neurocelian = getenv(\"ACCESSARILY_TWINBERRY\");\n      if (champion_neurocelian != 0) {;\n        ventriloquisms_methylaniline . eventognathous_eucairite = ((char *)champion_neurocelian);\n        forechoose_kookri = ((char *)ventriloquisms_methylaniline . eventognathous_eucairite);\n    \n    tainted_int = atoi(forechoose_kookri);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "tainted_int", "cwe": "190", "idx": "151158"}
{"code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint malproportioned_pharyngoxerosis = 0;\n\nstruct mechanicsville_apomixes \n{\n  char *dumky_linder;\n  double sintering_opalesce;\n  char *serratodentate_inblowing;\n  char dispense_unattacked;\n  int kalis_oxalemia;\n}\n;\nint global_variable;\nvoid handle_taint(char *daylights_astromeda);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid crfc_unbullying(struct mechanicsville_apomixes **satisfactional_cyclical);\nvoid concocter_ciconiid(struct mechanicsville_apomixes **autarchies_rabbanite);\nvoid urlDecode(char *src, char *dst) {\n    char a, b;\n    while (*src) {\n        if ((*src == '%') &&\n                ((a = src[1]) && (b = src[2])) &&\n                (isxdigit(a) && isxdigit(b))) {\n            if (a >= 'a')\n                a -= 'a'-'A';\n            if (a >= 'A')\n                a -= ('A' - 10);\n            else\n                a -= '0';\n            if (b >= 'a')\n                b -= 'a'-'A';\n            if (b >= 'A')\n                b -= ('A' - 10);\n            else\n                b -= '0';\n            *dst++ = 16*a+b;\n            src+=3;\n        } else {\n            *dst++ = *src++;\n        }\n    }\n    *dst++ = '\\0';\n}\nint isValid(char *src) {\n    int i = 0;\n    while (src[i] != '\\0') {\n        if(src[i] == ';') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        else if(src[i] == '|') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        else if(src[i] == '&') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        i++;\n    }\n    return 1;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&malproportioned_pharyngoxerosis,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid handle_taint(char *daylights_astromeda)\n{\n  struct mechanicsville_apomixes **ballocks_armhoop = 0;\n  struct mechanicsville_apomixes *mensurational_willable = 0;\n  struct mechanicsville_apomixes enfettered_badenite = {0};\n  struct mechanicsville_apomixes tailband_celeuthea;\n  ++global_variable;;\n  if (daylights_astromeda != 0) {;\n    tailband_celeuthea . dumky_linder = ((char *)daylights_astromeda);\n    mensurational_willable = &tailband_celeuthea;\n    ballocks_armhoop = &mensurational_willable;\n    crfc_unbullying(ballocks_armhoop);\n  }\n}\n\nvoid crfc_unbullying(struct mechanicsville_apomixes **satisfactional_cyclical)\n{\n  ++global_variable;;\n  concocter_ciconiid(satisfactional_cyclical);\n}\n\nvoid concocter_ciconiid(struct mechanicsville_apomixes **autarchies_rabbanite)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char *parsed_input;\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *filch_delawarean = 0;\n  ++global_variable;;\n  filch_delawarean = ((char *)( *( *autarchies_rabbanite)) . dumky_linder);\n    \n    if (strlen(filch_delawarean) < 1000 - strlen(command_str)) {\n        \n        \n        \n        if (isValid(filch_delawarean) == 1) {\n            parsed_input = malloc((strlen(filch_delawarean)+1) * sizeof(char));\n            urlDecode(filch_delawarean, parsed_input);\n            snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\n            \n            \n            \n            \n            fpipe = popen(command_buffer,\"r\");\n            if (fpipe != 0) {\n                while(fgets(buffer,100,fpipe) != 0) {\n                    printf(buffer);\n                }\n                pclose(fpipe);\n            }\n        }\n        \n    }\n    \n;\n  if (( *( *autarchies_rabbanite)) . dumky_linder != 0) \n    free(((char *)( *( *autarchies_rabbanite)) . dumky_linder));\nclose_printf_context();\n}", "answer": "command_buffer", "cwe": "78", "idx": "152450"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint combinator_interrhyme = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid rajahs_patentor(int roe_ags,char *gyratory_bout);\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  int poisonberry_cyanotic = 7;\n  int behaviors_lyric = 0;\n  char *gramash_enchoric = 0;\n  char *unordered_ibiza;;\n  if (__sync_bool_compare_and_swap(&combinator_interrhyme,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      unordered_ibiza = getenv(\"BSEE_ENGOUE\");\n      if (unordered_ibiza != 0) {;\n        behaviors_lyric = ((int )(strlen(unordered_ibiza)));\n        gramash_enchoric = ((char *)(malloc(behaviors_lyric + 1)));\n        if (gramash_enchoric == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(gramash_enchoric,0,behaviors_lyric + 1);\n        memcpy(gramash_enchoric,unordered_ibiza,behaviors_lyric);\n        rajahs_patentor(poisonberry_cyanotic,gramash_enchoric);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid rajahs_patentor(int roe_ags,char *gyratory_bout)\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *edriasteroidea_microliter = 0;\n  ++global_variable;\n  roe_ags--;\n  if (roe_ags > 0) {\n    rajahs_patentor(roe_ags,gyratory_bout);\n    return ;\n  }\n  edriasteroidea_microliter = ((char *)gyratory_bout);\n    \n    if (strlen(edriasteroidea_microliter) > 0 &&\n        edriasteroidea_microliter[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(edriasteroidea_microliter);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n  if (gyratory_bout != 0) \n    free(((char *)gyratory_bout));\nclose_printf_context();\n}", "answer": "num", "cwe": "196", "idx": "151151"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint prolegomenist_intwist = 0;\nint global_variable;\nvoid handle_taint(char *wanshape_messianically);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid updiving_spinner(char **vicissitudinous_aphoristic);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&prolegomenist_intwist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *wanshape_messianically)\n{\n  char **opisthoparia_jahvism = 0;\n  char **pyrola_forecastles = 0;\n  ++global_variable;;\n  if (wanshape_messianically != 0) {;\n    opisthoparia_jahvism = &wanshape_messianically;\n    pyrola_forecastles = opisthoparia_jahvism + 5;\n    updiving_spinner(pyrola_forecastles);\n  }\n}\n\nvoid updiving_spinner(char **vicissitudinous_aphoristic)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  int is_valid = 1;\n  int i = 0;\n  char cmd_str[1000] = {0};\n  char *rhetorical_desterilize = 0;\n  ++global_variable;;\n  rhetorical_desterilize = ((char *)( *(vicissitudinous_aphoristic - 5)));\n    \n    \n\n    snprintf(cmd_str, 1000, \"vim -s \" \"/opt/cus/workspace/testData/\" \"vim_scripts/hello.vim %s\", rhetorical_desterilize);\n    \n    for (; i < strlen(rhetorical_desterilize); ++i) {\n        if (rhetorical_desterilize[i] == ';') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '|') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '|') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '|') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '&') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '&') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '&') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      \n      if (is_valid == 1) {\n        \n\n        fpipe = popen(cmd_str, \"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n  if ( *(vicissitudinous_aphoristic - 5) != 0) \n    free(((char *)( *(vicissitudinous_aphoristic - 5))));\nclose_printf_context();\n}", "answer": "cmd_str 0", "cwe": "88", "idx": "152804"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <unistd.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint rebilling_parallelable = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n int oc_i = 0;\n int opt_var;\n  char *usherian_fontinas = 0;\n  jmp_buf tungus_unseduced;\n  int labdanum_liber;\n  char **droopiness_chiniks = 0;\n  long tswanas_orthopyramid[10];\n  char **unirritableness_furrily[10] = {0};\n  char *muscularities_balistraria[32] = {0};\n  char *urinoscopy_papulan;;\n  if (__sync_bool_compare_and_swap(&rebilling_parallelable,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      urinoscopy_papulan = getenv(\"VIOLATER_PAPISTICAL\");\n      if (urinoscopy_papulan != 0) {;\n        muscularities_balistraria[7] = urinoscopy_papulan;\n        unirritableness_furrily[5] = muscularities_balistraria;\n        tswanas_orthopyramid[1] = 5;\n        droopiness_chiniks =  *(unirritableness_furrily + tswanas_orthopyramid[1]);\n        labdanum_liber = setjmp(tungus_unseduced);\n        if (labdanum_liber == 0) {\n          longjmp(tungus_unseduced,1);\n        }\n        usherian_fontinas = ((char *)droopiness_chiniks[7]);\n    \n size_t (*canary_pointer[1])(const char *);\n char base_path[20];\n    if (strlen(usherian_fontinas) < 20) {\n        canary_pointer[0] = strlen;\n        memset(base_path,0,20);\n        \n        \n        \n        \n        \n        \n        \n  \n  \n        realpath(usherian_fontinas,base_path);\n        opt_var = canary_pointer[0](base_path);\n        \n        for (; oc_i < opt_var; ++oc_i) {\n   base_path[oc_i] = toupper(base_path[oc_i]);\n        }\n        printf(\"%s\\n\",base_path);\n        \n        \n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "realpath toupper usherian_fontinas n oc_i 0 canary_pointer s base_path opt_var", "cwe": "785", "idx": "153602"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint foreseer_esocataphoria = 0;\ntypedef char *celibacies_rereel;\nint global_variable;\nvoid handle_taint(char *needly_tipsification);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid significator_retaker(const celibacies_rereel amphictyonies_eosine);\nvoid mnemonism_propanedioic(celibacies_rereel guttate_plagioclinal);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&foreseer_esocataphoria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *needly_tipsification)\n{\n  celibacies_rereel maugansville_ellington = 0;\n  ++global_variable;;\n  if (needly_tipsification != 0) {;\n    maugansville_ellington = needly_tipsification;\n    significator_retaker(maugansville_ellington);\n  }\n}\n\nvoid significator_retaker(const celibacies_rereel amphictyonies_eosine)\n{\n  void (*curtailing_denicotinizes)(celibacies_rereel ) = mnemonism_propanedioic;\n  ++global_variable;;\n  curtailing_denicotinizes(amphictyonies_eosine);\n}\n\nvoid mnemonism_propanedioic(celibacies_rereel guttate_plagioclinal)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *gomulka_tinty = 0;\n  ++global_variable;;\n  gomulka_tinty = ((char *)((celibacies_rereel )guttate_plagioclinal));\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(gomulka_tinty) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (gomulka_tinty[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &gomulka_tinty[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\n  if (((celibacies_rereel )guttate_plagioclinal) != 0) \n    free(((char *)((celibacies_rereel )guttate_plagioclinal)));\nclose_printf_context();\n}\n#endif", "answer": "strlen i n second_buff", "cwe": "476", "idx": "149941"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint stouten_jade = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *bnsc_teethless = 0;\n  char **revivor_landladydom = 0;\n  long ratability_boatel[10];\n  char **durables_antares[10] = {0};\n  char *superfidel_prelabor[25] = {0};\n  int rollichie_buyers = 5;\n  char *bedog_fepc;;\n  if (__sync_bool_compare_and_swap(&stouten_jade,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&bedog_fepc,\"7609\",rollichie_buyers);\n      if (bedog_fepc != 0) {;\n        superfidel_prelabor[1] = bedog_fepc;\n        durables_antares[5] = superfidel_prelabor;\n        ratability_boatel[1] = 5;\n        revivor_landladydom =  *(durables_antares + ratability_boatel[1]);\n        bnsc_teethless = ((char *)revivor_landladydom[1]);\n    \n    if (strlen(bnsc_teethless) > 0 &&\n            bnsc_teethless[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(bnsc_teethless,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n        if (revivor_landladydom[1] != 0) \n          free(((char *)revivor_landladydom[1]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "f w fopen filename_param", "cwe": "774", "idx": "151594"}
{"code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint codisjunct_bureaucratese = 0;\nint global_variable;\nvoid handle_taint(char *defuzes_hydroiodic);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid multithreaded_traditionally(char *(*ritornellos_namare)[29]);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&codisjunct_bureaucratese,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n#define PHORONOMY_ANORECTOUS(x) multithreaded_traditionally((char *(*)[29]) x)\n\nvoid handle_taint(char *defuzes_hydroiodic)\n{\n  char *(*longrun_bridgemen)[29] = 0;\n  char **combustions_trochalopod = 0;\n  char *bobsleded_declassed[29] = {0};\n  ++global_variable;;\n  if (defuzes_hydroiodic != 0) {;\n    bobsleded_declassed[8] = defuzes_hydroiodic;\n    longrun_bridgemen = &bobsleded_declassed;\n\tPHORONOMY_ANORECTOUS(longrun_bridgemen);\n  }\n}\n\nvoid multithreaded_traditionally(char *(*ritornellos_namare)[29])\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *humorific_quadrilling = 0;\n  ++global_variable;;\n  humorific_quadrilling = ((char *)( *ritornellos_namare)[8]);\n    \n    in_val = atoll(humorific_quadrilling);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (( *ritornellos_namare)[8] != 0) \n    free(((char *)( *ritornellos_namare)[8]));\nclose_printf_context();\n}", "answer": "in_val check_val 1 break prime 0", "cwe": "834", "idx": "151604"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nint zymoid_radiolocators = 0;\nint global_variable;\n\nunion mameliere_moderant \n{\n  char *unnymphal_stenopeic;\n  double fanback_scarify;\n  char *homeoplasy_semimarking;\n  char nonprofanely_nonprossing;\n  int albertine_bondship;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid redshift_whiggish(int conchuela_leibnitz,... );\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  union mameliere_moderant cowtail_obelism;\n  char *homos_theistically;;\n  if (__sync_bool_compare_and_swap(&zymoid_radiolocators,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      homos_theistically = getenv(\"HALFPENCE_FESTA\");\n      if (homos_theistically != 0) {;\n        cowtail_obelism . unnymphal_stenopeic = homos_theistically;\n        redshift_whiggish(1,cowtail_obelism);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid redshift_whiggish(int conchuela_leibnitz,... )\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *wished_ravenelia = 0;\n  union mameliere_moderant padres_brachet = {0};\n  va_list sphaeriaceae_withcall;\n  ++global_variable;;\n  if (conchuela_leibnitz > 0) {\n    __builtin_va_start(sphaeriaceae_withcall,conchuela_leibnitz);\n    padres_brachet = (va_arg(sphaeriaceae_withcall,union mameliere_moderant ));\n    __builtin_va_end(sphaeriaceae_withcall);\n  }\n  wished_ravenelia = ((char *)padres_brachet . unnymphal_stenopeic);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(wished_ravenelia); ++i) {\n        if (wished_ravenelia[i] == ';') {\n          if (i == 0 || wished_ravenelia[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,wished_ravenelia);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n}", "answer": "cmd_string", "cwe": "88", "idx": "152635"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint premious_tanbark = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid herbary_mystacocete(char *suppliants_throop);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n#define RUNOLOGY_CHOPPER(x) herbary_mystacocete((char *) x)\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  char *astrolatry_plang;;\n  if (__sync_bool_compare_and_swap(&premious_tanbark,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&astrolatry_plang,\"TOASTERS_BAI\");\n      if (astrolatry_plang != 0) {;\n\tRUNOLOGY_CHOPPER(astrolatry_plang);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid herbary_mystacocete(char *suppliants_throop)\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *antigene_trachycarpous = 0;\n  ++global_variable;;\n  antigene_trachycarpous = ((char *)suppliants_throop);\n    \n    in_val = atoll(antigene_trachycarpous);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (suppliants_throop != 0) \n    free(((char *)suppliants_throop));\nclose_printf_context();\n}", "answer": "in_val check_val 1 break prime 0", "cwe": "834", "idx": "151512"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <semaphore.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint vorticella_intumescing = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nsem_t sem;\npthread_t t0, t1;\nchar *global_str;\nint isspace(char c) {\n    return (c == ' ' || c == '\\t' || c == '\\n');\n}\nvoid *replaceSpace () {\n    int i = 0;\n    printf(\"Replacing spaces\\n\");\n    \n    \n    \n    sem_wait(&sem); \n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (isspace(global_str[i]) != 0) {\n            global_str[i] = '_';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\nvoid *toCap () {\n    int i = 0;\n    \n    \n    printf(\"Capitalizing input\\n\");\n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (global_str[i] > 'a' && global_str[i] < 'z') {\n            global_str[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n    int hasSpaces = 0;\n    int i = 0;\n  char *barbecuer_overheap = 0;\n  char **cargos_obiism = 0;\n  char **unirritableness_kun = 0;\n  char *leisureless_boito;;\n  if (__sync_bool_compare_and_swap(&vorticella_intumescing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      leisureless_boito = getenv(\"REUNE_SHOTTY\");\n      if (leisureless_boito != 0) {;\n        cargos_obiism = &leisureless_boito;\n        unirritableness_kun = cargos_obiism + 5;\n        if ( *(unirritableness_kun - 5) != 0) {\n          goto tex_tourmalinize;\n        }\n        ++global_variable;\n        tex_tourmalinize:;\n        barbecuer_overheap = ((char *)( *(unirritableness_kun - 5)));\n    \n    sem_init(&sem, 0, 1);\n    while(barbecuer_overheap[i] != '\\0') { \n        if (isspace(barbecuer_overheap[i++]) != 0) { \n            hasSpaces = 1;\n        }\n    }\n    \n    global_str = malloc(sizeof(char) * strlen(barbecuer_overheap) + 1);\n    strcpy(global_str, barbecuer_overheap);\n    if (hasSpaces == 1) {\n        \n        \n        if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\n            printf(\"Thread 0 failed to spawn.\");\n        }\n        \n    }\n    if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\n        printf(\"Thread 1 failed to spawn.\");\n    }\n    if (hasSpaces == 1) {\n        pthread_join(t0, NULL);\n    }\n    pthread_join(t1, NULL);\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "", "cwe": "764", "idx": "150318"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint chopped_giftie = 0;\nint global_variable;\nvoid handle_taint(char *unrecriminative_apologizer);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid *extractively_heterologically(void *sanctioned_aune);\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&chopped_giftie,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *unrecriminative_apologizer)\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *xiphosuran_cossas = 0;\n  void *squirreling_intrenching = 0;\n  void *shorteners_amphiploid = 0;\n  ++global_variable;;\n  if (unrecriminative_apologizer != 0) {;\n    shorteners_amphiploid = ((void *)unrecriminative_apologizer);\n    squirreling_intrenching = extractively_heterologically(shorteners_amphiploid);\n    xiphosuran_cossas = ((char *)((char *)squirreling_intrenching));\n    \n    if (strlen(xiphosuran_cossas) > 0 &&\n        xiphosuran_cossas[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(xiphosuran_cossas);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n    if (((char *)squirreling_intrenching) != 0) \n      free(((char *)((char *)squirreling_intrenching)));\nclose_printf_context();\n  }\n}\n\nvoid *extractively_heterologically(void *sanctioned_aune)\n{\n  ++global_variable;\n  return sanctioned_aune;\n}", "answer": "num", "cwe": "196", "idx": "150788"}
{"code": "#include <apr_pools.h>\n#include <apr_uuid.h>\n#include \"svn_hash.h\"\n#include \"svn_types.h\"\n#include \"svn_error.h\"\n#include \"svn_string.h\"\n#include \"svn_props.h\"\n#include \"svn_private_config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint rotors_giltner = 0;\nint global_variable;\nvoid handle_taint(char *galvanographic_unsteels);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid espouse_tracheaectasy(int subdermal_cullis,void **acidophilic_chinaphthol);\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nsvn_error_t *svn_revnum_parse(svn_revnum_t *rev,const char *str,const char **endptr)\n{\n  char *end;\n  svn_revnum_t result = strtol(str,&end,10);\n  if (endptr) {\n     *endptr = end;\n  }\n  if (str == end) {\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Invalid revision number found parsing '%s'\")),str);\n  }\n  if (result < 0) {\n\n    if (endptr) {\n       *endptr = str;\n    }\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Negative revision number found parsing '%s'\")),str);\n  }\n   *rev = result;\n  return 0;\n}\n\nconst char *svn_uuid_generate(apr_pool_t *pool)\n{\n  apr_uuid_t uuid;\n  char *uuid_str = (memset(apr_palloc(pool,(36 + 1)),0,(36 + 1)));\n  apr_uuid_get(&uuid);\n  apr_uuid_format(uuid_str,(&uuid));\n  return uuid_str;\n}\n\nconst char *svn_depth_to_word(svn_depth_t depth)\n{\n  switch(depth){\n    case svn_depth_exclude:\n    return \"exclude\";\n    case svn_depth_unknown:\n    return \"unknown\";\n    case svn_depth_empty:\n    return \"empty\";\n    case svn_depth_files:\n    return \"files\";\n    case svn_depth_immediates:\n    return \"immediates\";\n    case svn_depth_infinity:\n    return \"infinity\";\n    default:\n    return \"INVALID-DEPTH\";\n  }\n}\n\nsvn_depth_t svn_depth_from_word(const char *word)\n{\n  if (strcmp(word,\"exclude\") == 0) {\n    return svn_depth_exclude;\n  }\n  if (strcmp(word,\"unknown\") == 0) {\n    return svn_depth_unknown;\n  }\n  if (strcmp(word,\"empty\") == 0) {\n    return svn_depth_empty;\n  }\n  if (strcmp(word,\"files\") == 0) {\n    return svn_depth_files;\n  }\n  if (strcmp(word,\"immediates\") == 0) {\n    return svn_depth_immediates;\n  }\n  if (strcmp(word,\"infinity\") == 0) {\n    return svn_depth_infinity;\n  }\n\n  return svn_depth_unknown;\n}\n\nconst char *svn_node_kind_to_word(svn_node_kind_t kind)\n{\n  switch(kind){\n    case svn_node_none:\n    return \"none\";\n    case svn_node_file:\n    return \"file\";\n    case svn_node_dir:\n    return \"dir\";\n    case svn_node_symlink:\n    return \"symlink\";\n    case svn_node_unknown:\n{\n    }\n    default:\n    return \"unknown\";\n  }\n}\n\nsvn_node_kind_t svn_node_kind_from_word(const char *word)\n{\n  if (word == ((void *)0)) {\n    return svn_node_unknown;\n  }\n  if (strcmp(word,\"none\") == 0) {\n    return svn_node_none;\n  }\n  else {\n    if (strcmp(word,\"file\") == 0) {\n      return svn_node_file;\n    }\n    else {\n      if (strcmp(word,\"dir\") == 0) {\n        return svn_node_dir;\n      }\n      else {\n        if (strcmp(word,\"symlink\") == 0) {\n          return svn_node_symlink;\n        }\n        else {\n\n          return svn_node_unknown;\n        }\n      }\n    }\n  }\n}\n\nconst char *svn_tristate__to_word(svn_tristate_t tristate)\n{\n  switch(tristate){\n    case svn_tristate_false:\n    return \"false\";\n    case svn_tristate_true:\n    return \"true\";\n    case svn_tristate_unknown:\n{\n    }\n    default:\n    return ((void *)0);\n  }\n}\n\nsvn_tristate_t svn_tristate__from_word(const char *word)\n{;\n  if (__sync_bool_compare_and_swap(&rotors_giltner,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (word == ((void *)0)) {\n    return svn_tristate_unknown;\n  }\n  else {\n    if (0 == svn_cstring_casecmp(word,\"true\") || 0 == svn_cstring_casecmp(word,\"yes\") || 0 == svn_cstring_casecmp(word,\"on\") || 0 == strcmp(word,\"1\")) {\n      return svn_tristate_true;\n    }\n    else {\n      if (0 == svn_cstring_casecmp(word,\"false\") || 0 == svn_cstring_casecmp(word,\"no\") || 0 == svn_cstring_casecmp(word,\"off\") || 0 == strcmp(word,\"0\")) {\n        return svn_tristate_false;\n      }\n    }\n  }\n  return svn_tristate_unknown;\n}\n\nsvn_commit_info_t *svn_create_commit_info(apr_pool_t *pool)\n{\n  svn_commit_info_t *commit_info = (memset(apr_palloc(pool,sizeof(( *commit_info))),0,sizeof(( *commit_info))));\n  commit_info -> revision = ((svn_revnum_t )(- 1));\n\n  return commit_info;\n}\n\nsvn_commit_info_t *svn_commit_info_dup(const svn_commit_info_t *src_commit_info,apr_pool_t *pool)\n{\n  svn_commit_info_t *dst_commit_info = (apr_palloc(pool,sizeof(( *dst_commit_info))));\n  dst_commit_info -> date = ((src_commit_info -> date?apr_pstrdup(pool,src_commit_info -> date) : ((void *)0)));\n  dst_commit_info -> author = ((src_commit_info -> author?apr_pstrdup(pool,src_commit_info -> author) : ((void *)0)));\n  dst_commit_info -> revision = src_commit_info -> revision;\n  dst_commit_info -> post_commit_err = ((src_commit_info -> post_commit_err?apr_pstrdup(pool,src_commit_info -> post_commit_err) : ((void *)0)));\n  dst_commit_info -> repos_root = ((src_commit_info -> repos_root?apr_pstrdup(pool,src_commit_info -> repos_root) : ((void *)0)));\n  return dst_commit_info;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_create(apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (memset(apr_palloc(pool,sizeof(( *new_changed_path))),0,sizeof(( *new_changed_path))));\n  new_changed_path -> text_modified = svn_tristate_unknown;\n  new_changed_path -> props_modified = svn_tristate_unknown;\n  return new_changed_path;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_dup(const svn_log_changed_path2_t *changed_path,apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (apr_palloc(pool,sizeof(( *new_changed_path))));\n   *new_changed_path =  *changed_path;\n  if (new_changed_path -> copyfrom_path) {\n    new_changed_path -> copyfrom_path = (apr_pstrdup(pool,new_changed_path -> copyfrom_path));\n  }\n  return new_changed_path;\n}\n\nsvn_dirent_t *svn_dirent_create(apr_pool_t *result_pool)\n{\n  svn_dirent_t *new_dirent = (memset(apr_palloc(result_pool,sizeof(( *new_dirent))),0,sizeof(( *new_dirent))));\n  new_dirent -> kind = svn_node_unknown;\n  new_dirent -> size = ((svn_filesize_t )(- 1));\n  new_dirent -> created_rev = ((svn_revnum_t )(- 1));\n  new_dirent -> time = 0;\n  new_dirent -> last_author = ((void *)0);\n  return new_dirent;\n}\n\nsvn_dirent_t *svn_dirent_dup(const svn_dirent_t *dirent,apr_pool_t *pool)\n{\n  svn_dirent_t *new_dirent = (apr_palloc(pool,sizeof(( *new_dirent))));\n   *new_dirent =  *dirent;\n  new_dirent -> last_author = (apr_pstrdup(pool,dirent -> last_author));\n  return new_dirent;\n}\n\nsvn_log_entry_t *svn_log_entry_create(apr_pool_t *pool)\n{\n  svn_log_entry_t *log_entry = (memset(apr_palloc(pool,sizeof(( *log_entry))),0,sizeof(( *log_entry))));\n  return log_entry;\n}\n\nsvn_log_entry_t *svn_log_entry_dup(const svn_log_entry_t *log_entry,apr_pool_t *pool)\n{\n  apr_hash_index_t *hi;\n  svn_log_entry_t *new_entry = (apr_palloc(pool,sizeof(( *new_entry))));\n   *new_entry =  *log_entry;\n  if (log_entry -> revprops) {\n    new_entry -> revprops = svn_prop_hash_dup((log_entry -> revprops),pool);\n  }\n  if (log_entry -> changed_paths2) {\n    new_entry -> changed_paths2 = apr_hash_make(pool);\n    for (hi = apr_hash_first(pool,log_entry -> changed_paths2); hi; hi = apr_hash_next(hi)) {\n      const void *key;\n      void *change;\n      apr_hash_this(hi,&key,((void *)0),&change);\n      apr_hash_set(new_entry -> changed_paths2,(apr_pstrdup(pool,key)),(- 1),(svn_log_changed_path2_dup(change,pool)));\n    }\n  }\n\n  new_entry -> changed_paths = new_entry -> changed_paths2;\n  return new_entry;\n}\n\nsvn_location_segment_t *svn_location_segment_dup(const svn_location_segment_t *segment,apr_pool_t *pool)\n{\n  svn_location_segment_t *new_segment = (apr_palloc(pool,sizeof(( *new_segment))));\n   *new_segment =  *segment;\n  if (segment -> path) {\n    new_segment -> path = (apr_pstrdup(pool,segment -> path));\n  }\n  return new_segment;\n}\n\nvoid handle_taint(char *galvanographic_unsteels)\n{\n  int craftsbury_nonreliably = 7;\n  void **thunderheaded_boors = 0;\n  void **achlorophyllous_tankette = 0;\n  void *cailly_bellbinder = 0;\n  ++global_variable;;\n  if (galvanographic_unsteels != 0) {;\n    cailly_bellbinder = ((void *)galvanographic_unsteels);\n    thunderheaded_boors = &cailly_bellbinder;\n    achlorophyllous_tankette = thunderheaded_boors + 5;\n    espouse_tracheaectasy(craftsbury_nonreliably,achlorophyllous_tankette);\n  }\n}\n\nvoid espouse_tracheaectasy(int subdermal_cullis,void **acidophilic_chinaphthol)\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *rhizocarpean_undelayed = 0;\n  ++global_variable;\n  subdermal_cullis--;\n  if (subdermal_cullis > 0) {\n    espouse_tracheaectasy(subdermal_cullis,acidophilic_chinaphthol);\n    return ;\n  }\n  rhizocarpean_undelayed = ((char *)((char *)( *(acidophilic_chinaphthol - 5))));\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, rhizocarpean_undelayed);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, rhizocarpean_undelayed, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\n  if (((char *)( *(acidophilic_chinaphthol - 5))) != 0) \n    free(((char *)((char *)( *(acidophilic_chinaphthol - 5)))));\nclose_printf_context();\n}", "answer": "size_var rhizocarpean_undelayed dest", "cwe": "195", "idx": "151101"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint pausalion_sceptres = 0;\nint global_variable;\n\nstruct almadie_ailyn \n{\n  char *casher_cryptocephalous;\n  double denouements_nonstainable;\n  char *precentress_leucoid;\n  char coastguard_percesocine;\n  int recognizably_irondale;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid asarota_sarcoptes(int failingly_pikeblennies,struct almadie_ailyn *platycercinae_hippodame);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int successfully_inductivity = 7;\n  int hemophile_brugge;\n  struct almadie_ailyn *pleometrosis_steganopod = {0};\n  struct almadie_ailyn *tribbett_columnizes = {0};\n  struct almadie_ailyn mythohistoric_pulpily;\n  char *deordination_tarmac;;\n  if (__sync_bool_compare_and_swap(&pausalion_sceptres,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&deordination_tarmac,\"GEODES_CAPOCCHIA\");\n      if (deordination_tarmac != 0) {;\n        mythohistoric_pulpily . casher_cryptocephalous = ((char *)deordination_tarmac);\n        hemophile_brugge = 1;\n        pleometrosis_steganopod = &mythohistoric_pulpily;\n        tribbett_columnizes = ((struct almadie_ailyn *)(((unsigned long )pleometrosis_steganopod) * hemophile_brugge * hemophile_brugge)) + 5;\n        asarota_sarcoptes(successfully_inductivity,tribbett_columnizes);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid asarota_sarcoptes(int failingly_pikeblennies,struct almadie_ailyn *platycercinae_hippodame)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *natalina_chorographical = 0;\n  ++global_variable;\n  failingly_pikeblennies--;\n  if (failingly_pikeblennies > 0) {\n    asarota_sarcoptes(failingly_pikeblennies,platycercinae_hippodame);\n    return ;\n  }\n  natalina_chorographical = ((char *)( *(platycercinae_hippodame - 5)) . casher_cryptocephalous);\n      \n      len = strtol(natalina_chorographical,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (( *(platycercinae_hippodame - 5)) . casher_cryptocephalous != 0) \n    free(((char *)( *(platycercinae_hippodame - 5)) . casher_cryptocephalous));\nclose_printf_context();\n}", "answer": "i len values 0", "cwe": "476", "idx": "149800"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint syllogize_mucosae = 0;\ntypedef char *tubicolous_kumis;\nint global_variable;\nvoid conli_microfilming(tubicolous_kumis *phytophylogeny_avocet);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid blowen_hayward(void (*alloa_mesosome)(tubicolous_kumis *));\nvoid moonflower_needlebook(const tubicolous_kumis whitmonday_bleck);\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&syllogize_mucosae,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      blowen_hayward(conli_microfilming);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid conli_microfilming(tubicolous_kumis *phytophylogeny_avocet)\n{\n  tubicolous_kumis acton_squeakproof = 0;\n  char *irrefutably_mauby;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&irrefutably_mauby,\"PRECULE_CHOOSES\");\n  if (irrefutably_mauby != 0) {;\n    acton_squeakproof = irrefutably_mauby;\n     *phytophylogeny_avocet = acton_squeakproof;\n  }\n}\n\nvoid blowen_hayward(void (*alloa_mesosome)(tubicolous_kumis *))\n{\n  ++global_variable;\n  tubicolous_kumis grammarless_poppied = 0;\n  alloa_mesosome(&grammarless_poppied);\n  if (grammarless_poppied != 0) {;\n    moonflower_needlebook(grammarless_poppied);\n  }\n}\n\nvoid moonflower_needlebook(const tubicolous_kumis whitmonday_bleck)\n{\n    long number;\n    struct struct_data *data = 0;\n  char *tightnesses_nudge = 0;\n  ++global_variable;;\n  tightnesses_nudge = ((char *)((tubicolous_kumis )whitmonday_bleck));\n    \n    number = strtol(tightnesses_nudge,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n  if (((tubicolous_kumis )whitmonday_bleck) != 0) \n    free(((char *)((tubicolous_kumis )whitmonday_bleck)));\nclose_printf_context();\n}\n#endif", "answer": "buffer_member", "cwe": "197", "idx": "151046"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint sunsuit_lath = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid basaree_maranh(char **cyclitols_jrc);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  void (*radiologically_renommee)(char **) = basaree_maranh;\n  int recreationist_whig;\n  char **pistillary_caterbrawl = 0;\n  char **faecalith_currencies = 0;\n  int maracay_hydrophiloid = 0;\n  char *goles_plagiostome = 0;\n  char *tisman_betties;;\n  if (__sync_bool_compare_and_swap(&sunsuit_lath,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&tisman_betties,\"SIALS_BLENNOMETRITIS\");\n      if (tisman_betties != 0) {;\n        maracay_hydrophiloid = ((int )(strlen(tisman_betties)));\n        goles_plagiostome = ((char *)(malloc(maracay_hydrophiloid + 1)));\n        if (goles_plagiostome == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(goles_plagiostome,0,maracay_hydrophiloid + 1);\n        memcpy(goles_plagiostome,tisman_betties,maracay_hydrophiloid);\n        if (tisman_betties != 0) \n          free(((char *)tisman_betties));\n        recreationist_whig = 1;\n        pistillary_caterbrawl = &goles_plagiostome;\n        faecalith_currencies = ((char **)(((unsigned long )pistillary_caterbrawl) * recreationist_whig * recreationist_whig)) + 5;\n        radiologically_renommee(faecalith_currencies);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid basaree_maranh(char **cyclitols_jrc)\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *fetches_reconsolidating = 0;\n  ++global_variable;;\n  fetches_reconsolidating = ((char *)( *(cyclitols_jrc - 5)));\n      \n      \n\n      pFile = fopen(fetches_reconsolidating,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\n  if ( *(cyclitols_jrc - 5) != 0) \n    free(((char *)( *(cyclitols_jrc - 5))));\nclose_printf_context();\n}\n#endif", "answer": "pFile buffer", "cwe": "476", "idx": "149701"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint montford_polymastodon = 0;\nint global_variable;\nvoid handle_taint(char *homeotherapy_depones);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&montford_polymastodon,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *homeotherapy_depones)\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *musked_derivations = 0;\n  char **evener_empasm = 0;\n  char **fliers_unemasculative = 0;\n  char *recommit_unrecited[100] = {0};\n  ++global_variable;;\n  if (homeotherapy_depones != 0) {;\n    recommit_unrecited[40] = homeotherapy_depones;\n    evener_empasm = recommit_unrecited;\n    fliers_unemasculative = evener_empasm + 5;\n    if ((fliers_unemasculative - 5)[40] != 0) {\n      goto migonitis_soothful;\n    }\n    ++global_variable;\n    migonitis_soothful:;\n    musked_derivations = ((char *)(fliers_unemasculative - 5)[40]);\n  \n  \n  csv = fopen(musked_derivations,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\n    if ((fliers_unemasculative - 5)[40] != 0) \n      free(((char *)(fliers_unemasculative - 5)[40]));\nclose_printf_context();\n  }\n}", "answer": "", "cwe": "476", "idx": "149841"}
{"code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint unifiers_unevangelic = 0;\ntypedef char *broadish_locoweed;\nint global_variable;\nvoid handle_taint(char *historiometric_propulsion);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid purpureous_disorientate(int interscene_subkingdom,broadish_locoweed prand_antiepileptic);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&unifiers_unevangelic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *historiometric_propulsion)\n{\n  int issachar_battlement = 7;\n  broadish_locoweed zootomy_sulphinic = 0;\n  long sawbucks_bergut[10];\n  broadish_locoweed saboraim_ginsberg[10] = {0};\n  broadish_locoweed bletting_patand = 0;\n  ++global_variable;;\n  if (historiometric_propulsion != 0) {;\n    bletting_patand = historiometric_propulsion;\n    saboraim_ginsberg[5] = bletting_patand;\n    sawbucks_bergut[1] = 5;\n    zootomy_sulphinic =  *(saboraim_ginsberg + sawbucks_bergut[1]);\n    purpureous_disorientate(issachar_battlement,zootomy_sulphinic);\n  }\n}\n\nvoid purpureous_disorientate(int interscene_subkingdom,broadish_locoweed prand_antiepileptic)\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *pims_sulphamidate = 0;\n  ++global_variable;\n  interscene_subkingdom--;\n  if (interscene_subkingdom > 0) {\n    purpureous_disorientate(interscene_subkingdom,prand_antiepileptic);\n    return ;\n  }\n  pims_sulphamidate = ((char *)prand_antiepileptic);\n      \n      \n\n      pFile = fopen(pims_sulphamidate,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\n  if (prand_antiepileptic != 0) \n    free(((char *)prand_antiepileptic));\nclose_printf_context();\n}", "answer": "pFile buffer", "cwe": "476", "idx": "149384"}
{"code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint zink_caricographer = 0;\ntypedef char *palingenesian_countour;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\ntypedef int (*fct_ptr)(const char *, const char *);\nfct_ptr switch_func(char *param)\n{\n  \n  int var_len = 0;\n  fct_ptr fct_ptr_addr = (fct_ptr )0;\n  var_len = strlen(param) % 3;\n  if (var_len == 0) {\n    return strcmp;\n  }\n  else if (var_len == 1) {\n    return strcoll;\n  }\n  else {\n    sscanf(param,\"%p\",&fct_ptr_addr);\n    return fct_ptr_addr;\n  }\n}\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n int cmp_flag = 0;\n  char *genetyllis_procure = 0;\n  palingenesian_countour carnified_muddlement = 0;\n  char *lectionary_metallist;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&zink_caricographer,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&lectionary_metallist,\"PHOTOETCHING_INQUILINISM\");\n      if (lectionary_metallist != 0) {;\n        carnified_muddlement = lectionary_metallist;\n        genetyllis_procure = ((char *)carnified_muddlement);\n    \n    \n \n fct_ptr fp;\n const char *rand_word = \"criticisms_metallide\";\n fp = switch_func(genetyllis_procure);\n    \n    \n \n    \n    cmp_flag = ( *fp)(rand_word,genetyllis_procure);\n    \n    if (cmp_flag == 0)\n        printf(\"strings are equal\\n\");\n    else\n        printf(\"strings are not equal\\n\");\n    \n;\n        if (carnified_muddlement != 0) \n          free(((char *)carnified_muddlement));\nclose_printf_context();\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#endif \n#endif ", "answer": "genetyllis_procure rand_word fp", "cwe": "822", "idx": "153708"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint christhood_renderings = 0;\nint global_variable;\nvoid handle_taint(char *tormae_vitaceous);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid bruceton_phoronomy(void *const greaseball_landslidden);\nvoid tetramorph_omagra(void *belgravia_unadmirableness);\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&christhood_renderings,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *tormae_vitaceous)\n{\n  void *voltaire_tannish = 0;\n  ++global_variable;;\n  if (tormae_vitaceous != 0) {;\n    voltaire_tannish = ((void *)tormae_vitaceous);\n    bruceton_phoronomy(voltaire_tannish);\n  }\n}\n\nvoid bruceton_phoronomy(void *const greaseball_landslidden)\n{\n  ++global_variable;;\n  tetramorph_omagra(greaseball_landslidden);\n}\n\nvoid tetramorph_omagra(void *belgravia_unadmirableness)\n{\n    long number;\n    struct struct_data *data = 0;\n  char *ruckle_fonnish = 0;\n  ++global_variable;;\n  ruckle_fonnish = ((char *)((char *)((void *)belgravia_unadmirableness)));\n    \n    number = strtol(ruckle_fonnish,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n  if (((char *)((void *)belgravia_unadmirableness)) != 0) \n    free(((char *)((char *)((void *)belgravia_unadmirableness))));\nclose_printf_context();\n}", "answer": "buffer_member", "cwe": "197", "idx": "151304"}
{"code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint tribunitive_stria = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid flourishing_stocked(char *mentalities_documentalist);\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  void (*davyum_aliceville)(char *) = flourishing_stocked;\n  int secundine_woolshearer = 0;\n  char *gorillaship_unexistent = 0;\n  char *antrophore_outprayed;;\n  if (__sync_bool_compare_and_swap(&tribunitive_stria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      antrophore_outprayed = getenv(\"REPERMIT_HERBARIIA\");\n      if (antrophore_outprayed != 0) {;\n        secundine_woolshearer = ((int )(strlen(antrophore_outprayed)));\n        gorillaship_unexistent = ((char *)(malloc(secundine_woolshearer + 1)));\n        if (gorillaship_unexistent == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(gorillaship_unexistent,0,secundine_woolshearer + 1);\n        memcpy(gorillaship_unexistent,antrophore_outprayed,secundine_woolshearer);\n        davyum_aliceville(gorillaship_unexistent);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid flourishing_stocked(char *mentalities_documentalist)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *lamellicorn_caruthersville = 0;\n  ++global_variable;;\n  lamellicorn_caruthersville = ((char *)mentalities_documentalist);\n    \n files = fopen(lamellicorn_caruthersville,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n  if (mentalities_documentalist != 0) \n    free(((char *)mentalities_documentalist));\nclose_printf_context();\n}", "answer": "w file_list ssi Fopen 1020 0 fputs errno 1 fscanf fopen ulimit due fflush filename error woohoo to 79s 24 n file files continue", "cwe": "775", "idx": "151603"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint lesli_endangered = 0;\n\nunion mucocellulosic_seated \n{\n  char *classicalities_perioesophageal;\n  double coxiest_conductive;\n  char *tinamidae_diastatically;\n  char urartic_defalcator;\n  int macrobius_acephalina;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n char *buffer = 0;\n  char *pruss_bibliopolic = 0;\n  jmp_buf situationally_alexanders;\n  int haithal_nobel;\n  union mucocellulosic_seated tweedles_quomodos = {0};\n  int **********cheirotherium_carbin = 0;\n  int *********proscolex_sensitivenesses = 0;\n  int ********eyewinks_nonnational = 0;\n  int *******bondland_pua = 0;\n  int ******subofficer_diffusive = 0;\n  int *****pterographic_aglisten = 0;\n  int ****palmiped_stercorean = 0;\n  int ***kairotic_inblow = 0;\n  int **decomposure_roseville = 0;\n  int *transhuman_highted = 0;\n  int lobuli_entremess;\n  union mucocellulosic_seated majestical_overmuches[10] = {0};\n  union mucocellulosic_seated tires_yaakov;\n  int zeugobranchia_overbar = 44;\n  char *axiolite_scumboard;;\n  if (__sync_bool_compare_and_swap(&lesli_endangered,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&axiolite_scumboard,\"2674\",zeugobranchia_overbar);\n      if (axiolite_scumboard != 0) {;\n        tires_yaakov . classicalities_perioesophageal = axiolite_scumboard;\n        lobuli_entremess = 5;\n        transhuman_highted = &lobuli_entremess;\n        decomposure_roseville = &transhuman_highted;\n        kairotic_inblow = &decomposure_roseville;\n        palmiped_stercorean = &kairotic_inblow;\n        pterographic_aglisten = &palmiped_stercorean;\n        subofficer_diffusive = &pterographic_aglisten;\n        bondland_pua = &subofficer_diffusive;\n        eyewinks_nonnational = &bondland_pua;\n        proscolex_sensitivenesses = &eyewinks_nonnational;\n        cheirotherium_carbin = &proscolex_sensitivenesses;\n        majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))] = tires_yaakov;\n        tweedles_quomodos = majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))];\n        haithal_nobel = setjmp(situationally_alexanders);\n        if (haithal_nobel == 0) {\n          longjmp(situationally_alexanders,1);\n        }\n        pruss_bibliopolic = ((char *)tweedles_quomodos . classicalities_perioesophageal);\n    \n    buffer = malloc((strlen(pruss_bibliopolic) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,pruss_bibliopolic);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n        if (tweedles_quomodos . classicalities_perioesophageal != 0) \n          free(((char *)tweedles_quomodos . classicalities_perioesophageal));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "buffer", "cwe": "415", "idx": "152925"}
{"code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint niobrara_eyn = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid fredi_outyelping(int hydrophore_punkas,char **preweigh_bushey);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  int revenants_bragi = 7;\n  int overtechnical_macadamized;\n  char **korntonder_grim = 0;\n  char **elfishly_baculite = 0;\n  char *unhinged_eccrinology[85] = {0};\n  char *unmarbleize_procne;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&niobrara_eyn,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      unmarbleize_procne = getenv(\"RETIED_SUGGIL\");\n      if (unmarbleize_procne != 0) {;\n        unhinged_eccrinology[64] = unmarbleize_procne;\n        overtechnical_macadamized = 1;\n        korntonder_grim = unhinged_eccrinology;\n        elfishly_baculite = ((char **)(((unsigned long )korntonder_grim) * overtechnical_macadamized * overtechnical_macadamized)) + 5;\n        fredi_outyelping(revenants_bragi,elfishly_baculite);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid fredi_outyelping(int hydrophore_punkas,char **preweigh_bushey)\n{\n int ss_i = 0;\n  char *cutlerr_caprificator = 0;\n  ++global_variable;\n  hydrophore_punkas--;\n  if (hydrophore_punkas > 0) {\n    fredi_outyelping(hydrophore_punkas,preweigh_bushey);\n    return ;\n  }\n  cutlerr_caprificator = ((char *)(preweigh_bushey - 5)[64]);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(cutlerr_caprificator)){\n  \n        if (cutlerr_caprificator[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n}", "answer": "strlen ss_i cutlerr_caprificator 48", "cwe": "835", "idx": "151942"}
{"code": "#include <apr_pools.h>\n#include <apr_uuid.h>\n#include \"svn_hash.h\"\n#include \"svn_types.h\"\n#include \"svn_error.h\"\n#include \"svn_string.h\"\n#include \"svn_props.h\"\n#include \"svn_private_config.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint bertina_filisters = 0;\nint global_variable;\nvoid handle_taint(char *pestis_leeper);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid montessorian_remeeting(int lupercalia_dentata,... );\n\nsvn_error_t *svn_revnum_parse(svn_revnum_t *rev,const char *str,const char **endptr)\n{\n  char *end;\n  svn_revnum_t result = strtol(str,&end,10);\n  if (endptr) {\n     *endptr = end;\n  }\n  if (str == end) {\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Invalid revision number found parsing '%s'\")),str);\n  }\n  if (result < 0) {\n\n    if (endptr) {\n       *endptr = str;\n    }\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Negative revision number found parsing '%s'\")),str);\n  }\n   *rev = result;\n  return 0;\n}\n\nconst char *svn_uuid_generate(apr_pool_t *pool)\n{\n  apr_uuid_t uuid;\n  char *uuid_str = (memset(apr_palloc(pool,(36 + 1)),0,(36 + 1)));\n  apr_uuid_get(&uuid);\n  apr_uuid_format(uuid_str,(&uuid));\n  return uuid_str;\n}\n\nconst char *svn_depth_to_word(svn_depth_t depth)\n{\n  switch(depth){\n    case svn_depth_exclude:\n    return \"exclude\";\n    case svn_depth_unknown:\n    return \"unknown\";\n    case svn_depth_empty:\n    return \"empty\";\n    case svn_depth_files:\n    return \"files\";\n    case svn_depth_immediates:\n    return \"immediates\";\n    case svn_depth_infinity:\n    return \"infinity\";\n    default:\n    return \"INVALID-DEPTH\";\n  }\n}\n\nsvn_depth_t svn_depth_from_word(const char *word)\n{\n  if (strcmp(word,\"exclude\") == 0) {\n    return svn_depth_exclude;\n  }\n  if (strcmp(word,\"unknown\") == 0) {\n    return svn_depth_unknown;\n  }\n  if (strcmp(word,\"empty\") == 0) {\n    return svn_depth_empty;\n  }\n  if (strcmp(word,\"files\") == 0) {\n    return svn_depth_files;\n  }\n  if (strcmp(word,\"immediates\") == 0) {\n    return svn_depth_immediates;\n  }\n  if (strcmp(word,\"infinity\") == 0) {\n    return svn_depth_infinity;\n  }\n\n  return svn_depth_unknown;\n}\n\nconst char *svn_node_kind_to_word(svn_node_kind_t kind)\n{\n  switch(kind){\n    case svn_node_none:\n    return \"none\";\n    case svn_node_file:\n    return \"file\";\n    case svn_node_dir:\n    return \"dir\";\n    case svn_node_symlink:\n    return \"symlink\";\n    case svn_node_unknown:\n{\n    }\n    default:\n    return \"unknown\";\n  }\n}\n\nsvn_node_kind_t svn_node_kind_from_word(const char *word)\n{\n  if (word == ((void *)0)) {\n    return svn_node_unknown;\n  }\n  if (strcmp(word,\"none\") == 0) {\n    return svn_node_none;\n  }\n  else {\n    if (strcmp(word,\"file\") == 0) {\n      return svn_node_file;\n    }\n    else {\n      if (strcmp(word,\"dir\") == 0) {\n        return svn_node_dir;\n      }\n      else {\n        if (strcmp(word,\"symlink\") == 0) {\n          return svn_node_symlink;\n        }\n        else {\n\n          return svn_node_unknown;\n        }\n      }\n    }\n  }\n}\n\nconst char *svn_tristate__to_word(svn_tristate_t tristate)\n{\n  switch(tristate){\n    case svn_tristate_false:\n    return \"false\";\n    case svn_tristate_true:\n    return \"true\";\n    case svn_tristate_unknown:\n{\n    }\n    default:\n    return ((void *)0);\n  }\n}\n\nsvn_tristate_t svn_tristate__from_word(const char *word)\n{;\n  if (__sync_bool_compare_and_swap(&bertina_filisters,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (word == ((void *)0)) {\n    return svn_tristate_unknown;\n  }\n  else {\n    if (0 == svn_cstring_casecmp(word,\"true\") || 0 == svn_cstring_casecmp(word,\"yes\") || 0 == svn_cstring_casecmp(word,\"on\") || 0 == strcmp(word,\"1\")) {\n      return svn_tristate_true;\n    }\n    else {\n      if (0 == svn_cstring_casecmp(word,\"false\") || 0 == svn_cstring_casecmp(word,\"no\") || 0 == svn_cstring_casecmp(word,\"off\") || 0 == strcmp(word,\"0\")) {\n        return svn_tristate_false;\n      }\n    }\n  }\n  return svn_tristate_unknown;\n}\n\nsvn_commit_info_t *svn_create_commit_info(apr_pool_t *pool)\n{\n  svn_commit_info_t *commit_info = (memset(apr_palloc(pool,sizeof(( *commit_info))),0,sizeof(( *commit_info))));\n  commit_info -> revision = ((svn_revnum_t )(- 1));\n\n  return commit_info;\n}\n\nsvn_commit_info_t *svn_commit_info_dup(const svn_commit_info_t *src_commit_info,apr_pool_t *pool)\n{\n  svn_commit_info_t *dst_commit_info = (apr_palloc(pool,sizeof(( *dst_commit_info))));\n  dst_commit_info -> date = ((src_commit_info -> date?apr_pstrdup(pool,src_commit_info -> date) : ((void *)0)));\n  dst_commit_info -> author = ((src_commit_info -> author?apr_pstrdup(pool,src_commit_info -> author) : ((void *)0)));\n  dst_commit_info -> revision = src_commit_info -> revision;\n  dst_commit_info -> post_commit_err = ((src_commit_info -> post_commit_err?apr_pstrdup(pool,src_commit_info -> post_commit_err) : ((void *)0)));\n  dst_commit_info -> repos_root = ((src_commit_info -> repos_root?apr_pstrdup(pool,src_commit_info -> repos_root) : ((void *)0)));\n  return dst_commit_info;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_create(apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (memset(apr_palloc(pool,sizeof(( *new_changed_path))),0,sizeof(( *new_changed_path))));\n  new_changed_path -> text_modified = svn_tristate_unknown;\n  new_changed_path -> props_modified = svn_tristate_unknown;\n  return new_changed_path;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_dup(const svn_log_changed_path2_t *changed_path,apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (apr_palloc(pool,sizeof(( *new_changed_path))));\n   *new_changed_path =  *changed_path;\n  if (new_changed_path -> copyfrom_path) {\n    new_changed_path -> copyfrom_path = (apr_pstrdup(pool,new_changed_path -> copyfrom_path));\n  }\n  return new_changed_path;\n}\n\nsvn_dirent_t *svn_dirent_create(apr_pool_t *result_pool)\n{\n  svn_dirent_t *new_dirent = (memset(apr_palloc(result_pool,sizeof(( *new_dirent))),0,sizeof(( *new_dirent))));\n  new_dirent -> kind = svn_node_unknown;\n  new_dirent -> size = ((svn_filesize_t )(- 1));\n  new_dirent -> created_rev = ((svn_revnum_t )(- 1));\n  new_dirent -> time = 0;\n  new_dirent -> last_author = ((void *)0);\n  return new_dirent;\n}\n\nsvn_dirent_t *svn_dirent_dup(const svn_dirent_t *dirent,apr_pool_t *pool)\n{\n  svn_dirent_t *new_dirent = (apr_palloc(pool,sizeof(( *new_dirent))));\n   *new_dirent =  *dirent;\n  new_dirent -> last_author = (apr_pstrdup(pool,dirent -> last_author));\n  return new_dirent;\n}\n\nsvn_log_entry_t *svn_log_entry_create(apr_pool_t *pool)\n{\n  svn_log_entry_t *log_entry = (memset(apr_palloc(pool,sizeof(( *log_entry))),0,sizeof(( *log_entry))));\n  return log_entry;\n}\n\nsvn_log_entry_t *svn_log_entry_dup(const svn_log_entry_t *log_entry,apr_pool_t *pool)\n{\n  apr_hash_index_t *hi;\n  svn_log_entry_t *new_entry = (apr_palloc(pool,sizeof(( *new_entry))));\n   *new_entry =  *log_entry;\n  if (log_entry -> revprops) {\n    new_entry -> revprops = svn_prop_hash_dup((log_entry -> revprops),pool);\n  }\n  if (log_entry -> changed_paths2) {\n    new_entry -> changed_paths2 = apr_hash_make(pool);\n    for (hi = apr_hash_first(pool,log_entry -> changed_paths2); hi; hi = apr_hash_next(hi)) {\n      const void *key;\n      void *change;\n      apr_hash_this(hi,&key,((void *)0),&change);\n      apr_hash_set(new_entry -> changed_paths2,(apr_pstrdup(pool,key)),(- 1),(svn_log_changed_path2_dup(change,pool)));\n    }\n  }\n\n  new_entry -> changed_paths = new_entry -> changed_paths2;\n  return new_entry;\n}\n\nsvn_location_segment_t *svn_location_segment_dup(const svn_location_segment_t *segment,apr_pool_t *pool)\n{\n  svn_location_segment_t *new_segment = (apr_palloc(pool,sizeof(( *new_segment))));\n   *new_segment =  *segment;\n  if (segment -> path) {\n    new_segment -> path = (apr_pstrdup(pool,segment -> path));\n  }\n  return new_segment;\n}\n\nvoid handle_taint(char *pestis_leeper)\n{\n  void *phaleucian_studdingsail = 0;\n  ++global_variable;;\n  if (pestis_leeper != 0) {;\n    phaleucian_studdingsail = ((void *)pestis_leeper);\n    montessorian_remeeting(1,phaleucian_studdingsail);\n  }\n}\n\nvoid montessorian_remeeting(int lupercalia_dentata,... )\n{\n    int stack_size = 0;\n  char *octopi_ephemeridae = 0;\n  int untemptably_hottentotese;\n  int campimetrical_jumbles;\n  void *mppd_dolores = 0;\n  va_list gweyn_unloose;\n  ++global_variable;;\n  if (lupercalia_dentata > 0) {\n    __builtin_va_start(gweyn_unloose,lupercalia_dentata);\n    mppd_dolores = (va_arg(gweyn_unloose,void *));\n    __builtin_va_end(gweyn_unloose);\n  }\n  campimetrical_jumbles = 5;\n  while(1 == 1){\n    campimetrical_jumbles = campimetrical_jumbles * 2;\n    campimetrical_jumbles = campimetrical_jumbles + 2;\n    if (campimetrical_jumbles > 1000) {\n      break; \n    }\n  }\n  untemptably_hottentotese = campimetrical_jumbles;\n  octopi_ephemeridae = ((char *)((char *)mppd_dolores));\n    \n    \n    \n    if (strlen(octopi_ephemeridae) > 1 &&\n     octopi_ephemeridae[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(octopi_ephemeridae,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\n  if (((char *)mppd_dolores) != 0) \n    free(((char *)((char *)mppd_dolores)));\nclose_printf_context();\n}", "answer": "stack_size x 1 char memset stack_string", "cwe": "789", "idx": "151458"}
{"code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint leptomeningitis_lactocele = 0;\nint global_variable;\nvoid handle_taint(char *chronologic_premies);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid reacting_jacana(char **corkwing_multisonorous);\nvoid boldoine_somatically(char **opianyl_taramasalata);\nvoid waily_unmodifiably(char **porchlike_spece);\nvoid zootomical_adonizing(char **preultimate_nonexceptional);\nvoid ostentous_lymphopenia(char **landladyship_screeny);\nvoid battalions_bonding(char **boodledom_scylla);\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas);\nvoid hultgren_humuslike(char **coronatorial_rifi);\nvoid draisine_uncombed(char **soundproofed_vaporability);\nvoid journeyman_cesiums(char **affusions_hardstand);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&leptomeningitis_lactocele,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *chronologic_premies)\n{\n  int sammy_noncommendably;\n  char **hickishness_tubal = 0;\n  char **erythrophage_algebraized = 0;\n  char *frizzling_browningesque[66] = {0};\n  ++global_variable;;\n  if (chronologic_premies != 0) {;\n    frizzling_browningesque[63] = chronologic_premies;\n    sammy_noncommendably = 1;\n    hickishness_tubal = frizzling_browningesque;\n    erythrophage_algebraized = ((char **)(((unsigned long )hickishness_tubal) * sammy_noncommendably * sammy_noncommendably)) + 5;\n    reacting_jacana(erythrophage_algebraized);\n  }\n}\n\nvoid reacting_jacana(char **corkwing_multisonorous)\n{\n  ++global_variable;;\n  boldoine_somatically(corkwing_multisonorous);\n}\n\nvoid boldoine_somatically(char **opianyl_taramasalata)\n{\n  ++global_variable;;\n  waily_unmodifiably(opianyl_taramasalata);\n}\n\nvoid waily_unmodifiably(char **porchlike_spece)\n{\n  ++global_variable;;\n  zootomical_adonizing(porchlike_spece);\n}\n\nvoid zootomical_adonizing(char **preultimate_nonexceptional)\n{\n  ++global_variable;;\n  ostentous_lymphopenia(preultimate_nonexceptional);\n}\n\nvoid ostentous_lymphopenia(char **landladyship_screeny)\n{\n  ++global_variable;;\n  battalions_bonding(landladyship_screeny);\n}\n\nvoid battalions_bonding(char **boodledom_scylla)\n{\n  ++global_variable;;\n  chlorophyllian_glossopetra(boodledom_scylla);\n}\n\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas)\n{\n  ++global_variable;;\n  hultgren_humuslike(prioristic_bugshas);\n}\n\nvoid hultgren_humuslike(char **coronatorial_rifi)\n{\n  ++global_variable;;\n  draisine_uncombed(coronatorial_rifi);\n}\n\nvoid draisine_uncombed(char **soundproofed_vaporability)\n{\n  ++global_variable;;\n  journeyman_cesiums(soundproofed_vaporability);\n}\n\nvoid journeyman_cesiums(char **affusions_hardstand)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *gasterophilus_dinitril = 0;\n  ++global_variable;;\n  gasterophilus_dinitril = ((char *)(affusions_hardstand - 5)[63]);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(gasterophilus_dinitril)+ 1));\n        if (cusData->data &&\n            (sscanf(gasterophilus_dinitril, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if ((affusions_hardstand - 5)[63] != 0) \n    free(((char *)(affusions_hardstand - 5)[63]));\nclose_printf_context();\n}", "answer": "data free cusData", "cwe": "663", "idx": "150275"}
{"code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint kobo_schizophrene = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    int (* before)(int);\n    char buffer[64];\n    int (* after)(int);\n};\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n    int i = 0;\n    struct struct* data = NULL;\n    int buff_size = 63;\n    int taint_len;\n  char *eupathy_forsythia = 0;\n  void *apex_diametrical = 0;\n  long basaree_propylidene[10];\n  void *biasing_conveying[10] = {0};\n  void *crambes_seidule = 0;\n  char *landladydom_drosky;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&kobo_schizophrene,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      landladydom_drosky = getenv(\"REPRESSOR_POMMELS\");\n      if (landladydom_drosky != 0) {;\n        crambes_seidule = ((void *)landladydom_drosky);\n        biasing_conveying[5] = crambes_seidule;\n        basaree_propylidene[1] = 5;\n        apex_diametrical =  *(biasing_conveying + basaree_propylidene[1]);\n        if (((char *)apex_diametrical) != 0) {\n          goto lusterlessness_monocarps;\n        }\n        ++global_variable;\n        lusterlessness_monocarps:;\n        eupathy_forsythia = ((char *)((char *)apex_diametrical));\n    \n    \n    \n    data = (struct struct*) malloc(sizeof(struct struct));\n    if (data != NULL) {\n        data->before = toupper;\n        memset(data->buffer, 'A', 64);\n        data->buffer[63] = '\\0';\n        data->after = toupper;\n        \n        \n        \n        \n        \n        taint_len = ((int )(strlen(eupathy_forsythia)));\n    \n    \n        for (; taint_len >= 0; (--buff_size , --taint_len)) {\n            data->buffer[buff_size] = eupathy_forsythia[taint_len];\n        }\n        \n        for (i = 0; i < 64; ++i) {\n            data->buffer[i] = toupper(data->buffer[i]);\n            printf(\"%c\",data->before(data->buffer[i]));\n        }\n        \n        \n        printf(\"\\n\");\n        free(data);\n        \n        \n        \n    }\n;\nclose_printf_context();\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#endif \n#endif ", "answer": "strlen toupper 64 int data i buffer c taint_len eupathy_forsythia before 0 buff_size", "cwe": "124", "idx": "153573"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint resultance_butyl = 0;\nint global_variable;\ntypedef char *gattamelata_wakener;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid speight_unaesthetical(gattamelata_wakener cometwise_exasperations);\nvoid orfield_orthographer(gattamelata_wakener interblended_stria);\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  gattamelata_wakener subnaturally_ketoses = 0;\n  char *grandiosity_confidences;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&resultance_butyl,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      grandiosity_confidences = getenv(\"MATINDOL_UNSPACED\");\n      if (grandiosity_confidences != 0) {;\n        subnaturally_ketoses = grandiosity_confidences;\n        speight_unaesthetical(subnaturally_ketoses);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid speight_unaesthetical(gattamelata_wakener cometwise_exasperations)\n{\n  ++global_variable;;\n  orfield_orthographer(cometwise_exasperations);\n}\n\nvoid orfield_orthographer(gattamelata_wakener interblended_stria)\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *vulvovaginitis_denticulation = 0;\n  ++global_variable;;\n  vulvovaginitis_denticulation = ((char *)interblended_stria);\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(vulvovaginitis_denticulation, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\nclose_printf_context();\n}", "answer": "dataStruct data 1 inc_amount 0", "cwe": "820", "idx": "150320"}
{"code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint dispermy_forsaken = 0;\nint global_variable;\nvoid neurohormone_radiopotassium(char **garnisher_unratable);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid billboard_who(void (*mariette_aplanatism)(char **));\nvoid shynesses_sticky(int fadged_allodia,... );\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&dispermy_forsaken,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      billboard_who(neurohormone_radiopotassium);\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid neurohormone_radiopotassium(char **garnisher_unratable)\n{\n  char *ephyrae_successionist;\n  ++global_variable;;\n  setup_printf_context();\n  ephyrae_successionist = getenv(\"BACKCOURTMAN_SUPERFRIENDLY\");\n  if (ephyrae_successionist != 0) {;\n     *garnisher_unratable = ephyrae_successionist;\n  }\n}\n\nvoid billboard_who(void (*mariette_aplanatism)(char **))\n{\n  ++global_variable;\n  char *slipperier_knittable = 0;\n  mariette_aplanatism(&slipperier_knittable);\n  if (slipperier_knittable != 0) {;\n    shynesses_sticky(1,slipperier_knittable);\n  }\n}\n\nvoid shynesses_sticky(int fadged_allodia,... )\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *biurea_aortographies = 0;\n  char *prejudgments_cetonia[15] = {0};\n  char *gools_angelizing = 0;\n  va_list preshrinked_deuzan;\n  ++global_variable;;\n  if (fadged_allodia > 0) {\n    __builtin_va_start(preshrinked_deuzan,fadged_allodia);\n    gools_angelizing = (va_arg(preshrinked_deuzan,char *));\n    __builtin_va_end(preshrinked_deuzan);\n  }\n  prejudgments_cetonia[7] = gools_angelizing;\n  biurea_aortographies = ((char *)prejudgments_cetonia[7]);\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(biurea_aortographies,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "contents", "cwe": "771", "idx": "151439"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint unrude_faire = 0;\ntypedef char *sniffily_cardin;\nint global_variable;\nvoid handle_taint(char *cosmetologist_uninfringible);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid epilegomenon_comourn(const sniffily_cardin handwaving_bottomchrome);\nvoid laved_tasimeter(sniffily_cardin wisps_refreshments);\nvoid epididymitis_mannerliness(sniffily_cardin knockemdown_longings);\nvoid sherd_advertisements(sniffily_cardin barolo_demotist);\nvoid budweiser_unepicurean(sniffily_cardin citternhead_voltmer);\nvoid neaps_homiletics(sniffily_cardin slaughterhouse_stokely);\nvoid nonadults_oside(sniffily_cardin metaller_buckjumper);\nvoid topography_cornland(sniffily_cardin poort_scents);\nvoid gish_wreakful(sniffily_cardin tergeminous_handymen);\nvoid nonvalidly_phrenopathy(sniffily_cardin morphographer_iris);\nvoid caramuel_blurry(sniffily_cardin desensitizes_washbasin);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&unrude_faire,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *cosmetologist_uninfringible)\n{\n  sniffily_cardin disbalancement_dilog = 0;\n  ++global_variable;;\n  if (cosmetologist_uninfringible != 0) {;\n    disbalancement_dilog = cosmetologist_uninfringible;\n    epilegomenon_comourn(disbalancement_dilog);\n  }\n}\n\nvoid epilegomenon_comourn(const sniffily_cardin handwaving_bottomchrome)\n{\n  ++global_variable;;\n  laved_tasimeter(handwaving_bottomchrome);\n}\n\nvoid laved_tasimeter(sniffily_cardin wisps_refreshments)\n{\n  ++global_variable;;\n  epididymitis_mannerliness(wisps_refreshments);\n}\n\nvoid epididymitis_mannerliness(sniffily_cardin knockemdown_longings)\n{\n  ++global_variable;;\n  sherd_advertisements(knockemdown_longings);\n}\n\nvoid sherd_advertisements(sniffily_cardin barolo_demotist)\n{\n  ++global_variable;;\n  budweiser_unepicurean(barolo_demotist);\n}\n\nvoid budweiser_unepicurean(sniffily_cardin citternhead_voltmer)\n{\n  ++global_variable;;\n  neaps_homiletics(citternhead_voltmer);\n}\n\nvoid neaps_homiletics(sniffily_cardin slaughterhouse_stokely)\n{\n  ++global_variable;;\n  nonadults_oside(slaughterhouse_stokely);\n}\n\nvoid nonadults_oside(sniffily_cardin metaller_buckjumper)\n{\n  ++global_variable;;\n  topography_cornland(metaller_buckjumper);\n}\n\nvoid topography_cornland(sniffily_cardin poort_scents)\n{\n  ++global_variable;;\n  gish_wreakful(poort_scents);\n}\n\nvoid gish_wreakful(sniffily_cardin tergeminous_handymen)\n{\n  ++global_variable;;\n  nonvalidly_phrenopathy(tergeminous_handymen);\n}\n\nvoid nonvalidly_phrenopathy(sniffily_cardin morphographer_iris)\n{\n  ++global_variable;;\n  caramuel_blurry(morphographer_iris);\n}\n\nvoid caramuel_blurry(sniffily_cardin desensitizes_washbasin)\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *finbacks_greetings = 0;\n  ++global_variable;;\n  finbacks_greetings = ((char *)((sniffily_cardin )desensitizes_washbasin));\n    \n    taint_size = strlen(finbacks_greetings);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,finbacks_greetings,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n  if (((sniffily_cardin )desensitizes_washbasin) != 0) \n    free(((char *)((sniffily_cardin )desensitizes_washbasin)));\nclose_printf_context();\n}", "answer": "error 12 ss_i errno malloc malloced_buff n char trace_flag Malloc ulimit taint_size due to 0 sizeof", "cwe": "401", "idx": "151476"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint apozema_relicensing = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid duncan_styrofoam(int segments_ephemeridae,char **outstair_stirpes);\nvoid douw_runfish(int laminariales_sourdine,char **dillseed_fabiform);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int hobbyist_clover = 7;\n  int bogglebo_unregular;\n  char **skimmed_nonmanneristic = 0;\n  char **unecstatic_jostlers = 0;\n  char *stooker_drillers[59] = {0};\n  char *outstanding_unrenovated;;\n  if (__sync_bool_compare_and_swap(&apozema_relicensing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      outstanding_unrenovated = getenv(\"UNLAUDATIVE_TRITIUM\");\n      if (outstanding_unrenovated != 0) {;\n        stooker_drillers[39] = outstanding_unrenovated;\n        bogglebo_unregular = 1;\n        skimmed_nonmanneristic = stooker_drillers;\n        unecstatic_jostlers = ((char **)(((unsigned long )skimmed_nonmanneristic) * bogglebo_unregular * bogglebo_unregular)) + 5;\n        duncan_styrofoam(hobbyist_clover,unecstatic_jostlers);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid duncan_styrofoam(int segments_ephemeridae,char **outstair_stirpes)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *gilbertson_propos = 0;\n  ++global_variable;\n  segments_ephemeridae--;\n  if (segments_ephemeridae > 0) {\n    douw_runfish(segments_ephemeridae,outstair_stirpes);\n    return ;\n  }\n  gilbertson_propos = ((char *)(outstair_stirpes - 5)[39]);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(gilbertson_propos)+ 1));\n        if (cusData->data &&\n            (sscanf(gilbertson_propos, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\nclose_printf_context();\n}\n\nvoid douw_runfish(int laminariales_sourdine,char **dillseed_fabiform)\n{\n  ++global_variable;\n  duncan_styrofoam(laminariales_sourdine,dillseed_fabiform);\n}", "answer": "data free cusData", "cwe": "663", "idx": "150019"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint interlink_matin = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *drawnet_transactioneer = 0;\n  char **praepubis_dorcy = 0;\n  int *somnambulists_dezhnev = 0;\n  int diclinous_opinionatively;\n  char **mariposa_homeoplastic[10] = {0};\n  char *kodakry_flavius[50] = {0};\n  int mashgiach_unappliqued = 5;\n  char *wagnerite_jaggier;;\n  if (__sync_bool_compare_and_swap(&interlink_matin,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&wagnerite_jaggier,\"3012\",mashgiach_unappliqued);\n      if (wagnerite_jaggier != 0) {;\n        kodakry_flavius[47] = wagnerite_jaggier;\n        diclinous_opinionatively = 5;\n        somnambulists_dezhnev = &diclinous_opinionatively;\n        mariposa_homeoplastic[ *somnambulists_dezhnev] = kodakry_flavius;\n        praepubis_dorcy = mariposa_homeoplastic[ *somnambulists_dezhnev];\n        if (praepubis_dorcy[47] != 0) {\n          goto overweb_plicae;\n        }\n        ++global_variable;\n        overweb_plicae:;\n        drawnet_transactioneer = ((char *)praepubis_dorcy[47]);\n    \n    if (strlen(drawnet_transactioneer) > 0 &&\n            drawnet_transactioneer[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(drawnet_transactioneer,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n        if (praepubis_dorcy[47] != 0) \n          free(((char *)praepubis_dorcy[47]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "f w fopen filename_param", "cwe": "774", "idx": "151862"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint asbjornsen_leipsic = 0;\n\nstruct successfully_ungrotesque \n{\n  char *pelides_pinnipedian;\n  double ballow_repletely;\n  char *hypothecative_vernacularizing;\n  char jawed_seacannie;\n  int iodothyrin_freedom;\n}\n;\nint global_variable;\nvoid handle_taint(char *coessentialness_frosts);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid cleanup(FILE **ptrs,int size)\n{\n  int i = 0;\n  \n  for (i = 0; i < size; i++) {\n    if (ptrs[i] != 0) {\n      fclose(ptrs[i]);\n    }\n  }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&asbjornsen_leipsic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid handle_taint(char *coessentialness_frosts)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[10];\n char filename[80];\n  char *approach_deamidase = 0;\n  int siriometer_daberath;\n  int scabid_letterman;\n  int railbus_caliver;\n  struct successfully_ungrotesque *shriekily_hummeler = {0};\n  struct successfully_ungrotesque *fixure_woodward = {0};\n  struct successfully_ungrotesque dishwiping_polysomitic;\n  ++global_variable;;\n  if (coessentialness_frosts != 0) {;\n    dishwiping_polysomitic . pelides_pinnipedian = ((char *)coessentialness_frosts);\n    railbus_caliver = 1;\n    shriekily_hummeler = &dishwiping_polysomitic;\n    fixure_woodward = ((struct successfully_ungrotesque *)(((unsigned long )shriekily_hummeler) * railbus_caliver * railbus_caliver)) + 5;\n    scabid_letterman = 5;\n    while(1 == 1){\n      scabid_letterman = scabid_letterman * 2;\n      scabid_letterman = scabid_letterman + 2;\n      if (scabid_letterman > 1000) {\n        break; \n      }\n    }\n    siriometer_daberath = scabid_letterman;\n    approach_deamidase = ((char *)( *(fixure_woodward - 5)) . pelides_pinnipedian);\n    \n files = fopen(approach_deamidase,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n            if (file == 0) {\n    if (file == 0 && errno == 24) {\n     printf(\"Fopen error due to ulimit\\n\");\n                }\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n   \n   file_list[ssi % 10] = file;\n   ssi++;\n        }\n        \n        \n    }\n    if (files != 0)\n        fclose(files);\n cleanup(file_list, ((ssi-1)%10)+1);\n    \n;\n    if (( *(fixure_woodward - 5)) . pelides_pinnipedian != 0) \n      free(((char *)( *(fixure_woodward - 5)) . pelides_pinnipedian));\nclose_printf_context();\n  }\n}", "answer": "w file_list ssi Fopen 1020 0 fputs 10 errno 1 fscanf fopen ulimit due fflush filename error woohoo 79s to 24 n file files continue", "cwe": "773", "idx": "151793"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint vivipary_anomatheca = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid depend_linalools(int prosses_outswagger,... );\nvoid corncutter_beetlers(void *dermatoplasm_hansoms);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  void *periosteous_jujubes = 0;\n  char *compatibleness_lipocardiac;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&vivipary_anomatheca,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      compatibleness_lipocardiac = getenv(\"PRELIBERALLY_XYLOBALSAMUM\");\n      if (compatibleness_lipocardiac != 0) {;\n        periosteous_jujubes = ((void *)compatibleness_lipocardiac);\n        depend_linalools(1,periosteous_jujubes);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid depend_linalools(int prosses_outswagger,... )\n{\n  void (*witchingly_footings)(void *) = corncutter_beetlers;\n  void *rotenones_obarni = 0;\n  va_list rout_recense;\n  ++global_variable;;\n  if (prosses_outswagger > 0) {\n    __builtin_va_start(rout_recense,prosses_outswagger);\n    rotenones_obarni = (va_arg(rout_recense,void *));\n    __builtin_va_end(rout_recense);\n  }\n  witchingly_footings(rotenones_obarni);\n}\n\nvoid corncutter_beetlers(void *dermatoplasm_hansoms)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *springeing_canapes = 0;\n  ++global_variable;;\n  springeing_canapes = ((char *)((char *)dermatoplasm_hansoms));\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(springeing_canapes); ++i) {\n        if (springeing_canapes[i] == ';') {\n          if (i == 0 || springeing_canapes[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,springeing_canapes);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n}", "answer": "cmd_string", "cwe": "88", "idx": "152497"}
{"code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint rodie_mall = 0;\n\nstruct aerologists_budgereegah \n{\n  char *jori_piggins;\n  double hypoparia_theologal;\n  char *stahlhelm_inspections;\n  char unsucculently_sororate;\n  int valera_aleichem;\n}\n;\nint global_variable;\nvoid handle_taint(char *uncareful_migrate);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid nonelaborate_semmit(struct aerologists_budgereegah brief_unhit);\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&rodie_mall,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *uncareful_migrate)\n{\n  struct aerologists_budgereegah sulpician_shufflers = {0};\n  long impatiens_lustrical[10];\n  struct aerologists_budgereegah shippens_orotinan[10] = {0};\n  struct aerologists_budgereegah taliacotian_hypertoxic;\n  ++global_variable;;\n  if (uncareful_migrate != 0) {;\n    taliacotian_hypertoxic . jori_piggins = ((char *)uncareful_migrate);\n    shippens_orotinan[5] = taliacotian_hypertoxic;\n    impatiens_lustrical[1] = 5;\n    sulpician_shufflers =  *(shippens_orotinan + impatiens_lustrical[1]);\n    nonelaborate_semmit(sulpician_shufflers);\n  }\n}\n\nvoid nonelaborate_semmit(struct aerologists_budgereegah brief_unhit)\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *seamlessly_uniangulate = 0;\n  ++global_variable;;\n  seamlessly_uniangulate = ((char *)brief_unhit . jori_piggins);\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(seamlessly_uniangulate,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\n  if (brief_unhit . jori_piggins != 0) \n    free(((char *)brief_unhit . jori_piggins));\nclose_printf_context();\n}", "answer": "contents", "cwe": "771", "idx": "151694"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint bastinado_pityproof = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid reglazes_clericalists(int zarathustra_reshowing,char **wielding_remex);\nint 191_global_var = 0;\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  int formalization_allegan = 7;\n  char **gamas_craniocele = 0;\n  char **jfif_unwinder = 0;\n  char *chitchatty_dianilide;;\n  if (__sync_bool_compare_and_swap(&bastinado_pityproof,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      chitchatty_dianilide = getenv(\"PELORIZED_MUTCHKINS\");\n      if (chitchatty_dianilide != 0) {;\n        gamas_craniocele = &chitchatty_dianilide;\n        jfif_unwinder = gamas_craniocele + 5;\n        reglazes_clericalists(formalization_allegan,jfif_unwinder);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid reglazes_clericalists(int zarathustra_reshowing,char **wielding_remex)\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *singhalese_pinkany = 0;\n  ++global_variable;\n  zarathustra_reshowing--;\n  if (zarathustra_reshowing > 0) {\n    reglazes_clericalists(zarathustra_reshowing,wielding_remex);\n    return ;\n  }\n  singhalese_pinkany = ((char *)( *(wielding_remex - 5)));\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(singhalese_pinkany, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\nclose_printf_context();\n}\n#endif", "answer": "fgetc 10 random_data sizeof buff malloc i char long unsigned 0 num", "cwe": "191", "idx": "151267"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint ecrevisse_transgressively = 0;\nint global_variable;\nvoid handle_taint(char *pepin_corseting);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&ecrevisse_transgressively,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid handle_taint(char *pepin_corseting)\n{\n    long number;\n    struct struct_data *data = 0;\n  char *convictor_planless = 0;\n  void **aqualunger_ungrappler = 0;\n  void **forecounsel_incenses = 0;\n  void *bedraped_pycnogonoid = 0;\n  ++global_variable;;\n  if (pepin_corseting != 0) {;\n    bedraped_pycnogonoid = ((void *)pepin_corseting);\n    aqualunger_ungrappler = &bedraped_pycnogonoid;\n    forecounsel_incenses = aqualunger_ungrappler + 5;\n    convictor_planless = ((char *)((char *)( *(forecounsel_incenses - 5))));\n    \n    number = strtol(convictor_planless,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n    if (((char *)( *(forecounsel_incenses - 5))) != 0) \n      free(((char *)((char *)( *(forecounsel_incenses - 5)))));\nclose_printf_context();\n  }\n}", "answer": "buffer_member", "cwe": "197", "idx": "150920"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint adjustation_lactonize = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar **anocarpous_syngamies(char **abolishing_choloidinic);\nvoid absentminded_logomachy(char **stetch_lumbricales);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*musettes_pyrazolyl)(char **) = absentminded_logomachy;\n  char **radnorshire_kumari = 0;\n  char *watcheyes_cheapener[18] = {0};\n  char *liquamen_undutifulness;;\n  if (__sync_bool_compare_and_swap(&adjustation_lactonize,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&liquamen_undutifulness,\"DOROTHY_ESCROWS\");\n      if (liquamen_undutifulness != 0) {;\n        watcheyes_cheapener[4] = liquamen_undutifulness;\n        radnorshire_kumari = anocarpous_syngamies(watcheyes_cheapener);\n        musettes_pyrazolyl(radnorshire_kumari);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nchar **anocarpous_syngamies(char **abolishing_choloidinic)\n{\n  ++global_variable;\n  return abolishing_choloidinic;\n}\n\nvoid absentminded_logomachy(char **stetch_lumbricales)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *epigonation_nonsupplicating = 0;\n  ++global_variable;;\n  epigonation_nonsupplicating = ((char *)stetch_lumbricales[4]);\n      \n      len = strtol(epigonation_nonsupplicating,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (stetch_lumbricales[4] != 0) \n    free(((char *)stetch_lumbricales[4]));\nclose_printf_context();\n}", "answer": "i len values 0", "cwe": "476", "idx": "149298"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint paracusic_jesuitizing = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid lamellary_birder(char *semitism_wil);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*wean_finings)(char *) = lamellary_birder;\n  int eudoxia_presufficiently = 51;\n  char *seamlike_ratement;;\n  if (__sync_bool_compare_and_swap(&paracusic_jesuitizing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&seamlike_ratement,\"1885\",eudoxia_presufficiently);\n      if (seamlike_ratement != 0) {;\n        wean_finings(seamlike_ratement);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid lamellary_birder(char *semitism_wil)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *dalecarlian_reassigning = 0;\n  ++global_variable;;\n  dalecarlian_reassigning = ((char *)semitism_wil);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(dalecarlian_reassigning)+ 1));\n        if (cusData->data &&\n            (sscanf(dalecarlian_reassigning, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if (semitism_wil != 0) \n    free(((char *)semitism_wil));\nclose_printf_context();\n}", "answer": "data free cusData", "cwe": "663", "idx": "150591"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint glycerize_foulsome = 0;\n\nstruct overpositively_hybridae \n{\n  char *cowpoke_snogs;\n  double nekrasov_caruncle;\n  char *mestizos_axillary;\n  char unruly_paraphs;\n  int lateness_parisianly;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n    int i = 0;\n    int buff_size = 63;\n    int taint_len;\n    char *heap_buff_64 = 0;\n  char *granularly_dutuburi = 0;\n  struct overpositively_hybridae *unkindlily_dimberdamber = {0};\n  struct overpositively_hybridae statolithic_subscript;\n  char *thomasite_siruelas;;\n  if (__sync_bool_compare_and_swap(&glycerize_foulsome,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      thomasite_siruelas = getenv(\"GRANDNEPHEWS_OUTBEGGED\");\n      if (thomasite_siruelas != 0) {;\n        statolithic_subscript . cowpoke_snogs = ((char *)thomasite_siruelas);\n        unkindlily_dimberdamber = &statolithic_subscript;\n        granularly_dutuburi = ((char *)( *unkindlily_dimberdamber) . cowpoke_snogs);\n    \n    \n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64, 'A' ,64);\n        heap_buff_64[64 - 1] = '\\0';\n        \n        \n        \n        taint_len = ((int )(strlen(granularly_dutuburi)));\n        for (; taint_len >= 0; (--buff_size , --taint_len)) {\n    \n    \n            heap_buff_64[buff_size] = granularly_dutuburi[taint_len];\n        }\n        \n        for (; i < 64; ++i) {\n            heap_buff_64[i] = toupper(heap_buff_64[i]);\n        }\n        \n        \n        printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\n        free(heap_buff_64);\n        \n        \n        \n    }\n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "strlen toupper 64 int i granularly_dutuburi taint_len heap_buff_64 0 buff_size", "cwe": "124", "idx": "153169"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint hollong_expediment = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar **abijah_unking(char **commissioner_kuska);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    char *buffer = 0U;\n    int len;\n  char *volante_pacers = 0;\n  int timesavers_microspermae;\n  int enclasped_standbybys;\n  char **ireland_tupuna = 0;\n  char *waterproof_infectors[92] = {0};\n  char *elotherium_pagiopod;;\n  if (__sync_bool_compare_and_swap(&hollong_expediment,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&elotherium_pagiopod,\"REPULSES_SQUISHIER\");\n      if (elotherium_pagiopod != 0) {;\n        waterproof_infectors[72] = elotherium_pagiopod;\n        ireland_tupuna = abijah_unking(waterproof_infectors);\n        enclasped_standbybys = 5;\n        while(1 == 1){\n          enclasped_standbybys = enclasped_standbybys * 2;\n          enclasped_standbybys = enclasped_standbybys + 2;\n          if (enclasped_standbybys > 1000) {\n            break; \n          }\n        }\n        timesavers_microspermae = enclasped_standbybys;\n        volante_pacers = ((char *)ireland_tupuna[72]);\n    \n    len = atoi(volante_pacers);\n    \n\n    if (len < 4096) {\n        buffer = ((char *)(malloc(4096 * sizeof(char ))));\n        if (buffer != 0) {\n            memset(buffer,'a',4096);\n            \n            \n\n            memset(&buffer[len],'b',4096 - len);\n            \n            buffer[4095] = 0;\n            printf(\"%s\\n\",buffer);\n            free(buffer);\n        }\n    } else {\n        printf(\"Number is too large to use\\n\");\n    }\n    \n    \n;\n        if (ireland_tupuna[72] != 0) \n          free(((char *)ireland_tupuna[72]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nchar **abijah_unking(char **commissioner_kuska)\n{\n  ++global_variable;\n  return commissioner_kuska;\n}", "answer": "len memset 4096 buffer b", "cwe": "839", "idx": "150879"}
{"code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint poca_ahira = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *brink_crimpier = 0;\n  jmp_buf clevises_roud;\n  int wailoo_noninfallible;\n  char *thieveries_utfangthief = 0;\n  int *hotdogs_ombres = 0;\n  int washway_quotingly;\n  char *disprison_omentitis[10] = {0};\n  int mediatorship_federalization = 0;\n  char *uterometer_boogeymen = 0;\n  char *margarethe_epilating;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&poca_ahira,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      margarethe_epilating = getenv(\"PEOPLEHOOD_GONADECTOMY\");\n      if (margarethe_epilating != 0) {;\n        mediatorship_federalization = ((int )(strlen(margarethe_epilating)));\n        uterometer_boogeymen = ((char *)(malloc(mediatorship_federalization + 1)));\n        if (uterometer_boogeymen == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(uterometer_boogeymen,0,mediatorship_federalization + 1);\n        memcpy(uterometer_boogeymen,margarethe_epilating,mediatorship_federalization);\n        disprison_omentitis[5] = uterometer_boogeymen;\n        washway_quotingly = 5;\n        hotdogs_ombres = &washway_quotingly;\n        thieveries_utfangthief =  *(disprison_omentitis +  *hotdogs_ombres);\n        wailoo_noninfallible = setjmp(clevises_roud);\n        if (wailoo_noninfallible == 0) {\n          longjmp(clevises_roud,1);\n        }\n        brink_crimpier = ((char *)thieveries_utfangthief);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(brink_crimpier); ++i) {\n        if (brink_crimpier[i] == ';') {\n          if (i == 0 || brink_crimpier[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,brink_crimpier);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if (thieveries_utfangthief != 0) \n          free(((char *)thieveries_utfangthief));\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}", "answer": "cmd_string", "cwe": "88", "idx": "152467"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint syngenesia_subshaft = 0;\ntypedef char *mood_baittle;\nint global_variable;\nvoid quakily_auriculares(mood_baittle *osteitis_ectopistes);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid buttercups_tovar(void (*anisogamous_myotalpa)(mood_baittle *));\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&syngenesia_subshaft,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      buttercups_tovar(quakily_auriculares);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid quakily_auriculares(mood_baittle *osteitis_ectopistes)\n{\n  mood_baittle durezza_coarrangement = 0;\n  char *kalis_richers;\n  ++global_variable;;\n  setup_printf_context();\n  kalis_richers = getenv(\"KURGANS_LAMUS\");\n  if (kalis_richers != 0) {;\n    durezza_coarrangement = kalis_richers;\n     *osteitis_ectopistes = durezza_coarrangement;\n  }\n}\n\nvoid buttercups_tovar(void (*anisogamous_myotalpa)(mood_baittle *))\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *quinamin_eldwen = 0;\n  ++global_variable;\n  mood_baittle forsee_russify = 0;\n  anisogamous_myotalpa(&forsee_russify);\n  if (forsee_russify != 0) {;\n    quinamin_eldwen = ((char *)forsee_russify);\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, quinamin_eldwen);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, quinamin_eldwen, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\nclose_printf_context();\n  }\n}\n#endif", "answer": "size_var dest quinamin_eldwen", "cwe": "195", "idx": "151227"}
{"code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint reunited_semiminess = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *pebworth_woolwich = 0;\n  jmp_buf commemorable_muliebrity;\n  int suppedit_forfeited;\n  char *outrapped_lesli = 0;\n  int *postvorta_stolkjaerre = 0;\n  int animalizing_verdure;\n  char *kopeks_superlunar[10] = {0};\n  int vetchiest_unavoidableness = 0;\n  char *handicrafts_khis = 0;\n  char *comedo_cephalology;;\n  if (__sync_bool_compare_and_swap(&reunited_semiminess,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      comedo_cephalology = getenv(\"SATSUMA_BLAMES\");\n      if (comedo_cephalology != 0) {;\n        vetchiest_unavoidableness = ((int )(strlen(comedo_cephalology)));\n        handicrafts_khis = ((char *)(malloc(vetchiest_unavoidableness + 1)));\n        if (handicrafts_khis == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(handicrafts_khis,0,vetchiest_unavoidableness + 1);\n        memcpy(handicrafts_khis,comedo_cephalology,vetchiest_unavoidableness);\n        animalizing_verdure = 5;\n        postvorta_stolkjaerre = &animalizing_verdure;\n        kopeks_superlunar[ *postvorta_stolkjaerre] = handicrafts_khis;\n        outrapped_lesli = kopeks_superlunar[ *postvorta_stolkjaerre];\n        suppedit_forfeited = setjmp(commemorable_muliebrity);\n        if (suppedit_forfeited == 0) {\n          longjmp(commemorable_muliebrity,1);\n        }\n        pebworth_woolwich = ((char *)outrapped_lesli);\n    \n    taint_size = strlen(pebworth_woolwich);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,pebworth_woolwich,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n        if (outrapped_lesli != 0) \n          free(((char *)outrapped_lesli));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "error 12 ss_i errno malloc malloced_buff n char trace_flag Malloc ulimit taint_size due to 0 sizeof", "cwe": "401", "idx": "151475"}
{"code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint swaddy_bookshelves = 0;\nint global_variable;\ntypedef char *outcheating_bequeathal;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\noutcheating_bequeathal dunt_vivid(outcheating_bequeathal emuls_boydekyn);\nvoid aguilarite_aerodontia(outcheating_bequeathal soliloquacious_spoofer);\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*sacrocoxalgia_wellsburg)(outcheating_bequeathal ) = aguilarite_aerodontia;\n  outcheating_bequeathal medicks_lawley = 0;\n  outcheating_bequeathal escallops_nonsiccative = 0;\n  char *omphalorrhagia_encumbering;;\n  if (__sync_bool_compare_and_swap(&swaddy_bookshelves,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&omphalorrhagia_encumbering,\"MILKSHOP_GUAYROTO\");\n      if (omphalorrhagia_encumbering != 0) {;\n        escallops_nonsiccative = omphalorrhagia_encumbering;\n        medicks_lawley = dunt_vivid(escallops_nonsiccative);\n        sacrocoxalgia_wellsburg(medicks_lawley);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\noutcheating_bequeathal dunt_vivid(outcheating_bequeathal emuls_boydekyn)\n{\n  ++global_variable;\n  return emuls_boydekyn;\n}\n\nvoid aguilarite_aerodontia(outcheating_bequeathal soliloquacious_spoofer)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *rhabarbaric_formicivora = 0;\n  ++global_variable;;\n  rhabarbaric_formicivora = ((char *)soliloquacious_spoofer);\n    \n    if (strlen(rhabarbaric_formicivora) > 0 &&\n            rhabarbaric_formicivora[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(rhabarbaric_formicivora,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n  if (soliloquacious_spoofer != 0) \n    free(((char *)soliloquacious_spoofer));\nclose_printf_context();\n}", "answer": "f w fopen filename_param", "cwe": "774", "idx": "151633"}
{"code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <unistd.h> \nint maloy_tawneys = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid wharfholder_lycea(void ***nonretired_ammocoetoid);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  void (*pedicels_quai)(void ***) = wharfholder_lycea;\n  void ***beggarwoman_torturable = 0;\n  void **pseudoovally_kaila = 0;\n  void *asok_unadhering = 0;\n  void *offhand_blemish = 0;\n  char *nonevasively_exodus;;\n  if (__sync_bool_compare_and_swap(&maloy_tawneys,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      nonevasively_exodus = getenv(\"GARNEL_SPLENECTOMIES\");\n      if (nonevasively_exodus != 0) {;\n        offhand_blemish = ((void *)nonevasively_exodus);\n        pseudoovally_kaila = &offhand_blemish;\n        beggarwoman_torturable = &pseudoovally_kaila;\n        pedicels_quai(beggarwoman_torturable);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid wharfholder_lycea(void ***nonretired_ammocoetoid)\n{\n int random_data;\n char fill_buff[50000];\n char file_path[50][31];\n int filedes;\n int count = 0;\n int taint_num;\n int ss_i = 0;\n  char *counterferment_spinules = 0;\n  ++global_variable;;\n  counterferment_spinules = ((char *)((char *)( *( *nonretired_ammocoetoid))));\n    \n random_data = open(\"/dev/urandom\",0);\n    read(random_data,fill_buff,49999U);\n    close(random_data);\n    fill_buff[49999] = '\\0';\n    taint_num = atoi(counterferment_spinules);\n    if (taint_num < 0) {\n        taint_num = 0;\n    }\n    \n    for (ss_i = 0; ss_i < taint_num; ++ss_i) {\n        ++count;\n        strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\n        filedes = mkstemp(file_path[ss_i % 50]);\n        write(filedes,fill_buff,sizeof(fill_buff));\n        close(filedes);\n    }\n    \n    \n    for (ss_i = 0; ss_i < 50; ++ss_i){\n  \n        if (count == ss_i) {\n            break;\n        }\n  \n        unlink(file_path[ss_i]);\n    }\n    \n    \n    \n;\nclose_printf_context();\n}", "answer": "ss_i break count 50 unlink file_path 0", "cwe": "459", "idx": "152089"}
