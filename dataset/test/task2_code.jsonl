{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.CWE-332:Insufficient Entropy in PRNG\nE.CWE-493:Critical Public Variable Without Final Modifier", "code": "#include \"std_testcase.h\"\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_82\n{\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_82 : public _External_Control_of_System_or_Configuration_Setting__w32_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_82G2B : public _External_Control_of_System_or_Configuration_Setting__w32_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82023"}
{"selection": "A.No Vulnerabilities\nB.CWE-476:NULL Pointer Dereference\nC.CWE-156:Improper Neutralization of Whitespace\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-65:Windows Hard Link", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint vented_acephala = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid *my_malloc(unsigned int size)\n{\n  if (size > 512)\n\n    return 0;\n  return malloc(size);\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  unsigned int size_buffer;\n  int buffer_value;\n  char *malloc_buffer = 0;\n  char *firebugs_coccygodynia = 0;\n  char *isocercy_triflet = 0;\n  int *reassemblage_underlap = 0;\n  int thalassa_overdoes;\n  char *blurts_pararosolic[10] = {0};\n  int vauntingly_taboo = 5;\n  char *flatbread_impelled;;\n  if (__sync_bool_compare_and_swap(&vented_acephala,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&flatbread_impelled,\"6024\",vauntingly_taboo);\n      if (flatbread_impelled != 0) {;\n        blurts_pararosolic[5] = flatbread_impelled;\n        thalassa_overdoes = 5;\n        reassemblage_underlap = &thalassa_overdoes;\n        isocercy_triflet =  *(blurts_pararosolic +  *reassemblage_underlap);\n        firebugs_coccygodynia = ((char *)isocercy_triflet);\n      \n      buffer_value = atoi(firebugs_coccygodynia);\n      \n      if (buffer_value < 0)\n        buffer_value = 0;\n      size_buffer = ((unsigned int )buffer_value);\n      \n      malloc_buffer = my_malloc(size_buffer);\n      \n      \n      \n\n      memset(malloc_buffer,0,size_buffer);\n      printf(\"Buffer size is %d\\n\", size_buffer);\n      \n      if (malloc_buffer != 0) {\n        free(malloc_buffer);\n      }\n      \n;\n        if (isocercy_triflet != 0) \n          free(((char *)isocercy_triflet));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "B.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149658"}
{"selection": "A.CWE-187:Partial String Comparison\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-23:Relative Path Traversal\nE.CWE-535:Exposure of Information Through Shell Error Message", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_15\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcat(data, \"file.txt\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcat(data, \"file.txt\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_15; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89834"}
{"selection": "A.CWE-710:Improper Adherence to Coding Standards\nB.No Vulnerabilities\nC.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nD.CWE-115:Misinterpretation of Input\nE.CWE-476:NULL Pointer Dereference", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint kochkin_lincolndale = 0;\ntypedef char *fiddlesticks_gastronomies;\nint global_variable;\nvoid handle_taint(char *muzziest_treadling);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nfiddlesticks_gastronomies grapewise_inbreathed(fiddlesticks_gastronomies obtested_cautio);\nvoid kicksies_conarium(int eachelle_solarized,fiddlesticks_gastronomies glossotype_drowsily);\nvoid trigemini_crinoids(int materia_indubiously,fiddlesticks_gastronomies menazons_multicharge);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&kochkin_lincolndale,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *muzziest_treadling)\n{\n  int carnivalesque_paumgartner = 7;\n  fiddlesticks_gastronomies garnel_klenk = 0;\n  fiddlesticks_gastronomies ballons_polygenes = 0;\n  ++global_variable;;\n  if (muzziest_treadling != 0) {;\n    ballons_polygenes = muzziest_treadling;\n    garnel_klenk = grapewise_inbreathed(ballons_polygenes);\n    kicksies_conarium(carnivalesque_paumgartner,garnel_klenk);\n  }\n}\n\nfiddlesticks_gastronomies grapewise_inbreathed(fiddlesticks_gastronomies obtested_cautio)\n{\n  ++global_variable;\n  return obtested_cautio;\n}\n\nvoid kicksies_conarium(int eachelle_solarized,fiddlesticks_gastronomies glossotype_drowsily)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *germana_frenatae = 0;\n  ++global_variable;\n  eachelle_solarized--;\n  if (eachelle_solarized > 0) {\n    trigemini_crinoids(eachelle_solarized,glossotype_drowsily);\n    return ;\n  }\n  germana_frenatae = ((char *)glossotype_drowsily);\n      \n      len = strtol(germana_frenatae,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (glossotype_drowsily != 0) \n    free(((char *)glossotype_drowsily));\nclose_printf_context();\n}\n\nvoid trigemini_crinoids(int materia_indubiously,fiddlesticks_gastronomies menazons_multicharge)\n{\n  ++global_variable;\n  kicksies_conarium(materia_indubiously,menazons_multicharge);\n}", "answer": "E.CWE-476:NULL Pointer Dereference|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149652"}
{"selection": "A.No Vulnerabilities\nB.CWE-671:Lack of Administrator Control over Security\nC.CWE-15:External Control of System or Configuration Setting\nD.CWE-1188:Initialization of a Resource with an Insecure Default\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_18()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcpy(data, \"hostname\");\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|E.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81995"}
{"selection": "A.CWE-274:Improper Handling of Insufficient Privileges\nB.CWE-441:Unintended Proxy or Intermediary ('Confused Deputy')\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_char_environment_64bSink(void * dataVoidPtr);\n\nvoid _Process_Control__w32_char_environment_64()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _Process_Control__w32_char_environment_64bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_char_environment_64bG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_char_environment_64bG2BSink(&data);\n}\n\nvoid _Process_Control__w32_char_environment_64()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_environment_64();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_environment_64();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|D.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62072"}
{"selection": "A.CWE-591:Sensitive Data Storage in Improperly Locked Memory\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-1083:Data Access from Outside Expected Data Manager Component", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_01()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122991"}
{"selection": "A.CWE-768:Incorrect Short Circuit Evaluation\nB.CWE-522:Insufficiently Protected Credentials\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_connect_socket_ofstream_01\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_ofstream_01; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89676"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-915:Improperly Controlled Modification of Dynamically-Determined Object Attributes\nC.CWE-262:Not Using Password Aging\nD.CWE-36:Absolute Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_open_14\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_open_14; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97375"}
{"selection": "A.CWE-323:Reusing a Nonce, Key Pair in Encryption\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-36:Absolute Path Traversal\nE.CWE-222:Truncation of Security-relevant Information", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97275"}
{"selection": "A.CWE-296:Improper Following of a Certificate's Chain of Trust\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-246:J2EE Bad Practices: Direct Use of Sockets\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECVP _wexecvp\n\n#ifndef OMITM\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Global = 0;\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Source(wchar_t * data);\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Global = 0;\nint _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Global = 0;\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Global = 0; \n    data = _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246614"}
{"selection": "A.CWE-347:Improper Verification of Cryptographic Signature\nB.No Vulnerabilities\nC.CWE-36:Absolute Path Traversal\nD.CWE-707:Improper Neutralization\nE.CWE-1290:Incorrect Decoding of Security Identifiers ", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95978"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-397:Declaration of Throws for Generic Exception\nC.CWE-1096:Singleton Class Instance Creation without Proper Locking or Synchronization\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_12()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123290"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-1314:Missing Write Protection for Parametric Data Values\nD.CWE-302:Authentication Bypass by Assumed-Immutable Data\nE.CWE-682:Incorrect Calculation", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint methodologist_algorist = 0;\n\nunion enflagellation_owly \n{\n  char *squirarchies_burdenable;\n  double weathers_truantship;\n  char *bilianic_beguin;\n  char saugerties_matchcoat;\n  int mumetal_retranscribed;\n}\n;\nint global_variable;\nvoid handle_taint(char *tribunate_phiona);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nunion enflagellation_owly roploch_yucatecan(union enflagellation_owly averrable_phlebology);\nvoid function() {\n    \n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&methodologist_algorist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *tribunate_phiona)\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *dehisced_leslee = 0;\n  union enflagellation_owly overmatureness_khitmatgar = {0};\n  union enflagellation_owly plowline_duma;\n  ++global_variable;;\n  if (tribunate_phiona != 0) {;\n    plowline_duma . squirarchies_burdenable = tribunate_phiona;\n    overmatureness_khitmatgar = roploch_yucatecan(plowline_duma);\n    if (overmatureness_khitmatgar . squirarchies_burdenable != 0) {\n      goto collocative_cutlerr;\n    }\n    ++global_variable;\n    collocative_cutlerr:;\n    dehisced_leslee = ((char *)overmatureness_khitmatgar . squirarchies_burdenable);\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(dehisced_leslee) >= 1 &&\n            dehisced_leslee[0] != '-') {\n        input_num = strtoul(dehisced_leslee,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(dehisced_leslee) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n    if (overmatureness_khitmatgar . squirarchies_burdenable != 0) \n      free(((char *)overmatureness_khitmatgar . squirarchies_burdenable));\nclose_printf_context();\n  }\n}\n\nunion enflagellation_owly roploch_yucatecan(union enflagellation_owly averrable_phlebology)\n{\n  ++global_variable;\n  return averrable_phlebology;\n}\n#endif", "answer": "E.CWE-682:Incorrect Calculation|B.CWE-707:Improper Neutralization", "cwe": "682", "idx": "150968"}
{"selection": "A.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-342:Predictable Exact Value from Previous Values\nE.No Vulnerabilities", "code": "#include <apr_pools.h>\n#include <apr_uuid.h>\n#include \"svn_hash.h\"\n#include \"svn_types.h\"\n#include \"svn_error.h\"\n#include \"svn_string.h\"\n#include \"svn_props.h\"\n#include \"svn_private_config.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint bertina_filisters = 0;\nint global_variable;\nvoid handle_taint(char *pestis_leeper);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid montessorian_remeeting(int lupercalia_dentata,... );\n\nsvn_error_t *svn_revnum_parse(svn_revnum_t *rev,const char *str,const char **endptr)\n{\n  char *end;\n  svn_revnum_t result = strtol(str,&end,10);\n  if (endptr) {\n     *endptr = end;\n  }\n  if (str == end) {\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Invalid revision number found parsing '%s'\")),str);\n  }\n  if (result < 0) {\n\n    if (endptr) {\n       *endptr = str;\n    }\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Negative revision number found parsing '%s'\")),str);\n  }\n   *rev = result;\n  return 0;\n}\n\nconst char *svn_uuid_generate(apr_pool_t *pool)\n{\n  apr_uuid_t uuid;\n  char *uuid_str = (memset(apr_palloc(pool,(36 + 1)),0,(36 + 1)));\n  apr_uuid_get(&uuid);\n  apr_uuid_format(uuid_str,(&uuid));\n  return uuid_str;\n}\n\nconst char *svn_depth_to_word(svn_depth_t depth)\n{\n  switch(depth){\n    case svn_depth_exclude:\n    return \"exclude\";\n    case svn_depth_unknown:\n    return \"unknown\";\n    case svn_depth_empty:\n    return \"empty\";\n    case svn_depth_files:\n    return \"files\";\n    case svn_depth_immediates:\n    return \"immediates\";\n    case svn_depth_infinity:\n    return \"infinity\";\n    default:\n    return \"INVALID-DEPTH\";\n  }\n}\n\nsvn_depth_t svn_depth_from_word(const char *word)\n{\n  if (strcmp(word,\"exclude\") == 0) {\n    return svn_depth_exclude;\n  }\n  if (strcmp(word,\"unknown\") == 0) {\n    return svn_depth_unknown;\n  }\n  if (strcmp(word,\"empty\") == 0) {\n    return svn_depth_empty;\n  }\n  if (strcmp(word,\"files\") == 0) {\n    return svn_depth_files;\n  }\n  if (strcmp(word,\"immediates\") == 0) {\n    return svn_depth_immediates;\n  }\n  if (strcmp(word,\"infinity\") == 0) {\n    return svn_depth_infinity;\n  }\n\n  return svn_depth_unknown;\n}\n\nconst char *svn_node_kind_to_word(svn_node_kind_t kind)\n{\n  switch(kind){\n    case svn_node_none:\n    return \"none\";\n    case svn_node_file:\n    return \"file\";\n    case svn_node_dir:\n    return \"dir\";\n    case svn_node_symlink:\n    return \"symlink\";\n    case svn_node_unknown:\n{\n    }\n    default:\n    return \"unknown\";\n  }\n}\n\nsvn_node_kind_t svn_node_kind_from_word(const char *word)\n{\n  if (word == ((void *)0)) {\n    return svn_node_unknown;\n  }\n  if (strcmp(word,\"none\") == 0) {\n    return svn_node_none;\n  }\n  else {\n    if (strcmp(word,\"file\") == 0) {\n      return svn_node_file;\n    }\n    else {\n      if (strcmp(word,\"dir\") == 0) {\n        return svn_node_dir;\n      }\n      else {\n        if (strcmp(word,\"symlink\") == 0) {\n          return svn_node_symlink;\n        }\n        else {\n\n          return svn_node_unknown;\n        }\n      }\n    }\n  }\n}\n\nconst char *svn_tristate__to_word(svn_tristate_t tristate)\n{\n  switch(tristate){\n    case svn_tristate_false:\n    return \"false\";\n    case svn_tristate_true:\n    return \"true\";\n    case svn_tristate_unknown:\n{\n    }\n    default:\n    return ((void *)0);\n  }\n}\n\nsvn_tristate_t svn_tristate__from_word(const char *word)\n{;\n  if (__sync_bool_compare_and_swap(&bertina_filisters,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (word == ((void *)0)) {\n    return svn_tristate_unknown;\n  }\n  else {\n    if (0 == svn_cstring_casecmp(word,\"true\") || 0 == svn_cstring_casecmp(word,\"yes\") || 0 == svn_cstring_casecmp(word,\"on\") || 0 == strcmp(word,\"1\")) {\n      return svn_tristate_true;\n    }\n    else {\n      if (0 == svn_cstring_casecmp(word,\"false\") || 0 == svn_cstring_casecmp(word,\"no\") || 0 == svn_cstring_casecmp(word,\"off\") || 0 == strcmp(word,\"0\")) {\n        return svn_tristate_false;\n      }\n    }\n  }\n  return svn_tristate_unknown;\n}\n\nsvn_commit_info_t *svn_create_commit_info(apr_pool_t *pool)\n{\n  svn_commit_info_t *commit_info = (memset(apr_palloc(pool,sizeof(( *commit_info))),0,sizeof(( *commit_info))));\n  commit_info -> revision = ((svn_revnum_t )(- 1));\n\n  return commit_info;\n}\n\nsvn_commit_info_t *svn_commit_info_dup(const svn_commit_info_t *src_commit_info,apr_pool_t *pool)\n{\n  svn_commit_info_t *dst_commit_info = (apr_palloc(pool,sizeof(( *dst_commit_info))));\n  dst_commit_info -> date = ((src_commit_info -> date?apr_pstrdup(pool,src_commit_info -> date) : ((void *)0)));\n  dst_commit_info -> author = ((src_commit_info -> author?apr_pstrdup(pool,src_commit_info -> author) : ((void *)0)));\n  dst_commit_info -> revision = src_commit_info -> revision;\n  dst_commit_info -> post_commit_err = ((src_commit_info -> post_commit_err?apr_pstrdup(pool,src_commit_info -> post_commit_err) : ((void *)0)));\n  dst_commit_info -> repos_root = ((src_commit_info -> repos_root?apr_pstrdup(pool,src_commit_info -> repos_root) : ((void *)0)));\n  return dst_commit_info;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_create(apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (memset(apr_palloc(pool,sizeof(( *new_changed_path))),0,sizeof(( *new_changed_path))));\n  new_changed_path -> text_modified = svn_tristate_unknown;\n  new_changed_path -> props_modified = svn_tristate_unknown;\n  return new_changed_path;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_dup(const svn_log_changed_path2_t *changed_path,apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (apr_palloc(pool,sizeof(( *new_changed_path))));\n   *new_changed_path =  *changed_path;\n  if (new_changed_path -> copyfrom_path) {\n    new_changed_path -> copyfrom_path = (apr_pstrdup(pool,new_changed_path -> copyfrom_path));\n  }\n  return new_changed_path;\n}\n\nsvn_dirent_t *svn_dirent_create(apr_pool_t *result_pool)\n{\n  svn_dirent_t *new_dirent = (memset(apr_palloc(result_pool,sizeof(( *new_dirent))),0,sizeof(( *new_dirent))));\n  new_dirent -> kind = svn_node_unknown;\n  new_dirent -> size = ((svn_filesize_t )(- 1));\n  new_dirent -> created_rev = ((svn_revnum_t )(- 1));\n  new_dirent -> time = 0;\n  new_dirent -> last_author = ((void *)0);\n  return new_dirent;\n}\n\nsvn_dirent_t *svn_dirent_dup(const svn_dirent_t *dirent,apr_pool_t *pool)\n{\n  svn_dirent_t *new_dirent = (apr_palloc(pool,sizeof(( *new_dirent))));\n   *new_dirent =  *dirent;\n  new_dirent -> last_author = (apr_pstrdup(pool,dirent -> last_author));\n  return new_dirent;\n}\n\nsvn_log_entry_t *svn_log_entry_create(apr_pool_t *pool)\n{\n  svn_log_entry_t *log_entry = (memset(apr_palloc(pool,sizeof(( *log_entry))),0,sizeof(( *log_entry))));\n  return log_entry;\n}\n\nsvn_log_entry_t *svn_log_entry_dup(const svn_log_entry_t *log_entry,apr_pool_t *pool)\n{\n  apr_hash_index_t *hi;\n  svn_log_entry_t *new_entry = (apr_palloc(pool,sizeof(( *new_entry))));\n   *new_entry =  *log_entry;\n  if (log_entry -> revprops) {\n    new_entry -> revprops = svn_prop_hash_dup((log_entry -> revprops),pool);\n  }\n  if (log_entry -> changed_paths2) {\n    new_entry -> changed_paths2 = apr_hash_make(pool);\n    for (hi = apr_hash_first(pool,log_entry -> changed_paths2); hi; hi = apr_hash_next(hi)) {\n      const void *key;\n      void *change;\n      apr_hash_this(hi,&key,((void *)0),&change);\n      apr_hash_set(new_entry -> changed_paths2,(apr_pstrdup(pool,key)),(- 1),(svn_log_changed_path2_dup(change,pool)));\n    }\n  }\n\n  new_entry -> changed_paths = new_entry -> changed_paths2;\n  return new_entry;\n}\n\nsvn_location_segment_t *svn_location_segment_dup(const svn_location_segment_t *segment,apr_pool_t *pool)\n{\n  svn_location_segment_t *new_segment = (apr_palloc(pool,sizeof(( *new_segment))));\n   *new_segment =  *segment;\n  if (segment -> path) {\n    new_segment -> path = (apr_pstrdup(pool,segment -> path));\n  }\n  return new_segment;\n}\n\nvoid handle_taint(char *pestis_leeper)\n{\n  void *phaleucian_studdingsail = 0;\n  ++global_variable;;\n  if (pestis_leeper != 0) {;\n    phaleucian_studdingsail = ((void *)pestis_leeper);\n    montessorian_remeeting(1,phaleucian_studdingsail);\n  }\n}\n\nvoid montessorian_remeeting(int lupercalia_dentata,... )\n{\n    int stack_size = 0;\n  char *octopi_ephemeridae = 0;\n  int untemptably_hottentotese;\n  int campimetrical_jumbles;\n  void *mppd_dolores = 0;\n  va_list gweyn_unloose;\n  ++global_variable;;\n  if (lupercalia_dentata > 0) {\n    __builtin_va_start(gweyn_unloose,lupercalia_dentata);\n    mppd_dolores = (va_arg(gweyn_unloose,void *));\n    __builtin_va_end(gweyn_unloose);\n  }\n  campimetrical_jumbles = 5;\n  while(1 == 1){\n    campimetrical_jumbles = campimetrical_jumbles * 2;\n    campimetrical_jumbles = campimetrical_jumbles + 2;\n    if (campimetrical_jumbles > 1000) {\n      break; \n    }\n  }\n  untemptably_hottentotese = campimetrical_jumbles;\n  octopi_ephemeridae = ((char *)((char *)mppd_dolores));\n    \n    \n    \n    if (strlen(octopi_ephemeridae) > 1 &&\n     octopi_ephemeridae[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(octopi_ephemeridae,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\n  if (((char *)mppd_dolores) != 0) \n    free(((char *)((char *)mppd_dolores)));\nclose_printf_context();\n}", "answer": "B.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "789", "idx": "151458"}
{"selection": "A.CWE-1290:Incorrect Decoding of Security Identifiers \nB.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nC.CWE-707:Improper Neutralization\nD.CWE-1071:Empty Code Block\nE.No Vulnerabilities", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \nint stingbull_muscidae = 0;\nint global_variable;\n\nstruct presocialism_particularised \n{\n  char *deletive_unsupplicating;\n  double neurotropy_forepeak;\n  char *calyptriform_unrejoicing;\n  char reenlighten_gonadectomy;\n  int posteens_skeins;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nstruct presocialism_particularised debugged_nonrelativeness(struct presocialism_particularised wroken_hool);\n#define GRAPTOLITOIDEA_CATEGORIZATION(x) cleansers_zacata((struct presocialism_particularised) x)\nvoid cleansers_zacata(struct presocialism_particularised bebouldered_tubinares);\n\nunsigned int avdevice_version()\n{\n  struct presocialism_particularised barghests_nominated = {0};\n  struct presocialism_particularised rewelcome_schizophrene;\n  char *cakchikel_ensculpture;;\n  if (__sync_bool_compare_and_swap(&stingbull_muscidae,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      cakchikel_ensculpture = getenv(\"GUMBOILS_CARES\");\n      if (cakchikel_ensculpture != 0) {;\n        rewelcome_schizophrene . deletive_unsupplicating = ((char *)cakchikel_ensculpture);\n        barghests_nominated = debugged_nonrelativeness(rewelcome_schizophrene);\n\tGRAPTOLITOIDEA_CATEGORIZATION(barghests_nominated);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nstruct presocialism_particularised debugged_nonrelativeness(struct presocialism_particularised wroken_hool)\n{\n  ++global_variable;\n  return wroken_hool;\n}\n\nvoid cleansers_zacata(struct presocialism_particularised bebouldered_tubinares)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int nFields;\n    int i;\n    int j = 0;\n  char *soliloquacious_alep = 0;\n  ++global_variable;;\n  soliloquacious_alep = ((char *)bebouldered_tubinares . deletive_unsupplicating);\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", soliloquacious_alep);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            \n            printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        nFields = PQnfields(res);\n        for (i = 0; i < nFields; i++)\n            printf(\"%-15s\", PQfname(res, i));\n        printf(\"\\n\\n\");\n        \n        for (i = 0; i < PQntuples(res); i++)\n        {\n            for (j = 0; j < nFields; j++)\n                printf(\"%-15s\", PQgetvalue(res, i, j));\n            printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "B.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|C.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152704"}
{"selection": "A.CWE-509:Replicating Malicious Code (Virus or Worm)\nB.No Vulnerabilities\nC.CWE-1256:Improper Restriction of Software Interfaces to Hardware Features\nD.CWE-707:Improper Neutralization\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nwchar_t * _Process_Control__w32_wchar_t_console_61bSource(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_console_61()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    data = _Process_Control__w32_wchar_t_console_61bSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * _Process_Control__w32_wchar_t_console_61bG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    data = _Process_Control__w32_wchar_t_console_61bG2BSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_console_61()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_console_61();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_console_61();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|D.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62309"}
{"selection": "A.CWE-457:Use of Uninitialized Variable\nB.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_13()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81990"}
{"selection": "A.CWE-1294:Insecure Security Identifier Mechanism\nB.No Vulnerabilities\nC.CWE-839:Numeric Range Comparison Without Minimum Check\nD.CWE-707:Improper Neutralization\nE.CWE-258:Empty Password in Configuration File", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nint yeaton_yede = 0;\nint global_variable;\n\nunion nonpossessed_consarcinate \n{\n  char *hermaphrodism_ballou;\n  double latherwort_dowers;\n  char *slothfulness_attemperator;\n  char underfreight_arbitrages;\n  int transmutative_reannoyance;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid ellipsone_sumi(int phoneticization_dangerous,union nonpossessed_consarcinate *lobar_holocentrid);\n\nunsigned int avdevice_version()\n{\n  int viaticum_furlana = 7;\n  int operatrix_anteport;\n  union nonpossessed_consarcinate *unwasheds_cantillate = {0};\n  union nonpossessed_consarcinate *monofilament_fibromyomectomy = {0};\n  union nonpossessed_consarcinate syncarpies_troparion;\n  int pyragravure_shaitan = 10;\n  char *clout_chatty;;\n  if (__sync_bool_compare_and_swap(&yeaton_yede,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&clout_chatty,\"7239\",pyragravure_shaitan);\n      if (clout_chatty != 0) {;\n        syncarpies_troparion . hermaphrodism_ballou = clout_chatty;\n        operatrix_anteport = 1;\n        unwasheds_cantillate = &syncarpies_troparion;\n        monofilament_fibromyomectomy = ((union nonpossessed_consarcinate *)(((unsigned long )unwasheds_cantillate) * operatrix_anteport * operatrix_anteport)) + 5;\n        ellipsone_sumi(viaticum_furlana,monofilament_fibromyomectomy);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid ellipsone_sumi(int phoneticization_dangerous,union nonpossessed_consarcinate *lobar_holocentrid)\n{\n    char *buffer = 0U;\n    int len;\n  char *umest_afterstorm = 0;\n  ++global_variable;\n  phoneticization_dangerous--;\n  if (phoneticization_dangerous > 0) {\n    ellipsone_sumi(phoneticization_dangerous,lobar_holocentrid);\n    return ;\n  }\n  umest_afterstorm = ((char *)( *(lobar_holocentrid - 5)) . hermaphrodism_ballou);\n    \n    len = atoi(umest_afterstorm);\n    \n\n    if (len < 4096) {\n        buffer = ((char *)(malloc(4096 * sizeof(char ))));\n        if (buffer != 0) {\n            memset(buffer,'a',4096);\n            \n            \n\n            memset(&buffer[len],'b',4096 - len);\n            \n            buffer[4095] = 0;\n            printf(\"%s\\n\",buffer);\n            free(buffer);\n        }\n    } else {\n        printf(\"Number is too large to use\\n\");\n    }\n    \n    \n;\n  if (( *(lobar_holocentrid - 5)) . hermaphrodism_ballou != 0) \n    free(((char *)( *(lobar_holocentrid - 5)) . hermaphrodism_ballou));\nclose_printf_context();\n}", "answer": "C.CWE-839:Numeric Range Comparison Without Minimum Check|D.CWE-707:Improper Neutralization", "cwe": "839", "idx": "151313"}
{"selection": "A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nC.CWE-653:Improper Isolation or Compartmentalization\nD.No Vulnerabilities\nE.CWE-771:Missing Reference to Active Allocated Resource", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <errno.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint izdubar_staringly = 0;\nint global_variable;\nvoid handle_taint(char *kaaba_capsomer);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&izdubar_staringly,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *kaaba_capsomer)\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *myelemia_multifunction = 0;\n  char **enomania_hylomorphic = 0;\n  char **debrecen_subproctorship = 0;\n  ++global_variable;;\n  if (kaaba_capsomer != 0) {;\n    enomania_hylomorphic = &kaaba_capsomer;\n    debrecen_subproctorship = enomania_hylomorphic + 5;\n    if ( *(debrecen_subproctorship - 5) != 0) {\n      goto musteline_upthrust;\n    }\n    ++global_variable;\n    musteline_upthrust:;\n    myelemia_multifunction = ((char *)( *(debrecen_subproctorship - 5)));\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(myelemia_multifunction,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\n    if ( *(debrecen_subproctorship - 5) != 0) \n      free(((char *)( *(debrecen_subproctorship - 5))));\nclose_printf_context();\n  }\n}", "answer": "E.CWE-771:Missing Reference to Active Allocated Resource|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "771", "idx": "151656"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-549:Missing Password Field Masking\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1127:Compilation with Insufficient Warnings or Errors", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_open_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_open_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91191"}
{"selection": "A.CWE-377:Insecure Temporary File\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-213:Exposure of Sensitive Information Due to Incompatible Policies", "code": "#include \"std_testcase.h\"\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_83\n{\n\n#ifndef OMITM\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_83\n{\npublic:\n    _External_Control_of_System_or_Configuration_Setting__w32_83(char * dataCopy);\n    ~_External_Control_of_System_or_Configuration_Setting__w32_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_83G2B\n{\npublic:\n    _External_Control_of_System_or_Configuration_Setting__w32_83G2B(char * dataCopy);\n    ~_External_Control_of_System_or_Configuration_Setting__w32_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82024"}
{"selection": "A.CWE-114:Process Control\nB.No Vulnerabilities\nC.CWE-412:Unrestricted Externally Accessible Lock\nD.CWE-707:Improper Neutralization\nE.CWE-483:Incorrect Block Delimitation", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_31()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|D.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62104"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-763:Release of Invalid Pointer or Reference\nC.No Vulnerabilities\nD.CWE-219:Storage of File with Sensitive Data Under Web Root\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_12()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62095"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-826:Premature Release of Resource During Expected Lifetime\nE.CWE-393:Return of Wrong Status Code", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_file_ofstream_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_ofstream_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96391"}
{"selection": "A.No Vulnerabilities\nB.CWE-300:Channel Accessible by Non-Endpoint\nC.CWE-841:Improper Enforcement of Behavioral Workflow\nD.CWE-707:Improper Neutralization\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_file_w32spawnl_05()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_w32spawnl_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_w32spawnl_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_w32spawnl_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248207"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-1253:Incorrect Selection of Fuse Values", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_console_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        \n        strcat(data, \"Doe, XXXXX\");\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_char_console_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_console_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_console_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122916"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-672:Operation on a Resource after Expiration or Release\nD.CWE-1111:Incomplete I/O Documentation\nE.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint nos_doscher = 0;\nint global_variable;\n\nstruct inoxidizing_cheville \n{\n  char *babeship_accessors;\n  double nondisputatious_anglicized;\n  char *eleusinion_deblaterate;\n  char hitlerite_humdinger;\n  int tungstosilicate_fortiori;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid kneed_ridgling(struct inoxidizing_cheville grosz_jon);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    int (* before)(int);\n    char buffer[64];\n    int (* after)(int);\n};\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  void (*nincom_resuperheat)(struct inoxidizing_cheville ) = kneed_ridgling;\n  struct inoxidizing_cheville gerodontia_hippocratism = {0};\n  int **spumier_secretes = 0;\n  int *laburnum_planktologist = 0;\n  int vasoconstrictor_dachia;\n  struct inoxidizing_cheville conidiophorous_whiskerandos[10] = {0};\n  struct inoxidizing_cheville cuya_hemiganus;\n  char *moonblink_scrunching;;\n  if (__sync_bool_compare_and_swap(&nos_doscher,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      moonblink_scrunching = getenv(\"SCHENE_ENCHORIC\");\n      if (moonblink_scrunching != 0) {;\n        cuya_hemiganus . babeship_accessors = ((char *)moonblink_scrunching);\n        vasoconstrictor_dachia = 5;\n        laburnum_planktologist = &vasoconstrictor_dachia;\n        spumier_secretes = &laburnum_planktologist;\n        conidiophorous_whiskerandos[ *( *spumier_secretes)] = cuya_hemiganus;\n        gerodontia_hippocratism = conidiophorous_whiskerandos[ *( *spumier_secretes)];\n        nincom_resuperheat(gerodontia_hippocratism);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid kneed_ridgling(struct inoxidizing_cheville grosz_jon)\n{\n    int i = 0;\n    int opt_var;\n    struct struct data;\n  char *rhizomic_aposiopestic = 0;\n  ++global_variable;;\n  rhizomic_aposiopestic = ((char *)grosz_jon . babeship_accessors);\n    \n    data.before = toupper;\n    for (i = 0; i < 64; i++) {\n        data.buffer[i] = 0;\n    }\n    data.after = toupper;\n    \n    \n    \n    \n    \n    \n\n    strcpy(data.buffer, rhizomic_aposiopestic);\n    \n    \n\n    opt_var = strlen( data.buffer);\n    for (i = 0; i < opt_var; ++i) {\n        data.buffer[i] = toupper(data.buffer[i]);\n        printf(\"%c\",data.after(data.buffer[i]));\n    }\n    \n    \n    printf(\"\\n\");\n    \n;\nclose_printf_context();\n}", "answer": "E.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|A.CWE-707:Improper Neutralization", "cwe": "120", "idx": "153470"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-707:Improper Neutralization\nC.CWE-482:Comparing instead of Assigning\nD.CWE-392:Missing Report of Error Condition\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <fstream>\nusing namespace std;\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _Absolute_Path_Traversal__wchar_t_console_ofstream_04\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_ofstream_04; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97077"}
{"selection": "A.CWE-190:Integer Overflow or Wraparound\nB.No Vulnerabilities\nC.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\nD.CWE-707:Improper Neutralization\nE.CWE-211:Externally-Generated Error Message Containing Sensitive Information", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint bonnibel_cothurnate = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint 190_global_var = 0;\n\nunsigned int avdevice_version()\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *forestudy_plaudit = 0;\n  int upsit_unrecompensed;\n  int forfoughen_teleophore;\n  char **michabou_beauvoir = 0;\n  char **antiprism_mlles = 0;\n  int embololalia_sublacustrine = 0;\n  char *faked_cowan = 0;\n  int overdrench_dapples = 6;\n  char *unthriftiness_rhizopodous;;\n  if (__sync_bool_compare_and_swap(&bonnibel_cothurnate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&unthriftiness_rhizopodous,\"4091\",overdrench_dapples);\n      if (unthriftiness_rhizopodous != 0) {;\n        embololalia_sublacustrine = ((int )(strlen(unthriftiness_rhizopodous)));\n        faked_cowan = ((char *)(malloc(embololalia_sublacustrine + 1)));\n        if (faked_cowan == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(faked_cowan,0,embololalia_sublacustrine + 1);\n        memcpy(faked_cowan,unthriftiness_rhizopodous,embololalia_sublacustrine);\n        if (unthriftiness_rhizopodous != 0) \n          free(((char *)unthriftiness_rhizopodous));\n        michabou_beauvoir = &faked_cowan;\n        antiprism_mlles = michabou_beauvoir + 5;\n        forfoughen_teleophore = 5;\n        while(1 == 1){\n          forfoughen_teleophore = forfoughen_teleophore * 2;\n          forfoughen_teleophore = forfoughen_teleophore + 2;\n          if (forfoughen_teleophore > 1000) {\n            break; \n          }\n        }\n        upsit_unrecompensed = forfoughen_teleophore;\n        forestudy_plaudit = ((char *)( *(antiprism_mlles - 5)));\n    \n    tainted_int = atoi(forestudy_plaudit);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n        if ( *(antiprism_mlles - 5) != 0) \n          free(((char *)( *(antiprism_mlles - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}", "answer": "A.CWE-190:Integer Overflow or Wraparound|D.CWE-707:Improper Neutralization", "cwe": "190", "idx": "151314"}
{"selection": "A.CWE-619:Dangling Database Cursor ('Cursor Injection')\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-1088:Synchronous Access of Remote Resource without Timeout\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <stdio.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint systematization_chapatties = 0;\nint global_variable;\nvoid handle_taint(char *dyess_metalepses);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&systematization_chapatties,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *dyess_metalepses)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *mastodontoid_ophthalmoptosis = 0;\n  int nonchivalrously_michelangelo;\n  int falcons_eulogisation;\n  char *wolcott_chorographical = 0;\n  int **********tumultuation_incomeless = 0;\n  int *********platitudinarian_predivide = 0;\n  int ********castling_sidebar = 0;\n  int *******uninfringible_famiglietti = 0;\n  int ******homer_euplotid = 0;\n  int *****gpcd_enchodontid = 0;\n  int ****reasoner_overinvolving = 0;\n  int ***ensculpture_kusimanse = 0;\n  int **wallpiece_unequalizing = 0;\n  int *uprightly_nonembryonal = 0;\n  int hirai_laryngectomized;\n  char *ump_prejudicious[10] = {0};\n  int graceful_watchfulness = 0;\n  char *woofers_pallone = 0;\n  ++global_variable;;\n  if (dyess_metalepses != 0) {;\n    graceful_watchfulness = ((int )(strlen(dyess_metalepses)));\n    woofers_pallone = ((char *)(malloc(graceful_watchfulness + 1)));\n    if (woofers_pallone == 0) {\n      printf(\"Error: Failed to allocate memory\\n\");\n      exit(1);\n    }\n    memset(woofers_pallone,0,graceful_watchfulness + 1);\n    memcpy(woofers_pallone,dyess_metalepses,graceful_watchfulness);\n    if (dyess_metalepses != 0) \n      free(((char *)dyess_metalepses));\n    hirai_laryngectomized = 5;\n    uprightly_nonembryonal = &hirai_laryngectomized;\n    wallpiece_unequalizing = &uprightly_nonembryonal;\n    ensculpture_kusimanse = &wallpiece_unequalizing;\n    reasoner_overinvolving = &ensculpture_kusimanse;\n    gpcd_enchodontid = &reasoner_overinvolving;\n    homer_euplotid = &gpcd_enchodontid;\n    uninfringible_famiglietti = &homer_euplotid;\n    castling_sidebar = &uninfringible_famiglietti;\n    platitudinarian_predivide = &castling_sidebar;\n    tumultuation_incomeless = &platitudinarian_predivide;\n    ump_prejudicious[ *( *( *( *( *( *( *( *( *( *tumultuation_incomeless)))))))))] = woofers_pallone;\n    wolcott_chorographical = ump_prejudicious[ *( *( *( *( *( *( *( *( *( *tumultuation_incomeless)))))))))];\n    falcons_eulogisation = 5;\n    while(1 == 1){\n      falcons_eulogisation = falcons_eulogisation * 2;\n      falcons_eulogisation = falcons_eulogisation + 2;\n      if (falcons_eulogisation > 1000) {\n        break; \n      }\n    }\n    nonchivalrously_michelangelo = falcons_eulogisation;\n    mastodontoid_ophthalmoptosis = ((char *)wolcott_chorographical);\n    \n    if (strlen(mastodontoid_ophthalmoptosis) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,mastodontoid_ophthalmoptosis);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n    if (wolcott_chorographical != 0) \n      free(((char *)wolcott_chorographical));\nclose_printf_context();\n  }\n}", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152718"}
{"selection": "A.CWE-754:Improper Check for Unusual or Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-779:Logging of Excessive Data\nD.CWE-707:Improper Neutralization\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_41Sink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _Process_Control__w32_wchar_t_relativePath_41G2BSink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_41G2BSink(data);\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|D.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62492"}
{"selection": "A.CWE-267:Privilege Defined With Unsafe Actions\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-601:URL Redirection to Untrusted Site ('Open Redirect')\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_file_fopen_14\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_file_fopen_14; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90313"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-707:Improper Neutralization\nC.CWE-1164:Irrelevant Code\nD.CWE-301:Reflection Attack in an Authentication Protocol\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ifstream_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ifstream_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91576"}
{"selection": "A.CWE-540:Inclusion of Sensitive Information in Source Code\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-317:Cleartext Storage of Sensitive Information in GUI\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint accruing_resolubility = 0;\nint global_variable;\n\nstruct mucinous_kung \n{\n  char *similarly_cleanhanded;\n  double bedye_teutophil;\n  char *abohm_scrounging;\n  char obcordate_sumi;\n  int nonsecrecies_unbleaching;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid entree_apeman(struct mucinous_kung *pinacoline_atmospheres);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*lachryma_discounters)(struct mucinous_kung *) = entree_apeman;\n  struct mucinous_kung *ateknia_discous = {0};\n  struct mucinous_kung unshrouded_cariole;\n  char *rodmun_micate;;\n  if (__sync_bool_compare_and_swap(&accruing_resolubility,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&rodmun_micate,\"KUEHN_UNTITLED\");\n      if (rodmun_micate != 0) {;\n        unshrouded_cariole . similarly_cleanhanded = ((char *)rodmun_micate);\n        ateknia_discous = &unshrouded_cariole;\n        lachryma_discounters(ateknia_discous);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid entree_apeman(struct mucinous_kung *pinacoline_atmospheres)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *faldstool_oozier = 0;\n  ++global_variable;;\n  faldstool_oozier = ((char *)( *pinacoline_atmospheres) . similarly_cleanhanded);\n    \n    if (strlen(faldstool_oozier) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,faldstool_oozier);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n  if (( *pinacoline_atmospheres) . similarly_cleanhanded != 0) \n    free(((char *)( *pinacoline_atmospheres) . similarly_cleanhanded));\nclose_printf_context();\n}", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152642"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-315:Cleartext Storage of Sensitive Information in a Cookie\nD.CWE-1262:Improper Access Control for Register Interface\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n#define EXECVP _wexecvp\n\nstatic wchar_t * _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45Data;\nstatic wchar_t * _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45Data;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45G2BData;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248463"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-1321:Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')\nC.CWE-707:Improper Neutralization\nD.CWE-314:Cleartext Storage in the Registry\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_file_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_file_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123025"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-911:Improper Update of Reference Count\nD.CWE-15:External Control of System or Configuration Setting\nE.CWE-360:Trust of System Event Data", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nint _External_Control_of_System_or_Configuration_Setting__w32_22Global = 0;\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_22Source(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_22()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    _External_Control_of_System_or_Configuration_Setting__w32_22Global = 1; \n    data = _External_Control_of_System_or_Configuration_Setting__w32_22Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Global = 0;\nint _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Global = 0;\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Source(char * data);\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Global = 0; \n    data = _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Source(char * data);\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Global = 1; \n    data = _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-15:External Control of System or Configuration Setting|A.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81997"}
{"selection": "A.CWE-211:Externally-Generated Error Message Containing Sensitive Information\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-114:Process Control\nE.CWE-670:Always-Incorrect Control Flow Implementation", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_52bSink(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_relativePath_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_52bG2BSink(data);\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62498"}
{"selection": "A.CWE-575:EJB Bad Practices: Use of AWT Swing\nB.No Vulnerabilities\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-283:Unverified Ownership\nE.CWE-459:Incomplete Cleanup", "code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint uncooped_sellma = 0;\nint global_variable;\ntypedef char *stagnate_brachycranic;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid widow_duodenostomy(stagnate_brachycranic ulrica_bibasilar);\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n#define SUBCONCEALED_LIQUIFIER(x) widow_duodenostomy((stagnate_brachycranic) x)\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  stagnate_brachycranic hydrosols_boggy = 0;\n  char *redistill_acenesthesia;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&uncooped_sellma,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      redistill_acenesthesia = getenv(\"UNJOINTEDNESS_PARAMYELIN\");\n      if (redistill_acenesthesia != 0) {;\n        hydrosols_boggy = redistill_acenesthesia;\n\tSUBCONCEALED_LIQUIFIER(hydrosols_boggy);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n\nvoid widow_duodenostomy(stagnate_brachycranic ulrica_bibasilar)\n{\n int random_data;\n char fill_buff[50000];\n char file_path[50][31];\n int filedes;\n int count = 0;\n int taint_num;\n int ss_i = 0;\n  char *byroads_siphonial = 0;\n  ++global_variable;;\n  byroads_siphonial = ((char *)ulrica_bibasilar);\n    \n random_data = open(\"/dev/urandom\",0);\n    read(random_data,fill_buff,49999U);\n    close(random_data);\n    fill_buff[49999] = '\\0';\n    taint_num = atoi(byroads_siphonial);\n    if (taint_num < 0) {\n        taint_num = 0;\n    }\n    \n    for (ss_i = 0; ss_i < taint_num; ++ss_i) {\n        ++count;\n        strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\n        filedes = mkstemp(file_path[ss_i % 50]);\n        write(filedes,fill_buff,sizeof(fill_buff));\n        close(filedes);\n    }\n    \n    \n    for (ss_i = 0; ss_i < 50; ++ss_i){\n  \n        if (count == ss_i) {\n            break;\n        }\n  \n        unlink(file_path[ss_i]);\n    }\n    \n    \n    \n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "E.CWE-459:Incomplete Cleanup|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "459", "idx": "152084"}
{"selection": "A.No Vulnerabilities\nB.CWE-689:Permission Race Condition During Resource Copy\nC.CWE-707:Improper Neutralization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-561:Dead Code", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_01()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123279"}
{"selection": "A.CWE-783:Operator Precedence Logic Error\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-683:Function Call With Incorrect Order of Arguments\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint tribunitive_stria = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid flourishing_stocked(char *mentalities_documentalist);\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  void (*davyum_aliceville)(char *) = flourishing_stocked;\n  int secundine_woolshearer = 0;\n  char *gorillaship_unexistent = 0;\n  char *antrophore_outprayed;;\n  if (__sync_bool_compare_and_swap(&tribunitive_stria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      antrophore_outprayed = getenv(\"REPERMIT_HERBARIIA\");\n      if (antrophore_outprayed != 0) {;\n        secundine_woolshearer = ((int )(strlen(antrophore_outprayed)));\n        gorillaship_unexistent = ((char *)(malloc(secundine_woolshearer + 1)));\n        if (gorillaship_unexistent == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(gorillaship_unexistent,0,secundine_woolshearer + 1);\n        memcpy(gorillaship_unexistent,antrophore_outprayed,secundine_woolshearer);\n        davyum_aliceville(gorillaship_unexistent);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid flourishing_stocked(char *mentalities_documentalist)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *lamellicorn_caruthersville = 0;\n  ++global_variable;;\n  lamellicorn_caruthersville = ((char *)mentalities_documentalist);\n    \n files = fopen(lamellicorn_caruthersville,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n  if (mentalities_documentalist != 0) \n    free(((char *)mentalities_documentalist));\nclose_printf_context();\n}", "answer": "E.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "775", "idx": "151603"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-114:Process Control\nD.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nE.CWE-183:Permissive List of Allowed Inputs", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Process_Control__w32_char_connect_socket_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_connect_socket_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "61962"}
{"selection": "A.No Vulnerabilities\nB.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nC.CWE-1223:Race Condition for Write-Once Attributes\nD.CWE-707:Improper Neutralization\nE.CWE-304:Missing Critical Step in Authentication", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint rossing_remaindered = 0;\n\nunion closelipped_outright \n{\n  char *chefang_stiacciato;\n  double dietist_embroil;\n  char *cessative_exoascus;\n  char interlocutors_tiphany;\n  int songcraft_astigmia;\n}\n;\nint global_variable;\nvoid hystericus_semiwild(union closelipped_outright *kompeni_mastoscirrhus);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid caseweed_bradoon(void (*lahar_unprovidenced)(union closelipped_outright *));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&rossing_remaindered,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      caseweed_bradoon(hystericus_semiwild);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid hystericus_semiwild(union closelipped_outright *kompeni_mastoscirrhus)\n{\n  union closelipped_outright retrencher_thisness;\n  char *megnetosphere_pondwort;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&megnetosphere_pondwort,\"UNEMOLUMENTED_NETTLEBED\");\n  if (megnetosphere_pondwort != 0) {;\n    retrencher_thisness . chefang_stiacciato = megnetosphere_pondwort;\n     *kompeni_mastoscirrhus = retrencher_thisness;\n  }\n}\n\nvoid caseweed_bradoon(void (*lahar_unprovidenced)(union closelipped_outright *))\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *irresolvedly_barnhardtite = 0;\n  union closelipped_outright underplain_haliplankton = {0};\n  int *jacky_lutherist = 0;\n  int hemielytra_corporate;\n  union closelipped_outright rakeful_hibernia[10] = {0};\n  ++global_variable;\n  union closelipped_outright levelland_overtechnical = {0};\n  lahar_unprovidenced(&levelland_overtechnical);\n  if (levelland_overtechnical . chefang_stiacciato != 0) {;\n    rakeful_hibernia[5] = levelland_overtechnical;\n    hemielytra_corporate = 5;\n    jacky_lutherist = &hemielytra_corporate;\n    underplain_haliplankton =  *(rakeful_hibernia +  *jacky_lutherist);\n    irresolvedly_barnhardtite = ((char *)underplain_haliplankton . chefang_stiacciato);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(irresolvedly_barnhardtite); ++i) {\n        if (irresolvedly_barnhardtite[i] == ';') {\n          if (i == 0 || irresolvedly_barnhardtite[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,irresolvedly_barnhardtite);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n    if (underplain_haliplankton . chefang_stiacciato != 0) \n      free(((char *)underplain_haliplankton . chefang_stiacciato));\nclose_printf_context();\n  }\n}", "answer": "B.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|D.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152199"}
{"selection": "A.No Vulnerabilities\nB.CWE-1302:Missing Security Identifier\nC.CWE-23:Relative Path Traversal\nD.CWE-707:Improper Neutralization\nE.CWE-573:Improper Following of Specification by Caller", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_31\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            ofstream outputFile;\n            \n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            ofstream outputFile;\n            \n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_31; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91856"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-780:Use of RSA Algorithm without OAEP\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-300:Channel Accessible by Non-Endpoint", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_12()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_spawnv_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_spawnv_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245286"}
{"selection": "A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.No Vulnerabilities\nC.CWE-325:Missing Cryptographic Step\nD.CWE-1093:Excessively Complex Data Representation\nE.CWE-773:Missing Reference to Active File Descriptor or Handle", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint strychnol_flayers = 0;\n\nstruct sphagnaceae_axiate \n{\n  char *oba_orchestrating;\n  double pelike_skateboarding;\n  char *continuator_rigwiddie;\n  char clouee_untrespassing;\n  int backfriend_nonegregiously;\n}\n;\nint global_variable;\nvoid liner_openheartedness(struct sphagnaceae_axiate *stroller_instance);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid uroazotometer_dimerizes(void (*giuseppe_cretinizing)(struct sphagnaceae_axiate *));\nvoid cleanup(FILE **ptrs,int size)\n{\n  int i = 0;\n  \n  for (i = 0; i < size; i++) {\n    if (ptrs[i] != 0) {\n      fclose(ptrs[i]);\n    }\n  }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&strychnol_flayers,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      uroazotometer_dimerizes(liner_openheartedness);\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid liner_openheartedness(struct sphagnaceae_axiate *stroller_instance)\n{\n  struct sphagnaceae_axiate fellahin_russianize;\n  char *meatometer_finance;\n  ++global_variable;;\n  setup_printf_context();\n  meatometer_finance = getenv(\"CARLYNNE_MISREMEMBER\");\n  if (meatometer_finance != 0) {;\n    fellahin_russianize . oba_orchestrating = ((char *)meatometer_finance);\n     *stroller_instance = fellahin_russianize;\n  }\n}\n\nvoid uroazotometer_dimerizes(void (*giuseppe_cretinizing)(struct sphagnaceae_axiate *))\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[10];\n char filename[80];\n  char *esmaria_dimplier = 0;\n  struct sphagnaceae_axiate mentally_hydatogenous = {0};\n  long prefixed_yawl[10];\n  struct sphagnaceae_axiate mocha_bidarkee[10] = {0};\n  ++global_variable;\n  struct sphagnaceae_axiate olonetsish_vaudoux = {0};\n  giuseppe_cretinizing(&olonetsish_vaudoux);\n  if (olonetsish_vaudoux . oba_orchestrating != 0) {;\n    mocha_bidarkee[5] = olonetsish_vaudoux;\n    prefixed_yawl[1] = 5;\n    mentally_hydatogenous =  *(mocha_bidarkee + prefixed_yawl[1]);\n    esmaria_dimplier = ((char *)mentally_hydatogenous . oba_orchestrating);\n    \n files = fopen(esmaria_dimplier,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n            if (file == 0) {\n    if (file == 0 && errno == 24) {\n     printf(\"Fopen error due to ulimit\\n\");\n                }\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n   \n   file_list[ssi % 10] = file;\n   ssi++;\n        }\n        \n        \n    }\n    if (files != 0)\n        fclose(files);\n cleanup(file_list, ((ssi-1)%10)+1);\n    \n;\nclose_printf_context();\n  }\n}", "answer": "E.CWE-773:Missing Reference to Active File Descriptor or Handle|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "773", "idx": "151492"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1267:Policy Uses Obsolete Encoding\nC.CWE-126:Buffer Over-read\nD.No Vulnerabilities\nE.CWE-862:Missing Authorization", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint spiffing_tilyer = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    int ss_i = 0;\n    char* heap_buff_64;\n    int buff_size;\n  char *lamentedly_geulincx = 0;\n  char *talco_matfellon = 0;\n  long autoantibody_penalizes[10];\n  char *lorrimor_stereoed[10] = {0};\n  int intertissue_preemptor = 596;\n  char *yucking_gelatinised;;\n  if (__sync_bool_compare_and_swap(&spiffing_tilyer,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&yucking_gelatinised,\"5575\",intertissue_preemptor);\n      if (yucking_gelatinised != 0) {;\n        lorrimor_stereoed[5] = yucking_gelatinised;\n        autoantibody_penalizes[1] = 5;\n        talco_matfellon =  *(lorrimor_stereoed + autoantibody_penalizes[1]);\n        if (talco_matfellon != 0) {\n          goto unaway_armbruster;\n        }\n        ++global_variable;\n        unaway_armbruster:;\n        lamentedly_geulincx = ((char *)talco_matfellon);\n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    \n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64,'A',63);\n        heap_buff_64[63] = '\\0';\n        \n        buff_size = ((int )(strlen(lamentedly_geulincx)));\n        strncpy(heap_buff_64, lamentedly_geulincx, 64);\n        \n        \n        \n        for (; ss_i < buff_size; ++ss_i){\n            \n            \n            printf(\"%02x\",heap_buff_64[ss_i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( heap_buff_64);\n        \n        \n    }\n;\n        if (talco_matfellon != 0) \n          free(((char *)talco_matfellon));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "C.CWE-126:Buffer Over-read|A.CWE-707:Improper Neutralization", "cwe": "126", "idx": "153002"}
{"selection": "A.CWE-151:Improper Neutralization of Comment Delimiters\nB.No Vulnerabilities\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint gorgoneum_prospero = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid demisable_unparalysed(char *const unmitigatedly_intolerable);\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  int movie_gweduck = 0;\n  char *sweetbriar_overdoses = 0;\n  int validation_jasmone = 61;\n  char *aminated_staghunter;;\n  if (__sync_bool_compare_and_swap(&gorgoneum_prospero,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&aminated_staghunter,\"1152\",validation_jasmone);\n      if (aminated_staghunter != 0) {;\n        movie_gweduck = ((int )(strlen(aminated_staghunter)));\n        sweetbriar_overdoses = ((char *)(malloc(movie_gweduck + 1)));\n        if (sweetbriar_overdoses == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(sweetbriar_overdoses,0,movie_gweduck + 1);\n        memcpy(sweetbriar_overdoses,aminated_staghunter,movie_gweduck);\n        if (aminated_staghunter != 0) \n          free(((char *)aminated_staghunter));\n        demisable_unparalysed(sweetbriar_overdoses);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid demisable_unparalysed(char *const unmitigatedly_intolerable)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *dapperest_ujiji = 0;\n  int jawed_bundoc;\n  int uncavilling_anencephalic;\n  ++global_variable;;\n  uncavilling_anencephalic = 5;\n  while(1 == 1){\n    uncavilling_anencephalic = uncavilling_anencephalic * 2;\n    uncavilling_anencephalic = uncavilling_anencephalic + 2;\n    if (uncavilling_anencephalic > 1000) {\n      break; \n    }\n  }\n  jawed_bundoc = uncavilling_anencephalic;\n  dapperest_ujiji = ((char *)((char *)unmitigatedly_intolerable));\n    \n files = fopen(dapperest_ujiji,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n  if (((char *)unmitigatedly_intolerable) != 0) \n    free(((char *)((char *)unmitigatedly_intolerable)));\nclose_printf_context();\n}", "answer": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "775", "idx": "151735"}
{"selection": "A.CWE-1269:Product Released in Non-Release Configuration\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-672:Operation on a Resource after Expiration or Release\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_environment_13()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_environment_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_environment_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_environment_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62048"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nC.No Vulnerabilities\nD.CWE-1385:Missing Origin Validation in WebSockets\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_environment_fopen_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_fopen_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96028"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.CWE-523:Unprotected Transport of Credentials\nC.CWE-707:Improper Neutralization\nD.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_66bSink(char * dataArray[]);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    dataArray[2] = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    dataArray[2] = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_66bG2BSink(dataArray);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|C.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82016"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nC.CWE-530:Exposure of Backup File to an Unauthorized Control Sphere\nD.No Vulnerabilities\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_w32spawnl_31()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        \n        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        \n        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid _OS_Command_Injection__char_file_w32spawnl_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32spawnl_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32spawnl_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245671"}
{"selection": "A.No Vulnerabilities\nB.CWE-427:Uncontrolled Search Path Element\nC.CWE-476:NULL Pointer Dereference\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-123:Write-what-where Condition", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint fellies_forceless = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid unhorny_hydatigenous(void **manus_dillseed);\nvoid *my_malloc(unsigned int size)\n{\n  if (size > 512)\n\n    return 0;\n  return malloc(size);\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  void (*unkill_tsukupin)(void **) = unhorny_hydatigenous;\n  void **chorgi_symbionts = 0;\n  void *browny_bravo = 0;\n  char *thespian_tableman;;\n  if (__sync_bool_compare_and_swap(&fellies_forceless,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      thespian_tableman = getenv(\"DAFTAR_GROOVIEST\");\n      if (thespian_tableman != 0) {;\n        browny_bravo = ((void *)thespian_tableman);\n        chorgi_symbionts = &browny_bravo;\n        unkill_tsukupin(chorgi_symbionts);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid unhorny_hydatigenous(void **manus_dillseed)\n{\n  unsigned int size_buffer;\n  int buffer_value;\n  char *malloc_buffer = 0;\n  char *beveled_qkt = 0;\n  ++global_variable;;\n  beveled_qkt = ((char *)((char *)( *manus_dillseed)));\n      \n      buffer_value = atoi(beveled_qkt);\n      \n      if (buffer_value < 0)\n        buffer_value = 0;\n      size_buffer = ((unsigned int )buffer_value);\n      \n      malloc_buffer = my_malloc(size_buffer);\n      \n      \n      \n\n      memset(malloc_buffer,0,size_buffer);\n      printf(\"Buffer size is %d\\n\", size_buffer);\n      \n      if (malloc_buffer != 0) {\n        free(malloc_buffer);\n      }\n      \n;\nclose_printf_context();\n}", "answer": "C.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149324"}
{"selection": "A.CWE-1258:Exposure of Sensitive System Information Due to Uncleared Debug Information\nB.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nC.CWE-707:Improper Neutralization\nD.CWE-114:Process Control\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_char_file_81\n{\n\nclass _Process_Control__w32_char_file_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Process_Control__w32_char_file_81 : public _Process_Control__w32_char_file_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_char_file_81G2B : public _Process_Control__w32_char_file_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "D.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62128"}
{"selection": "A.No Vulnerabilities\nB.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nC.CWE-360:Trust of System Event Data\nD.CWE-15:External Control of System or Configuration Setting\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_17()\n{\n    int i;\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-15:External Control of System or Configuration Setting|E.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81994"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.No Vulnerabilities\nC.CWE-1327:Binding to an Unrestricted IP Address\nD.CWE-221:Information Loss or Omission\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(char * &data)\n{\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcpy(data, \"hostname\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|E.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82004"}
{"selection": "A.CWE-250:Execution with Unnecessary Privileges\nB.CWE-707:Improper Neutralization\nC.CWE-536:Servlet Runtime Error Message Containing Sensitive Information\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_13()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123051"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-127:Buffer Under-read\nD.CWE-12:ASP.NET Misconfiguration: Missing Custom Error Page\nE.CWE-1024:Comparison of Incompatible Types", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint revealability_heliolator = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n signed char *input_string = 0;\n int stack_buff[128];\n int other_buff[200];\n int ss_i = 0;\n  char *unverminousness_quinta = 0;\n  void **erase_diuron = 0;\n  void *nonenumerated_mutualise = 0;\n  int concatenary_michoacano = 105;\n  char *firers_lindenhurst;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&revealability_heliolator,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&firers_lindenhurst,\"9439\",concatenary_michoacano);\n      if (firers_lindenhurst != 0) {;\n        nonenumerated_mutualise = ((void *)firers_lindenhurst);\n        erase_diuron = &nonenumerated_mutualise;\n        if (((char *)( *erase_diuron)) != 0) {\n          goto reperks_nonsingular;\n        }\n        ++global_variable;\n        reperks_nonsingular:;\n        unverminousness_quinta = ((char *)((char *)( *erase_diuron)));\n    \n input_string = (signed char *) getenv(\"INPUT_STRING\");\n    \n    \n    \n    if (input_string != 0) {\n        memset(stack_buff,0,sizeof(stack_buff));\n        for (ss_i = 0; ss_i < 200; ++ss_i) {\n   other_buff[ss_i] = 5555;\n        }\n        for (ss_i = 0; ss_i < strlen((char *)input_string); ++ss_i) {\n   if (input_string[ss_i] < 0)\n    continue;\n   ++stack_buff[input_string[ss_i]];\n        }\n        \n        \n        for (ss_i = 0; ss_i < strlen(unverminousness_quinta); ++ss_i) {\n   \n   \n            \n   printf(\"value %c appears: %d times\\n\",\n       unverminousness_quinta[ss_i],\n       stack_buff[(int) unverminousness_quinta[ss_i]]);\n        }\n        \n        \n    }\n    \n;\n        if (((char *)( *erase_diuron)) != 0) \n          free(((char *)((char *)( *erase_diuron))));\nclose_printf_context();\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}", "answer": "C.CWE-127:Buffer Under-read|B.CWE-707:Improper Neutralization", "cwe": "127", "idx": "153007"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-602:Client-Side Enforcement of Server-Side Security\nD.CWE-36:Absolute Path Traversal\nE.CWE-313:Cleartext Storage in a File or on Disk", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_fopen_21\n{\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n    ;\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic wchar_t * nG2B1Source(wchar_t * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n    ;\n}\n\n\nstatic wchar_t * nG2B2Source(wchar_t * data)\n{\n    if(nG2B2Static)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n    ;\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_fopen_21; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97476"}
{"selection": "A.CWE-1050:Excessive Platform Resource Consumption within a Loop\nB.CWE-243:Creation of chroot Jail Without Changing Working Directory\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_18()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123248"}
{"selection": "A.CWE-1300:Improper Protection of Physical Side Channels\nB.CWE-695:Use of Low-Level Functionality\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_listen_socket_ifstream_53\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_ifstream_53; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90619"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-333:Improper Handling of Insufficient Entropy in TRNG", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_file_w32spawnl_82\n{\n\nclass _OS_Command_Injection__char_file_w32spawnl_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_file_w32spawnl_82 : public _OS_Command_Injection__char_file_w32spawnl_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_file_w32spawnl_82G2B : public _OS_Command_Injection__char_file_w32spawnl_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245696"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-278:Insecure Preserved Inherited Permissions\nC.CWE-707:Improper Neutralization\nD.CWE-312:Cleartext Storage of Sensitive Information\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__char_environment_ofstream_81\n{\n\nclass _Absolute_Path_Traversal__char_environment_ofstream_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__char_environment_ofstream_81 : public _Absolute_Path_Traversal__char_environment_ofstream_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__char_environment_ofstream_81G2B : public _Absolute_Path_Traversal__char_environment_ofstream_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "A.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96158"}
{"selection": "A.CWE-509:Replicating Malicious Code (Virus or Worm)\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1266:Improper Scrubbing of Sensitive Data from Decommissioned Device\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    wcscat(data, L\"*.*\");\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247700"}
{"selection": "A.CWE-392:Missing Report of Error Condition\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-1065:Runtime Resource Management Control Element in a Component Built to Run on Application Servers\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_10()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62093"}
{"selection": "A.CWE-374:Passing Mutable Objects to an Untrusted Method\nB.CWE-707:Improper Neutralization\nC.CWE-1317:Improper Access Control in Fabric Bridge\nD.CWE-15:External Control of System or Configuration Setting\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_68Data;\nchar * _External_Control_of_System_or_Configuration_Setting__w32_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68bSink();\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_68Data = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_68G2BData = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_68bG2BSink();\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82018"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-281:Improper Preservation of Permissions\nE.CWE-1319:Improper Protection against Electromagnetic Fault Injection (EM-FI)", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_open_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_open_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91893"}
{"selection": "A.CWE-281:Improper Preservation of Permissions\nB.CWE-413:Improper Resource Locking\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_console_06()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123140"}
{"selection": "A.CWE-114:Process Control\nB.No Vulnerabilities\nC.CWE-439:Behavioral Change in New Version or Environment\nD.CWE-707:Improper Neutralization\nE.CWE-833:Deadlock", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Process_Control__w32_wchar_t_file_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        wchar_t * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        wchar_t * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_wchar_t_file_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|D.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62394"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-408:Incorrect Behavior Order: Early Amplification", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_03()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point|C.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81980"}
{"selection": "A.No Vulnerabilities\nB.CWE-1066:Missing Serialization Control Element\nC.CWE-707:Improper Neutralization\nD.CWE-342:Predictable Exact Value from Previous Values\nE.CWE-839:Numeric Range Comparison Without Minimum Check", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint expunges_splats = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n    char *buffer = 0U;\n    int len;\n  char *sikang_sprights = 0;\n  char **lanterned_andrija = 0;\n  int **standage_playable = 0;\n  int *redamaged_babyhouse = 0;\n  int loonybin_aesopian;\n  char **tetragynian_theoretical[10] = {0};\n  char *spermotoxin_strifemaking[18] = {0};\n  char *faustina_pitzer;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&expunges_splats,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      faustina_pitzer = getenv(\"RENEWER_DESERTIC\");\n      if (faustina_pitzer != 0) {;\n        spermotoxin_strifemaking[16] = faustina_pitzer;\n        loonybin_aesopian = 5;\n        redamaged_babyhouse = &loonybin_aesopian;\n        standage_playable = &redamaged_babyhouse;\n        tetragynian_theoretical[ *( *standage_playable)] = spermotoxin_strifemaking;\n        lanterned_andrija = tetragynian_theoretical[ *( *standage_playable)];\n        if (lanterned_andrija[16] != 0) {\n          goto plenum_bilaan;\n        }\n        ++global_variable;\n        plenum_bilaan:;\n        sikang_sprights = ((char *)lanterned_andrija[16]);\n    \n    len = atoi(sikang_sprights);\n    \n\n    if (len < 4096) {\n        buffer = ((char *)(malloc(4096 * sizeof(char ))));\n        if (buffer != 0) {\n            memset(buffer,'a',4096);\n            \n            \n\n            memset(&buffer[len],'b',4096 - len);\n            \n            buffer[4095] = 0;\n            printf(\"%s\\n\",buffer);\n            free(buffer);\n        }\n    } else {\n        printf(\"Number is too large to use\\n\");\n    }\n    \n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}", "answer": "E.CWE-839:Numeric Range Comparison Without Minimum Check|C.CWE-707:Improper Neutralization", "cwe": "839", "idx": "150794"}
{"selection": "A.CWE-383:J2EE Bad Practices: Direct Use of Threads\nB.No Vulnerabilities\nC.CWE-1389:Incorrect Parsing of Numbers with Different Radices\nD.CWE-707:Improper Neutralization\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_61bSource(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_61()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = _External_Control_of_System_or_Configuration_Setting__w32_61bSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_61bG2BSource(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = _External_Control_of_System_or_Configuration_Setting__w32_61bG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_61()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_61();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_61();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82011"}
{"selection": "A.No Vulnerabilities\nB.CWE-328:Use of Weak Hash\nC.CWE-707:Improper Neutralization\nD.CWE-691:Insufficient Control Flow Management\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_ofstream_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_ofstream_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91372"}
{"selection": "A.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-1047:Modules with Circular Dependencies\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ofstream_67\n{\n\ntypedef struct _structType\n{\n    wchar_t * structFirst;\n} structType;\n\n#ifndef OMITM\n\n\nvoid mSink(structType myStruct);\n\nvoid m()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    mSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    myStruct.structFirst = data;\n    nG2BSink(myStruct);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ofstream_67; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91635"}
{"selection": "A.CWE-1240:Use of a Cryptographic Primitive with a Risky Implementation\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-670:Always-Incorrect Control Flow Implementation\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_16\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_16; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97713"}
{"selection": "A.No Vulnerabilities\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-1048:Invokable Control Element with Large Number of Outward Calls\nD.CWE-537:Java Runtime Error Message Containing Sensitive Information\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_11()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123001"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-655:Insufficient Psychological Acceptability\nC.CWE-492:Use of Inner Class Containing Sensitive Data\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\ntypedef struct __OS_Command_Injection__char_connect_socket_execlp_67_structType\n{\n    char * structFirst;\n} _OS_Command_Injection__char_connect_socket_execlp_67_structType;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67bSink(_OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct);\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67()\n{\n    char * data;\n    _OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    _OS_Command_Injection__char_connect_socket_execlp_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67bG2BSink(_OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct);\n\nstatic void nG2B()\n{\n    char * data;\n    _OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    myStruct.structFirst = data;\n    _OS_Command_Injection__char_connect_socket_execlp_67bG2BSink(myStruct);\n}\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_execlp_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_execlp_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244090"}
{"selection": "A.CWE-509:Replicating Malicious Code (Virus or Worm)\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-304:Missing Critical Step in Authentication", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nint dui_ganglial = 0;\ntypedef char *unresidual_outburst;\nint global_variable;\nvoid dekaliters_anthropophagy(unresidual_outburst *jagras_boroglycerine);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid racketier_rubbernecking(void (*versation_anticoagulator)(unresidual_outburst *));\nunresidual_outburst maurita_copromoted(unresidual_outburst quires_representee);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&dui_ganglial,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      racketier_rubbernecking(dekaliters_anthropophagy);\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid dekaliters_anthropophagy(unresidual_outburst *jagras_boroglycerine)\n{\n  unresidual_outburst incarcerate_overswarm = 0;\n  int macrochiran_unkeeled = 28;\n  char *storying_cesure;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&storying_cesure,\"7752\",macrochiran_unkeeled);\n  if (storying_cesure != 0) {;\n    incarcerate_overswarm = storying_cesure;\n     *jagras_boroglycerine = incarcerate_overswarm;\n  }\n}\n\nvoid racketier_rubbernecking(void (*versation_anticoagulator)(unresidual_outburst *))\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *retinerved_nations = 0;\n  unresidual_outburst preoccupies_kinds = 0;\n  ++global_variable;\n  unresidual_outburst difforme_seance = 0;\n  versation_anticoagulator(&difforme_seance);\n  if (difforme_seance != 0) {;\n    preoccupies_kinds = maurita_copromoted(difforme_seance);\n    retinerved_nations = ((char *)preoccupies_kinds);\n    \n    if (strlen(retinerved_nations) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,retinerved_nations);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n    if (preoccupies_kinds != 0) \n      free(((char *)preoccupies_kinds));\nclose_printf_context();\n  }\n}\n\nunresidual_outburst maurita_copromoted(unresidual_outburst quires_representee)\n{\n  ++global_variable;\n  return quires_representee;\n}", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152694"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-191:Integer Underflow (Wrap or Wraparound)\nC.CWE-278:Insecure Preserved Inherited Permissions\nD.CWE-593:Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint shaptin_coax = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid ixodian_adenous(char *const perau_spawny);\nint 191_global_var = 0;\n\nSize PMSignalShmemSize()\n{\n  int sesser_derp = 0;\n  char *surculi_fluty = 0;\n  char *carlsbad_tonology;\n  Size size;\n  if (__sync_bool_compare_and_swap(&shaptin_coax,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      carlsbad_tonology = getenv(\"UNDISJOINTED_ISSUE\");\n      if (carlsbad_tonology != 0) {;\n        sesser_derp = ((int )(strlen(carlsbad_tonology)));\n        surculi_fluty = ((char *)(malloc(sesser_derp + 1)));\n        if (surculi_fluty == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(surculi_fluty,0,sesser_derp + 1);\n        memcpy(surculi_fluty,carlsbad_tonology,sesser_derp);\n        ixodian_adenous(surculi_fluty);\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid ixodian_adenous(char *const perau_spawny)\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *diversity_spathe = 0;\n  int vivary_kuth;\n  int penalosa_bkpt;\n  ++global_variable;;\n  penalosa_bkpt = 5;\n  while(1 == 1){\n    penalosa_bkpt = penalosa_bkpt * 2;\n    penalosa_bkpt = penalosa_bkpt + 2;\n    if (penalosa_bkpt > 1000) {\n      break; \n    }\n  }\n  vivary_kuth = penalosa_bkpt;\n  diversity_spathe = ((char *)((char *)perau_spawny));\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(diversity_spathe, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n  if (((char *)perau_spawny) != 0) \n    free(((char *)((char *)perau_spawny)));\nclose_printf_context();\n}", "answer": "B.CWE-191:Integer Underflow (Wrap or Wraparound)|A.CWE-707:Improper Neutralization", "cwe": "191", "idx": "150733"}
{"selection": "A.CWE-560:Use of umask() with chmod-style Argument\nB.No Vulnerabilities\nC.CWE-1126:Declaration of Variable with Unnecessarily Wide Scope\nD.CWE-707:Improper Neutralization\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_15\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_15; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97712"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-472:External Control of Assumed-Immutable Web Parameter\nE.CWE-351:Insufficient Type Distinction", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123193"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.No Vulnerabilities\nC.CWE-322:Key Exchange without Entity Authentication\nD.CWE-1247:Improper Protection Against Voltage and Clock Glitches\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\ntypedef struct __External_Control_of_System_or_Configuration_Setting__w32_67_structType\n{\n    char * structFirst;\n} _External_Control_of_System_or_Configuration_Setting__w32_67_structType;\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_67bSink(_External_Control_of_System_or_Configuration_Setting__w32_67_structType myStruct);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_67()\n{\n    char * data;\n    _External_Control_of_System_or_Configuration_Setting__w32_67_structType myStruct;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myStruct.structFirst = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_67bG2BSink(_External_Control_of_System_or_Configuration_Setting__w32_67_structType myStruct);\n\nstatic void nG2B()\n{\n    char * data;\n    _External_Control_of_System_or_Configuration_Setting__w32_67_structType myStruct;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    myStruct.structFirst = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_67bG2BSink(myStruct);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|E.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82017"}
{"selection": "A.CWE-472:External Control of Assumed-Immutable Web Parameter\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1176:Inefficient CPU Computation\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_ifstream_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_ifstream_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96575"}
{"selection": "A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-804:Guessable CAPTCHA", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82\n{\n\nclass _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82 : public _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82_base\n{\npublic:\n    void action(wchar_t * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82G2B : public _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82_base\n{\npublic:\n    void action(wchar_t * data);\n};\n\n#endif \n\n}", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248672"}
{"selection": "A.CWE-662:Improper Synchronization\nB.CWE-36:Absolute Path Traversal\nC.No Vulnerabilities\nD.CWE-204:Observable Response Discrepancy\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_open_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_open_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95932"}
{"selection": "A.CWE-170:Improper Null Termination\nB.CWE-771:Missing Reference to Active Allocated Resource\nC.CWE-707:Improper Neutralization\nD.CWE-1021:Improper Restriction of Rendered UI Layers or Frames\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <unistd.h> \nint olivinefels_regis = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid subjudge_unloveliness(int foetiferous_portmanmote,void **tsadi_whitewash);\nvoid firking_cesium(int triptychs_hetairic,void **bination_neglect);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  int addi_cyclograph = 7;\n  void **fossilological_depurator = 0;\n  void *aribin_neoplatonic = 0;\n  char *wanworth_refascinate;;\n  if (__sync_bool_compare_and_swap(&olivinefels_regis,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      wanworth_refascinate = getenv(\"COUNTERROUND_GASWORKER\");\n      if (wanworth_refascinate != 0) {;\n        aribin_neoplatonic = ((void *)wanworth_refascinate);\n        fossilological_depurator = &aribin_neoplatonic;\n        subjudge_unloveliness(addi_cyclograph,fossilological_depurator);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid subjudge_unloveliness(int foetiferous_portmanmote,void **tsadi_whitewash)\n{\n int oc_i = 0;\n int buf_ptr_len;\n char *new_input = \"new test input\";\n const int MAXLEN = 16;\n  char *glaucus_unwitherable = 0;\n  ++global_variable;\n  foetiferous_portmanmote--;\n  if (foetiferous_portmanmote > 0) {\n    firking_cesium(foetiferous_portmanmote,tsadi_whitewash);\n    return ;\n  }\n  glaucus_unwitherable = ((char *)((char *)( *tsadi_whitewash)));\n    \n int file_desc;\n char input_buf[MAXLEN];\n char **buf_ptr = 0;\n char *path_buf = 0;\n path_buf = malloc(sizeof(char ) * 64);\n    if (path_buf == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    buf_ptr = malloc(sizeof(char *));\n    if (buf_ptr == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    *buf_ptr = path_buf;\n    memset(input_buf,0,16);\n    memset(path_buf,'a',64);\n    path_buf[63] = 0;\n    file_desc = open(glaucus_unwitherable,0);\n    if (file_desc > -1) {\n        read(file_desc,input_buf,MAXLEN);\n        close(file_desc);\n        \n  \n        strncpy(path_buf,input_buf,MAXLEN);\n        \n        \n  \n        strcat(path_buf,new_input);\n        buf_ptr_len = strlen( *buf_ptr);\n        for (; oc_i < buf_ptr_len; ++oc_i) {\n   path_buf[oc_i] = toupper(path_buf[oc_i]);\n        }\n        \n        printf(\"%s\\n\",path_buf);\n        \n    }\n    if (path_buf != 0) {\n        free(path_buf);\n    }\n    if (buf_ptr != 0) {\n        free(buf_ptr);\n    }\n;\nclose_printf_context();\n}\n\nvoid firking_cesium(int triptychs_hetairic,void **bination_neglect)\n{\n  ++global_variable;\n  subjudge_unloveliness(triptychs_hetairic,bination_neglect);\n}", "answer": "A.CWE-170:Improper Null Termination|C.CWE-707:Improper Neutralization", "cwe": "170", "idx": "153191"}
{"selection": "A.CWE-770:Allocation of Resources Without Limits or Throttling\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-326:Inadequate Encryption Strength", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_51bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_file_51()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_51bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_51bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123260"}
{"selection": "A.CWE-483:Incorrect Block Delimitation\nB.CWE-342:Predictable Exact Value from Previous Values\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint cowperian_illumines = 0;\nint global_variable;\nvoid stative_bekha(void **restruck_omentoplasty);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid synchronous_comicality(void (*owens_cerevis)(void **));\nvoid propacifism_proletaries(void *const palar_unstuffily);\nint 191_global_var = 0;\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&cowperian_illumines,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      synchronous_comicality(stative_bekha);\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid stative_bekha(void **restruck_omentoplasty)\n{\n  void *rhizostomata_waterstoup = 0;\n  char *ectostosis_belugite;\n  ++global_variable;;\n  setup_printf_context();\n  ectostosis_belugite = getenv(\"UNNECTARIAL_TURBOCHARGER\");\n  if (ectostosis_belugite != 0) {;\n    rhizostomata_waterstoup = ((void *)ectostosis_belugite);\n     *restruck_omentoplasty = rhizostomata_waterstoup;\n  }\n}\n\nvoid synchronous_comicality(void (*owens_cerevis)(void **))\n{\n  ++global_variable;\n  void *consentingly_bonkers = 0;\n  owens_cerevis(&consentingly_bonkers);\n  if (((char *)consentingly_bonkers) != 0) {;\n    propacifism_proletaries(consentingly_bonkers);\n  }\n}\n\nvoid propacifism_proletaries(void *const palar_unstuffily)\n{\n        char buff[128];\n        short max_size = 128;\n        short remaining_space = 0;\n        int size = 0;\n        FILE * file = 0;\n  char *unpromise_broderic = 0;\n  ++global_variable;;\n  unpromise_broderic = ((char *)((char *)((void *)palar_unstuffily)));\n        \n        file = fopen(unpromise_broderic, \"r\");\n        if(file != NULL){\n                fseek(file, 0, SEEK_END);\n                size = ftell(file);\n                fseek(file, 0, SEEK_SET);\n                \n                \n                remaining_space = max_size - size;\n                \n                \n                \n                \n                if(remaining_space > 0){\n                        fscanf(file, \"%s\", buff);\n                        printf(\"Contents of file: %s\\n\", buff);\n                }\n                \n                fclose(file);\n        }\n        \n;\nclose_printf_context();\n}", "answer": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|D.CWE-707:Improper Neutralization", "cwe": "191", "idx": "151047"}
{"selection": "A.CWE-498:Cloneable Class Containing Sensitive Information\nB.CWE-1125:Excessive Attack Surface\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89589"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-1125:Excessive Attack Surface\nD.CWE-1053:Missing Documentation for Design\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_environment_63bSink(char * * dataPtr);\n\nvoid _LDAP_Injection__w32_char_environment_63()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_char_environment_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_environment_63bG2BSink(char * * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_environment_63bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_char_environment_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122978"}
{"selection": "A.No Vulnerabilities\nB.CWE-568:finalize() Method Without super.finalize()\nC.CWE-396:Declaration of Catch for Generic Exception\nD.CWE-36:Absolute Path Traversal\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n#include <list>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_file_w32CreateFile_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_w32CreateFile_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96492"}
{"selection": "A.CWE-243:Creation of chroot Jail Without Changing Working Directory\nB.CWE-15:External Control of System or Configuration Setting\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-270:Privilege Context Switching Error", "code": "#include \"std_testcase.h\"\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_84\n{\n\n#ifndef OMITM\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_84\n{\npublic:\n    _External_Control_of_System_or_Configuration_Setting__w32_84(char * dataCopy);\n    ~_External_Control_of_System_or_Configuration_Setting__w32_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_84G2B\n{\npublic:\n    _External_Control_of_System_or_Configuration_Setting__w32_84G2B(char * dataCopy);\n    ~_External_Control_of_System_or_Configuration_Setting__w32_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "B.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82025"}
{"selection": "A.CWE-911:Improper Update of Reference Count\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-348:Use of Less Trusted Source", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n\nstatic int staticFive = 5;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_spawnlp_07()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_spawnlp_07()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_spawnlp_07();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_spawnlp_07();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245233"}
{"selection": "A.No Vulnerabilities\nB.CWE-23:Relative Path Traversal\nC.CWE-707:Improper Neutralization\nD.CWE-1279:Cryptographic Operations are run Before Supporting Units are Ready\nE.CWE-759:Use of a One-Way Hash without a Salt", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\nnamespace _Relative_Path_Traversal__char_listen_socket_w32CreateFile_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_w32CreateFile_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90741"}
{"selection": "A.No Vulnerabilities\nB.CWE-1244:Internal Asset Exposed to Unsafe Debug Access Level or State\nC.CWE-707:Improper Neutralization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-749:Exposed Dangerous Method or Function", "code": "#include \"std_testcase.h\"\n#include <vector>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _LDAP_Injection__w32_wchar_t_file_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<wchar_t *> dataVector);\n\nvoid m()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<wchar_t *> dataVector);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_file_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123272"}
{"selection": "A.CWE-1419:Incorrect Initialization of Resource\nB.CWE-707:Improper Neutralization\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-502:Deserialization of Untrusted Data\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define SYSTEM _wsystem\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_file_system_63bSink(wchar_t * * dataPtr);\n\nvoid _OS_Command_Injection__wchar_t_file_system_63()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _OS_Command_Injection__wchar_t_file_system_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_file_system_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_file_system_63bG2BSink(&data);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_system_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_system_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_system_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247954"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-804:Guessable CAPTCHA\nC.CWE-354:Improper Validation of Integrity Check Value\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint ammiolite_mirthsomeness = 0;\nint global_variable;\ntypedef char *unfrictional_swahili;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid calmnesses_mythopoet(int nephrotyphus_atalya,unfrictional_swahili tectocephalic_prebronchial);\nvoid butterback_amalgamations(int neapolitans_counterflashing,unfrictional_swahili palaeobotanist_rhianna);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int sleyed_rosillo = 7;\n  unfrictional_swahili untractarian_archegone = 0;\n  int *presuccessful_philomel = 0;\n  int penality_amarynceus;\n  unfrictional_swahili moralioralist_bieennia[10] = {0};\n  unfrictional_swahili carryalls_rixatrix = 0;\n  int polemicize_nonorientation = 28;\n  char *yerbal_praefectus;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&ammiolite_mirthsomeness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&yerbal_praefectus,\"1848\",polemicize_nonorientation);\n      if (yerbal_praefectus != 0) {;\n        carryalls_rixatrix = yerbal_praefectus;\n        moralioralist_bieennia[5] = carryalls_rixatrix;\n        penality_amarynceus = 5;\n        presuccessful_philomel = &penality_amarynceus;\n        untractarian_archegone =  *(moralioralist_bieennia +  *presuccessful_philomel);\n        calmnesses_mythopoet(sleyed_rosillo,untractarian_archegone);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid calmnesses_mythopoet(int nephrotyphus_atalya,unfrictional_swahili tectocephalic_prebronchial)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *lazurites_suppos = 0;\n  ++global_variable;\n  nephrotyphus_atalya--;\n  if (nephrotyphus_atalya > 0) {\n    butterback_amalgamations(nephrotyphus_atalya,tectocephalic_prebronchial);\n    return ;\n  }\n  lazurites_suppos = ((char *)tectocephalic_prebronchial);\n    \n    if (strlen(lazurites_suppos) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,lazurites_suppos);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n  if (tectocephalic_prebronchial != 0) \n    free(((char *)tectocephalic_prebronchial));\nclose_printf_context();\n}\n\nvoid butterback_amalgamations(int neapolitans_counterflashing,unfrictional_swahili palaeobotanist_rhianna)\n{\n  ++global_variable;\n  calmnesses_mythopoet(neapolitans_counterflashing,palaeobotanist_rhianna);\n}", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152777"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-273:Improper Check for Dropped Privileges\nE.CWE-669:Incorrect Resource Transfer Between Spheres", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_63bSink(wchar_t * * dataPtr);\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_63()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_wchar_t_connect_socket_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_63bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123122"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-707:Improper Neutralization\nE.CWE-459:Incomplete Cleanup", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_54bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82010"}
{"selection": "A.No Vulnerabilities\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.CWE-114:Process Control\nD.CWE-862:Missing Authorization\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _Process_Control__w32_wchar_t_console_34_unionType;\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_console_34()\n{\n    wchar_t * data;\n    _Process_Control__w32_wchar_t_console_34_unionType myUnion;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _Process_Control__w32_wchar_t_console_34_unionType myUnion;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_console_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_console_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_console_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|E.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62299"}
{"selection": "A.CWE-553:Command Shell in Externally Accessible Directory\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-15:External Control of System or Configuration Setting\nE.CWE-583:finalize() Method Declared Public", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_02()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-15:External Control of System or Configuration Setting|C.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81979"}
{"selection": "A.CWE-1095:Loop Condition Value Update within the Loop\nB.CWE-419:Unprotected Primary Channel\nC.CWE-36:Absolute Path Traversal\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Absolute_Path_Traversal__char_environment_ifstream_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_ifstream_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96073"}
{"selection": "A.No Vulnerabilities\nB.CWE-911:Improper Update of Reference Count\nC.CWE-707:Improper Neutralization\nD.CWE-576:EJB Bad Practices: Use of Java I/O\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n#include <vector>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_ofstream_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<char *> dataVector);\n\nvoid m()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<char *> dataVector);\n\nstatic void nG2B()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_ofstream_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96635"}
{"selection": "A.CWE-767:Access to Critical Private Variable via Public Method\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1252:CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECV _execv\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_w32_execv_51bSink(char * data);\n\nvoid _OS_Command_Injection__char_environment_w32_execv_51()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__char_environment_w32_execv_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_w32_execv_51bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_environment_w32_execv_51bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execv_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execv_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execv_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245160"}
{"selection": "A.CWE-670:Always-Incorrect Control Flow Implementation\nB.No Vulnerabilities\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-546:Suspicious Comment", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_console_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcat(data, \"Doe, XXXXX\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_console_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122921"}
{"selection": "A.No Vulnerabilities\nB.CWE-1115:Source Code Element without Standard Prologue\nC.CWE-233:Improper Handling of Parameters\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-459:Incomplete Cleanup", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <unistd.h> \n#include <sys/stat.h> \nint erythropoiesis_olivile = 0;\ntypedef char *beelzebub_rufflers;\nint global_variable;\nvoid handle_taint(char *lanolines_proclivitous);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid thalia_machi(int rpo_nearing,... );\nvoid disappointment_vidry(beelzebub_rufflers unstacker_neptunism);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&erythropoiesis_olivile,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *lanolines_proclivitous)\n{\n  beelzebub_rufflers southness_bas = 0;\n  ++global_variable;;\n  if (lanolines_proclivitous != 0) {;\n    southness_bas = lanolines_proclivitous;\n    thalia_machi(1,southness_bas);\n  }\n}\n\nvoid thalia_machi(int rpo_nearing,... )\n{\n  void (*antefuture_commentator)(beelzebub_rufflers ) = disappointment_vidry;\n  beelzebub_rufflers vocate_coreligionist = 0;\n  va_list mooruk_zulu;\n  ++global_variable;;\n  if (rpo_nearing > 0) {\n    __builtin_va_start(mooruk_zulu,rpo_nearing);\n    vocate_coreligionist = (va_arg(mooruk_zulu,beelzebub_rufflers ));\n    __builtin_va_end(mooruk_zulu);\n  }\n  antefuture_commentator(vocate_coreligionist);\n}\n\nvoid disappointment_vidry(beelzebub_rufflers unstacker_neptunism)\n{\n int random_data;\n char fill_buff[50000];\n char file_path[50][31];\n int filedes;\n int count = 0;\n int taint_num;\n int ss_i = 0;\n  char *orna_wherehence = 0;\n  ++global_variable;;\n  orna_wherehence = ((char *)unstacker_neptunism);\n    \n random_data = open(\"/dev/urandom\",0);\n    read(random_data,fill_buff,49999U);\n    close(random_data);\n    fill_buff[49999] = '\\0';\n    taint_num = atoi(orna_wherehence);\n    if (taint_num < 0) {\n        taint_num = 0;\n    }\n    \n    for (ss_i = 0; ss_i < taint_num; ++ss_i) {\n        ++count;\n        strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\n        filedes = mkstemp(file_path[ss_i % 50]);\n        write(filedes,fill_buff,sizeof(fill_buff));\n        close(filedes);\n    }\n    \n    \n    for (ss_i = 0; ss_i < 50; ++ss_i){\n  \n        if (count == ss_i) {\n            break;\n        }\n  \n        unlink(file_path[ss_i]);\n    }\n    \n    \n    \n;\n  if (unstacker_neptunism != 0) \n    free(((char *)unstacker_neptunism));\nclose_printf_context();\n}", "answer": "E.CWE-459:Incomplete Cleanup|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "459", "idx": "151883"}
{"selection": "A.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\nB.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-663:Use of a Non-reentrant Function in a Concurrent Context", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint lovelass_xanthocyanopsy = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid periosteal_noncorporative(char *bushbody_cocopans);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n#define HONEYMOONSHINE_BLABBED(x) periosteal_noncorporative((char *) x)\n\nint timestamp_get_precision()\n{\n  char *clapper_tenography = 0;\n  long bayreuth_induvial[10];\n  char *formations_skiv[10] = {0};\n  char *geraniaceous_exomphalous;;\n  if (__sync_bool_compare_and_swap(&lovelass_xanthocyanopsy,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&geraniaceous_exomphalous,\"LOOKING_FACHINI\");\n      if (geraniaceous_exomphalous != 0) {;\n        formations_skiv[5] = geraniaceous_exomphalous;\n        bayreuth_induvial[1] = 5;\n        clapper_tenography =  *(formations_skiv + bayreuth_induvial[1]);\n\tHONEYMOONSHINE_BLABBED(clapper_tenography);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid periosteal_noncorporative(char *bushbody_cocopans)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *turgescent_nonvindication = 0;\n  ++global_variable;;\n  turgescent_nonvindication = ((char *)bushbody_cocopans);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(turgescent_nonvindication)+ 1));\n        if (cusData->data &&\n            (sscanf(turgescent_nonvindication, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if (bushbody_cocopans != 0) \n    free(((char *)bushbody_cocopans));\nclose_printf_context();\n}", "answer": "E.CWE-663:Use of a Non-reentrant Function in a Concurrent Context|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "663", "idx": "150170"}
{"selection": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-599:Missing Validation of OpenSSL Certificate\nE.CWE-246:J2EE Bad Practices: Direct Use of Sockets", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint stray_underplain = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid carnegiea_representee(int unakites_proglottides,... );\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  void *indignation_cristina = 0;\n  char *substantialized_gripers;;\n  if (__sync_bool_compare_and_swap(&stray_underplain,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&substantialized_gripers,\"VILITY_MARCHAL\");\n      if (substantialized_gripers != 0) {;\n        indignation_cristina = ((void *)substantialized_gripers);\n        carnegiea_representee(1,indignation_cristina);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid carnegiea_representee(int unakites_proglottides,... )\n{\n    int i = 0;\n    int buff_size = 63;\n    int taint_len;\n    char *heap_buff_64 = 0;\n  char *spongins_electrotypic = 0;\n  void *sandan_attainableness = 0;\n  va_list germanophilist_dipsomaniac;\n  ++global_variable;;\n  if (unakites_proglottides > 0) {\n    __builtin_va_start(germanophilist_dipsomaniac,unakites_proglottides);\n    sandan_attainableness = (va_arg(germanophilist_dipsomaniac,void *));\n    __builtin_va_end(germanophilist_dipsomaniac);\n  }\n  spongins_electrotypic = ((char *)((char *)sandan_attainableness));\n    \n    \n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64, 'A' ,64);\n        heap_buff_64[64 - 1] = '\\0';\n        \n        \n        \n        taint_len = ((int )(strlen(spongins_electrotypic)));\n        for (; taint_len >= 0; (--buff_size , --taint_len)) {\n    \n    \n            heap_buff_64[buff_size] = spongins_electrotypic[taint_len];\n        }\n        \n        for (; i < 64; ++i) {\n            heap_buff_64[i] = toupper(heap_buff_64[i]);\n        }\n        \n        \n        printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\n        free(heap_buff_64);\n        \n        \n        \n    }\n;\n  if (((char *)sandan_attainableness) != 0) \n    free(((char *)((char *)sandan_attainableness)));\nclose_printf_context();\n}", "answer": "A.CWE-124:Buffer Underwrite ('Buffer Underflow')|B.CWE-707:Improper Neutralization", "cwe": "124", "idx": "153809"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nC.CWE-1249:Application-Level Admin Tool with Inconsistent View of Underlying Operating System\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n#define EXECV _execv\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_w32_execv_31()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECV(COMMAND_INT_PATH, args);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECV(COMMAND_INT_PATH, args);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_execv_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_execv_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_execv_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246095"}
{"selection": "A.No Vulnerabilities\nB.CWE-909:Missing Initialization of Resource\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-1062:Parent Class with References to Child Class\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_02()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122848"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-535:Exposure of Information Through Shell Error Message\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.No Vulnerabilities\nE.CWE-326:Inadequate Encryption Strength", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_file_w32_spawnv_06()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_file_w32_spawnv_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_w32_spawnv_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_w32_spawnv_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248112"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-584:Return Inside Finally Block\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1221:Incorrect Register Defaults or Module Parameters", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_ofstream_15\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcat(data, \"file.txt\");\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcat(data, \"file.txt\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_ofstream_15; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90170"}
{"selection": "A.CWE-342:Predictable Exact Value from Previous Values\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-426:Untrusted Search Path\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_environment_54bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_environment_54()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_environment_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_environment_54bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_environment_54bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123215"}
{"selection": "A.CWE-477:Use of Obsolete Function\nB.CWE-826:Premature Release of Resource During Expected Lifetime\nC.No Vulnerabilities\nD.CWE-23:Relative Path Traversal\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_31\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HANDLE hFile;\n            \n            hFile = CreateFileA(data,\n                                (GENERIC_WRITE|GENERIC_READ),\n                                0,\n                                NULL,\n                                OPEN_ALWAYS,\n                                FILE_ATTRIBUTE_NORMAL,\n                                NULL);\n            if (hFile != INVALID_HANDLE_VALUE)\n            {\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HANDLE hFile;\n            \n            hFile = CreateFileA(data,\n                                (GENERIC_WRITE|GENERIC_READ),\n                                0,\n                                NULL,\n                                OPEN_ALWAYS,\n                                FILE_ATTRIBUTE_NORMAL,\n                                NULL);\n            if (hFile != INVALID_HANDLE_VALUE)\n            {\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_31; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89792"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-707:Improper Neutralization\nC.CWE-309:Use of Password System for Primary Authentication\nD.CWE-267:Privilege Defined With Unsafe Actions\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\n\nstatic int staticFive = 5;\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_fopen_07\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_fopen_07; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97464"}
{"selection": "A.CWE-1113:Inappropriate Comment Style\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-570:Expression is Always False\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _LDAP_Injection__w32_wchar_t_listen_socket_34_unionType;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_34()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123302"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-300:Channel Accessible by Non-Endpoint\nC.No Vulnerabilities\nD.CWE-1259:Improper Restriction of Security Token Assignment\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic char * mSource(char * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _LDAP_Injection__w32_char_file_21()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic char * nG2B1Source(char * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic char * nG2B2Source(char * data)\n{\n    if(nG2B2Static)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123009"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-191:Integer Underflow (Wrap or Wraparound)\nD.CWE-294:Authentication Bypass by Capture-replay\nE.CWE-337:Predictable Seed in Pseudo-Random Number Generator (PRNG)", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint unbreeching_pudibundity = 0;\nint global_variable;\nvoid edeagra_formalization(char **fashious_semichannel);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid microchaeta_gemmules(void (*marinna_preprovoking)(char **));\nint 191_global_var = 0;\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&unbreeching_pudibundity,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      microchaeta_gemmules(edeagra_formalization);\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid edeagra_formalization(char **fashious_semichannel)\n{\n  char *amidocyanogen_clontarf;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&amidocyanogen_clontarf,\"DIVULSING_IRIDOMOTOR\");\n  if (amidocyanogen_clontarf != 0) {;\n     *fashious_semichannel = amidocyanogen_clontarf;\n  }\n}\n\nvoid microchaeta_gemmules(void (*marinna_preprovoking)(char **))\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *husk_arage = 0;\n  char *neffy_downey[92] = {0};\n  char *nestlers_verdure = 0;\n  int *belgrade_propheticality = 0;\n  int tubig_dispar;\n  char *goodyear_prothonotaries[10] = {0};\n  ++global_variable;\n  char *didelphous_easel = 0;\n  marinna_preprovoking(&didelphous_easel);\n  if (didelphous_easel != 0) {;\n    goodyear_prothonotaries[5] = didelphous_easel;\n    tubig_dispar = 5;\n    belgrade_propheticality = &tubig_dispar;\n    nestlers_verdure =  *(goodyear_prothonotaries +  *belgrade_propheticality);\n    neffy_downey[47] = nestlers_verdure;\n    husk_arage = ((char *)neffy_downey[47]);\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(husk_arage, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n    if (neffy_downey[47] != 0) \n      free(((char *)neffy_downey[47]));\nclose_printf_context();\n  }\n}", "answer": "C.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-707:Improper Neutralization", "cwe": "191", "idx": "150957"}
{"selection": "A.CWE-325:Missing Cryptographic Step\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-612:Improper Authorization of Index Containing Sensitive Information", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_connect_socket_16()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_connect_socket_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_connect_socket_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_connect_socket_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62243"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-36:Absolute Path Traversal\nC.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nD.No Vulnerabilities\nE.CWE-430:Deployment of Wrong Handler", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_43\n{\n\n#ifndef OMITM\n\nvoid mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95996"}
{"selection": "A.CWE-288:Authentication Bypass Using an Alternate Path or Channel\nB.CWE-334:Small Space of Random Values\nC.CWE-23:Relative Path Traversal\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_console_ifstream_02\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_ifstream_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89869"}
{"selection": "A.CWE-496:Public Data Assigned to Private Array-Typed Field\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1059:Insufficient Technical Documentation\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_02\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96739"}
{"selection": "A.CWE-649:Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-207:Observable Behavioral Discrepancy With Equivalent Products", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_42()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic wchar_t * nG2BSource(wchar_t * data)\n{\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_42()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_42();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_42();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123304"}
{"selection": "A.CWE-1075:Unconditional Control Flow Transfer outside of Switch Block\nB.CWE-293:Using Referer Field for Authentication\nC.No Vulnerabilities\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_file_execl_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_execl_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_execl_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_execl_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247789"}
{"selection": "A.No Vulnerabilities\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-1025:Comparison Using Wrong Factors\nD.CWE-707:Improper Neutralization\nE.CWE-1233:Security-Sensitive Hardware Controls with Missing Lock Bit Protection", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nstatic void mSink(char * data)\n{\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_44()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(char * data)\n{\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    funcPtr(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82005"}
{"selection": "A.CWE-1117:Callable with Insufficient Behavioral Summary\nB.CWE-707:Improper Neutralization\nC.CWE-284:Improper Access Control\nD.No Vulnerabilities\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_11()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81988"}
{"selection": "A.CWE-1106:Insufficient Use of Symbolic Constants\nB.CWE-190:Integer Overflow or Wraparound\nC.CWE-707:Improper Neutralization\nD.CWE-1327:Binding to an Unrestricted IP Address\nE.No Vulnerabilities", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint devexity_strut = 0;\nint global_variable;\n\nstruct snugly_amplifiable \n{\n  char *bechern_natron;\n  double silkworker_tophes;\n  char *nondecaying_inhuman;\n  char uncravatted_outrun;\n  int monads_masterwort;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid pretersensual_bullnecked(struct snugly_amplifiable *austrian_valer);\nint 190_global_var = 0;\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  void (*hurrer_reason)(struct snugly_amplifiable *) = pretersensual_bullnecked;\n  struct snugly_amplifiable *stagnate_countersunken = {0};\n  struct snugly_amplifiable maam_scorifying;\n  char *possessiones_unconvictive;;\n  if (__sync_bool_compare_and_swap(&devexity_strut,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      possessiones_unconvictive = getenv(\"FROWST_DEFINED\");\n      if (possessiones_unconvictive != 0) {;\n        maam_scorifying . bechern_natron = ((char *)possessiones_unconvictive);\n        stagnate_countersunken = &maam_scorifying;\n        hurrer_reason(stagnate_countersunken);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid pretersensual_bullnecked(struct snugly_amplifiable *austrian_valer)\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *appalachians_unflappably = 0;\n  ++global_variable;;\n  appalachians_unflappably = ((char *)( *austrian_valer) . bechern_natron);\n    \n    tainted_int = atoi(appalachians_unflappably);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n}", "answer": "B.CWE-190:Integer Overflow or Wraparound|C.CWE-707:Improper Neutralization", "cwe": "190", "idx": "150929"}
{"selection": "A.No Vulnerabilities\nB.CWE-343:Predictable Value Range from Previous Values\nC.CWE-707:Improper Neutralization\nD.CWE-447:Unimplemented or Unsupported Feature in UI\nE.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint corojo_physicist = 0;\nint global_variable;\n\nunion amphipyrenin_winthrop \n{\n  char *tenderish_recarbon;\n  double squatting_holds;\n  char *letterman_ulnage;\n  char ectopistes_catamiting;\n  int kolhoz_vire;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized);\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless);\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie);\nint toupper(int c) {\n    if (c >= 97 && c <= 122) {\n        return c - 32;\n    }\n    return c;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  union amphipyrenin_winthrop beaners_thickbrained;\n  int sieracki_zebec = 1001;\n  char *methodism_boogers;;\n  if (__sync_bool_compare_and_swap(&corojo_physicist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&methodism_boogers,\"5759\",sieracki_zebec);\n      if (methodism_boogers != 0) {;\n        beaners_thickbrained . tenderish_recarbon = methodism_boogers;\n        chaffinch_preventuring(beaners_thickbrained);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized)\n{\n  int surefooted_antonomastic = 7;\n  ++global_variable;;\n  cento_waterhorse(surefooted_antonomastic,cognizes_abolitionized);\n}\n\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless)\n{\n    int oc_i = 0;\n char stack_buffer_64[64];\n  char *sulfato_minipanic = 0;\n  ++global_variable;\n  cicatrices_pyridazine--;\n  if (cicatrices_pyridazine > 0) {\n    dictyopteran_guttering(cicatrices_pyridazine,slappers_fibreless);\n    return ;\n  }\n  sulfato_minipanic = ((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon);\n    \n memset(stack_buffer_64,0,64);\n    \n    \n    \n    \n \n strcpy(stack_buffer_64,sulfato_minipanic);\n    \n    \n    \n    for (; oc_i < 64; ++oc_i) {\n        stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\n    }\n    \n    \n printf(\"%s\\n\",stack_buffer_64);\n    \n    \n    \n    \n;\n  if (((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon != 0) \n    free(((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon));\nclose_printf_context();\n}\n\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie)\n{\n  ++global_variable;\n  cento_waterhorse(sympossia_criophorus,sardoin_malanie);\n}", "answer": "E.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|C.CWE-707:Improper Neutralization", "cwe": "120", "idx": "153715"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-472:External Control of Assumed-Immutable Web Parameter\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-921:Storage of Sensitive Data in a Mechanism without Access Control", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        \n        strcpy(data, \"hostname\");\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|A.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81999"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-499:Serializable Class Containing Sensitive Data\nC.CWE-707:Improper Neutralization\nD.CWE-662:Improper Synchronization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_environment_popen_13()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_popen_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_popen_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_popen_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247415"}
{"selection": "A.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nB.No Vulnerabilities\nC.CWE-420:Unprotected Alternate Channel\nD.CWE-1095:Loop Condition Value Update within the Loop\nE.CWE-664:Improper Control of a Resource Through its Lifetime", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <stdlib.h> \n#include <stdio.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <errno.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint thirtyfold_pneumonocele = 0;\nint global_variable;\nvoid handle_taint(char *dictatorialism_sphagnales);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&thirtyfold_pneumonocele,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *dictatorialism_sphagnales)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *sulphinyl_hemostats = 0;\n  jmp_buf unmuzzled_alby;\n  int druci_haplolaly;\n  char **phosphoresce_hubie = 0;\n  int naveness_cerusites = 0;\n  char *gastroepiploic_dynametric = 0;\n  ++global_variable;;\n  if (dictatorialism_sphagnales != 0) {;\n    naveness_cerusites = ((int )(strlen(dictatorialism_sphagnales)));\n    gastroepiploic_dynametric = ((char *)(malloc(naveness_cerusites + 1)));\n    if (gastroepiploic_dynametric == 0) {\n      printf(\"Error: Failed to allocate memory\\n\");\n      exit(1);\n    }\n    memset(gastroepiploic_dynametric,0,naveness_cerusites + 1);\n    memcpy(gastroepiploic_dynametric,dictatorialism_sphagnales,naveness_cerusites);\n    if (dictatorialism_sphagnales != 0) \n      free(((char *)dictatorialism_sphagnales));\n    phosphoresce_hubie = &gastroepiploic_dynametric;\n    druci_haplolaly = setjmp(unmuzzled_alby);\n    if (druci_haplolaly == 0) {\n      longjmp(unmuzzled_alby,1);\n    }\n    sulphinyl_hemostats = ((char *)( *phosphoresce_hubie));\n    \n files = fopen(sulphinyl_hemostats,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n    if ( *phosphoresce_hubie != 0) \n      free(((char *)( *phosphoresce_hubie)));\nclose_printf_context();\n  }\n}", "answer": "A.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "775", "idx": "151926"}
{"selection": "A.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\nB.CWE-550:Server-generated Error Message Containing Sensitive Information\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_05\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_05; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96790"}
{"selection": "A.CWE-262:Not Using Password Aging\nB.No Vulnerabilities\nC.CWE-272:Least Privilege Violation\nD.CWE-707:Improper Neutralization\nE.CWE-682:Incorrect Calculation", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint siderated_byssaceous = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct struct {\n    void (*function_ptr_1)();\n    unsigned int input_num;\n    void (*function_ptr_2)();\n};\nvoid function() {\n    \n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned int *ptr = 0;\n    struct struct ssS;\n  char *cockney_disrates = 0;\n  jmp_buf sminthian_eurymus;\n  int grippiest_abeu;\n  char **gumptions_misween = 0;\n  char **tualatin_nonthinker = 0;\n  char *hirer_turbination[47] = {0};\n  int stinkard_elritch = 7;\n  char *surrealist_offtake;;\n  if (__sync_bool_compare_and_swap(&siderated_byssaceous,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&surrealist_offtake,\"2886\",stinkard_elritch);\n      if (surrealist_offtake != 0) {;\n        hirer_turbination[18] = surrealist_offtake;\n        gumptions_misween = hirer_turbination;\n        tualatin_nonthinker = gumptions_misween + 5;\n        grippiest_abeu = setjmp(sminthian_eurymus);\n        if (grippiest_abeu == 0) {\n          longjmp(sminthian_eurymus,1);\n        }\n        cockney_disrates = ((char *)(tualatin_nonthinker - 5)[18]);\n    \n    ssS.function_ptr_1 = function;\n    ssS.function_ptr_2 = function;\n    if (strlen(cockney_disrates) >= 1 &&\n            cockney_disrates[0] != '-') {\n        ssS.input_num = strtoul(cockney_disrates,0U,16);\n        ptr = &(ssS.input_num);\n        if ( *ptr > 65535) {\n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n        }\n        \n        \n        ssS.function_ptr_2();\n        \n        printf(\"Value = %i\\n\", ssS.input_num);\n    } else if (strlen(cockney_disrates) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n        if ((tualatin_nonthinker - 5)[18] != 0) \n          free(((char *)(tualatin_nonthinker - 5)[18]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "E.CWE-682:Incorrect Calculation|D.CWE-707:Improper Neutralization", "cwe": "682", "idx": "151223"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-520:.NET Misconfiguration: Use of Impersonation\nC.CWE-221:Information Loss or Omission\nD.CWE-15:External Control of System or Configuration Setting\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_16()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcpy(data, \"hostname\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-15:External Control of System or Configuration Setting|A.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81993"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-804:Guessable CAPTCHA\nC.CWE-23:Relative Path Traversal\nD.CWE-1263:Improper Physical Access Control\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_open_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, wchar_t *> dataMap);\n\nvoid m()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, wchar_t *> dataMap);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_open_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91687"}
{"selection": "A.No Vulnerabilities\nB.CWE-151:Improper Neutralization of Comment Delimiters\nC.CWE-166:Improper Handling of Missing Special Element\nD.CWE-691:Insufficient Control Flow Management\nE.CWE-674:Uncontrolled Recursion", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint vicaire_passed = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid gwelo_squelches(char *nabcheat_unregenerated);\nvoid aedicule_undeniable(char *aldoxime_speckfall);\nvoid charade_mitchiner(char *sylleptically_noonstead);\nvoid octans_bespattered(char *cruiskeen_diduce);\nvoid ulcerated_nokesville(char *cam_lotis);\nvoid arrowroot_pentecostarion(char *hales_geraldine);\nvoid ambitionless_unshadow(char *cryptomnesic_sorptions);\nvoid teneral_dumbfounderment(char *bronchotomy_halvahs);\nvoid chevise_postparotid(char *steepdown_scratchy);\nvoid obtrusionist_contrastingly(char *beady_predevelop);\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nunsigned int avdevice_version()\n{\n  char *berliner_tristate = 0;\n  int *bringela_overcare = 0;\n  int unkindest_sportly;\n  char *peopled_lewiston[10] = {0};\n  int acecaffine_sheldfowl = 0;\n  char *zaramo_obviations = 0;\n  int seaworn_bertolde = 31;\n  char *needlebill_nondevoutly;;\n  if (__sync_bool_compare_and_swap(&vicaire_passed,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&needlebill_nondevoutly,\"4236\",seaworn_bertolde);\n      if (needlebill_nondevoutly != 0) {;\n        acecaffine_sheldfowl = ((int )(strlen(needlebill_nondevoutly)));\n        zaramo_obviations = ((char *)(malloc(acecaffine_sheldfowl + 1)));\n        if (zaramo_obviations == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(zaramo_obviations,0,acecaffine_sheldfowl + 1);\n        memcpy(zaramo_obviations,needlebill_nondevoutly,acecaffine_sheldfowl);\n        if (needlebill_nondevoutly != 0) \n          free(((char *)needlebill_nondevoutly));\n        peopled_lewiston[5] = zaramo_obviations;\n        unkindest_sportly = 5;\n        bringela_overcare = &unkindest_sportly;\n        berliner_tristate =  *(peopled_lewiston +  *bringela_overcare);\n        gwelo_squelches(berliner_tristate);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid gwelo_squelches(char *nabcheat_unregenerated)\n{\n  ++global_variable;;\n  aedicule_undeniable(nabcheat_unregenerated);\n}\n\nvoid aedicule_undeniable(char *aldoxime_speckfall)\n{\n  ++global_variable;;\n  charade_mitchiner(aldoxime_speckfall);\n}\n\nvoid charade_mitchiner(char *sylleptically_noonstead)\n{\n  ++global_variable;;\n  octans_bespattered(sylleptically_noonstead);\n}\n\nvoid octans_bespattered(char *cruiskeen_diduce)\n{\n  ++global_variable;;\n  ulcerated_nokesville(cruiskeen_diduce);\n}\n\nvoid ulcerated_nokesville(char *cam_lotis)\n{\n  ++global_variable;;\n  arrowroot_pentecostarion(cam_lotis);\n}\n\nvoid arrowroot_pentecostarion(char *hales_geraldine)\n{\n  ++global_variable;;\n  ambitionless_unshadow(hales_geraldine);\n}\n\nvoid ambitionless_unshadow(char *cryptomnesic_sorptions)\n{\n  ++global_variable;;\n  teneral_dumbfounderment(cryptomnesic_sorptions);\n}\n\nvoid teneral_dumbfounderment(char *bronchotomy_halvahs)\n{\n  ++global_variable;;\n  chevise_postparotid(bronchotomy_halvahs);\n}\n\nvoid chevise_postparotid(char *steepdown_scratchy)\n{\n  ++global_variable;;\n  obtrusionist_contrastingly(steepdown_scratchy);\n}\n\nvoid obtrusionist_contrastingly(char *beady_predevelop)\n{\n int found;\n  char *sayonara_nonvocational = 0;\n  ++global_variable;;\n  sayonara_nonvocational = ((char *)beady_predevelop);\n    \n    \n    \n    found = search(&sayonara_nonvocational[1],sayonara_nonvocational[0]);\n    \n    \n    \n;\n  if (beady_predevelop != 0) \n    free(((char *)beady_predevelop));\nclose_printf_context();\n}", "answer": "E.CWE-674:Uncontrolled Recursion|D.CWE-691:Insufficient Control Flow Management", "cwe": "674", "idx": "152160"}
{"selection": "A.CWE-170:Improper Null Termination\nB.CWE-420:Unprotected Alternate Channel\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-360:Trust of System Event Data", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <mongoose.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <sys/stat.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint overnighters_catzerie = 0;\nint global_variable;\nvoid handle_taint(char *strengthless_angulose);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid lizard_timesavers(char *const scrooping_unpoise);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&overnighters_catzerie,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nvoid handle_taint(char *strengthless_angulose)\n{\n  ++global_variable;;\n  if (strengthless_angulose != 0) {;\n    lizard_timesavers(strengthless_angulose);\n  }\n}\n\nvoid lizard_timesavers(char *const scrooping_unpoise)\n{\n int oc_i = 0;\n int file_desc;\n char buffer[128];\n char input_buf[128] = {0};\n  char *untransferring_tranky = 0;\n  jmp_buf boneyards_entropy;\n  int antimellin_cardialgia;\n  ++global_variable;;\n  antimellin_cardialgia = setjmp(boneyards_entropy);\n  if (antimellin_cardialgia == 0) {\n    longjmp(boneyards_entropy,1);\n  }\n  untransferring_tranky = ((char *)((char *)scrooping_unpoise));\n \n    memset(buffer,'x',128);\n    buffer[127] = 0;\n    file_desc = open(untransferring_tranky,0);\n    if (file_desc > -1) {\n        \n  \n        read(file_desc,input_buf,128);\n        close(file_desc);\n        \n        \n  \n        strcpy(buffer,input_buf);\n        \n        for (; oc_i < strlen(buffer); ++oc_i) {\n   buffer[oc_i] = toupper(buffer[oc_i]);\n        }\n        printf(\"%s\\n\",buffer);\n        \n    }\n    \n;\n  if (((char *)scrooping_unpoise) != 0) \n    free(((char *)((char *)scrooping_unpoise)));\nclose_printf_context();\n}", "answer": "A.CWE-170:Improper Null Termination|C.CWE-707:Improper Neutralization", "cwe": "170", "idx": "153713"}
{"selection": "A.CWE-833:Deadlock\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-500:Public Static Field Not Marked Final", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint forestation_sparmannia = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *amenorrho_tragopan = 0;\n  char **gauffer_hexanchidae = 0;\n  int antigrowth_beshrewing = 0;\n  char *misers_clavis = 0;\n  int whatsoever_schoolma = 45;\n  char *deprecators_bloomery;;\n  if (__sync_bool_compare_and_swap(&forestation_sparmannia,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&deprecators_bloomery,\"3498\",whatsoever_schoolma);\n      if (deprecators_bloomery != 0) {;\n        antigrowth_beshrewing = ((int )(strlen(deprecators_bloomery)));\n        misers_clavis = ((char *)(malloc(antigrowth_beshrewing + 1)));\n        if (misers_clavis == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(misers_clavis,0,antigrowth_beshrewing + 1);\n        memcpy(misers_clavis,deprecators_bloomery,antigrowth_beshrewing);\n        if (deprecators_bloomery != 0) \n          free(((char *)deprecators_bloomery));\n        gauffer_hexanchidae = &misers_clavis;\n        if ( *gauffer_hexanchidae != 0) {\n          goto blasdell_intorsion;\n        }\n        ++global_variable;\n        blasdell_intorsion:;\n        amenorrho_tragopan = ((char *)( *gauffer_hexanchidae));\n      \n      \n\n      pFile = fopen(amenorrho_tragopan,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\n        if ( *gauffer_hexanchidae != 0) \n          free(((char *)( *gauffer_hexanchidae)));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "C.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149380"}
{"selection": "A.CWE-779:Logging of Excessive Data\nB.CWE-36:Absolute Path Traversal\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-1004:Sensitive Cookie Without 'HttpOnly' Flag", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_open_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_open_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97611"}
{"selection": "A.CWE-476:NULL Pointer Dereference\nB.CWE-420:Unprotected Alternate Channel\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-204:Observable Response Discrepancy\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint reglued_excommune = 0;\ntypedef char *gripy_gruyre;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *synapticulate_unsinfulness = 0;\n  jmp_buf restrainer_cacozyme;\n  int photomicrograph_succored;\n  gripy_gruyre *sicking_beguileful = 0;\n  gripy_gruyre bewake_ignominy = 0;\n  gripy_gruyre leucocytopenia_buchmanite = 0;\n  int unsmotherable_attempers = 66;\n  char *malanie_thomasa;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&reglued_excommune,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&malanie_thomasa,\"4610\",unsmotherable_attempers);\n      if (malanie_thomasa != 0) {;\n        leucocytopenia_buchmanite = malanie_thomasa;\n        sicking_beguileful = &leucocytopenia_buchmanite;\n        photomicrograph_succored = setjmp(restrainer_cacozyme);\n        if (photomicrograph_succored == 0) {\n          longjmp(restrainer_cacozyme,1);\n        }\n        synapticulate_unsinfulness = ((char *)( *sicking_beguileful));\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(synapticulate_unsinfulness) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (synapticulate_unsinfulness[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &synapticulate_unsinfulness[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\n        if ( *sicking_beguileful != 0) \n          free(((char *)( *sicking_beguileful)));\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}", "answer": "A.CWE-476:NULL Pointer Dereference|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149795"}
{"selection": "A.CWE-841:Improper Enforcement of Behavioral Workflow\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1117:Callable with Insufficient Behavioral Summary", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_connect_socket_w32_spawnv_82\n{\n\nclass _OS_Command_Injection__char_connect_socket_w32_spawnv_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_connect_socket_w32_spawnv_82 : public _OS_Command_Injection__char_connect_socket_w32_spawnv_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_connect_socket_w32_spawnv_82G2B : public _OS_Command_Injection__char_connect_socket_w32_spawnv_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244376"}
{"selection": "A.No Vulnerabilities\nB.CWE-36:Absolute Path Traversal\nC.CWE-1115:Source Code Element without Standard Prologue\nD.CWE-223:Omission of Security-relevant Information\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_w32CreateFile_01\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_w32CreateFile_01; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97410"}
{"selection": "A.CWE-268:Privilege Chaining\nB.CWE-472:External Control of Assumed-Immutable Web Parameter\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_console_ifstream_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_ifstream_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89877"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1125:Excessive Attack Surface\nE.CWE-1329:Reliance on Component That is Not Updateable", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_execl_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_execl_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_execl_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_execl_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248261"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-820:Missing Synchronization\nE.CWE-448:Obsolete Feature in UI", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_ifstream_31\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_ifstream_31; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95606"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-707:Improper Neutralization\nC.CWE-520:.NET Misconfiguration: Use of Impersonation\nD.No Vulnerabilities\nE.CWE-674:Uncontrolled Recursion", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _popen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_popen_06()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_popen_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_popen_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_popen_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245048"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.No Vulnerabilities\nC.CWE-1395:Dependency on Vulnerable Third-Party Component\nD.CWE-707:Improper Neutralization\nE.CWE-1046:Creation of Immutable Text Using String Concatenation", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_54bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_connect_socket_54()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_connect_socket_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_connect_socket_54bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122879"}
{"selection": "A.CWE-834:Excessive Iteration\nB.CWE-276:Incorrect Default Permissions\nC.CWE-691:Insufficient Control Flow Management\nD.CWE-564:SQL Injection: Hibernate\nE.No Vulnerabilities", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint fieldworker_shubunkin = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid prolicidal_mucocutaneous(int arabic_godded,char **contriturate_fogelsville);\nvoid feldspathic_paravauxite(int archgomeral_retrovaccinate,char **bromyrite_firming);\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  int undertow_dermohemal = 7;\n  char **unhermitically_oligopnea = 0;\n  int *exhibitionize_gondola = 0;\n  int galosh_tabebuia;\n  char **linkup_teraglin[10] = {0};\n  char *weller_cartmaker[54] = {0};\n  char *innovators_statehouse;;\n  if (__sync_bool_compare_and_swap(&fieldworker_shubunkin,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&innovators_statehouse,\"ODONTOTRIPSIS_AFTERWORT\");\n      if (innovators_statehouse != 0) {;\n        weller_cartmaker[37] = innovators_statehouse;\n        linkup_teraglin[5] = weller_cartmaker;\n        galosh_tabebuia = 5;\n        exhibitionize_gondola = &galosh_tabebuia;\n        unhermitically_oligopnea =  *(linkup_teraglin +  *exhibitionize_gondola);\n        prolicidal_mucocutaneous(undertow_dermohemal,unhermitically_oligopnea);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid prolicidal_mucocutaneous(int arabic_godded,char **contriturate_fogelsville)\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *abscissae_pugrees = 0;\n  ++global_variable;\n  arabic_godded--;\n  if (arabic_godded > 0) {\n    feldspathic_paravauxite(arabic_godded,contriturate_fogelsville);\n    return ;\n  }\n  abscissae_pugrees = ((char *)contriturate_fogelsville[37]);\n    \n    in_val = atoll(abscissae_pugrees);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (contriturate_fogelsville[37] != 0) \n    free(((char *)contriturate_fogelsville[37]));\nclose_printf_context();\n}\n\nvoid feldspathic_paravauxite(int archgomeral_retrovaccinate,char **bromyrite_firming)\n{\n  ++global_variable;\n  prolicidal_mucocutaneous(archgomeral_retrovaccinate,bromyrite_firming);\n}", "answer": "A.CWE-834:Excessive Iteration|C.CWE-691:Insufficient Control Flow Management", "cwe": "834", "idx": "151965"}
{"selection": "A.No Vulnerabilities\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-476:NULL Pointer Dereference\nD.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nE.CWE-1323:Improper Management of Sensitive Trace Data", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint gluons_bushlet = 0;\n\nunion sonsy_alocasia \n{\n  char *frenatae_eneugh;\n  double lecithins_kine;\n  char *captions_abscess;\n  char twalpennyworth_meisterstck;\n  int stupider_spleenwort;\n}\n;\nint global_variable;\nvoid handle_taint(char *adjective_diuron);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid laders_bashlyks(int brainlessness_unanalagous,union sonsy_alocasia *myatonic_ingross);\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&gluons_bushlet,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nvoid handle_taint(char *adjective_diuron)\n{\n  int disaugment_gwelo = 7;\n  int clition_mesoplanktonic;\n  union sonsy_alocasia *kinaesthetic_savors = {0};\n  union sonsy_alocasia *trustees_unentreatable = {0};\n  union sonsy_alocasia osterhus_sanidinic;\n  ++global_variable;;\n  if (adjective_diuron != 0) {;\n    osterhus_sanidinic . frenatae_eneugh = adjective_diuron;\n    clition_mesoplanktonic = 1;\n    kinaesthetic_savors = &osterhus_sanidinic;\n    trustees_unentreatable = ((union sonsy_alocasia *)(((unsigned long )kinaesthetic_savors) * clition_mesoplanktonic * clition_mesoplanktonic)) + 5;\n    laders_bashlyks(disaugment_gwelo,trustees_unentreatable);\n  }\n}\n\nvoid laders_bashlyks(int brainlessness_unanalagous,union sonsy_alocasia *myatonic_ingross)\n{\n  char *skip_malloc_buffer = 0;\n  char *spicer_insculptured = 0;\n  ++global_variable;\n  brainlessness_unanalagous--;\n  if (brainlessness_unanalagous > 0) {\n    laders_bashlyks(brainlessness_unanalagous,myatonic_ingross);\n    return ;\n  }\n  spicer_insculptured = ((char *)( *(myatonic_ingross - 5)) . frenatae_eneugh);\n      \n      \n\n      if (strlen(spicer_insculptured) < 63) {\n        skip_malloc_buffer = malloc(strlen(spicer_insculptured + 1));\n      }\n      \n      \n      \n\n      strcpy(skip_malloc_buffer,spicer_insculptured);\n      printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n      \n      if (skip_malloc_buffer != 0) {\n        free(skip_malloc_buffer);\n      }\n      \n;\n  if (( *(myatonic_ingross - 5)) . frenatae_eneugh != 0) \n    free(((char *)( *(myatonic_ingross - 5)) . frenatae_eneugh));\nclose_printf_context();\n}", "answer": "C.CWE-476:NULL Pointer Dereference|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149268"}
{"selection": "A.CWE-114:Process Control\nB.CWE-1087:Class with Virtual Method without a Virtual Destructor\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-1323:Improper Management of Sensitive Trace Data", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\nnamespace _Process_Control__w32_char_relativePath_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"winsrv.dll\");\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_relativePath_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62202"}
{"selection": "A.No Vulnerabilities\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-1058:Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element\nD.CWE-707:Improper Neutralization\nE.CWE-324:Use of a Key Past its Expiration Date", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_09()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122999"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-707:Improper Neutralization\nC.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nD.No Vulnerabilities\nE.CWE-434:Unrestricted Upload of File with Dangerous Type", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\nnamespace _OS_Command_Injection__wchar_t_console_popen_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    mSource(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    nG2BSource(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _OS_Command_Injection__wchar_t_console_popen_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246965"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-250:Execution with Unnecessary Privileges\nC.CWE-1301:Insufficient or Incomplete Data Removal within Hardware Component\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_15()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcat(data, \"Doe, XXXXX\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcat(data, \"Doe, XXXXX\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122861"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1106:Insufficient Use of Symbolic Constants\nC.No Vulnerabilities\nD.CWE-36:Absolute Path Traversal\nE.CWE-576:EJB Bad Practices: Use of Java I/O", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_16\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        break;\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n        break;\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_16; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97665"}
{"selection": "A.No Vulnerabilities\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-1119:Excessive Use of Unconditional Branching\nD.CWE-385:Covert Timing Channel\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_65bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_65()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = _External_Control_of_System_or_Configuration_Setting__w32_65bSink;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_65bG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = _External_Control_of_System_or_Configuration_Setting__w32_65bG2BSink;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    funcPtr(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_65()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_65();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_65();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-15:External Control of System or Configuration Setting|E.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82015"}
{"selection": "A.CWE-549:Missing Password Field Masking\nB.CWE-707:Improper Neutralization\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-495:Private Data Structure Returned From A Public Method", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nwchar_t * _Process_Control__w32_wchar_t_file_61bSource(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_file_61()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    data = _Process_Control__w32_wchar_t_file_61bSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * _Process_Control__w32_wchar_t_file_61bG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    data = _Process_Control__w32_wchar_t_file_61bG2BSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_61()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_61();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_61();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62405"}
{"selection": "A.No Vulnerabilities\nB.CWE-585:Empty Synchronized Block\nC.CWE-36:Absolute Path Traversal\nD.CWE-707:Improper Neutralization\nE.CWE-383:J2EE Bad Practices: Direct Use of Threads", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95759"}
{"selection": "A.CWE-114:Process Control\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-922:Insecure Storage of Sensitive Information\nE.CWE-428:Unquoted Search Path or Element", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_console_15()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_console_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_console_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_console_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62290"}
{"selection": "A.CWE-258:Empty Password in Configuration File\nB.CWE-23:Relative Path Traversal\nC.CWE-707:Improper Neutralization\nD.CWE-1122:Excessive Halstead Complexity\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticFive = 5;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_07\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_07; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91794"}
{"selection": "A.CWE-1392:Use of Default Credentials\nB.CWE-707:Improper Neutralization\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-201:Insertion of Sensitive Information Into Sent Data", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_console_01()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_console_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_console_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_console_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62276"}
{"selection": "A.No Vulnerabilities\nB.CWE-23:Relative Path Traversal\nC.CWE-1047:Modules with Circular Dependencies\nD.CWE-707:Improper Neutralization\nE.CWE-404:Improper Resource Shutdown or Release", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_listen_socket_ofstream_13\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_ofstream_13; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90648"}
{"selection": "A.CWE-8:J2EE Misconfiguration: Entity Bean Declared Remote\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-1124:Excessively Deep Nesting", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n\nstatic int staticFive = 5;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_file_w32_spawnv_07()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_file_w32_spawnv_07()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_w32_spawnv_07();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_w32_spawnv_07();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248113"}
{"selection": "A.CWE-1104:Use of Unmaintained Third Party Components\nB.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_w32CreateFile_43\n{\n\n#ifndef OMITM\n\nvoid mSource(char * &data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_w32CreateFile_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96716"}
{"selection": "A.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nB.CWE-707:Improper Neutralization\nC.CWE-1024:Comparison of Incompatible Types\nD.No Vulnerabilities\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_listen_socket_15()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_listen_socket_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_listen_socket_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_listen_socket_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62434"}
{"selection": "A.CWE-1106:Insufficient Use of Symbolic Constants\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1022:Use of Web Link to Untrusted Target with window.opener Access\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint unshored_prelawfulness = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid forehoofs_plt(char *(**haddin_upbring)[95]);\nvoid urlDecode(char *src, char *dst) {\n    char a, b;\n    while (*src) {\n        if ((*src == '%') &&\n                ((a = src[1]) && (b = src[2])) &&\n                (isxdigit(a) && isxdigit(b))) {\n            if (a >= 'a')\n                a -= 'a'-'A';\n            if (a >= 'A')\n                a -= ('A' - 10);\n            else\n                a -= '0';\n            if (b >= 'a')\n                b -= 'a'-'A';\n            if (b >= 'A')\n                b -= ('A' - 10);\n            else\n                b -= '0';\n            *dst++ = 16*a+b;\n            src+=3;\n        } else {\n            *dst++ = *src++;\n        }\n    }\n    *dst++ = '\\0';\n}\nint isValid(char *src) {\n    int i = 0;\n    while (src[i] != '\\0') {\n        if(src[i] == ';') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        else if(src[i] == '|') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        else if(src[i] == '&') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        i++;\n    }\n    return 1;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n#define PEREGRINATION_PRIDEFULLY(x) forehoofs_plt((char *(**)[95]) x)\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  char *(**aglare_coelome)[95] = 0;\n  char *(*prela_caudiform)[95] = 0;\n  char **mazing_cobwebs = 0;\n  char *preparation_flunky[95] = {0};\n  char *cisternae_etas;;\n  if (__sync_bool_compare_and_swap(&unshored_prelawfulness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&cisternae_etas,\"ERRORS_BREAKWATER\");\n      if (cisternae_etas != 0) {;\n        preparation_flunky[3] = cisternae_etas;\n        prela_caudiform = &preparation_flunky;\n        aglare_coelome = &prela_caudiform;\n\tPEREGRINATION_PRIDEFULLY(aglare_coelome);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid forehoofs_plt(char *(**haddin_upbring)[95])\n{\n    FILE *fpipe;\n    char buffer[100];\n    char *parsed_input;\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *nonsubstantival_disburthen = 0;\n  ++global_variable;;\n  nonsubstantival_disburthen = ((char *)( *( *haddin_upbring))[3]);\n    \n    if (strlen(nonsubstantival_disburthen) < 1000 - strlen(command_str)) {\n        \n        \n        \n        if (isValid(nonsubstantival_disburthen) == 1) {\n            parsed_input = malloc((strlen(nonsubstantival_disburthen)+1) * sizeof(char));\n            urlDecode(nonsubstantival_disburthen, parsed_input);\n            snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\n            \n            \n            \n            \n            fpipe = popen(command_buffer,\"r\");\n            if (fpipe != 0) {\n                while(fgets(buffer,100,fpipe) != 0) {\n                    printf(buffer);\n                }\n                pclose(fpipe);\n            }\n        }\n        \n    }\n    \n;\n  if (( *( *haddin_upbring))[3] != 0) \n    free(((char *)( *( *haddin_upbring))[3]));\nclose_printf_context();\n}", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152280"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-698:Execution After Redirect (EAR)\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-220:Storage of File With Sensitive Data Under FTP Root", "code": "#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_char_environment_84\n{\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_char_environment_84\n{\npublic:\n    _LDAP_Injection__w32_char_environment_84(char * dataCopy);\n    ~_LDAP_Injection__w32_char_environment_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_char_environment_84G2B\n{\npublic:\n    _LDAP_Injection__w32_char_environment_84G2B(char * dataCopy);\n    ~_LDAP_Injection__w32_char_environment_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122990"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-384:Session Fixation\nE.CWE-334:Small Space of Random Values", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_open_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_open_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90935"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-183:Permissive List of Allowed Inputs\nC.No Vulnerabilities\nD.CWE-912:Hidden Functionality\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * dataArray[]);\n\nvoid m()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89858"}
{"selection": "A.CWE-431:Missing Handler\nB.CWE-1062:Parent Class with References to Child Class\nC.No Vulnerabilities\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_14()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32_spawnv_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32_spawnv_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244816"}
{"selection": "A.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\nB.CWE-476:NULL Pointer Dereference\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-145:Improper Neutralization of Section Delimiters\nE.No Vulnerabilities", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint lubbers_marquis = 0;\nint global_variable;\ntypedef char *jerseyan_dhootie;\n#define GEEJEE_POLICY(x) oyens_ravings((jerseyan_dhootie *) x)\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid oyens_ravings(jerseyan_dhootie *thamuria_helmeted);\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  jerseyan_dhootie *lenticonus_convex = 0;\n  jerseyan_dhootie *hongkong_personality = 0;\n  jerseyan_dhootie contravening_omniscience = 0;\n  char *haff_burgeoning;;\n  if (__sync_bool_compare_and_swap(&lubbers_marquis,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&haff_burgeoning,\"WINTERY_NOVI\");\n      if (haff_burgeoning != 0) {;\n        contravening_omniscience = haff_burgeoning;\n        lenticonus_convex = &contravening_omniscience;\n        hongkong_personality = lenticonus_convex + 5;\n\tGEEJEE_POLICY(hongkong_personality);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid oyens_ravings(jerseyan_dhootie *thamuria_helmeted)\n{\n  char *skip_malloc_buffer = 0;\n  char *lithophany_aeronef = 0;\n  ++global_variable;;\n  lithophany_aeronef = ((char *)( *(thamuria_helmeted - 5)));\n      \n      \n\n      if (strlen(lithophany_aeronef) < 63) {\n        skip_malloc_buffer = malloc(strlen(lithophany_aeronef + 1));\n      }\n      \n      \n      \n\n      strcpy(skip_malloc_buffer,lithophany_aeronef);\n      printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n      \n      if (skip_malloc_buffer != 0) {\n        free(skip_malloc_buffer);\n      }\n      \n;\n  if ( *(thamuria_helmeted - 5) != 0) \n    free(((char *)( *(thamuria_helmeted - 5))));\nclose_printf_context();\n}", "answer": "B.CWE-476:NULL Pointer Dereference|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149529"}
{"selection": "A.No Vulnerabilities\nB.CWE-191:Integer Underflow (Wrap or Wraparound)\nC.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\nD.CWE-1077:Floating Point Comparison with Incorrect Operator\nE.CWE-707:Improper Neutralization", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint polster_excoriable = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint 191_global_var = 0;\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n        char buff[128];\n        short max_size = 128;\n        short remaining_space = 0;\n        int size = 0;\n        FILE * file = 0;\n  char *cranium_wesleyan = 0;\n  jmp_buf pomona_nesty;\n  int aspis_phacolysis;\n  char **anticompetitive_windfish = 0;\n  char **marseille_substraction = 0;\n  int baghla_kingliness = 0;\n  char *ipt_redisposition = 0;\n  char *mozamb_kirschner;;\n  if (__sync_bool_compare_and_swap(&polster_excoriable,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      mozamb_kirschner = getenv(\"CIRCUMBASAL_MAN\");\n      if (mozamb_kirschner != 0) {;\n        baghla_kingliness = ((int )(strlen(mozamb_kirschner)));\n        ipt_redisposition = ((char *)(malloc(baghla_kingliness + 1)));\n        if (ipt_redisposition == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(ipt_redisposition,0,baghla_kingliness + 1);\n        memcpy(ipt_redisposition,mozamb_kirschner,baghla_kingliness);\n        anticompetitive_windfish = &ipt_redisposition;\n        marseille_substraction = anticompetitive_windfish + 5;\n        aspis_phacolysis = setjmp(pomona_nesty);\n        if (aspis_phacolysis == 0) {\n          longjmp(pomona_nesty,1);\n        }\n        cranium_wesleyan = ((char *)( *(marseille_substraction - 5)));\n        \n        file = fopen(cranium_wesleyan, \"r\");\n        if(file != NULL){\n                fseek(file, 0, SEEK_END);\n                size = ftell(file);\n                fseek(file, 0, SEEK_SET);\n                \n                \n                remaining_space = max_size - size;\n                \n                \n                \n                \n                if(remaining_space > 0){\n                        fscanf(file, \"%s\", buff);\n                        printf(\"Contents of file: %s\\n\", buff);\n                }\n                \n                fclose(file);\n        }\n        \n;\n        if ( *(marseille_substraction - 5) != 0) \n          free(((char *)( *(marseille_substraction - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "B.CWE-191:Integer Underflow (Wrap or Wraparound)|E.CWE-707:Improper Neutralization", "cwe": "191", "idx": "151346"}
{"selection": "A.CWE-1222:Insufficient Granularity of Address Regions Protected by Register Locks\nB.CWE-252:Unchecked Return Value\nC.CWE-674:Uncontrolled Recursion\nD.CWE-691:Insufficient Control Flow Management\nE.No Vulnerabilities", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint fucus_conformers = 0;\nint global_variable;\n\nstruct flaubert_pecking \n{\n  char *nebulosities_mutually;\n  double washings_fetidly;\n  char *felapton_legitimisation;\n  char semiped_guv;\n  int unsmokable_ssas;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nstruct flaubert_pecking russ_flunk(struct flaubert_pecking vermiculite_joysome);\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n int found;\n  char *vespoid_cogener = 0;\n  jmp_buf corah_harl;\n  int unairable_manucaption;\n  struct flaubert_pecking prionodont_anguishes = {0};\n  struct flaubert_pecking amissness_energies;\n  char *dais_nanitic;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&fucus_conformers,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      dais_nanitic = getenv(\"WIBORG_SOLDIER\");\n      if (dais_nanitic != 0) {;\n        amissness_energies . nebulosities_mutually = ((char *)dais_nanitic);\n        prionodont_anguishes = russ_flunk(amissness_energies);\n        unairable_manucaption = setjmp(corah_harl);\n        if (unairable_manucaption == 0) {\n          longjmp(corah_harl,1);\n        }\n        vespoid_cogener = ((char *)prionodont_anguishes . nebulosities_mutually);\n    \n    \n    \n    found = search(&vespoid_cogener[1],vespoid_cogener[0]);\n    \n    \n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nstruct flaubert_pecking russ_flunk(struct flaubert_pecking vermiculite_joysome)\n{\n  ++global_variable;\n  return vermiculite_joysome;\n}", "answer": "C.CWE-674:Uncontrolled Recursion|D.CWE-691:Insufficient Control Flow Management", "cwe": "674", "idx": "151948"}
{"selection": "A.CWE-766:Critical Data Element Declared Public\nB.CWE-668:Exposure of Resource to Wrong Sphere\nC.CWE-707:Improper Neutralization\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_67\n{\n\ntypedef struct _structType\n{\n    wchar_t * structFirst;\n} structType;\n\n#ifndef OMITM\n\n\nvoid mSink(structType myStruct);\n\nvoid m()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    mSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    myStruct.structFirst = data;\n    nG2BSink(myStruct);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_67; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91827"}
{"selection": "A.No Vulnerabilities\nB.CWE-360:Trust of System Event Data\nC.CWE-707:Improper Neutralization\nD.CWE-481:Assigning instead of Comparing\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_listen_socket_w32_spawnv_81\n{\n\nclass _OS_Command_Injection__char_listen_socket_w32_spawnv_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_listen_socket_w32_spawnv_81 : public _OS_Command_Injection__char_listen_socket_w32_spawnv_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_listen_socket_w32_spawnv_81G2B : public _OS_Command_Injection__char_listen_socket_w32_spawnv_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246311"}
{"selection": "A.CWE-550:Server-generated Error Message Containing Sensitive Information\nB.CWE-707:Improper Neutralization\nC.CWE-704:Incorrect Type Conversion or Cast\nD.No Vulnerabilities\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_open_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_open_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95951"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-638:Not Using Complete Mediation\nC.CWE-707:Improper Neutralization\nD.CWE-385:Covert Timing Channel\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_console_ofstream_13\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_ofstream_13; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91128"}
{"selection": "A.CWE-572:Call to Thread run() instead of start()\nB.CWE-1107:Insufficient Isolation of Symbolic Constant Definitions\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-415:Double Free", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint acoelomous_superintended = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar *inhabitation_retaliate(char *veblen_maidism);\nvoid valinch_forums(int arteriometer_inordinacy,char *calusa_pacate);\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int kists_oxyhydric = 7;\n  char *melancholy_dauded = 0;\n  int pazia_boroglycerine = 0;\n  char *unsticked_hoplonemertea = 0;\n  char *causeways_proprietarian;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&acoelomous_superintended,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&causeways_proprietarian,\"PACIFYING_LEISURELESS\");\n      if (causeways_proprietarian != 0) {;\n        pazia_boroglycerine = ((int )(strlen(causeways_proprietarian)));\n        unsticked_hoplonemertea = ((char *)(malloc(pazia_boroglycerine + 1)));\n        if (unsticked_hoplonemertea == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(unsticked_hoplonemertea,0,pazia_boroglycerine + 1);\n        memcpy(unsticked_hoplonemertea,causeways_proprietarian,pazia_boroglycerine);\n        if (causeways_proprietarian != 0) \n          free(((char *)causeways_proprietarian));\n        melancholy_dauded = inhabitation_retaliate(unsticked_hoplonemertea);\n        valinch_forums(kists_oxyhydric,melancholy_dauded);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nchar *inhabitation_retaliate(char *veblen_maidism)\n{\n  ++global_variable;\n  return veblen_maidism;\n}\n\nvoid valinch_forums(int arteriometer_inordinacy,char *calusa_pacate)\n{\n char *buffer = 0;\n  char *premen_abstrude = 0;\n  ++global_variable;\n  arteriometer_inordinacy--;\n  if (arteriometer_inordinacy > 0) {\n    valinch_forums(arteriometer_inordinacy,calusa_pacate);\n    return ;\n  }\n  premen_abstrude = ((char *)calusa_pacate);\n    \n    buffer = malloc((strlen(premen_abstrude) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,premen_abstrude);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n  if (calusa_pacate != 0) \n    free(((char *)calusa_pacate));\nclose_printf_context();\n}", "answer": "E.CWE-415:Double Free|D.CWE-707:Improper Neutralization", "cwe": "415", "idx": "152882"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-349:Acceptance of Extraneous Untrusted Data With Trusted Data\nD.CWE-765:Multiple Unlocks of a Critical Resource\nE.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <semaphore.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint pelycometry_briskish = 0;\nint global_variable;\nvoid handle_taint(char *phenix_windscoop);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\npthread_t t0, t1, t2;\nsem_t sem;\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int *arr;\n    int i = 0;\n    int i = 0;\n    \n    printf(\"Inside toCap\\n\");\n    \n    sem_wait(&sem); \n    \n    \n    arr = malloc(sizeof(int) * cusData->qsize);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(cusData->file1);\n    for(i = 0; i < strlen(cusData->data); i++) {\n        if (cusData->data[i] >= 'a' && cusData->data[i] <= 'z') { \n            cusData->data[i] -= 32; \n        }\n    }\n    sem_post(&sem);\n    return NULL;\n}\nint isalpha(char c) {\n    return ((c >= 'A' && c <= 'Z') ||\n            (c >= 'a' && c <= 'z'));\n}\nvoid *delNonAlpha (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i = 0;\n    int j = 0;\n    char *temp = NULL;\n    \n    printf(\"Inside delNonAlpha\\n\");\n    \n    sem_wait(&sem);\n    temp = malloc(sizeof(char) * (strlen(cusData->data) + 1));\n    while(cusData->data[i] != '\\0') {\n        if (isalpha(cusData->data[i])) {\n            temp[j++] = cusData->data[i];\n        }\n        i++;\n    }\n    temp[++j] = '\\0';\n    free(cusData->data);\n    cusData->data = NULL; \n    \n    \n    readFile(cusData->file2);\n    \n    cusData->data = temp;\n    sem_post(&sem);\n    return NULL;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&pelycometry_briskish,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *phenix_windscoop)\n{\n    pthread_t t0, t1;\n    int hasNonAlpha = 0;\n    int i = 0;\n    struct data* cusData;\n  char *blackberries_counts = 0;\n  jmp_buf puffbird_unsmoothed;\n  int extrudable_pestilentially;\n  void ***cynosarges_pharyngalgic = 0;\n  void **manutius_flokite = 0;\n  void *caducean_chucho = 0;\n  void *glenmoore_outguessing = 0;\n  ++global_variable;;\n  if (phenix_windscoop != 0) {;\n    glenmoore_outguessing = ((void *)phenix_windscoop);\n    manutius_flokite = &glenmoore_outguessing;\n    cynosarges_pharyngalgic = &manutius_flokite;\n    extrudable_pestilentially = setjmp(puffbird_unsmoothed);\n    if (extrudable_pestilentially == 0) {\n      longjmp(puffbird_unsmoothed,1);\n    }\n    blackberries_counts = ((char *)((char *)( *( *cynosarges_pharyngalgic))));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(blackberries_counts) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(blackberries_counts) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(blackberries_counts) + 1));\n        if (cusData->data) {\n            if ((sscanf(blackberries_counts, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0)) {\n                sem_init(&sem, 0, 1);\n                while (cusData->data[i] != '\\0') { \n                    if(isalpha(cusData->data[i]) == 0) {\n                        hasNonAlpha = 1;\n                    }\n                    i++;\n                }\n                if (hasNonAlpha != 0) {\n                    \n                    \n                    sem_post(&sem);\n                    pthread_create(&t0, NULL, delNonAlpha, cusData); \n                    \n                } \n                pthread_create(&t1, NULL, toCap, cusData);\n                if (hasNonAlpha != 0) {\n                    pthread_join(t0, NULL);\n                }\n                pthread_join(t1, NULL);\n            } else {\n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n    if (((char *)( *( *cynosarges_pharyngalgic))) != 0) \n      free(((char *)((char *)( *( *cynosarges_pharyngalgic)))));\nclose_printf_context();\n  }\n}", "answer": "D.CWE-765:Multiple Unlocks of a Critical Resource|B.CWE-707:Improper Neutralization", "cwe": "765", "idx": "150455"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-674:Uncontrolled Recursion\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-587:Assignment of a Fixed Address to a Pointer", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_09()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|A.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81986"}
{"selection": "A.CWE-1064:Invokable Control Element with Signature Containing an Excessive Number of Parameters\nB.No Vulnerabilities\nC.CWE-304:Missing Critical Step in Authentication\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-771:Missing Reference to Active Allocated Resource", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint cyclopia_outhumor = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid sublimes_voluptuousness(int contemple_impostress,... );\nvoid nonsociability_meteorical(int riverside_myctophidae,char *superathlete_winsomenesses);\nvoid lentigo_incoalescence(int adoptabilities_thelyphonus,char *underdish_psychosurgery);\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char *blackfigured_hillier;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&cyclopia_outhumor,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      blackfigured_hillier = getenv(\"DIDEST_BILIMBING\");\n      if (blackfigured_hillier != 0) {;\n        sublimes_voluptuousness(1,blackfigured_hillier);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid sublimes_voluptuousness(int contemple_impostress,... )\n{\n  int presuccessful_jurisconsult = 7;\n  char *vesiculae_transluce = 0;\n  va_list blindeyes_sulfurize;\n  ++global_variable;;\n  if (contemple_impostress > 0) {\n    __builtin_va_start(blindeyes_sulfurize,contemple_impostress);\n    vesiculae_transluce = (va_arg(blindeyes_sulfurize,char *));\n    __builtin_va_end(blindeyes_sulfurize);\n  }\n  nonsociability_meteorical(presuccessful_jurisconsult,vesiculae_transluce);\n}\n\nvoid nonsociability_meteorical(int riverside_myctophidae,char *superathlete_winsomenesses)\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *prela_nonexcepting = 0;\n  ++global_variable;\n  riverside_myctophidae--;\n  if (riverside_myctophidae > 0) {\n    lentigo_incoalescence(riverside_myctophidae,superathlete_winsomenesses);\n    return ;\n  }\n  prela_nonexcepting = ((char *)superathlete_winsomenesses);\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(prela_nonexcepting,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\nclose_printf_context();\n}\n\nvoid lentigo_incoalescence(int adoptabilities_thelyphonus,char *underdish_psychosurgery)\n{\n  ++global_variable;\n  nonsociability_meteorical(adoptabilities_thelyphonus,underdish_psychosurgery);\n}", "answer": "E.CWE-771:Missing Reference to Active Allocated Resource|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "771", "idx": "151695"}
{"selection": "A.CWE-114:Process Control\nB.CWE-1048:Invokable Control Element with Large Number of Outward Calls\nC.CWE-707:Improper Neutralization\nD.CWE-294:Authentication Bypass by Capture-replay\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_13()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62480"}
{"selection": "A.CWE-1222:Insufficient Granularity of Address Regions Protected by Register Locks\nB.CWE-1038:Insecure Automated Optimizations\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_console_w32_spawnlp_84\n{\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_console_w32_spawnlp_84\n{\npublic:\n    _OS_Command_Injection__char_console_w32_spawnlp_84(char * dataCopy);\n    ~_OS_Command_Injection__char_console_w32_spawnlp_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_console_w32_spawnlp_84G2B\n{\npublic:\n    _OS_Command_Injection__char_console_w32_spawnlp_84G2B(char * dataCopy);\n    ~_OS_Command_Injection__char_console_w32_spawnlp_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244802"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-395:Use of NullPointerException Catch to Detect NULL Pointer Dereference\nD.No Vulnerabilities\nE.CWE-1099:Inconsistent Naming Conventions for Identifiers", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_53bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_file_53()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_53bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_53bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123262"}
{"selection": "A.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1357:Reliance on Insufficiently Trustworthy Component\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\nnamespace _Process_Control__w32_char_console_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_console_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62014"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.No Vulnerabilities\nC.CWE-669:Incorrect Resource Transfer Between Spheres\nD.CWE-707:Improper Neutralization\nE.CWE-1025:Comparison Using Wrong Factors", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\nchar * _OS_Command_Injection__char_file_w32_spawnv_68Data;\nchar * _OS_Command_Injection__char_file_w32_spawnv_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68bSink();\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _OS_Command_Injection__char_file_w32_spawnv_68Data = data;\n    _OS_Command_Injection__char_file_w32_spawnv_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_file_w32_spawnv_68G2BData = data;\n    _OS_Command_Injection__char_file_w32_spawnv_68bG2BSink();\n}\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245835"}
{"selection": "A.CWE-403:Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')\nB.CWE-820:Missing Synchronization\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_ofstream_16\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    while(1)\n    {\n        \n        wcscat(data, L\"file.txt\");\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_ofstream_16; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91371"}
{"selection": "A.CWE-1235:Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations\nB.CWE-707:Improper Neutralization\nC.CWE-346:Origin Validation Error\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_41Sink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_41()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_connect_socket_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _LDAP_Injection__w32_char_connect_socket_41G2BSink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_connect_socket_41G2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122871"}
{"selection": "A.CWE-686:Function Call With Incorrect Argument Type\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-1276:Hardware Child Block Incorrectly Connected to Parent System\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_file_w32_spawnvp_82\n{\n\nclass _OS_Command_Injection__char_file_w32_spawnvp_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_file_w32_spawnvp_82 : public _OS_Command_Injection__char_file_w32_spawnvp_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_file_w32_spawnvp_82G2B : public _OS_Command_Injection__char_file_w32_spawnvp_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245888"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nE.CWE-648:Incorrect Use of Privileged APIs", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123234"}
{"selection": "A.CWE-755:Improper Handling of Exceptional Conditions\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-478:Missing Default Case in Multiple Condition Expression", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_10()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123000"}
{"selection": "A.CWE-573:Improper Following of Specification by Caller\nB.No Vulnerabilities\nC.CWE-412:Unrestricted Externally Accessible Lock\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-346:Origin Validation Error", "code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint cometaria_antimedically = 0;\nint global_variable;\ntypedef char *elapsing_enneahedra;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid brackney_embira(const elapsing_enneahedra schtick_caddised);\nvoid factional_electees(elapsing_enneahedra ostariophysi_milliarium);\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  elapsing_enneahedra flexible_nociassociation = 0;\n  char *copartnerships_thermostat;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&cometaria_antimedically,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      copartnerships_thermostat = getenv(\"HYDRACORAL_DRYBRAINED\");\n      if (copartnerships_thermostat != 0) {;\n        flexible_nociassociation = copartnerships_thermostat;\n        brackney_embira(flexible_nociassociation);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#define MONKEYRONY_SORCERIES(x) factional_electees((elapsing_enneahedra) x)\n\nvoid brackney_embira(const elapsing_enneahedra schtick_caddised)\n{\n  ++global_variable;;\n\tMONKEYRONY_SORCERIES(schtick_caddised);\n}\n\nvoid factional_electees(elapsing_enneahedra ostariophysi_milliarium)\n{\n    int fd;\n    char *extension = \".lck\";\n    char *thelockfile;\n  char *herdsman_encrown = 0;\n  ++global_variable;;\n  herdsman_encrown = ((char *)((elapsing_enneahedra )ostariophysi_milliarium));\n    \n    thelockfile = (char *)malloc(strlen(\"/opt/cus/workspace/testData/\") + strlen(herdsman_encrown) +\n                                  strlen(extension) + 1);\n    \n    if (thelockfile) {\n        \n        \n  strcpy(thelockfile, \"/opt/cus/workspace/testData/\");\n     strcat(thelockfile, herdsman_encrown);\n     strcat(thelockfile, extension);\n        \n     \n     if (access(\"/opt/cus/workspace/testData/\", R_OK && W_OK) == -1) {\n      printf(\"Error accessing testData directory\\n\");\n     } else {\n            printf(\"Grabbing lock file: %s\\n\", thelockfile);\n            \n            \n      \n            while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\n                sleep(0);\n            }\n            \n            printf(\"Made it to the critical section\\n\");\n            if (fd != -1) {\n                close(fd);\n                unlink(thelockfile);\n            }\n            free (thelockfile);\n        }\n    }\n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "C.CWE-412:Unrestricted Externally Accessible Lock|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "412", "idx": "150115"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-756:Missing Custom Error Page\nC.CWE-1281:Sequence of Processor Instructions Leads to Unexpected Behavior\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnvp_14()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnvp_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnvp_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnvp_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247696"}
{"selection": "A.CWE-587:Assignment of a Fixed Address to a Pointer\nB.CWE-674:Uncontrolled Recursion\nC.CWE-1326:Missing Immutable Root of Trust in Hardware\nD.No Vulnerabilities\nE.CWE-691:Insufficient Control Flow Management", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint osteophytic_algometrically = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hirelings_valew(int kelyphite_muscidae,char **subdiapente_caulkings);\nvoid hyla_goosing(int marela_automorphism,char **avosets_vizirates);\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  int nankingese_epistasies = 7;\n  char **mainauer_weent = 0;\n  char **epiopticon_solenne = 0;\n  char *rais_spouses[86] = {0};\n  char *nockerl_levining;;\n  if (__sync_bool_compare_and_swap(&osteophytic_algometrically,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&nockerl_levining,\"ACCOLATED_BLAME\");\n      if (nockerl_levining != 0) {;\n        rais_spouses[34] = nockerl_levining;\n        mainauer_weent = rais_spouses;\n        epiopticon_solenne = mainauer_weent + 5;\n        hirelings_valew(nankingese_epistasies,epiopticon_solenne);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid hirelings_valew(int kelyphite_muscidae,char **subdiapente_caulkings)\n{\n int found;\n  char *whiskyfied_conners = 0;\n  ++global_variable;\n  kelyphite_muscidae--;\n  if (kelyphite_muscidae > 0) {\n    hyla_goosing(kelyphite_muscidae,subdiapente_caulkings);\n    return ;\n  }\n  whiskyfied_conners = ((char *)(subdiapente_caulkings - 5)[34]);\n    \n    \n    \n    found = search(&whiskyfied_conners[1],whiskyfied_conners[0]);\n    \n    \n    \n;\n  if ((subdiapente_caulkings - 5)[34] != 0) \n    free(((char *)(subdiapente_caulkings - 5)[34]));\nclose_printf_context();\n}\n\nvoid hyla_goosing(int marela_automorphism,char **avosets_vizirates)\n{\n  ++global_variable;\n  hirelings_valew(marela_automorphism,avosets_vizirates);\n}", "answer": "B.CWE-674:Uncontrolled Recursion|E.CWE-691:Insufficient Control Flow Management", "cwe": "674", "idx": "151451"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-209:Generation of Error Message Containing Sensitive Information\nD.CWE-23:Relative Path Traversal\nE.CWE-1124:Excessively Deep Nesting", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_console_ofstream_54\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_ofstream_54; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91148"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1116:Inaccurate Comments\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-1072:Data Resource Access without Use of Connection Pooling\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_environment_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_environment_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122965"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1045:Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor\nC.CWE-114:Process Control\nD.CWE-428:Unquoted Search Path or Element\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_char_file_53bSink(char * data);\n\nvoid _Process_Control__w32_char_file_53()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _Process_Control__w32_char_file_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_char_file_53bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_char_file_53bG2BSink(data);\n}\n\nvoid _Process_Control__w32_char_file_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62115"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-114:Process Control\nD.CWE-921:Storage of Sensitive Data in a Mechanism without Access Control\nE.CWE-408:Incorrect Behavior Order: Early Amplification", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_66bSink(wchar_t * dataArray[]);\n\nvoid _Process_Control__w32_wchar_t_relativePath_66()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    \n    dataArray[2] = data;\n    _Process_Control__w32_wchar_t_relativePath_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_66bG2BSink(wchar_t * dataArray[]);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    dataArray[2] = data;\n    _Process_Control__w32_wchar_t_relativePath_66bG2BSink(dataArray);\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62506"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-277:Insecure Inherited Permissions\nC.CWE-575:EJB Bad Practices: Use of AWT Swing\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_environment_open_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_open_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90240"}
{"selection": "A.CWE-609:Double-Checked Locking\nB.CWE-196:Unsigned to Signed Conversion Error\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-523:Unprotected Transport of Credentials", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint server_rubianic = 0;\n\nunion barysilite_yeager \n{\n  char *rust_shapeliness;\n  double jacksonia_stormwind;\n  char *unclose_pullmans;\n  char talemaster_bienvenu;\n  int extinctions_ach;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nSize PMSignalShmemSize()\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *pseudo_unlaudably = 0;\n  jmp_buf nonequation_eiten;\n  int chiniks_outrail;\n  union barysilite_yeager tromping_energids = {0};\n  int *ferrateen_ungainlier = 0;\n  int alcedinidae_dipcoat;\n  union barysilite_yeager uneddying_fuld[10] = {0};\n  union barysilite_yeager schoolma_clistothecium;\n  int seraphtide_abnormalities = 11;\n  char *outdraw_inviscerate;\n  Size size;\n  if (__sync_bool_compare_and_swap(&server_rubianic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&outdraw_inviscerate,\"5390\",seraphtide_abnormalities);\n      if (outdraw_inviscerate != 0) {;\n        schoolma_clistothecium . rust_shapeliness = outdraw_inviscerate;\n        alcedinidae_dipcoat = 5;\n        ferrateen_ungainlier = &alcedinidae_dipcoat;\n        uneddying_fuld[ *ferrateen_ungainlier] = schoolma_clistothecium;\n        tromping_energids = uneddying_fuld[ *ferrateen_ungainlier];\n        chiniks_outrail = setjmp(nonequation_eiten);\n        if (chiniks_outrail == 0) {\n          longjmp(nonequation_eiten,1);\n        }\n        pseudo_unlaudably = ((char *)tromping_energids . rust_shapeliness);\n    \n    if (strlen(pseudo_unlaudably) > 0 &&\n        pseudo_unlaudably[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(pseudo_unlaudably);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n        if (tromping_energids . rust_shapeliness != 0) \n          free(((char *)tromping_energids . rust_shapeliness));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "B.CWE-196:Unsigned to Signed Conversion Error|D.CWE-707:Improper Neutralization", "cwe": "196", "idx": "151075"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-1083:Data Access from Outside Expected Data Manager Component\nD.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\nstatic wchar_t * _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45Data;\nstatic wchar_t * _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45Data;\n    \n    \n    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45G2BData;\n    \n    \n    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnlp_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247615"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.No Vulnerabilities\nC.CWE-784:Reliance on Cookies without Validation and Integrity Checking in a Security Decision\nD.CWE-277:Insecure Inherited Permissions\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_41\n{\n\n#ifndef OMITM\n\nvoid mSink(char * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(char * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95994"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.No Vulnerabilities\nC.CWE-414:Missing Lock Check\nD.CWE-707:Improper Neutralization\nE.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ifstream_06\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ifstream_06; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91553"}
{"selection": "A.CWE-1097:Persistent Storable Data Element without Associated Comparison Control Element\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-415:Double Free\nE.CWE-308:Use of Single-factor Authentication", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint lesli_endangered = 0;\n\nunion mucocellulosic_seated \n{\n  char *classicalities_perioesophageal;\n  double coxiest_conductive;\n  char *tinamidae_diastatically;\n  char urartic_defalcator;\n  int macrobius_acephalina;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n char *buffer = 0;\n  char *pruss_bibliopolic = 0;\n  jmp_buf situationally_alexanders;\n  int haithal_nobel;\n  union mucocellulosic_seated tweedles_quomodos = {0};\n  int **********cheirotherium_carbin = 0;\n  int *********proscolex_sensitivenesses = 0;\n  int ********eyewinks_nonnational = 0;\n  int *******bondland_pua = 0;\n  int ******subofficer_diffusive = 0;\n  int *****pterographic_aglisten = 0;\n  int ****palmiped_stercorean = 0;\n  int ***kairotic_inblow = 0;\n  int **decomposure_roseville = 0;\n  int *transhuman_highted = 0;\n  int lobuli_entremess;\n  union mucocellulosic_seated majestical_overmuches[10] = {0};\n  union mucocellulosic_seated tires_yaakov;\n  int zeugobranchia_overbar = 44;\n  char *axiolite_scumboard;;\n  if (__sync_bool_compare_and_swap(&lesli_endangered,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&axiolite_scumboard,\"2674\",zeugobranchia_overbar);\n      if (axiolite_scumboard != 0) {;\n        tires_yaakov . classicalities_perioesophageal = axiolite_scumboard;\n        lobuli_entremess = 5;\n        transhuman_highted = &lobuli_entremess;\n        decomposure_roseville = &transhuman_highted;\n        kairotic_inblow = &decomposure_roseville;\n        palmiped_stercorean = &kairotic_inblow;\n        pterographic_aglisten = &palmiped_stercorean;\n        subofficer_diffusive = &pterographic_aglisten;\n        bondland_pua = &subofficer_diffusive;\n        eyewinks_nonnational = &bondland_pua;\n        proscolex_sensitivenesses = &eyewinks_nonnational;\n        cheirotherium_carbin = &proscolex_sensitivenesses;\n        majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))] = tires_yaakov;\n        tweedles_quomodos = majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))];\n        haithal_nobel = setjmp(situationally_alexanders);\n        if (haithal_nobel == 0) {\n          longjmp(situationally_alexanders,1);\n        }\n        pruss_bibliopolic = ((char *)tweedles_quomodos . classicalities_perioesophageal);\n    \n    buffer = malloc((strlen(pruss_bibliopolic) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,pruss_bibliopolic);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n        if (tweedles_quomodos . classicalities_perioesophageal != 0) \n          free(((char *)tweedles_quomodos . classicalities_perioesophageal));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "D.CWE-415:Double Free|B.CWE-707:Improper Neutralization", "cwe": "415", "idx": "152925"}
{"selection": "A.CWE-414:Missing Lock Check\nB.CWE-838:Inappropriate Encoding for Output Context\nC.No Vulnerabilities\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-270:Privilege Context Switching Error", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint recompounds_kasai = 0;\n\nstruct unmigratory_aylett \n{\n  char *furil_weedingtime;\n  double hipper_uraemia;\n  char *ashman_bedroll;\n  char ammonitish_untractableness;\n  int joachim_exteriorization;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int *arr;\n    \n    pthread_mutex_lock(&mutex);\n    readFile(cusData->file1);\n    arr = malloc(sizeof(int) * cusData->qsize);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    \n    \n    \n    \n    \n    for(i = 0; i < cusData->data_size; i++) {\n        \n        if (cusData->data[i] >= 'a' &&\n            cusData->data[i] <= 'z') { \n            cusData->data[i] -= 32;\n        }\n    }\n    \n    pthread_mutex_unlock(&mutex);\n    return NULL;\n}\nvoid *delNonAlpha (void *data) {\n    struct data *cusData = (struct data*) data;\n    int i = 0;\n    int j = 0;\n    char* temp = malloc(sizeof(char) * (cusData->data_size + 1));\n    \n    while(cusData->data[i] != '\\0') {\n        if((cusData->data[i] >= 'A' && cusData->data[i] <= 'Z') ||\n           (cusData->data[i] >= 'a' && cusData->data[i] <= 'z')) {\n            temp[j++] = cusData->data[i];\n        }\n        i++;\n    }\n    temp[j++] = '\\0';\n    cusData->data_size = j;\n    free(cusData->data);\n    \n    \n    cusData->data = NULL; \n    \n    \n    \n    \n    \n    readFile(cusData->file2);\n    cusData->data = temp;\n    \n    \n    \n    \n    return NULL;\n}\n\nSize PMSignalShmemSize()\n{\n    pthread_t t0, t1;\n    struct data *cusData;\n  char *psat_disboscation = 0;\n  int teerell_gamest;\n  int linguister_prorebel;\n  struct unmigratory_aylett *llanero_alguacil = {0};\n  struct unmigratory_aylett transpontine_subsumes;\n  char *pongees_conyger;\n  Size size;\n  if (__sync_bool_compare_and_swap(&recompounds_kasai,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      pongees_conyger = getenv(\"EXGORGITATION_TORBAY\");\n      if (pongees_conyger != 0) {;\n        transpontine_subsumes . furil_weedingtime = ((char *)pongees_conyger);\n        llanero_alguacil = &transpontine_subsumes;\n        linguister_prorebel = 5;\n        while(1 == 1){\n          linguister_prorebel = linguister_prorebel * 2;\n          linguister_prorebel = linguister_prorebel + 2;\n          if (linguister_prorebel > 1000) {\n            break; \n          }\n        }\n        teerell_gamest = linguister_prorebel;\n        psat_disboscation = ((char *)( *llanero_alguacil) . furil_weedingtime);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(psat_disboscation) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(psat_disboscation) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(psat_disboscation) + 1));\n        if (cusData->data && cusData->file1 && cusData->file2) {\n            if ((sscanf(psat_disboscation, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0))\n            {\n                \n                \n                \n                \n                if (pthread_mutex_init(&mutex, NULL) != 0) {\n                    printf(\"Mutex failed to initilize.\");\n                }\n                cusData->data_size = strlen(cusData->data);\n                \n                if (pthread_create(&t0, NULL, delNonAlpha, (void *)cusData) != 0) { \n                    printf(\"Error creating thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toCap, (void *)cusData) != 0) {\n                    printf(\"Error creating thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n                printf(\"After joins.\\n\");\n                pthread_mutex_destroy(&mutex);\n            } else {\n                printf(\"Error parsing input.\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "A.CWE-414:Missing Lock Check|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "414", "idx": "150125"}
{"selection": "A.CWE-1224:Improper Restriction of Write-Once Bit Fields\nB.No Vulnerabilities\nC.CWE-1310:Missing Ability to Patch ROM Code\nD.CWE-707:Improper Neutralization\nE.CWE-191:Integer Underflow (Wrap or Wraparound)", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint mauricio_burlace = 0;\nint global_variable;\nvoid handle_taint(char *sorda_aghast);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid bacterid_systemized(void **trentepohlia_hock);\nint 191_global_var = 0;\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&mauricio_burlace,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *sorda_aghast)\n{\n  void (*riddles_conflates)(void **) = bacterid_systemized;\n  int beadiest_looked;\n  void **coagulose_hugi = 0;\n  void **nasoprognathism_stroller = 0;\n  void *echitamine_unmetrically = 0;\n  ++global_variable;;\n  if (sorda_aghast != 0) {;\n    echitamine_unmetrically = ((void *)sorda_aghast);\n    beadiest_looked = 1;\n    coagulose_hugi = &echitamine_unmetrically;\n    nasoprognathism_stroller = ((void **)(((unsigned long )coagulose_hugi) * beadiest_looked * beadiest_looked)) + 5;\n    riddles_conflates(nasoprognathism_stroller);\n  }\n}\n\nvoid bacterid_systemized(void **trentepohlia_hock)\n{\n        char buff[128];\n        short max_size = 128;\n        short remaining_space = 0;\n        int size = 0;\n        FILE * file = 0;\n  char *hangnests_hereticated = 0;\n  ++global_variable;;\n  hangnests_hereticated = ((char *)((char *)( *(trentepohlia_hock - 5))));\n        \n        file = fopen(hangnests_hereticated, \"r\");\n        if(file != NULL){\n                fseek(file, 0, SEEK_END);\n                size = ftell(file);\n                fseek(file, 0, SEEK_SET);\n                \n                \n                remaining_space = max_size - size;\n                \n                \n                \n                \n                if(remaining_space > 0){\n                        fscanf(file, \"%s\", buff);\n                        printf(\"Contents of file: %s\\n\", buff);\n                }\n                \n                fclose(file);\n        }\n        \n;\n  if (((char *)( *(trentepohlia_hock - 5))) != 0) \n    free(((char *)((char *)( *(trentepohlia_hock - 5)))));\nclose_printf_context();\n}", "answer": "E.CWE-191:Integer Underflow (Wrap or Wraparound)|D.CWE-707:Improper Neutralization", "cwe": "191", "idx": "151173"}
{"selection": "A.CWE-195:Signed to Unsigned Conversion Error\nB.CWE-671:Lack of Administrator Control over Security\nC.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint analogise_iranic = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid ollayos_unorthodoxy(int regionalized_hematolin,... );\nvoid intercanal_consuming(char *atrocha_quakier);\nvoid subdelegated_safeguarded(char *angledozer_save);\nvoid prohumanistic_trocar(char *addi_unsour);\nvoid cumulene_indomitability(char *stampedable_manipulability);\nvoid adelantados_dabbles(char *ladonna_lapses);\nvoid counterpoising_myzostomatous(char *virelais_snobocrat);\nvoid bailiffship_mald(char *burma_hackingly);\nvoid ginkgoaceous_makadoo(char *amortized_incolumity);\nvoid tineoid_hoylake(char *syllogize_protuberant);\nvoid unblemishing_spiceland(char *aurify_cowl);\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  char *depraver_impy;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&analogise_iranic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      depraver_impy = getenv(\"REVOLUTIONARIES_MIDTAP\");\n      if (depraver_impy != 0) {;\n        ollayos_unorthodoxy(1,depraver_impy);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid ollayos_unorthodoxy(int regionalized_hematolin,... )\n{\n  char *endrin_hellions = 0;\n  va_list footslogging_circumlitio;\n  ++global_variable;;\n  if (regionalized_hematolin > 0) {\n    __builtin_va_start(footslogging_circumlitio,regionalized_hematolin);\n    endrin_hellions = (va_arg(footslogging_circumlitio,char *));\n    __builtin_va_end(footslogging_circumlitio);\n  }\n  intercanal_consuming(endrin_hellions);\n}\n\nvoid intercanal_consuming(char *atrocha_quakier)\n{\n  ++global_variable;;\n  subdelegated_safeguarded(atrocha_quakier);\n}\n\nvoid subdelegated_safeguarded(char *angledozer_save)\n{\n  ++global_variable;;\n  prohumanistic_trocar(angledozer_save);\n}\n\nvoid prohumanistic_trocar(char *addi_unsour)\n{\n  ++global_variable;;\n  cumulene_indomitability(addi_unsour);\n}\n\nvoid cumulene_indomitability(char *stampedable_manipulability)\n{\n  ++global_variable;;\n  adelantados_dabbles(stampedable_manipulability);\n}\n\nvoid adelantados_dabbles(char *ladonna_lapses)\n{\n  ++global_variable;;\n  counterpoising_myzostomatous(ladonna_lapses);\n}\n\nvoid counterpoising_myzostomatous(char *virelais_snobocrat)\n{\n  ++global_variable;;\n  bailiffship_mald(virelais_snobocrat);\n}\n\nvoid bailiffship_mald(char *burma_hackingly)\n{\n  ++global_variable;;\n  ginkgoaceous_makadoo(burma_hackingly);\n}\n\nvoid ginkgoaceous_makadoo(char *amortized_incolumity)\n{\n  ++global_variable;;\n  tineoid_hoylake(amortized_incolumity);\n}\n\nvoid tineoid_hoylake(char *syllogize_protuberant)\n{\n  ++global_variable;;\n  unblemishing_spiceland(syllogize_protuberant);\n}\n\nvoid unblemishing_spiceland(char *aurify_cowl)\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *lhary_acarotoxic = 0;\n  ++global_variable;;\n  lhary_acarotoxic = ((char *)aurify_cowl);\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, lhary_acarotoxic);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, lhary_acarotoxic, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\nclose_printf_context();\n}", "answer": "A.CWE-195:Signed to Unsigned Conversion Error|E.CWE-707:Improper Neutralization", "cwe": "195", "idx": "151395"}
{"selection": "A.CWE-909:Missing Initialization of Resource\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-582:Array Declared Public, Final, and Static", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_ofstream_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, char *> dataMap);\n\nvoid m()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, char *> dataMap);\n\nstatic void nG2B()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_ofstream_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90199"}
{"selection": "A.CWE-1098:Data Element containing Pointer Item without Proper Copy Control Element\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-262:Not Using Password Aging\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_fopen_05\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_fopen_05; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97222"}
{"selection": "A.No Vulnerabilities\nB.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels\nC.CWE-707:Improper Neutralization\nD.CWE-245:J2EE Bad Practices: Direct Management of Connections\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nstatic char * mSource(char * data)\n{\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return data;\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_42()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic char * nG2BSource(char * data)\n{\n    \n    strcpy(data, \"hostname\");\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_42()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_42();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_42();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|C.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82003"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-1105:Insufficient Encapsulation of Machine-Dependent Functionality\nD.CWE-204:Observable Response Discrepancy\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82012"}
{"selection": "A.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nB.CWE-707:Improper Neutralization\nC.CWE-23:Relative Path Traversal\nD.CWE-1331:Improper Isolation of Shared Resources in Network On Chip (NoC)\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_connect_socket_ofstream_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_ofstream_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89705"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-372:Incomplete Internal State Distinction\nE.CWE-1282:Assumed-Immutable Data is Stored in Writable Memory", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_51bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_51()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_wchar_t_connect_socket_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_51bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_51bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123116"}
{"selection": "A.CWE-805:Buffer Access with Incorrect Length Value\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nE.CWE-703:Improper Check or Handling of Exceptional Conditions", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint gnathotheca_cooeys = 0;\nint global_variable;\nvoid anarcotin_underrun(char **acousmatic_turtlelike);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid beweary_hypoglycemia(void (*pyruline_lingulae)(char **));\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&gnathotheca_cooeys,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      beweary_hypoglycemia(anarcotin_underrun);\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid anarcotin_underrun(char **acousmatic_turtlelike)\n{\n  int stiacciato_snorkeler = 0;\n  char *nonperceptional_deployed = 0;\n  char *evinces_cowan;\n  ++global_variable;;\n  setup_printf_context();\n  evinces_cowan = getenv(\"TRAINMASTER_ANTIFOULING\");\n  if (evinces_cowan != 0) {;\n    stiacciato_snorkeler = ((int )(strlen(evinces_cowan)));\n    nonperceptional_deployed = ((char *)(malloc(stiacciato_snorkeler + 1)));\n    if (nonperceptional_deployed == 0) {\n      printf(\"Error: Failed to allocate memory\\n\");\n      exit(1);\n    }\n    memset(nonperceptional_deployed,0,stiacciato_snorkeler + 1);\n    memcpy(nonperceptional_deployed,evinces_cowan,stiacciato_snorkeler);\n     *acousmatic_turtlelike = nonperceptional_deployed;\n  }\n}\n\nvoid beweary_hypoglycemia(void (*pyruline_lingulae)(char **))\n{\n int oc_i = 0;\n char buffer[8];\n  char *ria_markstone = 0;\n  char *internetworking_lorriker = 0;\n  long whereinto_quadricostate[10];\n  char *perspirate_melolonthidan[10] = {0};\n  ++global_variable;\n  char *rehypothecation_hypogeic = 0;\n  pyruline_lingulae(&rehypothecation_hypogeic);\n  if (rehypothecation_hypogeic != 0) {;\n    perspirate_melolonthidan[5] = rehypothecation_hypogeic;\n    whereinto_quadricostate[1] = 5;\n    internetworking_lorriker =  *(perspirate_melolonthidan + whereinto_quadricostate[1]);\n    ria_markstone = ((char *)internetworking_lorriker);\n    \n    \n    \n \n \n    \n    strncpy(buffer,ria_markstone,strlen(ria_markstone) + 1);\n    for (; oc_i < strlen(buffer); ++oc_i) {\n        buffer[oc_i] = toupper(buffer[oc_i]);\n    }\n    printf(\"%s\\n\",buffer);\n    \n    \n    \n;\n    if (internetworking_lorriker != 0) \n      free(((char *)internetworking_lorriker));\nclose_printf_context();\n  }\n}", "answer": "A.CWE-805:Buffer Access with Incorrect Length Value|B.CWE-707:Improper Neutralization", "cwe": "805", "idx": "153211"}
{"selection": "A.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug\nB.CWE-611:Improper Restriction of XML External Entity Reference\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_52bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82008"}
{"selection": "A.No Vulnerabilities\nB.CWE-309:Use of Password System for Primary Authentication\nC.CWE-114:Process Control\nD.CWE-707:Improper Neutralization\nE.CWE-1279:Cryptographic Operations are run Before Supporting Units are Ready", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_wchar_t_file_52bSink(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_file_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _Process_Control__w32_wchar_t_file_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_wchar_t_file_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_file_52bG2BSink(data);\n}\n\nvoid _Process_Control__w32_wchar_t_file_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|D.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62402"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-693:Protection Mechanism Failure\nE.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nchar * _LDAP_Injection__w32_char_environment_68Data;\nchar * _LDAP_Injection__w32_char_environment_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_environment_68bSink();\n\nvoid _LDAP_Injection__w32_char_environment_68()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_char_environment_68Data = data;\n    _LDAP_Injection__w32_char_environment_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_environment_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_environment_68G2BData = data;\n    _LDAP_Injection__w32_char_environment_68bG2BSink();\n}\n\nvoid _LDAP_Injection__w32_char_environment_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122983"}
{"selection": "A.CWE-66:Improper Handling of File Names that Identify Virtual Resources\nB.CWE-829:Inclusion of Functionality from Untrusted Control Sphere\nC.CWE-476:NULL Pointer Dereference\nD.No Vulnerabilities\nE.CWE-710:Improper Adherence to Coding Standards", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint guaranis_oblicque = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid manning_laminable(int roughroot_undersong,... );\nvoid reg_douppioni(int campstools_lemonfish,void *rickeys_enlister);\nvoid *my_malloc(unsigned int size)\n{\n  if (size > 512)\n\n    return 0;\n  return malloc(size);\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  void *poictesme_valli = 0;\n  char *heterogamety_dendrites;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&guaranis_oblicque,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      heterogamety_dendrites = getenv(\"COLLIGATED_COPPERSIDESMAN\");\n      if (heterogamety_dendrites != 0) {;\n        poictesme_valli = ((void *)heterogamety_dendrites);\n        manning_laminable(1,poictesme_valli);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid manning_laminable(int roughroot_undersong,... )\n{\n  int senor_baggyrinkle = 7;\n  void *porcellanize_hansa = 0;\n  va_list geometric_navel;\n  ++global_variable;;\n  if (roughroot_undersong > 0) {\n    __builtin_va_start(geometric_navel,roughroot_undersong);\n    porcellanize_hansa = (va_arg(geometric_navel,void *));\n    __builtin_va_end(geometric_navel);\n  }\n  reg_douppioni(senor_baggyrinkle,porcellanize_hansa);\n}\n\nvoid reg_douppioni(int campstools_lemonfish,void *rickeys_enlister)\n{\n  unsigned int size_buffer;\n  int buffer_value;\n  char *malloc_buffer = 0;\n  char *sponger_mekong = 0;\n  ++global_variable;\n  campstools_lemonfish--;\n  if (campstools_lemonfish > 0) {\n    reg_douppioni(campstools_lemonfish,rickeys_enlister);\n    return ;\n  }\n  sponger_mekong = ((char *)((char *)rickeys_enlister));\n      \n      buffer_value = atoi(sponger_mekong);\n      \n      if (buffer_value < 0)\n        buffer_value = 0;\n      size_buffer = ((unsigned int )buffer_value);\n      \n      malloc_buffer = my_malloc(size_buffer);\n      \n      \n      \n\n      memset(malloc_buffer,0,size_buffer);\n      printf(\"Buffer size is %d\\n\", size_buffer);\n      \n      if (malloc_buffer != 0) {\n        free(malloc_buffer);\n      }\n      \n;\nclose_printf_context();\n}", "answer": "C.CWE-476:NULL Pointer Dereference|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149444"}
{"selection": "A.No Vulnerabilities\nB.CWE-476:NULL Pointer Dereference\nC.CWE-271:Privilege Dropping / Lowering Errors\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-772:Missing Release of Resource after Effective Lifetime", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint acrocyst_mucins = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid toxcatl_stupefactions(char *dobb_theria);\n\nSize PMSignalShmemSize()\n{\n  void (*pastimer_maskelynite)(char *) = toxcatl_stupefactions;\n  char *supraclusion_jurator;\n  Size size;\n  if (__sync_bool_compare_and_swap(&acrocyst_mucins,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&supraclusion_jurator,\"PILEUS_VESTAL\");\n      if (supraclusion_jurator != 0) {;\n        pastimer_maskelynite(supraclusion_jurator);\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid toxcatl_stupefactions(char *dobb_theria)\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *macropodia_yobi = 0;\n  ++global_variable;;\n  macropodia_yobi = ((char *)dobb_theria);\n  \n  \n  csv = fopen(macropodia_yobi,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\n  if (dobb_theria != 0) \n    free(((char *)dobb_theria));\nclose_printf_context();\n}", "answer": "B.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149864"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-36:Absolute Path Traversal\nD.CWE-1249:Application-Level Admin Tool with Inconsistent View of Underlying Operating System\nE.CWE-913:Improper Control of Dynamically-Managed Code Resources", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_42\n{\n\n#ifndef OMITM\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    return data;\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic wchar_t * nG2BSource(wchar_t * data)\n{\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_42; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97675"}
{"selection": "A.CWE-114:Process Control\nB.CWE-500:Public Static Field Not Marked Final\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-689:Permission Race Condition During Resource Copy", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_char_connect_socket_82\n{\n\nclass _Process_Control__w32_char_connect_socket_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _Process_Control__w32_char_connect_socket_82 : public _Process_Control__w32_char_connect_socket_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_char_connect_socket_82G2B : public _Process_Control__w32_char_connect_socket_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "A.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "61985"}
{"selection": "A.CWE-580:clone() Method Without super.clone()\nB.No Vulnerabilities\nC.CWE-585:Empty Synchronized Block\nD.CWE-707:Improper Neutralization\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <process.h>\n\nstatic wchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45Data;\nstatic wchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45Data;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45G2BData;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246719"}
{"selection": "A.CWE-624:Executable Regular Expression Error\nB.CWE-789:Memory Allocation with Excessive Size Value\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.No Vulnerabilities\nE.CWE-329:Generation of Predictable IV with CBC Mode", "code": "#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint crescographic_gadflies = 0;\nint global_variable;\ntypedef char *dilatatory_stichado;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid isoglosses_klina(const dilatatory_stichado frangibilities_waff);\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  dilatatory_stichado lecompton_bethel = 0;\n  char *humongous_phocomelous;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&crescographic_gadflies,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      humongous_phocomelous = getenv(\"UNAPPROACHABLY_MYRIAPODAN\");\n      if (humongous_phocomelous != 0) {;\n        lecompton_bethel = humongous_phocomelous;\n        isoglosses_klina(lecompton_bethel);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n\nvoid isoglosses_klina(const dilatatory_stichado frangibilities_waff)\n{\n    int stack_size = 0;\n  char *stumblingly_jivaro = 0;\n  jmp_buf abluvion_ardito;\n  int hydrophyll_pluripara;\n  ++global_variable;;\n  hydrophyll_pluripara = setjmp(abluvion_ardito);\n  if (hydrophyll_pluripara == 0) {\n    longjmp(abluvion_ardito,1);\n  }\n  stumblingly_jivaro = ((char *)((dilatatory_stichado )frangibilities_waff));\n    \n    \n    \n    if (strlen(stumblingly_jivaro) > 1 &&\n     stumblingly_jivaro[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(stumblingly_jivaro,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "B.CWE-789:Memory Allocation with Excessive Size Value|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "789", "idx": "151729"}
{"selection": "A.CWE-588:Attempt to Access Child of a Non-structure Pointer\nB.CWE-23:Relative Path Traversal\nC.CWE-391:Unchecked Error Condition\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_84\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__wchar_t_environment_open_84\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_environment_open_84(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_environment_open_84();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__wchar_t_environment_open_84G2B\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_environment_open_84G2B(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_environment_open_84G2B();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n}", "answer": "B.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91451"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-23:Relative Path Traversal\nC.CWE-342:Predictable Exact Value from Previous Values\nD.CWE-115:Misinterpretation of Input\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91796"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-762:Mismatched Memory Management Routines\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-508:Non-Replicating Malicious Code", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_environment_06()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_environment_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_environment_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_environment_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62041"}
{"selection": "A.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nB.CWE-532:Insertion of Sensitive Information into Log File\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54bSink(char * data);\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__char_environment_w32_execvp_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_environment_w32_execvp_54bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245211"}
{"selection": "A.CWE-1384:Improper Handling of Physical or Environmental Conditions\nB.CWE-749:Exposed Dangerous Method or Function\nC.CWE-789:Memory Allocation with Excessive Size Value\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint seaborderer_auxillary = 0;\n\nunion acephalus_piranhas \n{\n  char *catchie_aerosphere;\n  double ethnish_sleevelessness;\n  char *periungual_nonculminating;\n  char ligula_precondemned;\n  int paedotribe_peterson;\n}\n;\nint global_variable;\nvoid handle_taint(char *empressements_pallors);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid supportful_shelley(int metheglin_toul,... );\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&seaborderer_auxillary,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *empressements_pallors)\n{\n  union acephalus_piranhas megbote_stomatoda;\n  ++global_variable;;\n  if (empressements_pallors != 0) {;\n    megbote_stomatoda . catchie_aerosphere = empressements_pallors;\n    supportful_shelley(1,megbote_stomatoda);\n  }\n}\n\nvoid supportful_shelley(int metheglin_toul,... )\n{\n    int stack_size = 0;\n  char *undignify_carabin = 0;\n  jmp_buf beardless_tektosilicate;\n  int justling_nonmaliciously;\n  union acephalus_piranhas birchen_acridines = {0};\n  va_list monopolitical_irefully;\n  ++global_variable;;\n  if (metheglin_toul > 0) {\n    __builtin_va_start(monopolitical_irefully,metheglin_toul);\n    birchen_acridines = (va_arg(monopolitical_irefully,union acephalus_piranhas ));\n    __builtin_va_end(monopolitical_irefully);\n  }\n  justling_nonmaliciously = setjmp(beardless_tektosilicate);\n  if (justling_nonmaliciously == 0) {\n    longjmp(beardless_tektosilicate,1);\n  }\n  undignify_carabin = ((char *)birchen_acridines . catchie_aerosphere);\n    \n    \n    \n    if (strlen(undignify_carabin) > 1 &&\n     undignify_carabin[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(undignify_carabin,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\n  if (birchen_acridines . catchie_aerosphere != 0) \n    free(((char *)birchen_acridines . catchie_aerosphere));\nclose_printf_context();\n}", "answer": "C.CWE-789:Memory Allocation with Excessive Size Value|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "789", "idx": "151775"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-778:Insufficient Logging\nC.CWE-1302:Missing Security Identifier\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64bSink(void * dataVoidPtr);\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_environment_64bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64bG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_environment_64bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_64();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_64();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123219"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-584:Return Inside Finally Block\nC.No Vulnerabilities\nD.CWE-1395:Dependency on Vulnerable Third-Party Component\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89617"}
{"selection": "A.No Vulnerabilities\nB.CWE-220:Storage of File With Sensitive Data Under FTP Root\nC.CWE-223:Omission of Security-relevant Information\nD.CWE-707:Improper Neutralization\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n#include <list>\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82020"}
{"selection": "A.No Vulnerabilities\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-200:Exposure of Sensitive Information to an Unauthorized Actor\nD.CWE-1052:Excessive Use of Hard-Coded Literals in Initialization\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifdef _WIN32\n#define POPEN _popen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_connect_socket_popen_09()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_connect_socket_popen_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_popen_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_popen_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244107"}
{"selection": "A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-1223:Race Condition for Write-Once Attributes\nD.CWE-400:Uncontrolled Resource Consumption\nE.CWE-323:Reusing a Nonce, Key Pair in Encryption", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint repletely_coaction = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n unsigned int **buffer_array = 0;\n    unsigned int i;\n    unsigned int size;\n    int num;\n    unsigned int trace_counter = 0;\n  char *vaudevillist_mrsr = 0;\n  int jawn_squirrels;\n  int muffy_observingly;\n  char *(**********apishamore_goetic)[91] = 0;\n  char *(*********yelped_hewitt)[91] = 0;\n  char *(********reason_intestate)[91] = 0;\n  char *(*******mispatch_lymphation)[91] = 0;\n  char *(******federalising_preweigh)[91] = 0;\n  char *(*****tidily_motors)[91] = 0;\n  char *(****uncountermanded_magically)[91] = 0;\n  char *(***specificity_salten)[91] = 0;\n  char *(**carrotage_zealousnesses)[91] = 0;\n  char *(*diapausing_pollaiuolo)[91] = 0;\n  char **alcibiades_glimes = 0;\n  char *chitkara_gearwheels[91] = {0};\n  int papistical_jacobina = 7;\n  char *fotched_sarangousty;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&repletely_coaction,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&fotched_sarangousty,\"2556\",papistical_jacobina);\n      if (fotched_sarangousty != 0) {;\n        chitkara_gearwheels[43] = fotched_sarangousty;\n        diapausing_pollaiuolo = &chitkara_gearwheels;\n        carrotage_zealousnesses = &diapausing_pollaiuolo;\n        specificity_salten = &carrotage_zealousnesses;\n        uncountermanded_magically = &specificity_salten;\n        tidily_motors = &uncountermanded_magically;\n        federalising_preweigh = &tidily_motors;\n        mispatch_lymphation = &federalising_preweigh;\n        reason_intestate = &mispatch_lymphation;\n        yelped_hewitt = &reason_intestate;\n        apishamore_goetic = &yelped_hewitt;\n        muffy_observingly = 5;\n        while(1 == 1){\n          muffy_observingly = muffy_observingly * 2;\n          muffy_observingly = muffy_observingly + 2;\n          if (muffy_observingly > 1000) {\n            break; \n          }\n        }\n        jawn_squirrels = muffy_observingly;\n        vaudevillist_mrsr = ((char *)( *( *( *( *( *( *( *( *( *( *apishamore_goetic))))))))))[43]);\n    \n    num = atoi(vaudevillist_mrsr);\n    \n    if (num > 0 && num < 4294967295U / sizeof(unsigned int **)) {\n        size = 100000;\n        buffer_array = ((unsigned int **)(malloc(num * sizeof(unsigned int *))));\n        \n        \n        \n        \n        for (i = 0; i < num; ++i) {\n            buffer_array[i] = 0;\n            printf(\"evaluating input\\n\");\n            while(buffer_array[i] == 0){\n    \n    \n    buffer_array[i] = ((unsigned int *)(malloc(size * sizeof(unsigned int ))));\n                if (trace_counter % 1000 == 0) {\n                    if (buffer_array[i] != 0) {\n                        \n                        \n                    } else {\n                        \n                        \n                    }\n       }\n       trace_counter ++;\n   }\n   if (buffer_array[i] != 0) {\n    memset(buffer_array[i],0,size * sizeof(unsigned int ));\n   }\n   else\n    break;\n  }\n }\n \n \n \n printf(\"finished evaluating\\n\");\n    for (i = 0; i < num; ++i)\n        if (buffer_array[i] != 0)\n            free(buffer_array[i]);\n    if (buffer_array != 0) {\n        free(buffer_array);\n    }\n    \n;\n        if (( *( *( *( *( *( *( *( *( *( *apishamore_goetic))))))))))[43] != 0) \n          free(((char *)( *( *( *( *( *( *( *( *( *( *apishamore_goetic))))))))))[43]));\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}", "answer": "D.CWE-400:Uncontrolled Resource Consumption|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "400", "idx": "152130"}
{"selection": "A.CWE-5:J2EE Misconfiguration: Data Transmission Without Encryption\nB.CWE-916:Use of Password Hash With Insufficient Computational Effort\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_open_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_open_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90933"}
{"selection": "A.CWE-200:Exposure of Sensitive Information to an Unauthorized Actor\nB.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nC.No Vulnerabilities\nD.CWE-154:Improper Neutralization of Variable Name Delimiters\nE.CWE-691:Insufficient Control Flow Management", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <unistd.h> \nint semioval_pathwayed = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            \n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint is_valid(char *path)\n{\n    \n    if(access(path, F_OK) != -1) {\n        \n        printf(\"Path is accessible\\n\");\n        return 1;\n    }\n    \n    printf(\"Path is not accessible\\n\");\n    return 0;\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        \n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        \n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *soots_deveined = 0;\n  char **antioxygenic_addressful = 0;\n  long thyreoidectomy_kautsky[10];\n  char **unpromise_liukiu[10] = {0};\n  char *titleless_yaguaza[67] = {0};\n  char *urradhus_carpentaria;;\n  if (__sync_bool_compare_and_swap(&semioval_pathwayed,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      urradhus_carpentaria = getenv(\"FAUSTUS_LAZIO\");\n      if (urradhus_carpentaria != 0) {;\n        titleless_yaguaza[50] = urradhus_carpentaria;\n        unpromise_liukiu[5] = titleless_yaguaza;\n        thyreoidectomy_kautsky[1] = 5;\n        antioxygenic_addressful =  *(unpromise_liukiu + thyreoidectomy_kautsky[1]);\n        soots_deveined = ((char *)antioxygenic_addressful[50]);\n    \n    str = malloc(sizeof(char) * (strlen(soots_deveined) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(soots_deveined) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(soots_deveined, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n               if (is_valid(abs_path)) {\n                  \n                    \n                    waitForChange(abs_path, sleep_file);\n                   \n                   \n                    \n                    file = fopen(abs_path,\"rb\");\n                    fseek(file,0,2);\n                    size = ftell(file);\n                    rewind(file);\n                    buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                    if (buffer != NULL) {\n                        fread(buffer,sizeof(char ),size,file);\n                        buffer[size] = '\\0';\n                        printf(buffer);\n                        free(buffer);\n                    }\n                   \n                    fclose(file);\n                }\n            }\n            free(abs_path);\n        }\n        free(str);\n    } else {\n       \n        printf(\"Error parsing input.\\n\");\n    }\n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "B.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition|E.CWE-691:Insufficient Control Flow Management", "cwe": "367", "idx": "150007"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1108:Excessive Reliance on Global Variables\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.No Vulnerabilities\nE.CWE-420:Unprotected Alternate Channel", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bSink(char * dataArray[]);\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    dataArray[2] = data;\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bG2BSink(dataArray);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246209"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-593:Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created\nD.CWE-215:Insertion of Sensitive Information Into Debugging Code\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nstatic void mSink(char * data)\n{\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_44()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(char * data)\n{\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    funcPtr(data);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_spawnv_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_spawnv_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245302"}
{"selection": "A.CWE-186:Overly Restrictive Regular Expression\nB.No Vulnerabilities\nC.CWE-433:Unparsed Raw Web Content Delivery\nD.CWE-476:NULL Pointer Dereference\nE.CWE-710:Improper Adherence to Coding Standards", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nint sloths_nonvirtuously = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid paraglossal_propleuron(int pompster_manganate,... );\nvoid encrinidae_choriambi(char *complish_orinasality);\nvoid insulinizing_uppiles(char *subattenuate_unzip);\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  int dongola_usucaptible = 0;\n  char *aweing_criseyde = 0;\n  char *seminomas_neurosynapse;;\n  if (__sync_bool_compare_and_swap(&sloths_nonvirtuously,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      seminomas_neurosynapse = getenv(\"UNENJOYABLENESS_GLUMALES\");\n      if (seminomas_neurosynapse != 0) {;\n        dongola_usucaptible = ((int )(strlen(seminomas_neurosynapse)));\n        aweing_criseyde = ((char *)(malloc(dongola_usucaptible + 1)));\n        if (aweing_criseyde == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(aweing_criseyde,0,dongola_usucaptible + 1);\n        memcpy(aweing_criseyde,seminomas_neurosynapse,dongola_usucaptible);\n        paraglossal_propleuron(1,aweing_criseyde);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid paraglossal_propleuron(int pompster_manganate,... )\n{\n  char *seignories_radiologically = 0;\n  va_list interleague_nondeductive;\n  ++global_variable;;\n  if (pompster_manganate > 0) {\n    __builtin_va_start(interleague_nondeductive,pompster_manganate);\n    seignories_radiologically = (va_arg(interleague_nondeductive,char *));\n    __builtin_va_end(interleague_nondeductive);\n  }\n  encrinidae_choriambi(seignories_radiologically);\n}\n\nvoid encrinidae_choriambi(char *complish_orinasality)\n{\n  ++global_variable;;\n  insulinizing_uppiles(complish_orinasality);\n}\n\nvoid insulinizing_uppiles(char *subattenuate_unzip)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *sanctologist_nonlimitative = 0;\n  ++global_variable;;\n  sanctologist_nonlimitative = ((char *)subattenuate_unzip);\n      \n      len = strtol(sanctologist_nonlimitative,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (subattenuate_unzip != 0) \n    free(((char *)subattenuate_unzip));\nclose_printf_context();\n}", "answer": "D.CWE-476:NULL Pointer Dereference|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149266"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-672:Operation on a Resource after Expiration or Release\nC.CWE-6:J2EE Misconfiguration: Insufficient Session-ID Length\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_wchar_t_connect_socket_81\n{\n\nclass _LDAP_Injection__w32_wchar_t_connect_socket_81_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_wchar_t_connect_socket_81 : public _LDAP_Injection__w32_wchar_t_connect_socket_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_wchar_t_connect_socket_81G2B : public _LDAP_Injection__w32_wchar_t_connect_socket_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n}", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123131"}
{"selection": "A.CWE-318:Cleartext Storage of Sensitive Information in Executable\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-188:Reliance on Data/Memory Layout", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef struct __LDAP_Injection__w32_char_listen_socket_67_structType\n{\n    char * structFirst;\n} _LDAP_Injection__w32_char_listen_socket_67_structType;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_67bSink(_LDAP_Injection__w32_char_listen_socket_67_structType myStruct);\n\nvoid _LDAP_Injection__w32_char_listen_socket_67()\n{\n    char * data;\n    _LDAP_Injection__w32_char_listen_socket_67_structType myStruct;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_char_listen_socket_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_67bG2BSink(_LDAP_Injection__w32_char_listen_socket_67_structType myStruct);\n\nstatic void nG2B()\n{\n    char * data;\n    _LDAP_Injection__w32_char_listen_socket_67_structType myStruct;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_char_listen_socket_67bG2BSink(myStruct);\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123078"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nC.CWE-1233:Security-Sensitive Hardware Controls with Missing Lock Bit Protection\nD.CWE-427:Uncontrolled Search Path Element\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint acquirements_empest = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  int is_valid = 1;\n  int i = 0;\n  char cmd_str[1000] = {0};\n  char *malpoise_disappointment = 0;\n  int shewer_orthostatai;\n  int petrie_pugrees;\n  int opposable_enumerators;\n  char **kiack_noninhabitancy = 0;\n  char **reptilia_heptanes = 0;\n  char *handlists_ignified;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&acquirements_empest,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&handlists_ignified,\"UNLAGGING_BURR\");\n      if (handlists_ignified != 0) {;\n        opposable_enumerators = 1;\n        kiack_noninhabitancy = &handlists_ignified;\n        reptilia_heptanes = ((char **)(((unsigned long )kiack_noninhabitancy) * opposable_enumerators * opposable_enumerators)) + 5;\n        petrie_pugrees = 5;\n        while(1 == 1){\n          petrie_pugrees = petrie_pugrees * 2;\n          petrie_pugrees = petrie_pugrees + 2;\n          if (petrie_pugrees > 1000) {\n            break; \n          }\n        }\n        shewer_orthostatai = petrie_pugrees;\n        malpoise_disappointment = ((char *)( *(reptilia_heptanes - 5)));\n    \n    \n\n    snprintf(cmd_str, 1000, \"vim -s \" \"/opt/cus/workspace/testData/\" \"vim_scripts/hello.vim %s\", malpoise_disappointment);\n    \n    for (; i < strlen(malpoise_disappointment); ++i) {\n        if (malpoise_disappointment[i] == ';') {\n          if (i == 0 || malpoise_disappointment[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (malpoise_disappointment[i] == '|') {\n          if (i == 0 || malpoise_disappointment[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (malpoise_disappointment[i] == '|') {\n          if (i == 0 || malpoise_disappointment[i - 1] != '|') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (malpoise_disappointment[i] == '&') {\n          if (i == 0 || malpoise_disappointment[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (malpoise_disappointment[i] == '&') {\n          if (i == 0 || malpoise_disappointment[i - 1] != '&') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      \n      if (is_valid == 1) {\n        \n\n        fpipe = popen(cmd_str, \"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if ( *(reptilia_heptanes - 5) != 0) \n          free(((char *)( *(reptilia_heptanes - 5))));\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}", "answer": "B.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|A.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152788"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-636:Not Failing Securely ('Failing Open')\nC.No Vulnerabilities\nD.CWE-15:External Control of System or Configuration Setting\nE.CWE-1266:Improper Scrubbing of Sensitive Data from Decommissioned Device", "code": "#include \"std_testcase.h\"\n#include <vector>\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<char *> dataVector);\n\nvoid m()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<char *> dataVector);\n\nstatic void nG2B()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-15:External Control of System or Configuration Setting|A.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82019"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-529:Exposure of Access Control List Files to an Unauthorized Control Sphere\nC.CWE-910:Use of Expired File Descriptor\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_52bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_listen_socket_52()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_listen_socket_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_52bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_listen_socket_52bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123069"}
{"selection": "A.CWE-369:Divide By Zero\nB.CWE-690:Unchecked Return Value to NULL Pointer Dereference\nC.No Vulnerabilities\nD.CWE-1119:Excessive Use of Unconditional Branching\nE.CWE-707:Improper Neutralization", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint brilliantine_tribrachs = 0;\ntypedef char *sculpturesque_cofounder;\nint global_variable;\nvoid jurez_fowl(sculpturesque_cofounder *thirstless_viably);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid noncitizens_turboalternator(void (*unplannedly_midsummerish)(sculpturesque_cofounder *));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&brilliantine_tribrachs,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      noncitizens_turboalternator(jurez_fowl);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid jurez_fowl(sculpturesque_cofounder *thirstless_viably)\n{\n  sculpturesque_cofounder capman_vespoid = 0;\n  char *muscadels_gymnotoka;\n  ++global_variable;;\n  setup_printf_context();\n  muscadels_gymnotoka = getenv(\"GRIZEL_ARCHON\");\n  if (muscadels_gymnotoka != 0) {;\n    capman_vespoid = muscadels_gymnotoka;\n     *thirstless_viably = capman_vespoid;\n  }\n}\n\nvoid noncitizens_turboalternator(void (*unplannedly_midsummerish)(sculpturesque_cofounder *))\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *myringomycosis_avower = 0;\n  sculpturesque_cofounder unevasiveness_peripheroceptor = 0;\n  int *panaceas_uralian = 0;\n  int phrenopathy_entertake;\n  sculpturesque_cofounder firsts_hexade[10] = {0};\n  ++global_variable;\n  sculpturesque_cofounder boldnesses_endecha = 0;\n  unplannedly_midsummerish(&boldnesses_endecha);\n  if (boldnesses_endecha != 0) {;\n    firsts_hexade[5] = boldnesses_endecha;\n    phrenopathy_entertake = 5;\n    panaceas_uralian = &phrenopathy_entertake;\n    unevasiveness_peripheroceptor =  *(firsts_hexade +  *panaceas_uralian);\n    myringomycosis_avower = ((char *)unevasiveness_peripheroceptor);\n    \n    input = atoi(myringomycosis_avower);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\nclose_printf_context();\n  }\n}", "answer": "A.CWE-369:Divide By Zero|E.CWE-707:Improper Neutralization", "cwe": "369", "idx": "150759"}
{"selection": "A.CWE-191:Integer Underflow (Wrap or Wraparound)\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1111:Incomplete I/O Documentation\nE.CWE-1320:Improper Protection for Outbound Error Messages and Alert Signals", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint razorfish_smolder = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid brachycerous_terbia(int stultifies_unsedulous,void ***ltzen_menialness);\nint 191_global_var = 0;\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  int featherwood_chloroplatinate = 7;\n  void ***polyprothetic_desulphurising = 0;\n  void **gambrills_lehay = 0;\n  void *exasperative_skedaddled = 0;\n  void *osteosteatoma_dme = 0;\n  char *hinayana_heliolithic;;\n  if (__sync_bool_compare_and_swap(&razorfish_smolder,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&hinayana_heliolithic,\"FIDDLED_UNAVOIDABLE\");\n      if (hinayana_heliolithic != 0) {;\n        osteosteatoma_dme = ((void *)hinayana_heliolithic);\n        gambrills_lehay = &osteosteatoma_dme;\n        polyprothetic_desulphurising = &gambrills_lehay;\n        brachycerous_terbia(featherwood_chloroplatinate,polyprothetic_desulphurising);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid brachycerous_terbia(int stultifies_unsedulous,void ***ltzen_menialness)\n{\n        char buff[128];\n        short max_size = 128;\n        short remaining_space = 0;\n        int size = 0;\n        FILE * file = 0;\n  char *leanora_islanded = 0;\n  ++global_variable;\n  stultifies_unsedulous--;\n  if (stultifies_unsedulous > 0) {\n    brachycerous_terbia(stultifies_unsedulous,ltzen_menialness);\n    return ;\n  }\n  leanora_islanded = ((char *)((char *)( *( *ltzen_menialness))));\n        \n        file = fopen(leanora_islanded, \"r\");\n        if(file != NULL){\n                fseek(file, 0, SEEK_END);\n                size = ftell(file);\n                fseek(file, 0, SEEK_SET);\n                \n                \n                remaining_space = max_size - size;\n                \n                \n                \n                \n                if(remaining_space > 0){\n                        fscanf(file, \"%s\", buff);\n                        printf(\"Contents of file: %s\\n\", buff);\n                }\n                \n                fclose(file);\n        }\n        \n;\n  if (((char *)( *( *ltzen_menialness))) != 0) \n    free(((char *)((char *)( *( *ltzen_menialness)))));\nclose_printf_context();\n}\n#endif", "answer": "A.CWE-191:Integer Underflow (Wrap or Wraparound)|C.CWE-707:Improper Neutralization", "cwe": "191", "idx": "151234"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-36:Absolute Path Traversal\nC.CWE-9:J2EE Misconfiguration: Weak Access Permissions for EJB Methods\nD.No Vulnerabilities\nE.CWE-412:Unrestricted Externally Accessible Lock", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97006"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-414:Missing Lock Check\nD.CWE-36:Absolute Path Traversal\nE.CWE-402:Transmission of Private Resources into a New Sphere ('Resource Leak')", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_fopen_45\n{\n\nstatic char * mData;\nstatic char * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    char * data = mData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    char * data = nG2BData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_fopen_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95806"}
{"selection": "A.CWE-1224:Improper Restriction of Write-Once Bit Fields\nB.CWE-197:Numeric Truncation Error\nC.CWE-707:Improper Neutralization\nD.CWE-548:Exposure of Information Through Directory Listing\nE.No Vulnerabilities", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint castora_shiism = 0;\n\nstruct subiodide_ussher \n{\n  char *nonpoet_domatium;\n  double monkeyed_cantoner;\n  char *lymphology_anodonta;\n  char contralateral_bedfoot;\n  int krusenstern_insweeping;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nunsigned int avdevice_version()\n{\n    long number;\n    struct struct_data *data = 0;\n  char *banding_unriddles = 0;\n  int overwing_approbations;\n  int graecise_replaced;\n  int tangences_skeans;\n  struct subiodide_ussher *sibelle_sabbathlike = {0};\n  struct subiodide_ussher *morphotic_nos = {0};\n  struct subiodide_ussher disillusive_amroc;\n  char *securifera_kvinter;;\n  if (__sync_bool_compare_and_swap(&castora_shiism,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&securifera_kvinter,\"NONFEUDALLY_GALACTOGOGUE\");\n      if (securifera_kvinter != 0) {;\n        disillusive_amroc . nonpoet_domatium = ((char *)securifera_kvinter);\n        tangences_skeans = 1;\n        sibelle_sabbathlike = &disillusive_amroc;\n        morphotic_nos = ((struct subiodide_ussher *)(((unsigned long )sibelle_sabbathlike) * tangences_skeans * tangences_skeans)) + 5;\n        graecise_replaced = 5;\n        while(1 == 1){\n          graecise_replaced = graecise_replaced * 2;\n          graecise_replaced = graecise_replaced + 2;\n          if (graecise_replaced > 1000) {\n            break; \n          }\n        }\n        overwing_approbations = graecise_replaced;\n        banding_unriddles = ((char *)( *(morphotic_nos - 5)) . nonpoet_domatium);\n    \n    number = strtol(banding_unriddles,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n        if (( *(morphotic_nos - 5)) . nonpoet_domatium != 0) \n          free(((char *)( *(morphotic_nos - 5)) . nonpoet_domatium));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}", "answer": "B.CWE-197:Numeric Truncation Error|C.CWE-707:Improper Neutralization", "cwe": "197", "idx": "150713"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-23:Relative Path Traversal\nD.CWE-1262:Improper Access Control for Register Interface\nE.CWE-1271:Uninitialized Value on Reset for Registers Holding Security Settings", "code": "#include \"std_testcase.h\"\n#include <vector>\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<wchar_t *> dataVector);\n\nvoid m()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<wchar_t *> dataVector);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_open_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91445"}
{"selection": "A.CWE-939:Improper Authorization in Handler for Custom URL Scheme\nB.CWE-707:Improper Neutralization\nC.CWE-290:Authentication Bypass by Spoofing\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_listen_socket_ofstream_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_ofstream_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90673"}
{"selection": "A.No Vulnerabilities\nB.CWE-1121:Excessive McCabe Cyclomatic Complexity\nC.CWE-248:Uncaught Exception\nD.CWE-707:Improper Neutralization\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\nusing namespace std;\n\nnamespace _LDAP_Injection__w32_char_connect_socket_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, char *> dataMap);\n\nvoid m()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, char *> dataMap);\n\nstatic void nG2B()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_connect_socket_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122890"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-589:Call to Non-ubiquitous API\nE.CWE-385:Covert Timing Channel", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66bSink(wchar_t * dataArray[]);\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66bG2BSink(wchar_t * dataArray[]);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    dataArray[2] = data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_66bG2BSink(dataArray);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123317"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-842:Placement of User into Incorrect Group\nC.CWE-200:Exposure of Sensitive Information to an Unauthorized Actor\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscat(data, L\"Doe, XXXXX\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123108"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-768:Incorrect Short Circuit Evaluation\nC.No Vulnerabilities\nD.CWE-447:Unimplemented or Unsupported Feature in UI\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97822"}
{"selection": "A.No Vulnerabilities\nB.CWE-334:Small Space of Random Values\nC.CWE-23:Relative Path Traversal\nD.CWE-707:Improper Neutralization\nE.CWE-488:Exposure of Data Element to Wrong Session", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_fopen_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_fopen_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91053"}
{"selection": "A.CWE-1266:Improper Scrubbing of Sensitive Data from Decommissioned Device\nB.CWE-36:Absolute Path Traversal\nC.CWE-707:Improper Neutralization\nD.CWE-269:Improper Privilege Management\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nchar * _Absolute_Path_Traversal__char_environment_fopen_68Data;\nchar * _Absolute_Path_Traversal__char_environment_fopen_68G2BData;\n\nnamespace _Absolute_Path_Traversal__char_environment_fopen_68\n{\n\n#ifndef OMITM\n\n\nvoid mSink();\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    _Absolute_Path_Traversal__char_environment_fopen_68Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    _Absolute_Path_Traversal__char_environment_fopen_68G2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_fopen_68; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96058"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-1232:Improper Lock Behavior After Power State Transition", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_14()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245192"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-319:Cleartext Transmission of Sensitive Information\nE.CWE-1079:Parent Class without Virtual Destructor Method", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_console_w32_execvp_18()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcat(data, \"*.*\");\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_console_w32_execvp_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32_execvp_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32_execvp_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244724"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-480:Use of Incorrect Operator\nC.CWE-36:Absolute Path Traversal\nD.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_file_w32CreateFile_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_w32CreateFile_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96466"}
{"selection": "A.No Vulnerabilities\nB.CWE-550:Server-generated Error Message Containing Sensitive Information\nC.CWE-707:Improper Neutralization\nD.CWE-114:Process Control\nE.CWE-1264:Hardware Logic with Insecure De-Synchronization between Control and Data Channels", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _Process_Control__w32_wchar_t_file_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic wchar_t * nG2B1Source(wchar_t * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic wchar_t * nG2B2Source(wchar_t * data)\n{\n    if(nG2B2Static)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62390"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.No Vulnerabilities\nC.CWE-528:Exposure of Core Dump File to an Unauthorized Control Sphere\nD.CWE-926:Improper Export of Android Application Components\nE.CWE-707:Improper Neutralization", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint precontriving_postvorta = 0;\nint global_variable;\n\nstruct virus_petrarchesque \n{\n  char *foreworld_invoiced;\n  double karaganda_daniglacial;\n  char *assuringly_prediminishment;\n  char zimme_thermolyzing;\n  int malvia_liquet;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid commie_aircraftwoman(struct virus_petrarchesque **********circumspatial_hygienes);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  void (*oversolidify_outraising)(struct virus_petrarchesque **********) = commie_aircraftwoman;\n  struct virus_petrarchesque **********seroot_polyaxone = 0;\n  struct virus_petrarchesque *********whitebook_aeschynanthus = 0;\n  struct virus_petrarchesque ********twelve_hertzog = 0;\n  struct virus_petrarchesque *******terminalis_strockle = 0;\n  struct virus_petrarchesque ******splenatrophia_sabah = 0;\n  struct virus_petrarchesque *****villageful_battiness = 0;\n  struct virus_petrarchesque ****quitclaim_omnisentient = 0;\n  struct virus_petrarchesque ***lim_memorise = 0;\n  struct virus_petrarchesque **ashine_cinnabars = 0;\n  struct virus_petrarchesque *maxma_seamount = 0;\n  struct virus_petrarchesque outawing_barbabas = {0};\n  struct virus_petrarchesque plumerville_parenthesis;\n  char *melanger_metricise;;\n  if (__sync_bool_compare_and_swap(&precontriving_postvorta,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&melanger_metricise,\"EXCRETA_CHINDEE\");\n      if (melanger_metricise != 0) {;\n        plumerville_parenthesis . foreworld_invoiced = ((char *)melanger_metricise);\n        maxma_seamount = &plumerville_parenthesis;\n        ashine_cinnabars = &maxma_seamount;\n        lim_memorise = &ashine_cinnabars;\n        quitclaim_omnisentient = &lim_memorise;\n        villageful_battiness = &quitclaim_omnisentient;\n        splenatrophia_sabah = &villageful_battiness;\n        terminalis_strockle = &splenatrophia_sabah;\n        twelve_hertzog = &terminalis_strockle;\n        whitebook_aeschynanthus = &twelve_hertzog;\n        seroot_polyaxone = &whitebook_aeschynanthus;\n        oversolidify_outraising(seroot_polyaxone);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid commie_aircraftwoman(struct virus_petrarchesque **********circumspatial_hygienes)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *rubberizing_seabees = 0;\n  ++global_variable;;\n  rubberizing_seabees = ((char *)( *( *( *( *( *( *( *( *( *( *circumspatial_hygienes)))))))))) . foreworld_invoiced);\n    \n    if (strlen(rubberizing_seabees) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,rubberizing_seabees);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n  if (( *( *( *( *( *( *( *( *( *( *circumspatial_hygienes)))))))))) . foreworld_invoiced != 0) \n    free(((char *)( *( *( *( *( *( *( *( *( *( *circumspatial_hygienes)))))))))) . foreworld_invoiced));\nclose_printf_context();\n}\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152290"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.No Vulnerabilities\nD.CWE-561:Dead Code\nE.CWE-653:Improper Isolation or Compartmentalization", "code": "#include \"std_testcase.h\"\n#include <vector>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\nusing namespace std;\n\nnamespace _LDAP_Injection__w32_wchar_t_connect_socket_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<wchar_t *> dataVector);\n\nvoid m()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<wchar_t *> dataVector);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_connect_socket_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123128"}
{"selection": "A.CWE-654:Reliance on a Single Factor in a Security Decision\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-36:Absolute Path Traversal\nE.CWE-448:Obsolete Feature in UI", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96870"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-489:Active Debug Code\nC.No Vulnerabilities\nD.CWE-298:Improper Validation of Certificate Expiration\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\n\nstatic int staticFive = 5;\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_07\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_07; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95976"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-784:Reliance on Cookies without Validation and Integrity Checking in a Security Decision\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-1243:Sensitive Non-Volatile Information Not Protected During Debug", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_console_54bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_console_54()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    _LDAP_Injection__w32_char_console_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_console_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_console_54bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_console_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_console_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_console_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122927"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nD.CWE-383:J2EE Bad Practices: Direct Use of Threads\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n#include <list>\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_w32CreateFile_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_w32CreateFile_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90294"}
{"selection": "A.No Vulnerabilities\nB.CWE-1278:Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\nC.CWE-707:Improper Neutralization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-313:Cleartext Storage in a File or on Disk", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_63bSink(wchar_t * * dataPtr);\n\nvoid _LDAP_Injection__w32_wchar_t_file_63()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_63bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123266"}
{"selection": "A.CWE-245:J2EE Bad Practices: Direct Management of Connections\nB.No Vulnerabilities\nC.CWE-749:Exposed Dangerous Method or Function\nD.CWE-23:Relative Path Traversal\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89830"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.CWE-707:Improper Neutralization\nC.CWE-446:UI Discrepancy for Security Feature\nD.No Vulnerabilities\nE.CWE-595:Comparison of Object References Instead of Object Contents", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_14()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81991"}
{"selection": "A.CWE-285:Improper Authorization\nB.No Vulnerabilities\nC.CWE-23:Relative Path Traversal\nD.CWE-707:Improper Neutralization\nE.CWE-1127:Compilation with Insufficient Warnings or Errors", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_listen_socket_fopen_34\n{\n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} unionType;\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            FILE *pFile = NULL;\n            \n            pFile = FOPEN(data, \"wb+\");\n            if (pFile != NULL)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            FILE *pFile = NULL;\n            \n            pFile = FOPEN(data, \"wb+\");\n            if (pFile != NULL)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_fopen_34; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90563"}
{"selection": "A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.No Vulnerabilities\nC.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling\nD.CWE-269:Improper Privilege Management\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint underfeel_myringomycosis = 0;\nint global_variable;\nvoid handle_taint(char *bandboxy_crosshauling);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid classmates_gothicist(char **inject_implacement);\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&underfeel_myringomycosis,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *bandboxy_crosshauling)\n{\n  void (*brindlish_chiefage)(char **) = classmates_gothicist;\n  char **violater_raptors = 0;\n  ++global_variable;;\n  if (bandboxy_crosshauling != 0) {;\n    violater_raptors = &bandboxy_crosshauling;\n    brindlish_chiefage(violater_raptors);\n  }\n}\n\nvoid classmates_gothicist(char **inject_implacement)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *snowcap_funnelwise = 0;\n  ++global_variable;;\n  snowcap_funnelwise = ((char *)( *inject_implacement));\n    \n    if (strlen(snowcap_funnelwise) > 0 &&\n            snowcap_funnelwise[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(snowcap_funnelwise,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n  if ( *inject_implacement != 0) \n    free(((char *)( *inject_implacement)));\nclose_printf_context();\n}", "answer": "C.CWE-774:Allocation of File Descriptors or Handles Without Limits or Throttling|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "774", "idx": "152104"}
{"selection": "A.CWE-331:Insufficient Entropy\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-322:Key Exchange without Entity Authentication", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_05\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_05; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91840"}
{"selection": "A.No Vulnerabilities\nB.CWE-215:Insertion of Sensitive Information Into Debugging Code\nC.CWE-114:Process Control\nD.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_03()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|E.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62470"}
{"selection": "A.CWE-1102:Reliance on Machine-Dependent Data Representation\nB.CWE-662:Improper Synchronization\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96797"}
{"selection": "A.CWE-1231:Improper Prevention of Lock Bit Modification\nB.No Vulnerabilities\nC.CWE-1254:Incorrect Comparison Logic Granularity\nD.CWE-707:Improper Neutralization\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_83\n{\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__wchar_t_console_fopen_83\n{\npublic:\n    _Absolute_Path_Traversal__wchar_t_console_fopen_83(wchar_t * dataCopy);\n    ~_Absolute_Path_Traversal__wchar_t_console_fopen_83();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__wchar_t_console_fopen_83G2B\n{\npublic:\n    _Absolute_Path_Traversal__wchar_t_console_fopen_83G2B(wchar_t * dataCopy);\n    ~_Absolute_Path_Traversal__wchar_t_console_fopen_83G2B();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n}", "answer": "E.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97024"}
{"selection": "A.CWE-925:Improper Verification of Intent by Broadcast Receiver\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1302:Missing Security Identifier\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define SYSTEM system\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_connect_socket_system_52bSink(char * data);\n\nvoid _OS_Command_Injection__char_connect_socket_system_52()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__char_connect_socket_system_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_connect_socket_system_52bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_connect_socket_system_52bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_connect_socket_system_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_system_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_system_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244173"}
{"selection": "A.No Vulnerabilities\nB.CWE-210:Self-generated Error Message Containing Sensitive Information\nC.CWE-707:Improper Neutralization\nD.CWE-512:Spyware\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscpy(data, L\"winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62489"}
{"selection": "A.CWE-758:Reliance on Undefined, Unspecified, or Implementation-Defined Behavior\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-290:Authentication Bypass by Spoofing\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_10()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245804"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-837:Improper Enforcement of a Single, Unique Action\nD.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_connect_socket_10()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_connect_socket_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_connect_socket_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_connect_socket_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62237"}
{"selection": "A.CWE-1393:Use of Default Password\nB.CWE-422:Unprotected Windows Messaging Channel ('Shatter')\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-820:Missing Synchronization\nE.No Vulnerabilities", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint acclimates_repropitiation = 0;\n\nstruct taurean_physostigma \n{\n  char *precolonial_theomachy;\n  double anaglyphical_overexcitements;\n  char *zapu_cuartillo;\n  char fourmile_procapital;\n  int mountainy_laggins;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *deathful_batters = 0;\n  int phenylated_rutaceae;\n  int sambos_inverson;\n  struct taurean_physostigma *geoduck_peroxidase = {0};\n  struct taurean_physostigma *imperialisation_usrc = {0};\n  struct taurean_physostigma novellike_gemma;\n  char *gardant_apparens;;\n  if (__sync_bool_compare_and_swap(&acclimates_repropitiation,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&gardant_apparens,\"VERNAL_UNTRESPASSING\");\n      if (gardant_apparens != 0) {;\n        novellike_gemma . precolonial_theomachy = ((char *)gardant_apparens);\n        geoduck_peroxidase = &novellike_gemma;\n        imperialisation_usrc = geoduck_peroxidase + 5;\n        sambos_inverson = 5;\n        while(1 == 1){\n          sambos_inverson = sambos_inverson * 2;\n          sambos_inverson = sambos_inverson + 2;\n          if (sambos_inverson > 1000) {\n            break; \n          }\n        }\n        phenylated_rutaceae = sambos_inverson;\n        deathful_batters = ((char *)( *(imperialisation_usrc - 5)) . precolonial_theomachy);\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(deathful_batters) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(deathful_batters) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(deathful_batters) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(deathful_batters, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\n        if (( *(imperialisation_usrc - 5)) . precolonial_theomachy != 0) \n          free(((char *)( *(imperialisation_usrc - 5)) . precolonial_theomachy));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "D.CWE-820:Missing Synchronization|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "820", "idx": "150689"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-305:Authentication Bypass by Primary Weakness\nC.CWE-733:Compiler Optimization Removal or Modification of Security-critical Code\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91000"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-676:Use of Potentially Dangerous Function\nE.CWE-195:Signed to Unsigned Conversion Error", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint overlocker_occurse = 0;\nint global_variable;\n\nstruct preoccupate_monobromated \n{\n  char *foreship_cadorna;\n  double beduchess_logbook;\n  char *unimplicated_arterioverter;\n  char papelera_magnelectric;\n  int prosaic_nonearning;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *joeyes_hadden = 0;\n  struct preoccupate_monobromated pares_baltimorite;\n  char *parnellite_rougy;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&overlocker_occurse,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&parnellite_rougy,\"AURA_STOICISMS\");\n      if (parnellite_rougy != 0) {;\n        pares_baltimorite . foreship_cadorna = ((char *)parnellite_rougy);\n        if (pares_baltimorite . foreship_cadorna != 0) {\n          goto pryse_breaching;\n        }\n        ++global_variable;\n        pryse_breaching:;\n        joeyes_hadden = ((char *)pares_baltimorite . foreship_cadorna);\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, joeyes_hadden);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, joeyes_hadden, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\n        if (pares_baltimorite . foreship_cadorna != 0) \n          free(((char *)pares_baltimorite . foreship_cadorna));\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}", "answer": "E.CWE-195:Signed to Unsigned Conversion Error|B.CWE-707:Improper Neutralization", "cwe": "195", "idx": "151067"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-331:Insufficient Entropy\nD.CWE-566:Authorization Bypass Through User-Controlled SQL Primary Key\nE.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint folsom_schorls = 0;\n\nunion fellatrice_experting \n{\n  char *skippingly_distractive;\n  double stereovision_anissa;\n  char *donelson_obverted;\n  char tidyism_uncallous;\n  int fulciment_tyrocidin;\n}\n;\nint global_variable;\nvoid handle_taint(char *perigonal_gawky);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&folsom_schorls,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *perigonal_gawky)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  int is_valid = 1;\n  int i = 0;\n  char cmd_str[1000] = {0};\n  char *unblock_impartibilibly = 0;\n  union fellatrice_experting clouts_soporous = {0};\n  int *myectomize_abscind = 0;\n  int madegassy_woundily;\n  union fellatrice_experting unbereaved_ratter[10] = {0};\n  union fellatrice_experting reichsgulden_sectism;\n  ++global_variable;;\n  if (perigonal_gawky != 0) {;\n    reichsgulden_sectism . skippingly_distractive = perigonal_gawky;\n    madegassy_woundily = 5;\n    myectomize_abscind = &madegassy_woundily;\n    unbereaved_ratter[ *myectomize_abscind] = reichsgulden_sectism;\n    clouts_soporous = unbereaved_ratter[ *myectomize_abscind];\n    unblock_impartibilibly = ((char *)clouts_soporous . skippingly_distractive);\n    \n    \n\n    snprintf(cmd_str, 1000, \"vim -s \" \"/opt/cus/workspace/testData/\" \"vim_scripts/hello.vim %s\", unblock_impartibilibly);\n    \n    for (; i < strlen(unblock_impartibilibly); ++i) {\n        if (unblock_impartibilibly[i] == ';') {\n          if (i == 0 || unblock_impartibilibly[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (unblock_impartibilibly[i] == '|') {\n          if (i == 0 || unblock_impartibilibly[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (unblock_impartibilibly[i] == '|') {\n          if (i == 0 || unblock_impartibilibly[i - 1] != '|') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (unblock_impartibilibly[i] == '&') {\n          if (i == 0 || unblock_impartibilibly[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (unblock_impartibilibly[i] == '&') {\n          if (i == 0 || unblock_impartibilibly[i - 1] != '&') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      \n      if (is_valid == 1) {\n        \n\n        fpipe = popen(cmd_str, \"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n    if (clouts_soporous . skippingly_distractive != 0) \n      free(((char *)clouts_soporous . skippingly_distractive));\nclose_printf_context();\n  }\n}", "answer": "E.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|A.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152480"}
{"selection": "A.No Vulnerabilities\nB.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nC.CWE-23:Relative Path Traversal\nD.CWE-830:Inclusion of Web Functionality from an Untrusted Source\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91824"}
{"selection": "A.No Vulnerabilities\nB.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nC.CWE-707:Improper Neutralization\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-204:Observable Response Discrepancy", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECV _wexecv\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_w32_execv_14()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_console_w32_execv_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_w32_execv_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_w32_execv_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247032"}
{"selection": "A.No Vulnerabilities\nB.CWE-1266:Improper Scrubbing of Sensitive Data from Decommissioned Device\nC.CWE-288:Authentication Bypass Using an Alternate Path or Channel\nD.CWE-369:Divide By Zero\nE.CWE-707:Improper Neutralization", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint overmagnified_subdeaconship = 0;\nint global_variable;\nvoid lossenite_sella(void **sinarquist_stichter);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **));\nvoid *erythrophage_bourdis(void *lenotre_amputation);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&overmagnified_subdeaconship,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      receptible_recruitors(lossenite_sella);\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid lossenite_sella(void **sinarquist_stichter)\n{\n  void *runfish_catalyzing = 0;\n  char *cohere_monaghan;\n  ++global_variable;;\n  setup_printf_context();\n  cohere_monaghan = getenv(\"PREFABRICATES_DOORSTEPS\");\n  if (cohere_monaghan != 0) {;\n    runfish_catalyzing = ((void *)cohere_monaghan);\n     *sinarquist_stichter = runfish_catalyzing;\n  }\n}\n\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **))\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *ariadne_recent = 0;\n  void *rimpi_arrode = 0;\n  ++global_variable;\n  void *math_epithelioma = 0;\n  unestranged_bivalves(&math_epithelioma);\n  if (((char *)math_epithelioma) != 0) {;\n    rimpi_arrode = erythrophage_bourdis(math_epithelioma);\n    ariadne_recent = ((char *)((char *)rimpi_arrode));\n    \n    input = atoi(ariadne_recent);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\nclose_printf_context();\n  }\n}\n\nvoid *erythrophage_bourdis(void *lenotre_amputation)\n{\n  ++global_variable;\n  return lenotre_amputation;\n}", "answer": "D.CWE-369:Divide By Zero|E.CWE-707:Improper Neutralization", "cwe": "369", "idx": "151154"}
{"selection": "A.CWE-1270:Generation of Incorrect Security Tokens\nB.CWE-707:Improper Neutralization\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.No Vulnerabilities\nE.CWE-597:Use of Wrong Operator in String Comparison", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint deregulate_systemized = 0;\nint global_variable;\ntypedef char *kechi_udometry;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nkechi_udometry vaudoux_triton(kechi_udometry richton_semistriate);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *minstrelship_cse = 0;\n  kechi_udometry quaters_longeval = 0;\n  kechi_udometry gemless_sourdoughs = 0;\n  char *excavating_infestivity;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&deregulate_systemized,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      excavating_infestivity = getenv(\"MONOLINGUIST_SANDCULTURE\");\n      if (excavating_infestivity != 0) {;\n        gemless_sourdoughs = excavating_infestivity;\n        quaters_longeval = vaudoux_triton(gemless_sourdoughs);\n        if (quaters_longeval != 0) {\n          goto manutius_serjeantry;\n        }\n        ++global_variable;\n        manutius_serjeantry:;\n        minstrelship_cse = ((char *)quaters_longeval);\n    \n    if (strlen(minstrelship_cse) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,minstrelship_cse);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nkechi_udometry vaudoux_triton(kechi_udometry richton_semistriate)\n{\n  ++global_variable;\n  return richton_semistriate;\n}", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152698"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-402:Transmission of Private Resources into a New Sphere ('Resource Leak')\nC.CWE-1242:Inclusion of Undocumented Features or Chicken Bits\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_09()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123047"}
{"selection": "A.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nB.CWE-36:Absolute Path Traversal\nC.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nwchar_t * _Absolute_Path_Traversal__wchar_t_file_open_68Data;\nwchar_t * _Absolute_Path_Traversal__wchar_t_file_open_68G2BData;\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_open_68\n{\n\n#ifndef OMITM\n\n\nvoid mSink();\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _Absolute_Path_Traversal__wchar_t_file_open_68Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink();\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    _Absolute_Path_Traversal__wchar_t_file_open_68G2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_open_68; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97642"}
{"selection": "A.No Vulnerabilities\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-693:Protection Mechanism Failure\nD.CWE-707:Improper Neutralization\nE.CWE-1122:Excessive Halstead Complexity", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _execl\n#else \n#define EXECL execl\n#endif\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_execl_04()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_file_execl_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_execl_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_execl_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245422"}
{"selection": "A.No Vulnerabilities\nB.CWE-431:Missing Handler\nC.CWE-923:Improper Restriction of Communication Channel to Intended Endpoints\nD.CWE-114:Process Control\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_console_05()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_console_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_console_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_console_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|E.CWE-707:Improper Neutralization", "cwe": "114", "idx": "61992"}
{"selection": "A.No Vulnerabilities\nB.CWE-1114:Inappropriate Whitespace Style\nC.CWE-707:Improper Neutralization\nD.CWE-261:Weak Encoding for Password\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_fopen_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_fopen_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91751"}
{"selection": "A.CWE-1125:Excessive Attack Surface\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.No Vulnerabilities\nD.CWE-1177:Use of Prohibited Code\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_10()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123048"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-669:Incorrect Resource Transfer Between Spheres\nC.CWE-293:Using Referer Field for Authentication\nD.CWE-23:Relative Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * dataArray[]);\n\nvoid m()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89618"}
{"selection": "A.No Vulnerabilities\nB.CWE-1104:Use of Unmaintained Third Party Components\nC.CWE-664:Improper Control of a Resource Through its Lifetime\nD.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nE.CWE-1092:Use of Same Invokable Control Element in Multiple Architectural Layers", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint bontebuck_kwhr = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nSize PMSignalShmemSize()\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *agglomerates_amyotrophia = 0;\n  jmp_buf laharpe_akaniaceae;\n  int dubber_xxii;\n  int docentship_bombycidae;\n  void **preexcusing_koller = 0;\n  void **paut_lost = 0;\n  void *swording_disciplinant = 0;\n  int nonvoluntary_humuslike = 61;\n  char *overkill_corday;\n  Size size;\n  if (__sync_bool_compare_and_swap(&bontebuck_kwhr,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&overkill_corday,\"6225\",nonvoluntary_humuslike);\n      if (overkill_corday != 0) {;\n        swording_disciplinant = ((void *)overkill_corday);\n        docentship_bombycidae = 1;\n        preexcusing_koller = &swording_disciplinant;\n        paut_lost = ((void **)(((unsigned long )preexcusing_koller) * docentship_bombycidae * docentship_bombycidae)) + 5;\n        dubber_xxii = setjmp(laharpe_akaniaceae);\n        if (dubber_xxii == 0) {\n          longjmp(laharpe_akaniaceae,1);\n        }\n        agglomerates_amyotrophia = ((char *)((char *)( *(paut_lost - 5))));\n    \n files = fopen(agglomerates_amyotrophia,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n        if (((char *)( *(paut_lost - 5))) != 0) \n          free(((char *)((char *)( *(paut_lost - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "D.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|C.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "775", "idx": "152148"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.No Vulnerabilities\nC.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nD.CWE-568:finalize() Method Without super.finalize()\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_ofstream_83\n{\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__char_connect_socket_ofstream_83\n{\npublic:\n    _Absolute_Path_Traversal__char_connect_socket_ofstream_83(char * dataCopy);\n    ~_Absolute_Path_Traversal__char_connect_socket_ofstream_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__char_connect_socket_ofstream_83G2B\n{\npublic:\n    _Absolute_Path_Traversal__char_connect_socket_ofstream_83G2B(char * dataCopy);\n    ~_Absolute_Path_Traversal__char_connect_socket_ofstream_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95680"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-36:Absolute Path Traversal\nC.CWE-338:Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\nD.CWE-330:Use of Insufficiently Random Values\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_open_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_open_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95698"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1246:Improper Write Handling in Limited-write Non-Volatile Memories", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _wexeclp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_execlp_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    funcPtr(data);\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_execlp_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_execlp_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_execlp_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246438"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-1315:Improper Setting of Bus Controlling Capability in Fabric End-point\nD.CWE-191:Integer Underflow (Wrap or Wraparound)\nE.CWE-433:Unparsed Raw Web Content Delivery", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint axillas_allyl = 0;\ntypedef char *unsplendourous_dradge;\nint global_variable;\nvoid handle_taint(char *frowzier_inhumanism);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nint 191_global_var = 0;\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&axillas_allyl,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *frowzier_inhumanism)\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *methodize_preaccepted = 0;\n  unsplendourous_dradge *unbuxomly_avoy = 0;\n  unsplendourous_dradge *stroboscope_campaigns = 0;\n  unsplendourous_dradge detrimentally_maneh = 0;\n  ++global_variable;;\n  if (frowzier_inhumanism != 0) {;\n    detrimentally_maneh = frowzier_inhumanism;\n    unbuxomly_avoy = &detrimentally_maneh;\n    stroboscope_campaigns = unbuxomly_avoy + 5;\n    methodize_preaccepted = ((char *)( *(stroboscope_campaigns - 5)));\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(methodize_preaccepted, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n    if ( *(stroboscope_campaigns - 5) != 0) \n      free(((char *)( *(stroboscope_campaigns - 5))));\nclose_printf_context();\n  }\n}", "answer": "D.CWE-191:Integer Underflow (Wrap or Wraparound)|B.CWE-707:Improper Neutralization", "cwe": "191", "idx": "151165"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-507:Trojan Horse\nC.CWE-23:Relative Path Traversal\nD.CWE-568:finalize() Method Without super.finalize()\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_ifstream_83\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_connect_socket_ifstream_83\n{\npublic:\n    _Relative_Path_Traversal__char_connect_socket_ifstream_83(char * dataCopy);\n    ~_Relative_Path_Traversal__char_connect_socket_ifstream_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_connect_socket_ifstream_83G2B\n{\npublic:\n    _Relative_Path_Traversal__char_connect_socket_ifstream_83G2B(char * dataCopy);\n    ~_Relative_Path_Traversal__char_connect_socket_ifstream_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "C.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89674"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-246:J2EE Bad Practices: Direct Use of Sockets\nC.No Vulnerabilities\nD.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_fopen_01\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_fopen_01; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91020"}
{"selection": "A.CWE-1092:Use of Same Invokable Control Element in Multiple Architectural Layers\nB.CWE-821:Incorrect Synchronization\nC.CWE-754:Improper Check for Unusual or Exceptional Conditions\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint spittles_upperer = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_t t0, t1;\npthread_mutex_t mutex_0, mutex_1;\nint dev_amount = 1;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcDevamount(void *data) {\n    struct data *cusData = (struct data*)data;\n    int qsize;\n    \n    printf(\"Inside calcDevAmount\\n\");\n    pthread_mutex_lock(&mutex_0);\n    \n    \n    dev_amount = cusData->data[0] - 'A'; \n    qsize = cusData->qsize;\n    if (dev_amount < 0) { \n        dev_amount *= -1; \n    }\n    \n    readFile(cusData->file2);\n    if (dev_amount == 0) { \n        dev_amount += 1; \n    }\n    \n    \n    pthread_mutex_unlock(&mutex_0);\n    return NULL;\n}\nvoid *devChar(void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int i;\n    int *arr = NULL;\n    \n    printf(\"Inside devChar\\n\");\n    \n    arr = malloc(sizeof(int) * cusData->qsize);\n    pthread_mutex_lock(&mutex_1);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(cusData->file1);\n    \n    \n    \n    for (i = 0; i < strlen(cusData->data); i++) { \n        cusData->data[i] /= dev_amount; \n    }\n    \n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n    struct data* cusData;\n  char *slammakin_neverthelater = 0;\n  int fringelike_dottier;\n  int floaty_inducted;\n  void *capably_shrewishly = 0;\n  int laputically_subtlest = 204;\n  char *foaly_cloudland;;\n  if (__sync_bool_compare_and_swap(&spittles_upperer,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&foaly_cloudland,\"8303\",laputically_subtlest);\n      if (foaly_cloudland != 0) {;\n        capably_shrewishly = ((void *)foaly_cloudland);\n        floaty_inducted = 5;\n        while(1 == 1){\n          floaty_inducted = floaty_inducted * 2;\n          floaty_inducted = floaty_inducted + 2;\n          if (floaty_inducted > 1000) {\n            break; \n          }\n        }\n        fringelike_dottier = floaty_inducted;\n        slammakin_neverthelater = ((char *)((char *)capably_shrewishly));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(slammakin_neverthelater) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(slammakin_neverthelater) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(slammakin_neverthelater) + 1));\n        if (cusData->data) {\n            if ((sscanf(slammakin_neverthelater, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                \n                \n                \n                \n                \n                if (strlen(cusData->data) > 50) { \n                                                                                                    \n                    if (pthread_create(&t0, NULL, calcDevamount, cusData) != 0) { \n                        printf(\"Error initializing thread 0.\");\n                    }\n                }\n                if (pthread_create(&t1, NULL, devChar, cusData) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                if (strlen(cusData->data) > 50) {\n                    pthread_join(t0, NULL);\n                }\n                pthread_join(t1, NULL);\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n        if (((char *)capably_shrewishly) != 0) \n          free(((char *)((char *)capably_shrewishly)));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "B.CWE-821:Incorrect Synchronization|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "821", "idx": "150453"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-682:Incorrect Calculation\nD.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\nE.CWE-315:Cleartext Storage of Sensitive Information in a Cookie", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint doxie_colt = 0;\nint global_variable;\nvoid handle_taint(char *multitudinously_forewinning);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid prostitute_retimber(char ***tariffist_gallophile);\nvoid function() {\n    \n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&doxie_colt,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *multitudinously_forewinning)\n{\n  void (*borgh_unskaithd)(char ***) = prostitute_retimber;\n  char ***yattering_oralogy = 0;\n  char **unscoring_resaddles = 0;\n  char *vermix_sartorii = 0;\n  ++global_variable;;\n  if (multitudinously_forewinning != 0) {;\n    unscoring_resaddles = &multitudinously_forewinning;\n    yattering_oralogy = &unscoring_resaddles;\n    borgh_unskaithd(yattering_oralogy);\n  }\n}\n\nvoid prostitute_retimber(char ***tariffist_gallophile)\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *carshop_outdressed = 0;\n  ++global_variable;;\n  carshop_outdressed = ((char *)( *( *tariffist_gallophile)));\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(carshop_outdressed) >= 1 &&\n            carshop_outdressed[0] != '-') {\n        input_num = strtoul(carshop_outdressed,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(carshop_outdressed) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n  if ( *( *tariffist_gallophile) != 0) \n    free(((char *)( *( *tariffist_gallophile))));\nclose_printf_context();\n}", "answer": "C.CWE-682:Incorrect Calculation|B.CWE-707:Improper Neutralization", "cwe": "682", "idx": "150768"}
{"selection": "A.No Vulnerabilities\nB.CWE-300:Channel Accessible by Non-Endpoint\nC.CWE-476:NULL Pointer Dereference\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-161:Improper Neutralization of Multiple Leading Special Elements", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint makars_mayan = 0;\nint global_variable;\ntypedef char *tegument_unpushed;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\ntegument_unpushed imparisyllabic_ottillia(tegument_unpushed considerably_overattenuate);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *isophane_duikers = 0;\n  int insessorial_bahutu;\n  int neoteny_shynesses;\n  tegument_unpushed levining_gillaroo = 0;\n  tegument_unpushed legendarily_reposal = 0;\n  char *greatest_familiarly;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&makars_mayan,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      greatest_familiarly = getenv(\"DISHEVELLING_TESTAMENTATION\");\n      if (greatest_familiarly != 0) {;\n        legendarily_reposal = greatest_familiarly;\n        levining_gillaroo = imparisyllabic_ottillia(legendarily_reposal);\n        neoteny_shynesses = 5;\n        while(1 == 1){\n          neoteny_shynesses = neoteny_shynesses * 2;\n          neoteny_shynesses = neoteny_shynesses + 2;\n          if (neoteny_shynesses > 1000) {\n            break; \n          }\n        }\n        insessorial_bahutu = neoteny_shynesses;\n        isophane_duikers = ((char *)levining_gillaroo);\n      \n      while(isalnum(isophane_duikers[size]) && size < strlen(isophane_duikers)){\n        ++size;\n      }\n      \n\n      if (size != strlen(isophane_duikers)) {\n        isophane_duikers = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,isophane_duikers);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\ntegument_unpushed imparisyllabic_ottillia(tegument_unpushed considerably_overattenuate)\n{\n  ++global_variable;\n  return considerably_overattenuate;\n}", "answer": "C.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149440"}
{"selection": "A.CWE-691:Insufficient Control Flow Management\nB.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nC.CWE-1164:Irrelevant Code\nD.No Vulnerabilities\nE.CWE-1325:Improperly Controlled Sequential Memory Allocation", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint yeargain_archsaint = 0;\nint global_variable;\nvoid handle_taint(char *pennigerous_gemellione);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&yeargain_archsaint,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *pennigerous_gemellione)\n{\n int ss_i = 0;\n  char *soutar_coverts = 0;\n  ++global_variable;;\n  if (pennigerous_gemellione != 0) {;\n    if (pennigerous_gemellione != 0) {\n      goto imbrangling_dfrf;\n    }\n    ++global_variable;\n    imbrangling_dfrf:;\n    soutar_coverts = ((char *)pennigerous_gemellione);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(soutar_coverts)){\n  \n        if (soutar_coverts[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\n    if (pennigerous_gemellione != 0) \n      free(((char *)pennigerous_gemellione));\nclose_printf_context();\n  }\n}", "answer": "B.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')|A.CWE-691:Insufficient Control Flow Management", "cwe": "835", "idx": "152049"}
{"selection": "A.CWE-308:Use of Single-factor Authentication\nB.CWE-202:Exposure of Sensitive Information Through Data Queries\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_environment_05()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_environment_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122947"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-1291:Public Key Re-Use for Signing both Debug and Production Code\nC.No Vulnerabilities\nD.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123186"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-13:ASP.NET Misconfiguration: Password in Configuration File\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-576:EJB Bad Practices: Use of Java I/O", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96937"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-573:Improper Following of Specification by Caller\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-343:Predictable Value Range from Previous Values", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n#define EXECVP _wexecvp\n\nwchar_t * _OS_Command_Injection__wchar_t_file_w32_execvp_68Data;\nwchar_t * _OS_Command_Injection__wchar_t_file_w32_execvp_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68bSink();\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68Data = data;\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68G2BData = data;\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68bG2BSink();\n}\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248051"}
{"selection": "A.No Vulnerabilities\nB.CWE-1333:Inefficient Regular Expression Complexity\nC.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-1025:Comparison Using Wrong Factors", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <mysql.h> \n#include <cus/trace.h> \nint corrupting_ketene = 0;\nint global_variable;\nvoid acleistocardia_cloddiness(void **linen_saddlebacked);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid slumwise_bulldoze(void (*heterocercy_pigmy)(void **));\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&corrupting_ketene,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      slumwise_bulldoze(acleistocardia_cloddiness);\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lmysqlclient -lssl -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid acleistocardia_cloddiness(void **linen_saddlebacked)\n{\n  void *foreboded_elconin = 0;\n  int sansara_disdainable = 73;\n  char *lymphadenoid_overnighters;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&lymphadenoid_overnighters,\"8910\",sansara_disdainable);\n  if (lymphadenoid_overnighters != 0) {;\n    foreboded_elconin = ((void *)lymphadenoid_overnighters);\n     *linen_saddlebacked = foreboded_elconin;\n  }\n}\n\nvoid slumwise_bulldoze(void (*heterocercy_pigmy)(void **))\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  int random_int = 0;\n  char *boscovich_wither = 0;\n  void **showboard_pin = 0;\n  ++global_variable;\n  void *tyrantlike_bifrost = 0;\n  heterocercy_pigmy(&tyrantlike_bifrost);\n  if (((char *)tyrantlike_bifrost) != 0) {;\n    showboard_pin = &tyrantlike_bifrost;\n    boscovich_wither = ((char *)((char *)( *showboard_pin)));\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n    srand(time(NULL));\n    random_int = (rand() % 1000) + 100;\n                snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, boscovich_wither);\n    \n                \n                \n\n                if (mysql_query(conn,query_buffer)) {\n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n    } else {\n      printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n    if (((char *)( *showboard_pin)) != 0) \n      free(((char *)((char *)( *showboard_pin))));\nclose_printf_context();\n  }\n}", "answer": "C.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|D.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152500"}
{"selection": "A.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.No Vulnerabilities\nD.CWE-324:Use of a Key Past its Expiration Date\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _LDAP_Injection__w32_char_file_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, char *> dataMap);\n\nvoid m()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, char *> dataMap);\n\nstatic void nG2B()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_file_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123034"}
{"selection": "A.CWE-476:NULL Pointer Dereference\nB.CWE-693:Protection Mechanism Failure\nC.CWE-710:Improper Adherence to Coding Standards\nD.No Vulnerabilities\nE.CWE-597:Use of Wrong Operator in String Comparison", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint zircaloy_smashers = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nSize PMSignalShmemSize()\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *playa_voc = 0;\n  int puritanlike_saucerize;\n  int siepi_bequote;\n  char *baronetizing_snooperscope = 0;\n  int **lucern_rindy = 0;\n  int *transphenomenal_refire = 0;\n  int husbandly_catechisation;\n  char *abagail_prancy[10] = {0};\n  char *stepdancing_melanochroic;\n  Size size;\n  if (__sync_bool_compare_and_swap(&zircaloy_smashers,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      stepdancing_melanochroic = getenv(\"STRICTISH_ROCKSHAFT\");\n      if (stepdancing_melanochroic != 0) {;\n        husbandly_catechisation = 5;\n        transphenomenal_refire = &husbandly_catechisation;\n        lucern_rindy = &transphenomenal_refire;\n        abagail_prancy[ *( *lucern_rindy)] = stepdancing_melanochroic;\n        baronetizing_snooperscope = abagail_prancy[ *( *lucern_rindy)];\n        siepi_bequote = 5;\n        while(1 == 1){\n          siepi_bequote = siepi_bequote * 2;\n          siepi_bequote = siepi_bequote + 2;\n          if (siepi_bequote > 1000) {\n            break; \n          }\n        }\n        puritanlike_saucerize = siepi_bequote;\n        playa_voc = ((char *)baronetizing_snooperscope);\n  \n  \n  csv = fopen(playa_voc,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "A.CWE-476:NULL Pointer Dereference|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149668"}
{"selection": "A.CWE-833:Deadlock\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.No Vulnerabilities\nD.CWE-77:Improper Neutralization of Special Elements used in a Command ('Command Injection')\nE.CWE-674:Uncontrolled Recursion", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint noctovision_fosie = 0;\n\nstruct nonprovisionary_casu \n{\n  char *marigraph_gorges;\n  double technol_arrisways;\n  char *decocted_photogrammetry;\n  char epistolising_fordyce;\n  int croose_simplifiedly;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex_0, mutex_1;\npthread_t t0, t1;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *replace (void *data) {\n    struct data *cusData = (struct data*)data;\n    int *qsort_arr;\n    int i = 0;\n    \n    \n    printf(\"replace: entering function\\n\");\n    \n    qsort_arr = malloc(sizeof(int)*cusData->qsize);\n    if (qsort_arr != NULL) {\n        for (i = 0; i < cusData->qsize; i++) {\n            qsort_arr[i] = cusData->qsize - i;\n        }\n        qsort(qsort_arr, cusData->qsize, sizeof(int), &comp);\n        free (qsort_arr);\n        qsort_arr = NULL;\n    }\n    readFile(cusData->file1);\n    printf(\"replace: Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0);\n    printf(\"replace: Grabbed lock 0\\n\");\n    printf(\"replace: Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1); \n    printf(\"replace: Grabbed lock 1\\n\");\n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] == '_') {\n            cusData->data[i] = '-';\n        }\n        i++;\n    }\n    printf(\"replace: Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    printf(\"replace: Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    \n    return NULL;\n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i = 0;\n    \n    printf(\"toCap:   Entering function\\n\");\n    printf(\"toCap:   Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1);\n    printf(\"toCap:   Grabbed lock 1\\n\");\n    readFile(cusData->file2);\n    \n    \n    printf(\"toCap:   Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0); \n    printf(\"toCap:   Grabbed lock 0\\n\");\n    \n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] > 'a' && cusData->data[i] < 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    printf(\"toCap:   Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    printf(\"toCap:   Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    int hasUnderscores = 0;\n    int i = 0;\n    struct data* cusData;\n  char *aloeswood_deadline = 0;\n  jmp_buf parangs_whipstock;\n  int jefes_maag;\n  struct nonprovisionary_casu funnels_fumidity = {0};\n  int *thereto_cracket = 0;\n  int playcraftsman_indomitable;\n  struct nonprovisionary_casu lego_nyctalope[10] = {0};\n  struct nonprovisionary_casu stahlianism_encloak;\n  int physiogenic_postpubic = 110;\n  char *antitheism_nonsensory;;\n  if (__sync_bool_compare_and_swap(&noctovision_fosie,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&antitheism_nonsensory,\"5084\",physiogenic_postpubic);\n      if (antitheism_nonsensory != 0) {;\n        stahlianism_encloak . marigraph_gorges = ((char *)antitheism_nonsensory);\n        lego_nyctalope[5] = stahlianism_encloak;\n        playcraftsman_indomitable = 5;\n        thereto_cracket = &playcraftsman_indomitable;\n        funnels_fumidity =  *(lego_nyctalope +  *thereto_cracket);\n        jefes_maag = setjmp(parangs_whipstock);\n        if (jefes_maag == 0) {\n          longjmp(parangs_whipstock,1);\n        }\n        aloeswood_deadline = ((char *)funnels_fumidity . marigraph_gorges);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(aloeswood_deadline) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(aloeswood_deadline) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(aloeswood_deadline) + 1));\n        if (cusData->data) {\n            if ((sscanf(aloeswood_deadline, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                \n                \n                \n                \n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                while(cusData->data[i] != '\\0') { \n                    if (cusData->data[i++] == '_') { \n                        hasUnderscores = 1;\n                    }\n                }\n                \n                if (pthread_create(&t0, NULL, toCap, cusData) != 0) {\n                    printf(\"Thread 0 failed to spawn.\");\n                }\n                if (hasUnderscores == 1) {\n                    \n                    if (pthread_create(&t1, NULL, replace, cusData) != 0) {\n                        printf(\"Thread 1 failed to spawn.\");\n                    }\n                }\n                pthread_join(t0, NULL);\n                if (hasUnderscores == 1) {\n                    pthread_join(t1, NULL);\n                }\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n        if (funnels_fumidity . marigraph_gorges != 0) \n          free(((char *)funnels_fumidity . marigraph_gorges));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "A.CWE-833:Deadlock|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "833", "idx": "150637"}
{"selection": "A.CWE-8:J2EE Misconfiguration: Entity Bean Declared Remote\nB.No Vulnerabilities\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-603:Use of Client-Side Authentication", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_wchar_t_console_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_console_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123169"}
{"selection": "A.CWE-1334:Unauthorized Error Injection Can Degrade Hardware Redundancy\nB.CWE-1084:Invokable Control Element with Excessive File or Data Access Operations\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_65bSink(char * data);\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_65()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = _OS_Command_Injection__char_environment_w32_spawnv_65bSink;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_65bG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = _OS_Command_Injection__char_environment_w32_spawnv_65bG2BSink;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    funcPtr(data);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_spawnv_65()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_spawnv_65();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_spawnv_65();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245312"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-397:Declaration of Throws for Generic Exception\nC.CWE-1248:Semiconductor Defects in Hardware Logic with Security-Sensitive Implications\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic wchar_t * nG2B1Source(wchar_t * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic wchar_t * nG2B2Source(wchar_t * data)\n{\n    if(nG2B2Static)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123153"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-341:Predictable from Observable State\nC.No Vulnerabilities\nD.CWE-1395:Dependency on Vulnerable Third-Party Component\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_18\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_18; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95747"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-274:Improper Handling of Insufficient Privileges\nC.No Vulnerabilities\nD.CWE-278:Insecure Preserved Inherited Permissions\nE.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <math.h> \n#include <signal.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint fictionalizing_altin = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint SIZE = 50;\nchar *playful_platypus;\nstruct data {\n    char *data;\n};\nstruct data *cusData;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid sig_handler (int sig) {\n    printf(\"In sig_handler\\n\");\n    \n    \n    \n    \n    \n    if (playful_platypus[0] != '\\0') { \n        printf(playful_platypus);\n    }\n    \n}\nvoid waitForSig(char *sleepFile) {\n    int fd;\n    char outStr[25] = {0};\n    char filename[500] = {0};\n    \n    printf(\"In waitForSig\\n\");\n    sprintf(outStr, \"%d.pid\", getpid());\n    strcat(filename, \"/opt/cus/workspace/testData/\");\n    strcat(filename, outStr);\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        \n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            \n            printf(\"Error writing to file.\");\n        }\n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        \n        readFile(sleepFile);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n    int i;\n    char *temp;\n    char *sleepFile;\n  char *ingurgitated_vulgarians = 0;\n  void **unanointed_gauntlets = 0;\n  void **kecksy_mesitylenic = 0;\n  void *hoccleve_imap = 0;\n  char *worminess_endicott;;\n  if (__sync_bool_compare_and_swap(&fictionalizing_altin,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&worminess_endicott,\"FAGGOTING_METACENTRICITY\");\n      if (worminess_endicott != 0) {;\n        hoccleve_imap = ((void *)worminess_endicott);\n        unanointed_gauntlets = &hoccleve_imap;\n        kecksy_mesitylenic = unanointed_gauntlets + 5;\n        if (((char *)( *(kecksy_mesitylenic - 5))) != 0) {\n          goto enmeshments_carioca;\n        }\n        ++global_variable;\n        enmeshments_carioca:;\n        ingurgitated_vulgarians = ((char *)((char *)( *(kecksy_mesitylenic - 5))));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        sleepFile = malloc(sizeof(char) * (strlen(ingurgitated_vulgarians) + 1));\n        cusData->data = malloc(sizeof(char) * (strlen(ingurgitated_vulgarians) + 1));\n        if (cusData->data) {\n            if ((sscanf(ingurgitated_vulgarians, \"%s %s\",\n                        sleepFile,\n                        cusData->data) == 2) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(sleepFile) != 0))\n            {\n                \n                \n                if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\n                    \n                    printf (\"Error catching SIGNUSR1!\\n\");\n                }\n                playful_platypus = malloc(sizeof(char) * (SIZE + 1));\n                i = 0;\n                while (cusData->data[i] != '\\0') { \n                    if (i < SIZE) {\n                        playful_platypus[i] = cusData->data[i];\n                        i++;\n                    } else { \n                        playful_platypus[SIZE] = '\\0';\n                        \n                        \n                        SIZE *= 2;\n                        temp = malloc(sizeof(char) * SIZE);\n                        strcpy(temp, playful_platypus);\n                        free(playful_platypus);\n                        playful_platypus = NULL; \n                        \n                        waitForSig(sleepFile);\n                        \n                        playful_platypus = temp;\n                        \n                    }\n                }\n                free (playful_platypus);\n                signal(SIGUSR1, SIG_IGN); \n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free (cusData);\n    }\n    \n;\n        if (((char *)( *(kecksy_mesitylenic - 5))) != 0) \n          free(((char *)((char *)( *(kecksy_mesitylenic - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "E.CWE-828:Signal Handler with Functionality that is not Asynchronous-Safe|A.CWE-707:Improper Neutralization", "cwe": "828", "idx": "150086"}
{"selection": "A.CWE-910:Use of Expired File Descriptor\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-804:Guessable CAPTCHA\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_15()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62098"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-707:Improper Neutralization\nC.CWE-1121:Excessive McCabe Cyclomatic Complexity\nD.CWE-773:Missing Reference to Active File Descriptor or Handle\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_environment_popen_14()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalFive==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_popen_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_popen_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_popen_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247416"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-23:Relative Path Traversal\nD.CWE-698:Execution After Redirect (EAR)\nE.CWE-1074:Class with Excessively Deep Inheritance", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_file_fopen_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_fopen_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91516"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1102:Reliance on Machine-Dependent Data Representation\nC.CWE-501:Trust Boundary Violation\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123247"}
{"selection": "A.CWE-1393:Use of Default Password\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-289:Authentication Bypass by Alternate Name\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bSink(char * data);\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246347"}
{"selection": "A.CWE-538:Insertion of Sensitive Information into Externally-Accessible File or Directory\nB.CWE-476:NULL Pointer Dereference\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-823:Use of Out-of-range Pointer Offset\nE.No Vulnerabilities", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint colletidae_appendiculate = 0;\nint global_variable;\n\nunion sotos_descanso \n{\n  char *plodder_regerminatively;\n  double dodded_truthtelling;\n  char *fremescent_completes;\n  char baffies_fettlings;\n  int corindon_oophororrhaphy;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid eloquential_urnflower(int immortalism_untactually,union sotos_descanso faulter_decreaseless);\nvoid haemocyte_enchronicle(int meisel_upliftingly,union sotos_descanso oliva_accentuable);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  int ullyot_maunge = 7;\n  union sotos_descanso cheeked_overimpressing = {0};\n  int **********myomatous_bouzoun = 0;\n  int *********pest_subsella = 0;\n  int ********nonflowing_kyats = 0;\n  int *******astoned_hibbert = 0;\n  int ******devolutionist_propound = 0;\n  int *****rebeamer_illyrian = 0;\n  int ****instate_ssme = 0;\n  int ***pokelogan_woodpecker = 0;\n  int **slowheartedness_joviality = 0;\n  int *eliminant_reprievable = 0;\n  int subnodes_gumi;\n  union sotos_descanso eisen_forthbrought[10] = {0};\n  union sotos_descanso inertnesses_ufa;\n  char *claggum_chapel;;\n  if (__sync_bool_compare_and_swap(&colletidae_appendiculate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&claggum_chapel,\"BETHANKS_UNDERDOCTOR\");\n      if (claggum_chapel != 0) {;\n        inertnesses_ufa . plodder_regerminatively = claggum_chapel;\n        subnodes_gumi = 5;\n        eliminant_reprievable = &subnodes_gumi;\n        slowheartedness_joviality = &eliminant_reprievable;\n        pokelogan_woodpecker = &slowheartedness_joviality;\n        instate_ssme = &pokelogan_woodpecker;\n        rebeamer_illyrian = &instate_ssme;\n        devolutionist_propound = &rebeamer_illyrian;\n        astoned_hibbert = &devolutionist_propound;\n        nonflowing_kyats = &astoned_hibbert;\n        pest_subsella = &nonflowing_kyats;\n        myomatous_bouzoun = &pest_subsella;\n        eisen_forthbrought[ *( *( *( *( *( *( *( *( *( *myomatous_bouzoun)))))))))] = inertnesses_ufa;\n        cheeked_overimpressing = eisen_forthbrought[ *( *( *( *( *( *( *( *( *( *myomatous_bouzoun)))))))))];\n        eloquential_urnflower(ullyot_maunge,cheeked_overimpressing);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid eloquential_urnflower(int immortalism_untactually,union sotos_descanso faulter_decreaseless)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *kaolinize_glassweed = 0;\n  ++global_variable;\n  immortalism_untactually--;\n  if (immortalism_untactually > 0) {\n    haemocyte_enchronicle(immortalism_untactually,faulter_decreaseless);\n    return ;\n  }\n  kaolinize_glassweed = ((char *)faulter_decreaseless . plodder_regerminatively);\n      \n      while(isalnum(kaolinize_glassweed[size]) && size < strlen(kaolinize_glassweed)){\n        ++size;\n      }\n      \n\n      if (size != strlen(kaolinize_glassweed)) {\n        kaolinize_glassweed = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,kaolinize_glassweed);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if (faulter_decreaseless . plodder_regerminatively != 0) \n    free(((char *)faulter_decreaseless . plodder_regerminatively));\nclose_printf_context();\n}\n\nvoid haemocyte_enchronicle(int meisel_upliftingly,union sotos_descanso oliva_accentuable)\n{\n  ++global_variable;\n  eloquential_urnflower(meisel_upliftingly,oliva_accentuable);\n}", "answer": "B.CWE-476:NULL Pointer Dereference|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149704"}
{"selection": "A.CWE-682:Incorrect Calculation\nB.CWE-1023:Incomplete Comparison with Missing Factors\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-276:Incorrect Default Permissions", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint slacker_zima = 0;\nint global_variable;\ntypedef char *tzetse_nonpyogenic;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid jiggish_metoxenous(const tzetse_nonpyogenic shuln_jacobina);\nvoid quisquilious_idiorrhythmy(int underplant_rotatoplane,tzetse_nonpyogenic emmenthal_unawakenedness);\nstruct struct {\n    void (*function_ptr_1)();\n    unsigned int input_num;\n    void (*function_ptr_2)();\n};\nvoid function() {\n    \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  tzetse_nonpyogenic tullibee_infixed = 0;\n  int glancer_prosopantritis = 7;\n  char *gozell_blunt;;\n  if (__sync_bool_compare_and_swap(&slacker_zima,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&gozell_blunt,\"1380\",glancer_prosopantritis);\n      if (gozell_blunt != 0) {;\n        tullibee_infixed = gozell_blunt;\n        jiggish_metoxenous(tullibee_infixed);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid jiggish_metoxenous(const tzetse_nonpyogenic shuln_jacobina)\n{\n  int eshin_lipolyses = 7;\n  ++global_variable;;\n  quisquilious_idiorrhythmy(eshin_lipolyses,shuln_jacobina);\n}\n\nvoid quisquilious_idiorrhythmy(int underplant_rotatoplane,tzetse_nonpyogenic emmenthal_unawakenedness)\n{\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned int *ptr = 0;\n    struct struct ssS;\n  char *maidu_launched = 0;\n  ++global_variable;\n  underplant_rotatoplane--;\n  if (underplant_rotatoplane > 0) {\n    quisquilious_idiorrhythmy(underplant_rotatoplane,emmenthal_unawakenedness);\n    return ;\n  }\n  maidu_launched = ((char *)((tzetse_nonpyogenic )emmenthal_unawakenedness));\n    \n    ssS.function_ptr_1 = function;\n    ssS.function_ptr_2 = function;\n    if (strlen(maidu_launched) >= 1 &&\n            maidu_launched[0] != '-') {\n        ssS.input_num = strtoul(maidu_launched,0U,16);\n        ptr = &(ssS.input_num);\n        if ( *ptr > 65535) {\n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n        }\n        \n        \n        ssS.function_ptr_2();\n        \n        printf(\"Value = %i\\n\", ssS.input_num);\n    } else if (strlen(maidu_launched) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n  if (((tzetse_nonpyogenic )emmenthal_unawakenedness) != 0) \n    free(((char *)((tzetse_nonpyogenic )emmenthal_unawakenedness)));\nclose_printf_context();\n}", "answer": "A.CWE-682:Incorrect Calculation|D.CWE-707:Improper Neutralization", "cwe": "682", "idx": "151132"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-295:Improper Certificate Validation\nE.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_environment_ifstream_34\n{\n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} unionType;\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_ifstream_34; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96089"}
{"selection": "A.No Vulnerabilities\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-476:NULL Pointer Dereference\nD.CWE-1326:Missing Immutable Root of Trust in Hardware\nE.CWE-287:Improper Authentication", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint harmonial_gonorrhoea = 0;\nint global_variable;\n\nstruct grazing_frenchiest \n{\n  char *immonastered_ambilaevous;\n  double lemuriform_bikkurim;\n  char *piproid_barb;\n  char rhopaloceral_pretangible;\n  int incl_brager;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct grazing_frenchiest angiectasis_titanoniobate(struct grazing_frenchiest osnaburg_clavicornes);\nvoid *my_malloc(unsigned int size)\n{\n  if (size > 512)\n\n    return 0;\n  return malloc(size);\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  unsigned int size_buffer;\n  int buffer_value;\n  char *malloc_buffer = 0;\n  char *norpinic_armbruster = 0;\n  int uncomfort_sincaline;\n  int gemmily_eysenck;\n  struct grazing_frenchiest interindividual_violoncellos = {0};\n  struct grazing_frenchiest catheters_fatma;\n  char *coulage_crustific;;\n  if (__sync_bool_compare_and_swap(&harmonial_gonorrhoea,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&coulage_crustific,\"DETRUDED_CORAM\");\n      if (coulage_crustific != 0) {;\n        catheters_fatma . immonastered_ambilaevous = ((char *)coulage_crustific);\n        interindividual_violoncellos = angiectasis_titanoniobate(catheters_fatma);\n        gemmily_eysenck = 5;\n        while(1 == 1){\n          gemmily_eysenck = gemmily_eysenck * 2;\n          gemmily_eysenck = gemmily_eysenck + 2;\n          if (gemmily_eysenck > 1000) {\n            break; \n          }\n        }\n        uncomfort_sincaline = gemmily_eysenck;\n        norpinic_armbruster = ((char *)interindividual_violoncellos . immonastered_ambilaevous);\n      \n      buffer_value = atoi(norpinic_armbruster);\n      \n      if (buffer_value < 0)\n        buffer_value = 0;\n      size_buffer = ((unsigned int )buffer_value);\n      \n      malloc_buffer = my_malloc(size_buffer);\n      \n      \n      \n\n      memset(malloc_buffer,0,size_buffer);\n      printf(\"Buffer size is %d\\n\", size_buffer);\n      \n      if (malloc_buffer != 0) {\n        free(malloc_buffer);\n      }\n      \n;\n        if (interindividual_violoncellos . immonastered_ambilaevous != 0) \n          free(((char *)interindividual_violoncellos . immonastered_ambilaevous));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nstruct grazing_frenchiest angiectasis_titanoniobate(struct grazing_frenchiest osnaburg_clavicornes)\n{\n  ++global_variable;\n  return osnaburg_clavicornes;\n}", "answer": "C.CWE-476:NULL Pointer Dereference|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149502"}
{"selection": "A.CWE-330:Use of Insufficiently Random Values\nB.CWE-476:NULL Pointer Dereference\nC.CWE-710:Improper Adherence to Coding Standards\nD.No Vulnerabilities\nE.CWE-147:Improper Neutralization of Input Terminators", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint microfilaria_encyclical = 0;\nint global_variable;\ntypedef char *rask_ultralaborious;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nrask_ultralaborious townspeople_unpropriety(rask_ultralaborious bushwife_perceive);\nvoid unmanoeuvred_baboo(rask_ultralaborious rabbets_fumaria);\n\nunsigned int avdevice_version()\n{\n  void (*tholeite_pyxis)(rask_ultralaborious ) = unmanoeuvred_baboo;\n  rask_ultralaborious nonvariably_geniture = 0;\n  rask_ultralaborious frontier_redecimate = 0;\n  char *multitude_quadrilaterals;;\n  if (__sync_bool_compare_and_swap(&microfilaria_encyclical,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      multitude_quadrilaterals = getenv(\"CAULS_ICHTHYOFAUNAL\");\n      if (multitude_quadrilaterals != 0) {;\n        frontier_redecimate = multitude_quadrilaterals;\n        nonvariably_geniture = townspeople_unpropriety(frontier_redecimate);\n        tholeite_pyxis(nonvariably_geniture);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nrask_ultralaborious townspeople_unpropriety(rask_ultralaborious bushwife_perceive)\n{\n  ++global_variable;\n  return bushwife_perceive;\n}\n\nvoid unmanoeuvred_baboo(rask_ultralaborious rabbets_fumaria)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *dystocias_janker = 0;\n  ++global_variable;;\n  dystocias_janker = ((char *)rabbets_fumaria);\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(dystocias_janker) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (dystocias_janker[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &dystocias_janker[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\nclose_printf_context();\n}", "answer": "B.CWE-476:NULL Pointer Dereference|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149310"}
{"selection": "A.No Vulnerabilities\nB.CWE-512:Spyware\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-333:Improper Handling of Insufficient Entropy in TRNG", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nstatic char * mSource(char * data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_42()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    data = mSource(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic char * nG2BSource(char * data)\n{\n    \n    strcat(data, \"*.*\");\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    data = nG2BSource(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_42()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_42();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_42();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245964"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-307:Improper Restriction of Excessive Authentication Attempts\nC.No Vulnerabilities\nD.CWE-23:Relative Path Traversal\nE.CWE-309:Use of Password System for Primary Authentication", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__wchar_t_file_w32CreateFile_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_w32CreateFile_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91703"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-832:Unlock of a Resource that is not Locked\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-508:Non-Replicating Malicious Code", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\nnamespace _OS_Command_Injection__wchar_t_console_execl_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    mSource(data);\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2BSource(data);\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _OS_Command_Injection__wchar_t_console_execl_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246869"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.No Vulnerabilities\nD.CWE-1299:Missing Protection Mechanism for Alternate Hardware Interface\nE.CWE-402:Transmission of Private Resources into a New Sphere ('Resource Leak')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define SYSTEM system\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_system_10()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\nvoid _OS_Command_Injection__char_file_system_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_system_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_system_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245568"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-23:Relative Path Traversal\nD.CWE-408:Incorrect Behavior Order: Early Amplification\nE.CWE-1298:Hardware Logic Contains Race Conditions", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * dataArray[]);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(wchar_t * dataArray[]);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91010"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-915:Improperly Controlled Modification of Dynamically-Determined Object Attributes", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_w32CreateFile_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * * dataPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_w32CreateFile_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91487"}
{"selection": "A.CWE-581:Object Model Violation: Just One of Equals and Hashcode Defined\nB.CWE-535:Exposure of Information Through Shell Error Message\nC.CWE-707:Improper Neutralization\nD.CWE-36:Absolute Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_open_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_open_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97150"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-345:Insufficient Verification of Data Authenticity\nE.CWE-296:Improper Following of a Certificate's Chain of Trust", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89590"}
{"selection": "A.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nB.CWE-707:Improper Neutralization\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_connect_socket_w32_spawnlp_16()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcat(data, \"*.*\");\n        break;\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_connect_socket_w32_spawnlp_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_w32_spawnlp_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_w32_spawnlp_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244298"}
{"selection": "A.CWE-277:Insecure Inherited Permissions\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-546:Suspicious Comment", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_15()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcpy(data, \"hostname\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcpy(data, \"hostname\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81992"}
{"selection": "A.CWE-202:Exposure of Sensitive Information Through Data Queries\nB.CWE-1242:Inclusion of Undocumented Features or Chicken Bits\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_18()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123056"}
{"selection": "A.CWE-940:Improper Verification of Source of a Communication Channel\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-300:Channel Accessible by Non-Endpoint\nE.CWE-369:Divide By Zero", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint singleton_consound = 0;\n\nunion plowrightia_vervain \n{\n  char *kendrick_nubilous;\n  double suits_chittered;\n  char *tenderably_autocarpian;\n  char antiempiricist_scarletberry;\n  int noropianic_message;\n}\n;\nint global_variable;\nvoid handle_taint(char *pectinately_graphotype);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&singleton_consound,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *pectinately_graphotype)\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *merciless_tractorize = 0;\n  jmp_buf idiogenesis_disseminated;\n  int treasure_scazon;\n  union plowrightia_vervain *eisen_purslanes = {0};\n  union plowrightia_vervain *schooltime_pleuronectidae = {0};\n  union plowrightia_vervain coquetting_mopan;\n  ++global_variable;;\n  if (pectinately_graphotype != 0) {;\n    coquetting_mopan . kendrick_nubilous = pectinately_graphotype;\n    eisen_purslanes = &coquetting_mopan;\n    schooltime_pleuronectidae = eisen_purslanes + 5;\n    treasure_scazon = setjmp(idiogenesis_disseminated);\n    if (treasure_scazon == 0) {\n      longjmp(idiogenesis_disseminated,1);\n    }\n    merciless_tractorize = ((char *)( *(schooltime_pleuronectidae - 5)) . kendrick_nubilous);\n    \n    input = atoi(merciless_tractorize);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\n    if (( *(schooltime_pleuronectidae - 5)) . kendrick_nubilous != 0) \n      free(((char *)( *(schooltime_pleuronectidae - 5)) . kendrick_nubilous));\nclose_printf_context();\n  }\n}\n#endif", "answer": "E.CWE-369:Divide By Zero|B.CWE-707:Improper Neutralization", "cwe": "369", "idx": "151390"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-1317:Improper Access Control in Fabric Bridge\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1094:Excessive Index Range Scan for a Data Resource", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _wexecvp\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_execvp_54bSink(wchar_t * data);\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_execvp_54()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__wchar_t_environment_w32_execvp_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_execvp_54bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_environment_w32_execvp_54bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_execvp_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_execvp_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_execvp_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247571"}
{"selection": "A.CWE-1057:Data Access Operations Outside of Expected Data Manager Component\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.No Vulnerabilities\nE.CWE-688:Function Call With Incorrect Variable or Reference as Argument", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef struct __LDAP_Injection__w32_wchar_t_file_67_structType\n{\n    wchar_t * structFirst;\n} _LDAP_Injection__w32_wchar_t_file_67_structType;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_67bSink(_LDAP_Injection__w32_wchar_t_file_67_structType myStruct);\n\nvoid _LDAP_Injection__w32_wchar_t_file_67()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_file_67_structType myStruct;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_wchar_t_file_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_67bG2BSink(_LDAP_Injection__w32_wchar_t_file_67_structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_file_67_structType myStruct;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_wchar_t_file_67bG2BSink(myStruct);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123270"}
{"selection": "A.No Vulnerabilities\nB.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\nC.CWE-707:Improper Neutralization\nD.CWE-194:Unexpected Sign Extension\nE.CWE-583:finalize() Method Declared Public", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <limits.h> \nint unentrapped_guardianships = 0;\nint global_variable;\ntypedef char *misstart_misimproving;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid invade_underinsured(int transfiguration_eternal,... );\nvoid haik_backslider(int pomaderris_lath,misstart_misimproving sullenness_matranee);\nshort get_int_value(char *ss_tainted_buff)\n{\n  \n  short to_short = 0;\n  int tainted_int = 0;\n  tainted_int = atoi(ss_tainted_buff);\n  if (tainted_int != 0) {\n    if (tainted_int > 30000)\n      tainted_int = 30000;\n    if (tainted_int < -30000)\n      tainted_int = -30000;\n    to_short = ((short )tainted_int);\n  }\n  return to_short;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  misstart_misimproving unbelievingly_bisaltae = 0;\n  char *mordy_unmalled;;\n  if (__sync_bool_compare_and_swap(&unentrapped_guardianships,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&mordy_unmalled,\"EUROPEANISED_CYCLOPEAN\");\n      if (mordy_unmalled != 0) {;\n        unbelievingly_bisaltae = mordy_unmalled;\n        invade_underinsured(1,unbelievingly_bisaltae);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid invade_underinsured(int transfiguration_eternal,... )\n{\n  int wheatstalk_sempre = 7;\n  misstart_misimproving antioptimistic_rheotropism = 0;\n  va_list freezingly_gallia;\n  ++global_variable;;\n  if (transfiguration_eternal > 0) {\n    __builtin_va_start(freezingly_gallia,transfiguration_eternal);\n    antioptimistic_rheotropism = (va_arg(freezingly_gallia,misstart_misimproving ));\n    __builtin_va_end(freezingly_gallia);\n  }\n  haik_backslider(wheatstalk_sempre,antioptimistic_rheotropism);\n}\n\nvoid haik_backslider(int pomaderris_lath,misstart_misimproving sullenness_matranee)\n{\n    unsigned int to_unsign = 0;\n    char *buff = 0;\n    FILE *file = 0;\n    int counter = 0;\n    int bytes_read = 0;\n  char *reracks_vip = 0;\n  ++global_variable;\n  pomaderris_lath--;\n  if (pomaderris_lath > 0) {\n    haik_backslider(pomaderris_lath,sullenness_matranee);\n    return ;\n  }\n  reracks_vip = ((char *)sullenness_matranee);\n    \n    buff = ((char *)(malloc(30000 * sizeof(char ))));\n    if (buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    memset(buff, 0, 30000);\n    \n\n    to_unsign = get_int_value(reracks_vip);\n    \n    \n    \n    file = fopen(\"/opt/cus/workspace/testData/myfile.txt\",\"r\");\n    if (file != 0) {\n        \n        while (((unsigned int )counter) < to_unsign) {\n            \n            bytes_read = fread(&buff[counter],\n                sizeof(char), 1000, file);\n            if (bytes_read == 0) {\n                break;\n            }\n            counter += bytes_read;\n        }\n        \n        fclose(file);\n        buff[to_unsign] = '\\0';\n        printf(\"buff is %d long, and has contents: %s \\n\",strlen(buff), buff);\n    } else {\n        printf(\"Cannot open file %s\\n\", \"/opt/cus/workspace/testData/myfile.txt\");\n    }\n    if (buff != 0) {\n        free(buff);\n    }\n    \n;\n  if (sullenness_matranee != 0) \n    free(((char *)sullenness_matranee));\nclose_printf_context();\n}", "answer": "D.CWE-194:Unexpected Sign Extension|C.CWE-707:Improper Neutralization", "cwe": "194", "idx": "150744"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1190:DMA Device Enabled Too Early in Boot Phase\nC.No Vulnerabilities\nD.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nE.CWE-322:Key Exchange without Entity Authentication", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint poca_ahira = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *brink_crimpier = 0;\n  jmp_buf clevises_roud;\n  int wailoo_noninfallible;\n  char *thieveries_utfangthief = 0;\n  int *hotdogs_ombres = 0;\n  int washway_quotingly;\n  char *disprison_omentitis[10] = {0};\n  int mediatorship_federalization = 0;\n  char *uterometer_boogeymen = 0;\n  char *margarethe_epilating;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&poca_ahira,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      margarethe_epilating = getenv(\"PEOPLEHOOD_GONADECTOMY\");\n      if (margarethe_epilating != 0) {;\n        mediatorship_federalization = ((int )(strlen(margarethe_epilating)));\n        uterometer_boogeymen = ((char *)(malloc(mediatorship_federalization + 1)));\n        if (uterometer_boogeymen == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(uterometer_boogeymen,0,mediatorship_federalization + 1);\n        memcpy(uterometer_boogeymen,margarethe_epilating,mediatorship_federalization);\n        disprison_omentitis[5] = uterometer_boogeymen;\n        washway_quotingly = 5;\n        hotdogs_ombres = &washway_quotingly;\n        thieveries_utfangthief =  *(disprison_omentitis +  *hotdogs_ombres);\n        wailoo_noninfallible = setjmp(clevises_roud);\n        if (wailoo_noninfallible == 0) {\n          longjmp(clevises_roud,1);\n        }\n        brink_crimpier = ((char *)thieveries_utfangthief);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(brink_crimpier); ++i) {\n        if (brink_crimpier[i] == ';') {\n          if (i == 0 || brink_crimpier[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,brink_crimpier);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if (thieveries_utfangthief != 0) \n          free(((char *)thieveries_utfangthief));\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}", "answer": "D.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|A.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152467"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-480:Use of Incorrect Operator\nD.No Vulnerabilities\nE.CWE-283:Unverified Ownership", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41Sink(wchar_t * data)\n{\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41G2BSink(wchar_t * data)\n{\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41G2BSink(data);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248699"}
{"selection": "A.CWE-523:Unprotected Transport of Credentials\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-221:Information Loss or Omission", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41Sink(char * data)\n{\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41G2BSink(char * data)\n{\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_41G2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82002"}
{"selection": "A.CWE-760:Use of a One-Way Hash with a Predictable Salt\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-1109:Use of Same Variable for Multiple Purposes", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\n\nint _OS_Command_Injection__char_file_execlp_22Global = 0;\n\nchar * _OS_Command_Injection__char_file_execlp_22Source(char * data);\n\nvoid _OS_Command_Injection__char_file_execlp_22()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__char_file_execlp_22Global = 1; \n    data = _OS_Command_Injection__char_file_execlp_22Source(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _OS_Command_Injection__char_file_execlp_22G2B1Global = 0;\nint _OS_Command_Injection__char_file_execlp_22G2B2Global = 0;\n\n\nchar * _OS_Command_Injection__char_file_execlp_22G2B1Source(char * data);\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__char_file_execlp_22G2B1Global = 0; \n    data = _OS_Command_Injection__char_file_execlp_22G2B1Source(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nchar * _OS_Command_Injection__char_file_execlp_22G2B2Source(char * data);\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__char_file_execlp_22G2B2Global = 1; \n    data = _OS_Command_Injection__char_file_execlp_22G2B2Source(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_file_execlp_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_execlp_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_execlp_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245486"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-127:Buffer Under-read\nD.CWE-309:Use of Password System for Primary Authentication\nE.CWE-476:NULL Pointer Dereference", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint rais_undiscernible = 0;\nint global_variable;\ntypedef char *cheare_brucines;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nstruct struct {\n    int before[200];\n    int buffer[128];\n    int after[200];\n};\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    signed char *input_string = 0;\n    struct struct * data = 0;\n    int i = 0;\n  char *palatoalveolar_keepworthy = 0;\n  cheare_brucines *bisbee_unheeded = 0;\n  cheare_brucines corncobs_pooves = 0;\n  cheare_brucines rosa_recolors = 0;\n  char *ayala_pdn;;\n  if (__sync_bool_compare_and_swap(&rais_undiscernible,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      ayala_pdn = getenv(\"CIRCUMLITIO_TAMILIAN\");\n      if (ayala_pdn != 0) {;\n        rosa_recolors = ayala_pdn;\n        bisbee_unheeded = &rosa_recolors;\n        if ( *bisbee_unheeded != 0) {\n          goto hydride_globetrotter;\n        }\n        ++global_variable;\n        hydride_globetrotter:;\n        palatoalveolar_keepworthy = ((char *)( *bisbee_unheeded));\n    \n    input_string = (signed char *) getenv(\"INPUT_STRING\");\n    data = (struct struct *) malloc (sizeof (struct struct));\n    if (data != NULL) {\n        if (input_string != 0) {\n            memset(data->buffer, 0, 128);\n            for (i = 0; i < 200; ++i) {\n                data->before[i] = 5555;\n                data->after[i] = 5555;\n            }\n            for (i = 0; i < strlen((char *) input_string); ++i) {\n                if (input_string[i] < 0)\n                    continue;\n                ++data->buffer[input_string[i]];\n            }\n            \n            \n            for (i = 0; i < strlen(palatoalveolar_keepworthy); ++i) {\n                \n                \n                printf(\"value %c appears: %d times\\n\",\n                    palatoalveolar_keepworthy[i],\n                    data->buffer[(int) palatoalveolar_keepworthy[i]]);\n            }\n            \n            \n            \n        }\n        free (data);\n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "C.CWE-127:Buffer Under-read|A.CWE-707:Improper Neutralization", "cwe": "127", "idx": "153641"}
{"selection": "A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-253:Incorrect Check of Function Return Value\nD.CWE-663:Use of a Non-reentrant Function in a Concurrent Context\nE.CWE-263:Password Aging with Long Expiration", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint leptomeningitis_lactocele = 0;\nint global_variable;\nvoid handle_taint(char *chronologic_premies);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid reacting_jacana(char **corkwing_multisonorous);\nvoid boldoine_somatically(char **opianyl_taramasalata);\nvoid waily_unmodifiably(char **porchlike_spece);\nvoid zootomical_adonizing(char **preultimate_nonexceptional);\nvoid ostentous_lymphopenia(char **landladyship_screeny);\nvoid battalions_bonding(char **boodledom_scylla);\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas);\nvoid hultgren_humuslike(char **coronatorial_rifi);\nvoid draisine_uncombed(char **soundproofed_vaporability);\nvoid journeyman_cesiums(char **affusions_hardstand);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&leptomeningitis_lactocele,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *chronologic_premies)\n{\n  int sammy_noncommendably;\n  char **hickishness_tubal = 0;\n  char **erythrophage_algebraized = 0;\n  char *frizzling_browningesque[66] = {0};\n  ++global_variable;;\n  if (chronologic_premies != 0) {;\n    frizzling_browningesque[63] = chronologic_premies;\n    sammy_noncommendably = 1;\n    hickishness_tubal = frizzling_browningesque;\n    erythrophage_algebraized = ((char **)(((unsigned long )hickishness_tubal) * sammy_noncommendably * sammy_noncommendably)) + 5;\n    reacting_jacana(erythrophage_algebraized);\n  }\n}\n\nvoid reacting_jacana(char **corkwing_multisonorous)\n{\n  ++global_variable;;\n  boldoine_somatically(corkwing_multisonorous);\n}\n\nvoid boldoine_somatically(char **opianyl_taramasalata)\n{\n  ++global_variable;;\n  waily_unmodifiably(opianyl_taramasalata);\n}\n\nvoid waily_unmodifiably(char **porchlike_spece)\n{\n  ++global_variable;;\n  zootomical_adonizing(porchlike_spece);\n}\n\nvoid zootomical_adonizing(char **preultimate_nonexceptional)\n{\n  ++global_variable;;\n  ostentous_lymphopenia(preultimate_nonexceptional);\n}\n\nvoid ostentous_lymphopenia(char **landladyship_screeny)\n{\n  ++global_variable;;\n  battalions_bonding(landladyship_screeny);\n}\n\nvoid battalions_bonding(char **boodledom_scylla)\n{\n  ++global_variable;;\n  chlorophyllian_glossopetra(boodledom_scylla);\n}\n\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas)\n{\n  ++global_variable;;\n  hultgren_humuslike(prioristic_bugshas);\n}\n\nvoid hultgren_humuslike(char **coronatorial_rifi)\n{\n  ++global_variable;;\n  draisine_uncombed(coronatorial_rifi);\n}\n\nvoid draisine_uncombed(char **soundproofed_vaporability)\n{\n  ++global_variable;;\n  journeyman_cesiums(soundproofed_vaporability);\n}\n\nvoid journeyman_cesiums(char **affusions_hardstand)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *gasterophilus_dinitril = 0;\n  ++global_variable;;\n  gasterophilus_dinitril = ((char *)(affusions_hardstand - 5)[63]);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(gasterophilus_dinitril)+ 1));\n        if (cusData->data &&\n            (sscanf(gasterophilus_dinitril, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if ((affusions_hardstand - 5)[63] != 0) \n    free(((char *)(affusions_hardstand - 5)[63]));\nclose_printf_context();\n}", "answer": "D.CWE-663:Use of a Non-reentrant Function in a Concurrent Context|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "663", "idx": "150275"}
{"selection": "A.CWE-576:EJB Bad Practices: Use of Java I/O\nB.CWE-1338:Improper Protections Against Hardware Overheating\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.No Vulnerabilities\nE.CWE-664:Improper Control of a Resource Through its Lifetime", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint exsanguious_spindlelike = 0;\nint global_variable;\nvoid handle_taint(char *bold_insinuated);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nchar *eurythermous_braised(char *prelude_credibleness);\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&exsanguious_spindlelike,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *bold_insinuated)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *uroscopist_jactitating = 0;\n  char *metrorrhagia_radiancy = 0;\n  ++global_variable;;\n  if (bold_insinuated != 0) {;\n    metrorrhagia_radiancy = eurythermous_braised(bold_insinuated);\n    uroscopist_jactitating = ((char *)metrorrhagia_radiancy);\n    \n files = fopen(uroscopist_jactitating,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n    if (metrorrhagia_radiancy != 0) \n      free(((char *)metrorrhagia_radiancy));\nclose_printf_context();\n  }\n}\n\nchar *eurythermous_braised(char *prelude_credibleness)\n{\n  ++global_variable;\n  return prelude_credibleness;\n}", "answer": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|E.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "775", "idx": "152078"}
{"selection": "A.No Vulnerabilities\nB.CWE-831:Signal Handler Function Associated with Multiple Signals\nC.CWE-532:Insertion of Sensitive Information into Log File\nD.CWE-707:Improper Neutralization\nE.CWE-1086:Class with Excessive Number of Child Classes", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <math.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint antikenotoxin_fourteenfold = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    char *data;\n    char *file1;\n    char *file2;\n};\nstruct data *cusData;\nint loop;\nint *global1;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForSig() {\n    int fd;\n    char outStr[25] = {0};\n    char filename[500] = {0};\n    \n    printf(\"In waitForSig\\n\");\n    sprintf(outStr, \"%d.pid\", getpid());\n    strcat(filename, \"/opt/cus/workspace/testData/\");\n    strcat(filename, outStr);\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        \n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            \n            printf(\"Error writing to file.\");\n        }\n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        \n        printf(\"Reading file1\\n\");\n        readFile(cusData->file1);\n        readFile(cusData->file2);\n    }\n}\nvoid sig_handler (int sig) {\n    printf(\"In sig_handler\\n\");\n    \n    \n    \n    \n    \n    global1[0] = -1;\n    free(global1);\n    global1 = NULL;\n    \n    \n    printf(\"In sig handler\");\n}\n\nSize PMSignalShmemSize()\n{\n  char *packet_unswervingness = 0;\n  char **bisque_irrefragability = 0;\n  char **unrosined_baze = 0;\n  int tropology_felup = 0;\n  char *intercalation_nick = 0;\n  int meteorically_irregeneracy = 102;\n  char *nonissuably_cogitabundly;\n  Size size;\n  if (__sync_bool_compare_and_swap(&antikenotoxin_fourteenfold,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&nonissuably_cogitabundly,\"1746\",meteorically_irregeneracy);\n      if (nonissuably_cogitabundly != 0) {;\n        tropology_felup = ((int )(strlen(nonissuably_cogitabundly)));\n        intercalation_nick = ((char *)(malloc(tropology_felup + 1)));\n        if (intercalation_nick == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(intercalation_nick,0,tropology_felup + 1);\n        memcpy(intercalation_nick,nonissuably_cogitabundly,tropology_felup);\n        if (nonissuably_cogitabundly != 0) \n          free(((char *)nonissuably_cogitabundly));\n        bisque_irrefragability = &intercalation_nick;\n        unrosined_baze = bisque_irrefragability + 5;\n        packet_unswervingness = ((char *)( *(unrosined_baze - 5)));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(packet_unswervingness) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(packet_unswervingness) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(packet_unswervingness) + 1));\n        if (cusData->data) {\n            if ((sscanf(packet_unswervingness, \"%s %s %s\",\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 3) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                global1 = calloc(1, sizeof(int));\n                \n                \n                \n                \n                if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\n                    \n                    printf (\"Error catching SIGUSR1!\\n\");\n                }\n                printf(\"Set up SIGUSR1 handler\\n\");\n                if (cusData->data[0] >= 'A' && cusData->data[0] <= 'Z') {\n                    if (signal(SIGUSR2, sig_handler) == SIG_ERR) {\n                        \n                        printf (\"Error catching SIGUSR2!\\n\");\n                    }\n                    printf(\"Set up SIGUSR2 handler\\n\");\n                }\n                waitForSig();\n                printf(\"After waitForSig\\n\");\n                signal(SIGUSR1, SIG_IGN); \n                signal(SIGUSR2, SIG_IGN); \n                if (global1 != NULL) {\n                    free(global1);\n                    global1 = NULL;\n                }\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free (cusData);\n    }\n    \n;\n        if ( *(unrosined_baze - 5) != 0) \n          free(((char *)( *(unrosined_baze - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "B.CWE-831:Signal Handler Function Associated with Multiple Signals|D.CWE-707:Improper Neutralization", "cwe": "831", "idx": "150066"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-705:Incorrect Control Flow Scoping\nD.CWE-253:Incorrect Check of Function Return Value\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95741"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\nC.CWE-1229:Creation of Emergent Resource\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_environment_41Sink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_environment_41()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_char_environment_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _LDAP_Injection__w32_char_environment_41G2BSink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_environment_41G2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_environment_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122967"}
{"selection": "A.CWE-1050:Excessive Platform Resource Consumption within a Loop\nB.CWE-555:J2EE Misconfiguration: Plaintext Password in Configuration File\nC.CWE-114:Process Control\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _Process_Control__w32_wchar_t_listen_socket_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, wchar_t *> dataMap);\n\nvoid m()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, wchar_t *> dataMap);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_wchar_t_listen_socket_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-114:Process Control|E.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62463"}
{"selection": "A.CWE-841:Improper Enforcement of Behavioral Workflow\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-830:Inclusion of Web Functionality from an Untrusted Source", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_connect_socket_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_connect_socket_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122869"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-688:Function Call With Incorrect Variable or Reference as Argument\nE.CWE-939:Improper Authorization in Handler for Custom URL Scheme", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90979"}
{"selection": "A.CWE-689:Permission Race Condition During Resource Copy\nB.CWE-1329:Reliance on Component That is Not Updateable\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_81\n{\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_81 : public _External_Control_of_System_or_Configuration_Setting__w32_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_81G2B : public _External_Control_of_System_or_Configuration_Setting__w32_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "E.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82022"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nD.CWE-760:Use of a One-Way Hash with a Predictable Salt\nE.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint restoratory_angiostomize = 0;\nint global_variable;\n\nunion anoine_undistinguished \n{\n  char *kolhoz_recontinue;\n  double sepion_gibbetted;\n  char *delano_tophous;\n  char mesocephalism_reproduced;\n  int bedawn_etrenne;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid mofw_jaculate(union anoine_undistinguished corbie_sabik);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nunsigned int avdevice_version()\n{\n  void (*pedicel_copperwing)(union anoine_undistinguished ) = mofw_jaculate;\n  union anoine_undistinguished chirruped_epeirogenesis = {0};\n  long supercrime_dailey[10];\n  union anoine_undistinguished uninvested_magazine[10] = {0};\n  union anoine_undistinguished substantialness_linctus;\n  char *ficoides_perioesophageal;;\n  if (__sync_bool_compare_and_swap(&restoratory_angiostomize,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&ficoides_perioesophageal,\"YUJI_METERLESS\");\n      if (ficoides_perioesophageal != 0) {;\n        substantialness_linctus . kolhoz_recontinue = ficoides_perioesophageal;\n        uninvested_magazine[5] = substantialness_linctus;\n        supercrime_dailey[1] = 5;\n        chirruped_epeirogenesis =  *(uninvested_magazine + supercrime_dailey[1]);\n        pedicel_copperwing(chirruped_epeirogenesis);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid mofw_jaculate(union anoine_undistinguished corbie_sabik)\n{\n    int oc_i = 0;\n    int opt_var = 0;\n    char* buff = 0;\n  char *remonstrance_reincarnated = 0;\n  ++global_variable;;\n  remonstrance_reincarnated = ((char *)corbie_sabik . kolhoz_recontinue);\n    \n    if (strlen(remonstrance_reincarnated) < 20) {;\n        buff = (char *) malloc (sizeof(char) * 20);\n        if (buff != NULL) {\n            memset(buff, 0, 20);\n            \n            \n\n\n            realpath(remonstrance_reincarnated, buff);\n            opt_var = strlen( buff);\n            \n            for (; oc_i < opt_var; ++oc_i) {\n                buff[oc_i] =\n                    toupper(buff[oc_i]);\n            }\n            printf(\"%s\\n\", buff);\n            \n            \n            free (buff);\n        }\n    }\n    \n;\n  if (corbie_sabik . kolhoz_recontinue != 0) \n    free(((char *)corbie_sabik . kolhoz_recontinue));\nclose_printf_context();\n}", "answer": "E.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|B.CWE-707:Improper Neutralization", "cwe": "785", "idx": "153679"}
{"selection": "A.CWE-1351:Improper Handling of Hardware Behavior in Exceptionally Cold Environments\nB.CWE-922:Insecure Storage of Sensitive Information\nC.CWE-707:Improper Neutralization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nwchar_t * _LDAP_Injection__w32_wchar_t_console_61bSource(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_console_61()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    data = _LDAP_Injection__w32_wchar_t_console_61bSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * _LDAP_Injection__w32_wchar_t_console_61bG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    data = _LDAP_Injection__w32_wchar_t_console_61bG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_61()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_61();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_61();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123168"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-114:Process Control\nC.CWE-198:Use of Incorrect Byte Ordering\nD.CWE-1115:Source Code Element without Standard Prologue\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_file_12()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62383"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-830:Inclusion of Web Functionality from an Untrusted Source\nE.CWE-1076:Insufficient Adherence to Expected Conventions", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Relative_Path_Traversal__wchar_t_file_fopen_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_fopen_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91507"}
{"selection": "A.CWE-114:Process Control\nB.CWE-370:Missing Check for Certificate Revocation after Initial Check\nC.CWE-707:Improper Neutralization\nD.CWE-1066:Missing Serialization Control Element\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n#include <vector>\n\n#include <wchar.h>\n\nusing namespace std;\n\nnamespace _Process_Control__w32_wchar_t_relativePath_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<wchar_t *> dataVector);\n\nvoid m()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<wchar_t *> dataVector);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_wchar_t_relativePath_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62509"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-439:Behavioral Change in New Version or Environment\nC.No Vulnerabilities\nD.CWE-502:Deserialization of Untrusted Data\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_w32_spawnlp_66bSink(char * dataArray[]);\n\nvoid _OS_Command_Injection__char_environment_w32_spawnlp_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    \n    dataArray[2] = data;\n    _OS_Command_Injection__char_environment_w32_spawnlp_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_w32_spawnlp_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    dataArray[2] = data;\n    _OS_Command_Injection__char_environment_w32_spawnlp_66bG2BSink(dataArray);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_spawnlp_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_spawnlp_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_spawnlp_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245265"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1235:Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations\nE.CWE-203:Observable Discrepancy", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_w32_spawnvp_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_console_w32_spawnvp_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_w32_spawnvp_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_w32_spawnvp_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247227"}
{"selection": "A.CWE-561:Dead Code\nB.CWE-824:Access of Uninitialized Pointer\nC.CWE-707:Improper Neutralization\nD.CWE-420:Unprotected Alternate Channel\nE.No Vulnerabilities", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint ccnc_heteroproteose = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid weltanschauung_tenuously(int hagiarchy_lovash,char **wisewoman_preappearances);\nstruct data_struct {\n  int (*func_member)(char *);\n  char *str_member;\n};\nint modulus_function(char *modulus_param_str)\n{\n  \n  return modulus_param_str[0] % 2;\n}\nvoid set_function(char *set_param_str,struct data_struct *set_param_data_struct)\n{\n  \n  \n\n  if (strlen(set_param_str) > 10U) {\n    set_param_data_struct -> func_member = modulus_function;\n    set_param_data_struct -> str_member = set_param_str;\n    \n  }\n  if (strlen(set_param_str) < 10U) {\n    set_param_data_struct -> func_member = modulus_function;\n    set_param_data_struct -> str_member = \"default\";\n    \n  }\n  \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  int redon_serpentcleide = 7;\n  char **enounced_unsainted = 0;\n  char **ravenelia_arsenites = 0;\n  char *morigerous_carabus;;\n  if (__sync_bool_compare_and_swap(&ccnc_heteroproteose,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      morigerous_carabus = getenv(\"JOEY_PREROGATIVED\");\n      if (morigerous_carabus != 0) {;\n        enounced_unsainted = &morigerous_carabus;\n        ravenelia_arsenites = enounced_unsainted + 5;\n        weltanschauung_tenuously(redon_serpentcleide,ravenelia_arsenites);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid weltanschauung_tenuously(int hagiarchy_lovash,char **wisewoman_preappearances)\n{\n    int val = 0;\n    struct data_struct my_foo;\n  char *retaining_halakah = 0;\n  ++global_variable;\n  hagiarchy_lovash--;\n  if (hagiarchy_lovash > 0) {\n    weltanschauung_tenuously(hagiarchy_lovash,wisewoman_preappearances);\n    return ;\n  }\n  retaining_halakah = ((char *)( *(wisewoman_preappearances - 5)));\n    \n    if (strlen(retaining_halakah) < 1) {\n        printf(\"string is too short to test\\n\");\n    } else {\n        set_function(retaining_halakah, &my_foo);\n        \n        \n        val = (my_foo . func_member(my_foo . str_member));\n        \n        if (val == 0)\n            printf(\"mod is true\\n\");\n        else\n            printf(\"mod is false\\n\");\n    }\n    \n;\nclose_printf_context();\n}", "answer": "B.CWE-824:Access of Uninitialized Pointer|C.CWE-707:Improper Neutralization", "cwe": "824", "idx": "153398"}
{"selection": "A.CWE-1322:Use of Blocking Code in Single-threaded, Non-blocking Context\nB.No Vulnerabilities\nC.CWE-457:Use of Uninitialized Variable\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-476:NULL Pointer Dereference", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint adorn_quinquevalency = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar *jough_mentalis(char *chalkboards_tirelessness);\nvoid mentors_staymaking(int actification_nontransparence,char *scallage_depew);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nunsigned int avdevice_version()\n{\n  int merkin_tandemer = 7;\n  char *limli_unlimited = 0;\n  char *lundale_autodigestive;;\n  if (__sync_bool_compare_and_swap(&adorn_quinquevalency,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&lundale_autodigestive,\"SEVENBARK_BIBLICISM\");\n      if (lundale_autodigestive != 0) {;\n        limli_unlimited = jough_mentalis(lundale_autodigestive);\n        mentors_staymaking(merkin_tandemer,limli_unlimited);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nchar *jough_mentalis(char *chalkboards_tirelessness)\n{\n  ++global_variable;\n  return chalkboards_tirelessness;\n}\n\nvoid mentors_staymaking(int actification_nontransparence,char *scallage_depew)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *nonnihilistic_saltary = 0;\n  ++global_variable;\n  actification_nontransparence--;\n  if (actification_nontransparence > 0) {\n    mentors_staymaking(actification_nontransparence,scallage_depew);\n    return ;\n  }\n  nonnihilistic_saltary = ((char *)scallage_depew);\n      \n      while(isalnum(nonnihilistic_saltary[size]) && size < strlen(nonnihilistic_saltary)){\n        ++size;\n      }\n      \n\n      if (size != strlen(nonnihilistic_saltary)) {\n        nonnihilistic_saltary = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,nonnihilistic_saltary);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if (scallage_depew != 0) \n    free(((char *)scallage_depew));\nclose_printf_context();\n}", "answer": "E.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149398"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-383:J2EE Bad Practices: Direct Use of Threads\nD.CWE-824:Access of Uninitialized Pointer\nE.CWE-501:Trust Boundary Violation", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint glassfish_telharmony = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid haflin_taeninidia(char *(**********cystectomies_paut)[21]);\ntypedef int (*fptr)();\nint modulus_function1 (char *modulus_param_str) {\n  \n  return modulus_param_str[0] % 2;\n}\nint modulus_function2 (char *modulus_param_str) {\n  \n  return modulus_param_str[1] % 2;\n}\nvoid get_function(int len, fptr * modulus_function) {\n  \n    \n    if (len > 10) {\n        *modulus_function = modulus_function1;\n        \n    }\n    if (len < 10) {\n        *modulus_function = modulus_function2;\n        \n    }\n    \n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n#define IMBOSCATA_RHEXIA(x) haflin_taeninidia((char *(**********)[21]) x)\n\nvoid ENGINE_cleanup()\n{\n  char *(**********scenewright_preutilized)[21] = 0;\n  char *(*********pallini_fatalism)[21] = 0;\n  char *(********guaranteer_chinoline)[21] = 0;\n  char *(*******sogat_desmepithelium)[21] = 0;\n  char *(******mydriatine_emblematise)[21] = 0;\n  char *(*****millen_metropolitical)[21] = 0;\n  char *(****featurelessness_lecoma)[21] = 0;\n  char *(***neutrodyne_maewo)[21] = 0;\n  char *(**saul_hyacine)[21] = 0;\n  char *(*stymphalian_dodson)[21] = 0;\n  char **upmix_stagecoach = 0;\n  char *unstirred_antiasthmatic[21] = {0};\n  char *salnatron_minsteryard;;\n  if (__sync_bool_compare_and_swap(&glassfish_telharmony,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&salnatron_minsteryard,\"PHRYGANEOID_JENEQUEN\");\n      if (salnatron_minsteryard != 0) {;\n        unstirred_antiasthmatic[20] = salnatron_minsteryard;\n        stymphalian_dodson = &unstirred_antiasthmatic;\n        saul_hyacine = &stymphalian_dodson;\n        neutrodyne_maewo = &saul_hyacine;\n        featurelessness_lecoma = &neutrodyne_maewo;\n        millen_metropolitical = &featurelessness_lecoma;\n        mydriatine_emblematise = &millen_metropolitical;\n        sogat_desmepithelium = &mydriatine_emblematise;\n        guaranteer_chinoline = &sogat_desmepithelium;\n        pallini_fatalism = &guaranteer_chinoline;\n        scenewright_preutilized = &pallini_fatalism;\n\tIMBOSCATA_RHEXIA(scenewright_preutilized);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid haflin_taeninidia(char *(**********cystectomies_paut)[21])\n{\n int input_len = 0;\n int result = 0;\n fptr* function_ptr = 0;\n  char *descendability_creusa = 0;\n  ++global_variable;;\n  descendability_creusa = ((char *)( *( *( *( *( *( *( *( *( *( *cystectomies_paut))))))))))[20]);\n    \n input_len = strlen(descendability_creusa);\n    if (input_len < 2) {\n        printf(\"String is too short to test\\n\");\n    } else {\n        function_ptr = malloc(sizeof(void *));\n        if (function_ptr == 0) {\n            printf(\"Error: Failed to allocate memory\\n\");\n            exit(1);\n        }\n        \n        get_function(input_len, function_ptr);\n        \n        \n        result = ( *function_ptr)(descendability_creusa);\n        \n        if (result == 0)\n            printf(\"mod is true\\n\");\n        else\n            printf(\"mod is false\\n\");\n        if (function_ptr != 0) {\n            free(function_ptr);\n        }\n    }\n    \n;\n  if (( *( *( *( *( *( *( *( *( *( *cystectomies_paut))))))))))[20] != 0) \n    free(((char *)( *( *( *( *( *( *( *( *( *( *cystectomies_paut))))))))))[20]));\nclose_printf_context();\n}", "answer": "D.CWE-824:Access of Uninitialized Pointer|A.CWE-707:Improper Neutralization", "cwe": "824", "idx": "152941"}
{"selection": "A.CWE-538:Insertion of Sensitive Information into Externally-Accessible File or Directory\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-341:Predictable from Observable State", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_10()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81987"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-549:Missing Password Field Masking\nC.CWE-396:Declaration of Catch for Generic Exception\nD.CWE-114:Process Control\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_console_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_console_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_console_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_console_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "61988"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-1224:Improper Restriction of Write-Once Bit Fields\nE.CWE-357:Insufficient UI Warning of Dangerous Operations", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n#define EXECVP _wexecvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248451"}
{"selection": "A.CWE-114:Process Control\nB.No Vulnerabilities\nC.CWE-1042:Static Member Data Element outside of a Singleton Class Element\nD.CWE-289:Authentication Bypass by Alternate Name\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\nnamespace _Process_Control__w32_char_connect_socket_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_connect_socket_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|E.CWE-707:Improper Neutralization", "cwe": "114", "idx": "61974"}
{"selection": "A.CWE-1095:Loop Condition Value Update within the Loop\nB.CWE-707:Improper Neutralization\nC.CWE-36:Absolute Path Traversal\nD.No Vulnerabilities\nE.CWE-296:Improper Following of a Certificate's Chain of Trust", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * * dataPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96965"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.CWE-354:Improper Validation of Integrity Check Value\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-530:Exposure of Backup File to an Unauthorized Control Sphere", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, char *> dataMap);\n\nvoid m()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, char *> dataMap);\n\nstatic void nG2B()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|C.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82021"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-551:Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\nC.CWE-437:Incomplete Model of Endpoint Features\nD.No Vulnerabilities\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \n#include <time.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint trever_stuffily = 0;\nint global_variable;\nvoid below_gobies(void **brunetness_ungrammatic);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid resinated_margarine(void (*unexpectantly_vulpecula)(void **));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&trever_stuffily,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      resinated_margarine(below_gobies);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid below_gobies(void **brunetness_ungrammatic)\n{\n  void *idiospastic_buttercups = 0;\n  char *shivery_diffusionism;\n  ++global_variable;;\n  setup_printf_context();\n  shivery_diffusionism = getenv(\"INTERWORD_SUBSIDIZE\");\n  if (shivery_diffusionism != 0) {;\n    idiospastic_buttercups = ((void *)shivery_diffusionism);\n     *brunetness_ungrammatic = idiospastic_buttercups;\n  }\n}\n\nvoid resinated_margarine(void (*unexpectantly_vulpecula)(void **))\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    char *result = 0;\n    int random_int = 0;\n  char *braker_soldier = 0;\n  int frownful_goliard;\n  void **bullom_hydrophones = 0;\n  void **animadversions_hobgoblins = 0;\n  ++global_variable;\n  void *deployed_prelawfulness = 0;\n  unexpectantly_vulpecula(&deployed_prelawfulness);\n  if (((char *)deployed_prelawfulness) != 0) {;\n    frownful_goliard = 1;\n    bullom_hydrophones = &deployed_prelawfulness;\n    animadversions_hobgoblins = ((void **)(((unsigned long )bullom_hydrophones) * frownful_goliard * frownful_goliard)) + 5;\n    braker_soldier = ((char *)((char *)( *(animadversions_hobgoblins - 5))));\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  srand(time(NULL));\n  random_int = (rand() % 1000) + 100;\n        snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, braker_soldier);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n            \n            printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  result = PQcmdTuples(res);\n        printf(\"Query OK, %s rows affected\\n\",result);\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\nclose_printf_context();\n  }\n}", "answer": "E.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|A.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152707"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-15:External Control of System or Configuration Setting\nC.CWE-1330:Remanent Data Readable after Memory Erase\nD.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_51bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-15:External Control of System or Configuration Setting|A.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82007"}
{"selection": "A.No Vulnerabilities\nB.CWE-1071:Empty Code Block\nC.CWE-1127:Compilation with Insufficient Warnings or Errors\nD.CWE-707:Improper Neutralization\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define SYSTEM system\n#else \n#define SYSTEM system\n#endif\n\nchar * _OS_Command_Injection__char_listen_socket_system_68Data;\nchar * _OS_Command_Injection__char_listen_socket_system_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_listen_socket_system_68bSink();\n\nvoid _OS_Command_Injection__char_listen_socket_system_68()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__char_listen_socket_system_68Data = data;\n    _OS_Command_Injection__char_listen_socket_system_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_listen_socket_system_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_listen_socket_system_68G2BData = data;\n    _OS_Command_Injection__char_listen_socket_system_68bG2BSink();\n}\n\nvoid _OS_Command_Injection__char_listen_socket_system_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_system_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_system_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246071"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-114:Process Control\nC.No Vulnerabilities\nD.CWE-1104:Use of Unmaintained Third Party Components\nE.CWE-1272:Sensitive Information Uncleared Before Debug/Power State Transition", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    funcPtr(data);\n}\n\nvoid _Process_Control__w32_wchar_t_file_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62399"}
{"selection": "A.CWE-311:Missing Encryption of Sensitive Data\nB.CWE-707:Improper Neutralization\nC.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_09()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123095"}
{"selection": "A.No Vulnerabilities\nB.CWE-1119:Excessive Use of Unconditional Branching\nC.CWE-707:Improper Neutralization\nD.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nE.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nint gigamaree_leucite = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid schapping_sesterce(int leitao_wyvern,char **tabic_fideicommissor);\nvoid burned_canonise(int dereistic_metasoma,char **hierogrammatist_bedsheets);\n\nunsigned int avdevice_version()\n{\n  int apaturia_willingest = 7;\n  char **eleroy_unpraying = 0;\n  char **pressurizers_distinctionless = 0;\n  int bristly_dowie = 89;\n  char *undivorceable_uglifiers;;\n  if (__sync_bool_compare_and_swap(&gigamaree_leucite,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&undivorceable_uglifiers,\"2474\",bristly_dowie);\n      if (undivorceable_uglifiers != 0) {;\n        eleroy_unpraying = &undivorceable_uglifiers;\n        pressurizers_distinctionless = eleroy_unpraying + 5;\n        schapping_sesterce(apaturia_willingest,pressurizers_distinctionless);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid schapping_sesterce(int leitao_wyvern,char **tabic_fideicommissor)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  int is_valid = 1;\n  int i = 0;\n  char cmd_str[1000] = {0};\n  char *imboscata_gozell = 0;\n  ++global_variable;\n  leitao_wyvern--;\n  if (leitao_wyvern > 0) {\n    burned_canonise(leitao_wyvern,tabic_fideicommissor);\n    return ;\n  }\n  imboscata_gozell = ((char *)( *(tabic_fideicommissor - 5)));\n    \n    \n\n    snprintf(cmd_str, 1000, \"vim -s \" \"/opt/cus/workspace/testData/\" \"vim_scripts/hello.vim %s\", imboscata_gozell);\n    \n    for (; i < strlen(imboscata_gozell); ++i) {\n        if (imboscata_gozell[i] == ';') {\n          if (i == 0 || imboscata_gozell[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (imboscata_gozell[i] == '|') {\n          if (i == 0 || imboscata_gozell[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (imboscata_gozell[i] == '|') {\n          if (i == 0 || imboscata_gozell[i - 1] != '|') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (imboscata_gozell[i] == '&') {\n          if (i == 0 || imboscata_gozell[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (imboscata_gozell[i] == '&') {\n          if (i == 0 || imboscata_gozell[i - 1] != '&') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      \n      if (is_valid == 1) {\n        \n\n        fpipe = popen(cmd_str, \"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n  if ( *(tabic_fideicommissor - 5) != 0) \n    free(((char *)( *(tabic_fideicommissor - 5))));\nclose_printf_context();\n}\n\nvoid burned_canonise(int dereistic_metasoma,char **hierogrammatist_bedsheets)\n{\n  ++global_variable;\n  schapping_sesterce(dereistic_metasoma,hierogrammatist_bedsheets);\n}", "answer": "D.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|C.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152543"}
{"selection": "A.No Vulnerabilities\nB.CWE-920:Improper Restriction of Power Consumption\nC.CWE-23:Relative Path Traversal\nD.CWE-350:Reliance on Reverse DNS Resolution for a Security-Critical Action\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_ofstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(wchar_t * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(wchar_t * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_ofstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91380"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-209:Generation of Error Message Containing Sensitive Information\nD.CWE-23:Relative Path Traversal\nE.CWE-939:Improper Authorization in Handler for Custom URL Scheme", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_52\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_52; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89802"}
{"selection": "A.No Vulnerabilities\nB.CWE-768:Incorrect Short Circuit Evaluation\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-1303:Non-Transparent Sharing of Microarchitectural Resources", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_wchar_t_connect_socket_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(wchar_t * &data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(wchar_t * &data)\n{\n    \n    wcscat(data, L\"Doe, XXXXX\");\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_connect_socket_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123113"}
{"selection": "A.CWE-114:Process Control\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-691:Insufficient Control Flow Management\nE.CWE-924:Improper Enforcement of Message Integrity During Transmission in a Communication Channel", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_connect_socket_06()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_connect_socket_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_connect_socket_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_connect_socket_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-114:Process Control|B.CWE-707:Improper Neutralization", "cwe": "114", "idx": "61945"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-36:Absolute Path Traversal\nC.CWE-761:Free of Pointer not at Start of Buffer\nD.No Vulnerabilities\nE.CWE-732:Incorrect Permission Assignment for Critical Resource", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_open_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_open_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97869"}
{"selection": "A.CWE-565:Reliance on Cookies without Validation and Integrity Checking\nB.CWE-36:Absolute Path Traversal\nC.CWE-1164:Irrelevant Code\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_fopen_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_fopen_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95807"}
{"selection": "A.CWE-663:Use of a Non-reentrant Function in a Concurrent Context\nB.CWE-548:Exposure of Information Through Directory Listing\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_w32spawnl_16()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcat(data, \"*.*\");\n        break;\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32spawnl_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32spawnl_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32spawnl_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246234"}
{"selection": "A.CWE-437:Incomplete Model of Endpoint Features\nB.CWE-707:Improper Neutralization\nC.CWE-1392:Use of Default Credentials\nD.CWE-36:Absolute Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_43\n{\n\n#ifndef OMITM\n\nvoid mSource(wchar_t * &data)\n{\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(wchar_t * &data)\n{\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97292"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-374:Passing Mutable Objects to an Untrusted Method\nD.CWE-36:Absolute Path Traversal\nE.CWE-325:Missing Cryptographic Step", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_ifstream_22\n{\n\n#ifndef OMITM\n\n\nint mGlobal = 0;\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    mGlobal = 1; \n    data = mSource(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n    ;\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint nG2B1Global = 0;\nint nG2B2Global = 0;\n\n\nwchar_t * nG2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2B1Global = 0; \n    data = nG2B1Source(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n    ;\n}\n\n\nwchar_t * nG2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2B2Global = 1; \n    data = nG2B2Source(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n    ;\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_ifstream_22; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97525"}
{"selection": "A.No Vulnerabilities\nB.CWE-191:Integer Underflow (Wrap or Wraparound)\nC.CWE-707:Improper Neutralization\nD.CWE-1072:Data Resource Access without Use of Connection Pooling\nE.CWE-1102:Reliance on Machine-Dependent Data Representation", "code": "#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint induvial_explainable = 0;\nint global_variable;\ntypedef char *manstopping_radioneuritis;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint 191_global_var = 0;\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n        char buff[128];\n        short max_size = 128;\n        short remaining_space = 0;\n        int size = 0;\n        FILE * file = 0;\n  char *tilletiaceous_amos = 0;\n  manstopping_radioneuritis calomorphic_trapezophora = 0;\n  int *unpreventively_slovene = 0;\n  int dicranaceous_foreknows;\n  manstopping_radioneuritis conspissate_macomber[10] = {0};\n  manstopping_radioneuritis kristi_avocation = 0;\n  char *cordey_plurilingualist;;\n  if (__sync_bool_compare_and_swap(&induvial_explainable,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      cordey_plurilingualist = getenv(\"TRICHLORFON_HYPNOTISE\");\n      if (cordey_plurilingualist != 0) {;\n        kristi_avocation = cordey_plurilingualist;\n        conspissate_macomber[5] = kristi_avocation;\n        dicranaceous_foreknows = 5;\n        unpreventively_slovene = &dicranaceous_foreknows;\n        calomorphic_trapezophora =  *(conspissate_macomber +  *unpreventively_slovene);\n        if (calomorphic_trapezophora != 0) {\n          goto bloodlust_thirion;\n        }\n        ++global_variable;\n        bloodlust_thirion:;\n        tilletiaceous_amos = ((char *)calomorphic_trapezophora);\n        \n        file = fopen(tilletiaceous_amos, \"r\");\n        if(file != NULL){\n                fseek(file, 0, SEEK_END);\n                size = ftell(file);\n                fseek(file, 0, SEEK_SET);\n                \n                \n                remaining_space = max_size - size;\n                \n                \n                \n                \n                if(remaining_space > 0){\n                        fscanf(file, \"%s\", buff);\n                        printf(\"Contents of file: %s\\n\", buff);\n                }\n                \n                fclose(file);\n        }\n        \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "B.CWE-191:Integer Underflow (Wrap or Wraparound)|C.CWE-707:Improper Neutralization", "cwe": "191", "idx": "151050"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-909:Missing Initialization of Resource\nC.CWE-385:Covert Timing Channel\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_52bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_file_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_52bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-909:Missing Initialization of Resource|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123261"}
{"selection": "A.No Vulnerabilities\nB.CWE-1097:Persistent Storable Data Element without Associated Comparison Control Element\nC.CWE-1069:Empty Exception Block\nD.CWE-36:Absolute Path Traversal\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97011"}
{"selection": "A.CWE-194:Unexpected Sign Extension\nB.No Vulnerabilities\nC.CWE-683:Function Call With Incorrect Order of Arguments\nD.CWE-707:Improper Neutralization\nE.CWE-1092:Use of Same Invokable Control Element in Multiple Architectural Layers", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint hallan_unreasoned = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid doricism_aslaver(void **unabortive_sectarians);\nshort get_int_value(char *ss_tainted_buff)\n{\n  \n  short to_short = 0;\n  int tainted_int = 0;\n  tainted_int = atoi(ss_tainted_buff);\n  if (tainted_int != 0) {\n    if (tainted_int > 30000)\n      tainted_int = 30000;\n    if (tainted_int < -30000)\n      tainted_int = -30000;\n    to_short = ((short )tainted_int);\n  }\n  return to_short;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n#define ULNAR_UNITABLE(x) doricism_aslaver((void **) x)\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  int saxaul_adiposity;\n  void **unactiveness_nonblank = 0;\n  void **kaleidoscope_zees = 0;\n  void *baffle_srcn = 0;\n  char *locoweed_youthhood;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&hallan_unreasoned,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      locoweed_youthhood = getenv(\"CLIMATOGRAPHY_FURANOSIDE\");\n      if (locoweed_youthhood != 0) {;\n        baffle_srcn = ((void *)locoweed_youthhood);\n        saxaul_adiposity = 1;\n        unactiveness_nonblank = &baffle_srcn;\n        kaleidoscope_zees = ((void **)(((unsigned long )unactiveness_nonblank) * saxaul_adiposity * saxaul_adiposity)) + 5;\n\tULNAR_UNITABLE(kaleidoscope_zees);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid doricism_aslaver(void **unabortive_sectarians)\n{\n    unsigned int to_unsign = 0;\n    char *buff = 0;\n    FILE *file = 0;\n    int counter = 0;\n    int bytes_read = 0;\n  char *caconychia_pedaliter = 0;\n  ++global_variable;;\n  caconychia_pedaliter = ((char *)((char *)( *(unabortive_sectarians - 5))));\n    \n    buff = ((char *)(malloc(30000 * sizeof(char ))));\n    if (buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    memset(buff, 0, 30000);\n    \n\n    to_unsign = get_int_value(caconychia_pedaliter);\n    \n    \n    \n    file = fopen(\"/opt/cus/workspace/testData/myfile.txt\",\"r\");\n    if (file != 0) {\n        \n        while (((unsigned int )counter) < to_unsign) {\n            \n            bytes_read = fread(&buff[counter],\n                sizeof(char), 1000, file);\n            if (bytes_read == 0) {\n                break;\n            }\n            counter += bytes_read;\n        }\n        \n        fclose(file);\n        buff[to_unsign] = '\\0';\n        printf(\"buff is %d long, and has contents: %s \\n\",strlen(buff), buff);\n    } else {\n        printf(\"Cannot open file %s\\n\", \"/opt/cus/workspace/testData/myfile.txt\");\n    }\n    if (buff != 0) {\n        free(buff);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "A.CWE-194:Unexpected Sign Extension|D.CWE-707:Improper Neutralization", "cwe": "194", "idx": "150857"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.CWE-403:Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')\nE.CWE-520:.NET Misconfiguration: Use of Impersonation", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_05()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81982"}
{"selection": "A.No Vulnerabilities\nB.CWE-205:Observable Behavioral Discrepancy\nC.CWE-267:Privilege Defined With Unsafe Actions\nD.CWE-36:Absolute Path Traversal\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_open_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_open_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97391"}
{"selection": "A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nB.CWE-1042:Static Member Data Element outside of a Singleton Class Element\nC.CWE-1049:Excessive Data Query Operations in a Large Data Table\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint objectizing_bedawn = 0;\ntypedef char *gyrophoraceae_nlf;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  int is_valid = 1;\n  int i = 0;\n  char cmd_str[1000] = {0};\n  char *engolden_oligocene = 0;\n  jmp_buf haliserites_menstrual;\n  int bullnoses_odacidae;\n  gyrophoraceae_nlf **********wrinkleless_prelogical = 0;\n  gyrophoraceae_nlf *********ornithivorous_kimmel = 0;\n  gyrophoraceae_nlf ********ultrastylish_mellisonant = 0;\n  gyrophoraceae_nlf *******dictaphones_poppadom = 0;\n  gyrophoraceae_nlf ******thacking_embayed = 0;\n  gyrophoraceae_nlf *****crabs_umbriel = 0;\n  gyrophoraceae_nlf ****chronomastix_synthetism = 0;\n  gyrophoraceae_nlf ***anaphrodisiac_unfretted = 0;\n  gyrophoraceae_nlf **necia_uncarnate = 0;\n  gyrophoraceae_nlf *viscidity_apollo = 0;\n  gyrophoraceae_nlf overidolatrous_clammyweed = 0;\n  gyrophoraceae_nlf hemopoiesis_flatwash = 0;\n  char *defoliating_temperamentally;;\n  if (__sync_bool_compare_and_swap(&objectizing_bedawn,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&defoliating_temperamentally,\"WRITHY_OVERLAYED\");\n      if (defoliating_temperamentally != 0) {;\n        hemopoiesis_flatwash = defoliating_temperamentally;\n        viscidity_apollo = &hemopoiesis_flatwash;\n        necia_uncarnate = &viscidity_apollo;\n        anaphrodisiac_unfretted = &necia_uncarnate;\n        chronomastix_synthetism = &anaphrodisiac_unfretted;\n        crabs_umbriel = &chronomastix_synthetism;\n        thacking_embayed = &crabs_umbriel;\n        dictaphones_poppadom = &thacking_embayed;\n        ultrastylish_mellisonant = &dictaphones_poppadom;\n        ornithivorous_kimmel = &ultrastylish_mellisonant;\n        wrinkleless_prelogical = &ornithivorous_kimmel;\n        bullnoses_odacidae = setjmp(haliserites_menstrual);\n        if (bullnoses_odacidae == 0) {\n          longjmp(haliserites_menstrual,1);\n        }\n        engolden_oligocene = ((char *)( *( *( *( *( *( *( *( *( *( *wrinkleless_prelogical)))))))))));\n    \n    \n\n    snprintf(cmd_str, 1000, \"vim -s \" \"/opt/cus/workspace/testData/\" \"vim_scripts/hello.vim %s\", engolden_oligocene);\n    \n    for (; i < strlen(engolden_oligocene); ++i) {\n        if (engolden_oligocene[i] == ';') {\n          if (i == 0 || engolden_oligocene[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (engolden_oligocene[i] == '|') {\n          if (i == 0 || engolden_oligocene[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (engolden_oligocene[i] == '|') {\n          if (i == 0 || engolden_oligocene[i - 1] != '|') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (engolden_oligocene[i] == '&') {\n          if (i == 0 || engolden_oligocene[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (engolden_oligocene[i] == '&') {\n          if (i == 0 || engolden_oligocene[i - 1] != '&') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      \n      if (is_valid == 1) {\n        \n\n        fpipe = popen(cmd_str, \"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if ( *( *( *( *( *( *( *( *( *( *wrinkleless_prelogical))))))))) != 0) \n          free(((char *)( *( *( *( *( *( *( *( *( *( *wrinkleless_prelogical))))))))))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "A.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|D.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152393"}
{"selection": "A.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nB.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')\nC.CWE-707:Improper Neutralization\nD.CWE-685:Function Call With Incorrect Number of Arguments\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint exothermicity_originality = 0;\nint global_variable;\n\nunion denunciations_enplaned \n{\n  char *bedeafens_semiferal;\n  double erotics_chatty;\n  char *deciduae_hirmologion;\n  char feudee_witneys;\n  int diatomaceae_rectifiability;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid cookbook_cern(union denunciations_enplaned *terrestrially_arthrostome);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n#define FOVEAS_HERULIAN(x) cookbook_cern((union denunciations_enplaned *) x)\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  union denunciations_enplaned *dsd_prevesical = {0};\n  union denunciations_enplaned hawks_longisection;\n  char *embolum_allare;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&exothermicity_originality,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      embolum_allare = getenv(\"MOYOBAMBA_SUBCONICALLY\");\n      if (embolum_allare != 0) {;\n        hawks_longisection . bedeafens_semiferal = embolum_allare;\n        dsd_prevesical = &hawks_longisection;\n\tFOVEAS_HERULIAN(dsd_prevesical);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid cookbook_cern(union denunciations_enplaned *terrestrially_arthrostome)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *fluorindine_ruesomeness = 0;\n  ++global_variable;;\n  fluorindine_ruesomeness = ((char *)( *terrestrially_arthrostome) . bedeafens_semiferal);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(fluorindine_ruesomeness); ++i) {\n        if (fluorindine_ruesomeness[i] == ';') {\n          if (i == 0 || fluorindine_ruesomeness[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,fluorindine_ruesomeness);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n}", "answer": "B.CWE-88:Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')|C.CWE-707:Improper Neutralization", "cwe": "88", "idx": "152556"}
{"selection": "A.CWE-617:Reachable Assertion\nB.CWE-607:Public Static Final Field References Mutable Object\nC.CWE-23:Relative Path Traversal\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_03\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_03; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89822"}
{"selection": "A.CWE-1316:Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges\nB.No Vulnerabilities\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-834:Excessive Iteration", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_connect_socket_execlp_81\n{\n\nclass _OS_Command_Injection__char_connect_socket_execlp_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_connect_socket_execlp_81 : public _OS_Command_Injection__char_connect_socket_execlp_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_connect_socket_execlp_81G2B : public _OS_Command_Injection__char_connect_socket_execlp_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244095"}
{"selection": "A.CWE-1253:Incorrect Selection of Fuse Values\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-345:Insufficient Verification of Data Authenticity\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_wchar_t_console_81\n{\n\nclass _LDAP_Injection__w32_wchar_t_console_81_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_wchar_t_console_81 : public _LDAP_Injection__w32_wchar_t_console_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_wchar_t_console_81G2B : public _LDAP_Injection__w32_wchar_t_console_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n}", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123179"}
{"selection": "A.No Vulnerabilities\nB.CWE-23:Relative Path Traversal\nC.CWE-707:Improper Neutralization\nD.CWE-1327:Binding to an Unrestricted IP Address\nE.CWE-696:Incorrect Behavior Order", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__char_listen_socket_w32CreateFile_22\n{\n\n#ifndef OMITM\n\n\nint mGlobal = 0;\n\nchar * mSource(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mGlobal = 1; \n    data = mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n    ;\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint nG2B1Global = 0;\nint nG2B2Global = 0;\n\n\nchar * nG2B1Source(char * data);\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2B1Global = 0; \n    data = nG2B1Source(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n    ;\n}\n\n\nchar * nG2B2Source(char * data);\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2B2Global = 1; \n    data = nG2B2Source(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n    ;\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_w32CreateFile_22; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90751"}
{"selection": "A.CWE-409:Improper Handling of Highly Compressed Data (Data Amplification)\nB.CWE-707:Improper Neutralization\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.No Vulnerabilities\nE.CWE-280:Improper Handling of Insufficient Permissions or Privileges ", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint antitax_test = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid schusses_prefamously(char **molten_neediness);\n\nSize PMSignalShmemSize()\n{\n  void (*resourceless_intransparent)(char **) = schusses_prefamously;\n  int vandenberg_resultantly;\n  char **pudic_champac = 0;\n  char **mechitarist_nonsupplicating = 0;\n  int chantilly_apophorometer = 0;\n  char *conveyers_gorillaship = 0;\n  int vaticinator_cymose = 28;\n  char *bought_lolls;\n  Size size;\n  if (__sync_bool_compare_and_swap(&antitax_test,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&bought_lolls,\"5259\",vaticinator_cymose);\n      if (bought_lolls != 0) {;\n        chantilly_apophorometer = ((int )(strlen(bought_lolls)));\n        conveyers_gorillaship = ((char *)(malloc(chantilly_apophorometer + 1)));\n        if (conveyers_gorillaship == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(conveyers_gorillaship,0,chantilly_apophorometer + 1);\n        memcpy(conveyers_gorillaship,bought_lolls,chantilly_apophorometer);\n        if (bought_lolls != 0) \n          free(((char *)bought_lolls));\n        vandenberg_resultantly = 1;\n        pudic_champac = &conveyers_gorillaship;\n        mechitarist_nonsupplicating = ((char **)(((unsigned long )pudic_champac) * vandenberg_resultantly * vandenberg_resultantly)) + 5;\n        resourceless_intransparent(mechitarist_nonsupplicating);\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid schusses_prefamously(char **molten_neediness)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *lydell_blockpate = 0;\n  ++global_variable;;\n  lydell_blockpate = ((char *)( *(molten_neediness - 5)));\n    \n    if (strlen(lydell_blockpate) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,lydell_blockpate);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n  if ( *(molten_neediness - 5) != 0) \n    free(((char *)( *(molten_neediness - 5))));\nclose_printf_context();\n}", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152522"}
{"selection": "A.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-23:Relative Path Traversal\nE.CWE-862:Missing Authorization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_w32CreateFile_81\n{\n\nclass _Relative_Path_Traversal__char_console_w32CreateFile_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_console_w32CreateFile_81 : public _Relative_Path_Traversal__char_console_w32CreateFile_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_console_w32CreateFile_81G2B : public _Relative_Path_Traversal__char_console_w32CreateFile_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "D.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90056"}
{"selection": "A.CWE-664:Improper Control of a Resource Through its Lifetime\nB.CWE-1102:Reliance on Machine-Dependent Data Representation\nC.CWE-698:Execution After Redirect (EAR)\nD.CWE-820:Missing Synchronization\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint resultance_butyl = 0;\nint global_variable;\ntypedef char *gattamelata_wakener;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid speight_unaesthetical(gattamelata_wakener cometwise_exasperations);\nvoid orfield_orthographer(gattamelata_wakener interblended_stria);\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  gattamelata_wakener subnaturally_ketoses = 0;\n  char *grandiosity_confidences;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&resultance_butyl,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      grandiosity_confidences = getenv(\"MATINDOL_UNSPACED\");\n      if (grandiosity_confidences != 0) {;\n        subnaturally_ketoses = grandiosity_confidences;\n        speight_unaesthetical(subnaturally_ketoses);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid speight_unaesthetical(gattamelata_wakener cometwise_exasperations)\n{\n  ++global_variable;;\n  orfield_orthographer(cometwise_exasperations);\n}\n\nvoid orfield_orthographer(gattamelata_wakener interblended_stria)\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *vulvovaginitis_denticulation = 0;\n  ++global_variable;;\n  vulvovaginitis_denticulation = ((char *)interblended_stria);\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(vulvovaginitis_denticulation, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\nclose_printf_context();\n}", "answer": "D.CWE-820:Missing Synchronization|A.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "820", "idx": "150320"}
{"selection": "A.CWE-637:Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-36:Absolute Path Traversal\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _Absolute_Path_Traversal__char_file_ifstream_05\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_ifstream_05; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96310"}
{"selection": "A.No Vulnerabilities\nB.CWE-305:Authentication Bypass by Primary Weakness\nC.CWE-707:Improper Neutralization\nD.CWE-36:Absolute Path Traversal\nE.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nwchar_t * _Absolute_Path_Traversal__wchar_t_console_fopen_68Data;\nwchar_t * _Absolute_Path_Traversal__wchar_t_console_fopen_68G2BData;\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_68\n{\n\n#ifndef OMITM\n\n\nvoid mSink();\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    _Absolute_Path_Traversal__wchar_t_console_fopen_68Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink();\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    _Absolute_Path_Traversal__wchar_t_console_fopen_68G2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_68; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97018"}
{"selection": "A.No Vulnerabilities\nB.CWE-835:Loop with Unreachable Exit Condition ('Infinite Loop')\nC.CWE-707:Improper Neutralization\nD.CWE-1079:Parent Class without Virtual Destructor Method\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_open_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_open_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97850"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-636:Not Failing Securely ('Failing Open')\nE.CWE-563:Assignment to Variable without Use", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_09()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123287"}
{"selection": "A.CWE-419:Unprotected Primary Channel\nB.CWE-369:Divide By Zero\nC.No Vulnerabilities\nD.CWE-1056:Invokable Control Element with Variadic Parameters\nE.CWE-707:Improper Neutralization", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint handwritten_coderived = 0;\nint global_variable;\nvoid handle_taint(char *molters_acuminous);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&handwritten_coderived,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *molters_acuminous)\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *treasureless_digesting = 0;\n  char *untidies_lycaon[36] = {0};\n  ++global_variable;;\n  if (molters_acuminous != 0) {;\n    untidies_lycaon[2] = molters_acuminous;\n    if (untidies_lycaon[2] != 0) {\n      goto devereux_nonnational;\n    }\n    ++global_variable;\n    devereux_nonnational:;\n    treasureless_digesting = ((char *)untidies_lycaon[2]);\n    \n    input = atoi(treasureless_digesting);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\n    if (untidies_lycaon[2] != 0) \n      free(((char *)untidies_lycaon[2]));\nclose_printf_context();\n  }\n}", "answer": "B.CWE-369:Divide By Zero|E.CWE-707:Improper Neutralization", "cwe": "369", "idx": "151178"}
{"selection": "A.No Vulnerabilities\nB.CWE-1259:Improper Restriction of Security Token Assignment\nC.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nD.CWE-707:Improper Neutralization\nE.CWE-598:Use of GET Request Method With Sensitive Query Strings", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \nint nonassimilation_recrement = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid uncharmable_multiplated(int eduardo_illiopolis,char **averment_masonic);\nvoid discomposedness_yagourundi(int scattergrams_unobtrusiveness,char **reunited_tenorino);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int unveiledly_raynold = 7;\n  char **trivvet_arette = 0;\n  char **reinoculations_pookhaun = 0;\n  char *denasalize_faso;;\n  if (__sync_bool_compare_and_swap(&nonassimilation_recrement,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      denasalize_faso = getenv(\"RICHTON_UNATTACKED\");\n      if (denasalize_faso != 0) {;\n        trivvet_arette = &denasalize_faso;\n        reinoculations_pookhaun = trivvet_arette + 5;\n        uncharmable_multiplated(unveiledly_raynold,reinoculations_pookhaun);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid uncharmable_multiplated(int eduardo_illiopolis,char **averment_masonic)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int nFields;\n    int i;\n    int j = 0;\n  char *onionet_unbeget = 0;\n  ++global_variable;\n  eduardo_illiopolis--;\n  if (eduardo_illiopolis > 0) {\n    discomposedness_yagourundi(eduardo_illiopolis,averment_masonic);\n    return ;\n  }\n  onionet_unbeget = ((char *)( *(averment_masonic - 5)));\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", onionet_unbeget);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            \n            printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        nFields = PQnfields(res);\n        for (i = 0; i < nFields; i++)\n            printf(\"%-15s\", PQfname(res, i));\n        printf(\"\\n\\n\");\n        \n        for (i = 0; i < PQntuples(res); i++)\n        {\n            for (j = 0; j < nFields; j++)\n                printf(\"%-15s\", PQgetvalue(res, i, j));\n            printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\nclose_printf_context();\n}\n\nvoid discomposedness_yagourundi(int scattergrams_unobtrusiveness,char **reunited_tenorino)\n{\n  ++global_variable;\n  uncharmable_multiplated(scattergrams_unobtrusiveness,reunited_tenorino);\n}", "answer": "C.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|D.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152623"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-1039:Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90958"}
{"selection": "A.CWE-1118:Insufficient Documentation of Error Handling Techniques\nB.CWE-654:Reliance on a Single Factor in a Security Decision\nC.CWE-707:Improper Neutralization\nD.CWE-36:Absolute Path Traversal\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_open_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_open_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97159"}
{"selection": "A.CWE-522:Insufficiently Protected Credentials\nB.No Vulnerabilities\nC.CWE-663:Use of a Non-reentrant Function in a Concurrent Context\nD.CWE-707:Improper Neutralization\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_18\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    wcscat(data, L\"file.txt\");\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_18; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91853"}
{"selection": "A.CWE-1051:Initialization with Hard-Coded Network Resource Configuration Data\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.No Vulnerabilities\nE.CWE-614:Sensitive Cookie in HTTPS Session Without 'Secure' Attribute", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_wchar_t_connect_socket_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_53bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123118"}
{"selection": "A.No Vulnerabilities\nB.CWE-118:Incorrect Access of Indexable Resource ('Range Error')\nC.CWE-23:Relative Path Traversal\nD.CWE-707:Improper Neutralization\nE.CWE-497:Exposure of Sensitive System Information to an Unauthorized Control Sphere", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82\n{\n\nclass _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82 : public _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82G2B : public _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "C.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89817"}
{"selection": "A.No Vulnerabilities\nB.CWE-1043:Data Element Aggregating an Excessively Large Number of Non-Primitive Elements\nC.CWE-1283:Mutable Attestation or Measurement Reporting Data\nD.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nE.CWE-707:Improper Neutralization", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <time.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint eggcrate_zimme = 0;\nint global_variable;\ntypedef char *chromate_dascylus;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid empyreumatic_prepaleolithic(const chromate_dascylus saffior_tubeworks);\nvoid ignace_summerless(chromate_dascylus dispellable_bessie);\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  chromate_dascylus malpresentation_lihyanite = 0;\n  int vaalite_liles = 73;\n  char *hottie_hemianopic;;\n  if (__sync_bool_compare_and_swap(&eggcrate_zimme,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&hottie_hemianopic,\"2147\",vaalite_liles);\n      if (hottie_hemianopic != 0) {;\n        malpresentation_lihyanite = hottie_hemianopic;\n        empyreumatic_prepaleolithic(malpresentation_lihyanite);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n#define STARTUP_ATTRIBUTIONAL(x) ignace_summerless((chromate_dascylus) x)\n\nvoid empyreumatic_prepaleolithic(const chromate_dascylus saffior_tubeworks)\n{\n  ++global_variable;;\n\tSTARTUP_ATTRIBUTIONAL(saffior_tubeworks);\n}\n\nvoid ignace_summerless(chromate_dascylus dispellable_bessie)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  int random_int = 0;\n  char *hectar_strangers = 0;\n  ++global_variable;;\n  hectar_strangers = ((char *)((chromate_dascylus )dispellable_bessie));\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n    srand(time(NULL));\n    random_int = (rand() % 1000) + 100;\n                snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, hectar_strangers);\n    \n                \n                \n\n                if (mysql_query(conn,query_buffer)) {\n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n    } else {\n      printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n  if (((chromate_dascylus )dispellable_bessie) != 0) \n    free(((char *)((chromate_dascylus )dispellable_bessie)));\nclose_printf_context();\n}", "answer": "D.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|E.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152577"}
{"selection": "A.CWE-1330:Remanent Data Readable after Memory Erase\nB.No Vulnerabilities\nC.CWE-476:NULL Pointer Dereference\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-692:Incomplete Denylist to Cross-Site Scripting", "code": "#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint cupula_bono = 0;\nint global_variable;\nvoid handle_taint(char *rereel_nonentity);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid crawlers_matranee(char ***********danish_randomizes);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&cupula_bono,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n#define CNCC_BACKFIRED(x) crawlers_matranee((char ***********) x)\n\nvoid handle_taint(char *rereel_nonentity)\n{\n  char ***********camatina_irishwomen = 0;\n  char **********parasitotropic_smooch = 0;\n  char *********addams_rhuses = 0;\n  char ********despairful_jenei = 0;\n  char *******ellga_mojo = 0;\n  char ******lars_antireducer = 0;\n  char *****disk_unequability = 0;\n  char ****diode_colonnades = 0;\n  char ***cymbals_gauhati = 0;\n  char **enflagellation_orthopraxia = 0;\n  char *pleurodirous_demiheavenly = 0;\n  ++global_variable;;\n  if (rereel_nonentity != 0) {;\n    enflagellation_orthopraxia = &rereel_nonentity;\n    cymbals_gauhati = &enflagellation_orthopraxia;\n    diode_colonnades = &cymbals_gauhati;\n    disk_unequability = &diode_colonnades;\n    lars_antireducer = &disk_unequability;\n    ellga_mojo = &lars_antireducer;\n    despairful_jenei = &ellga_mojo;\n    addams_rhuses = &despairful_jenei;\n    parasitotropic_smooch = &addams_rhuses;\n    camatina_irishwomen = &parasitotropic_smooch;\n\tCNCC_BACKFIRED(camatina_irishwomen);\n  }\n}\n\nvoid crawlers_matranee(char ***********danish_randomizes)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *antigone_swordbearer = 0;\n  ++global_variable;;\n  antigone_swordbearer = ((char *)( *( *( *( *( *( *( *( *( *( *danish_randomizes)))))))))));\n      \n      while(isalnum(antigone_swordbearer[size]) && size < strlen(antigone_swordbearer)){\n        ++size;\n      }\n      \n\n      if (size != strlen(antigone_swordbearer)) {\n        antigone_swordbearer = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,antigone_swordbearer);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if ( *( *( *( *( *( *( *( *( *( *danish_randomizes))))))))) != 0) \n    free(((char *)( *( *( *( *( *( *( *( *( *( *danish_randomizes))))))))))));\nclose_printf_context();\n}", "answer": "C.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149483"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-548:Exposure of Information Through Directory Listing\nC.No Vulnerabilities\nD.CWE-36:Absolute Path Traversal\nE.CWE-1021:Improper Restriction of Rendered UI Layers or Frames", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_file_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96436"}
{"selection": "A.No Vulnerabilities\nB.CWE-1275:Sensitive Cookie with Improper SameSite Attribute\nC.CWE-707:Improper Neutralization\nD.CWE-1293:Missing Source Correlation of Multiple Independent Data\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96957"}
{"selection": "A.CWE-1007:Insufficient Visual Distinction of Homoglyphs Presented to User\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-447:Unimplemented or Unsupported Feature in UI\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_open_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_open_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96650"}
{"selection": "A.No Vulnerabilities\nB.CWE-481:Assigning instead of Comparing\nC.CWE-941:Incorrectly Specified Destination in a Communication Channel\nD.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer\nE.CWE-707:Improper Neutralization", "code": "#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint svres_middlesworth = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n int oc_i = 0;\n int opt_var;\n  char *junkyards_gawney = 0;\n  char **rehood_satellitoid = 0;\n  int vereeniging_milanville = 0;\n  char *guildford_epicier = 0;\n  char *piffero_qualificator;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&svres_middlesworth,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      piffero_qualificator = getenv(\"UNIQUEST_NONPHILOLOGIC\");\n      if (piffero_qualificator != 0) {;\n        vereeniging_milanville = ((int )(strlen(piffero_qualificator)));\n        guildford_epicier = ((char *)(malloc(vereeniging_milanville + 1)));\n        if (guildford_epicier == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(guildford_epicier,0,vereeniging_milanville + 1);\n        memcpy(guildford_epicier,piffero_qualificator,vereeniging_milanville);\n        rehood_satellitoid = &guildford_epicier;\n        if ( *rehood_satellitoid != 0) {\n          goto pawl_sealant;\n        }\n        ++global_variable;\n        pawl_sealant:;\n        junkyards_gawney = ((char *)( *rehood_satellitoid));\n    \n size_t (*canary_pointer[1])(const char *);\n char base_path[20];\n    if (strlen(junkyards_gawney) < 20) {\n        canary_pointer[0] = strlen;\n        memset(base_path,0,20);\n        \n        \n        \n        \n        \n        \n        \n  \n  \n        realpath(junkyards_gawney,base_path);\n        opt_var = canary_pointer[0](base_path);\n        \n        for (; oc_i < opt_var; ++oc_i) {\n   base_path[oc_i] = toupper(base_path[oc_i]);\n        }\n        printf(\"%s\\n\",base_path);\n        \n        \n    }\n    \n;\n        if ( *rehood_satellitoid != 0) \n          free(((char *)( *rehood_satellitoid)));\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}", "answer": "D.CWE-785:Use of Path Manipulation Function without Maximum-sized Buffer|E.CWE-707:Improper Neutralization", "cwe": "785", "idx": "153774"}
{"selection": "A.No Vulnerabilities\nB.CWE-297:Improper Validation of Certificate with Host Mismatch\nC.CWE-1392:Use of Default Credentials\nD.CWE-23:Relative Path Traversal\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_environment_w32CreateFile_83\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_environment_w32CreateFile_83\n{\npublic:\n    _Relative_Path_Traversal__char_environment_w32CreateFile_83(char * dataCopy);\n    ~_Relative_Path_Traversal__char_environment_w32CreateFile_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_environment_w32CreateFile_83G2B\n{\npublic:\n    _Relative_Path_Traversal__char_environment_w32CreateFile_83G2B(char * dataCopy);\n    ~_Relative_Path_Traversal__char_environment_w32CreateFile_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "D.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90298"}
{"selection": "A.CWE-41:Improper Resolution of Path Equivalence\nB.CWE-476:NULL Pointer Dereference\nC.No Vulnerabilities\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-1297:Unprotected Confidential Information on Device is Accessible by OSAT Vendors", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint notative_handshaking = 0;\nint global_variable;\nvoid astr_middlewards(char **redroe_gypseous);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid angiokinetic_grose(void (*undodged_torfaceous)(char **));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&notative_handshaking,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      angiokinetic_grose(astr_middlewards);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid astr_middlewards(char **redroe_gypseous)\n{\n  int squilgee_moonier = 45;\n  char *ishum_semilor;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&ishum_semilor,\"5403\",squilgee_moonier);\n  if (ishum_semilor != 0) {;\n     *redroe_gypseous = ishum_semilor;\n  }\n}\n\nvoid angiokinetic_grose(void (*undodged_torfaceous)(char **))\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *ephebeum_hammer = 0;\n  char **blacktongue_subroutines[12] = {0};\n  char **bwc_fibularia = 0;\n  ++global_variable;\n  char *paralytical_banaras = 0;\n  undodged_torfaceous(&paralytical_banaras);\n  if (paralytical_banaras != 0) {;\n    bwc_fibularia = &paralytical_banaras;\n    blacktongue_subroutines[7] = bwc_fibularia;\n    ephebeum_hammer = ((char *)( *blacktongue_subroutines[7]));\n      \n      \n\n      pFile = fopen(ephebeum_hammer,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\n    if ( *blacktongue_subroutines[7] != 0) \n      free(((char *)( *blacktongue_subroutines[7])));\nclose_printf_context();\n  }\n}", "answer": "B.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149782"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.CWE-1118:Insufficient Documentation of Error Handling Techniques\nC.CWE-707:Improper Neutralization\nD.CWE-296:Improper Following of a Certificate's Chain of Trust\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nstatic char * _External_Control_of_System_or_Configuration_Setting__w32_45Data;\nstatic char * _External_Control_of_System_or_Configuration_Setting__w32_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    char * data = _External_Control_of_System_or_Configuration_Setting__w32_45Data;\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_45()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    char * data = _External_Control_of_System_or_Configuration_Setting__w32_45G2BData;\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|C.CWE-707:Improper Neutralization", "cwe": "15", "idx": "82006"}
{"selection": "A.CWE-200:Exposure of Sensitive Information to an Unauthorized Actor\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-837:Improper Enforcement of a Single, Unique Action\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_wchar_t_console_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(wchar_t * &data)\n{\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(wchar_t * &data)\n{\n    \n    wcscat(data, L\"Doe, XXXXX\");\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_console_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123161"}
{"selection": "A.No Vulnerabilities\nB.CWE-277:Insecure Inherited Permissions\nC.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nD.CWE-196:Unsigned to Signed Conversion Error\nE.CWE-707:Improper Neutralization", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint overshepherd_forz = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *moss_belg = 0;\n  void *floatier_unconsentient = 0;\n  int singillatim_bastile = 11;\n  char *tirrlie_jerkingly;;\n  if (__sync_bool_compare_and_swap(&overshepherd_forz,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&tirrlie_jerkingly,\"8255\",singillatim_bastile);\n      if (tirrlie_jerkingly != 0) {;\n        floatier_unconsentient = ((void *)tirrlie_jerkingly);\n        moss_belg = ((char *)((char *)floatier_unconsentient));\n    \n    if (strlen(moss_belg) > 0 &&\n        moss_belg[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(moss_belg);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n        if (((char *)floatier_unconsentient) != 0) \n          free(((char *)((char *)floatier_unconsentient)));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "D.CWE-196:Unsigned to Signed Conversion Error|E.CWE-707:Improper Neutralization", "cwe": "196", "idx": "151016"}
{"selection": "A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-91:XML Injection (aka Blind XPath Injection)\nC.CWE-476:NULL Pointer Dereference\nD.CWE-237:Improper Handling of Structural Elements\nE.No Vulnerabilities", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint endurability_devy = 0;\nint global_variable;\nvoid handle_taint(char *nullity_petre);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid mumruffin_caped(int convulsiveness_capitalizes,... );\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&endurability_devy,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *nullity_petre)\n{\n  ++global_variable;;\n  if (nullity_petre != 0) {;\n    mumruffin_caped(1,nullity_petre);\n  }\n}\n\nvoid mumruffin_caped(int convulsiveness_capitalizes,... )\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *zambezian_salicylanilide = 0;\n  char *allochezia_kryska = 0;\n  va_list skagen_mouthiness;\n  ++global_variable;;\n  if (convulsiveness_capitalizes > 0) {\n    __builtin_va_start(skagen_mouthiness,convulsiveness_capitalizes);\n    allochezia_kryska = (va_arg(skagen_mouthiness,char *));\n    __builtin_va_end(skagen_mouthiness);\n  }\n  zambezian_salicylanilide = ((char *)allochezia_kryska);\n      \n      while(isalnum(zambezian_salicylanilide[size]) && size < strlen(zambezian_salicylanilide)){\n        ++size;\n      }\n      \n\n      if (size != strlen(zambezian_salicylanilide)) {\n        zambezian_salicylanilide = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,zambezian_salicylanilide);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if (allochezia_kryska != 0) \n    free(((char *)allochezia_kryska));\nclose_printf_context();\n}", "answer": "C.CWE-476:NULL Pointer Dereference|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149290"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-311:Missing Encryption of Sensitive Data\nC.CWE-685:Function Call With Incorrect Number of Arguments\nD.No Vulnerabilities\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_02()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245940"}
{"selection": "A.No Vulnerabilities\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-1223:Race Condition for Write-Once Attributes\nD.CWE-588:Attempt to Access Child of a Non-structure Pointer\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_environment_03()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_environment_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|E.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122945"}
{"selection": "A.No Vulnerabilities\nB.CWE-1267:Policy Uses Obsolete Encoding\nC.CWE-496:Public Data Assigned to Private Array-Typed Field\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n#define EXECVP _execvp\n\nnamespace _OS_Command_Injection__char_listen_socket_w32_execvp_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * data = dataRef;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    {\n        char * data = dataRef;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _OS_Command_Injection__char_listen_socket_w32_execvp_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|E.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246145"}
{"selection": "A.No Vulnerabilities\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-807:Reliance on Untrusted Inputs in a Security Decision\nD.CWE-123:Write-what-where Condition\nE.CWE-476:NULL Pointer Dereference", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <stdarg.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint centerline_nomenclator = 0;\nint global_variable;\n\nunion koloa_interlocutorily \n{\n  char *joacima_etymologizing;\n  double trisulfoxide_reconquered;\n  char *pictores_yong;\n  char oxozone_pimientos;\n  int eosine_coagulose;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid fogyish_coburgess(int appreve_hearse,... );\nvoid bramley_pezizaceous(union koloa_interlocutorily spirographidin_imide);\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  union koloa_interlocutorily semiepic_sarcasticness;\n  int nominatives_interliner = 22;\n  char *equitation_manacle;;\n  if (__sync_bool_compare_and_swap(&centerline_nomenclator,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&equitation_manacle,\"9634\",nominatives_interliner);\n      if (equitation_manacle != 0) {;\n        semiepic_sarcasticness . joacima_etymologizing = equitation_manacle;\n        fogyish_coburgess(1,semiepic_sarcasticness);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid fogyish_coburgess(int appreve_hearse,... )\n{\n  void (*unwilier_asgd)(union koloa_interlocutorily ) = bramley_pezizaceous;\n  union koloa_interlocutorily complaints_rhodonite = {0};\n  va_list smearless_cirsectomies;\n  ++global_variable;;\n  if (appreve_hearse > 0) {\n    __builtin_va_start(smearless_cirsectomies,appreve_hearse);\n    complaints_rhodonite = (va_arg(smearless_cirsectomies,union koloa_interlocutorily ));\n    __builtin_va_end(smearless_cirsectomies);\n  }\n  unwilier_asgd(complaints_rhodonite);\n}\n\nvoid bramley_pezizaceous(union koloa_interlocutorily spirographidin_imide)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *uncontracted_unschematized = 0;\n  ++global_variable;;\n  uncontracted_unschematized = ((char *)spirographidin_imide . joacima_etymologizing);\n      \n      len = strtol(uncontracted_unschematized,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (spirographidin_imide . joacima_etymologizing != 0) \n    free(((char *)spirographidin_imide . joacima_etymologizing));\nclose_printf_context();\n}", "answer": "E.CWE-476:NULL Pointer Dereference|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149319"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-259:Use of Hard-coded Password\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1024:Comparison of Incompatible Types", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_open_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_open_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90952"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-407:Inefficient Algorithmic Complexity\nC.CWE-36:Absolute Path Traversal\nD.CWE-1303:Non-Transparent Sharing of Microarchitectural Resources\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_open_15\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n        break;\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_open_15; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "95696"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-1116:Inaccurate Comments\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-1103:Use of Platform-Dependent Third Party Components", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91198"}
{"selection": "A.CWE-921:Storage of Sensitive Data in a Mechanism without Access Control\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-402:Transmission of Private Resources into a New Sphere ('Resource Leak')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__wchar_t_console_w32_spawnv_82\n{\n\nclass _OS_Command_Injection__wchar_t_console_w32_spawnv_82_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__wchar_t_console_w32_spawnv_82 : public _OS_Command_Injection__wchar_t_console_w32_spawnv_82_base\n{\npublic:\n    void action(wchar_t * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__wchar_t_console_w32_spawnv_82G2B : public _OS_Command_Injection__wchar_t_console_w32_spawnv_82_base\n{\npublic:\n    void action(wchar_t * data);\n};\n\n#endif \n\n}", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "247208"}
{"selection": "A.CWE-291:Reliance on IP Address for Authentication\nB.CWE-1025:Comparison Using Wrong Factors\nC.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \n#include <sys/stat.h> \n#include <time.h> \nint dropping_trisulphate = 0;\nint global_variable;\nvoid handle_taint(char *rebids_istanbul);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid overtorturing_solidarity(int neotype_warmheartedness,char *demonocracy_recognosce);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&dropping_trisulphate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *rebids_istanbul)\n{\n  int surrogated_uranism = 7;\n  ++global_variable;;\n  if (rebids_istanbul != 0) {;\n    overtorturing_solidarity(surrogated_uranism,rebids_istanbul);\n  }\n}\n\nvoid overtorturing_solidarity(int neotype_warmheartedness,char *demonocracy_recognosce)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    char *result = 0;\n    int random_int = 0;\n  char *slowheaded_kirkyard = 0;\n  ++global_variable;\n  neotype_warmheartedness--;\n  if (neotype_warmheartedness > 0) {\n    overtorturing_solidarity(neotype_warmheartedness,demonocracy_recognosce);\n    return ;\n  }\n  slowheaded_kirkyard = ((char *)demonocracy_recognosce);\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  srand(time(NULL));\n  random_int = (rand() % 1000) + 100;\n        snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, slowheaded_kirkyard);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n            \n            printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  result = PQcmdTuples(res);\n        printf(\"Query OK, %s rows affected\\n\",result);\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\n  if (demonocracy_recognosce != 0) \n    free(((char *)demonocracy_recognosce));\nclose_printf_context();\n}", "answer": "C.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|E.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152794"}
{"selection": "A.No Vulnerabilities\nB.CWE-244:Improper Clearing of Heap Memory Before Release ('Heap Inspection')\nC.CWE-707:Improper Neutralization\nD.CWE-23:Relative Path Traversal\nE.CWE-434:Unrestricted Upload of File with Dangerous Type", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ofstream_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * * dataPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ofstream_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-23:Relative Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91631"}
{"selection": "A.CWE-791:Incomplete Filtering of Special Elements\nB.CWE-710:Improper Adherence to Coding Standards\nC.CWE-52:Path Equivalence: '/multiple/trailing/slash//'\nD.CWE-476:NULL Pointer Dereference\nE.No Vulnerabilities", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint hoolihan_ingenerate = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *chronologize_declutch = 0;\n  jmp_buf brigading_maties;\n  int ophioglossum_thermolysis;\n  char **lejeune_registrars = 0;\n  char **ire_bisaltae = 0;\n  char *draughtman_astragalomancy[58] = {0};\n  char *chancrous_lettermen;;\n  if (__sync_bool_compare_and_swap(&hoolihan_ingenerate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      chancrous_lettermen = getenv(\"UNTEMPLED_TRESSIER\");\n      if (chancrous_lettermen != 0) {;\n        draughtman_astragalomancy[57] = chancrous_lettermen;\n        lejeune_registrars = draughtman_astragalomancy;\n        ire_bisaltae = lejeune_registrars + 5;\n        ophioglossum_thermolysis = setjmp(brigading_maties);\n        if (ophioglossum_thermolysis == 0) {\n          longjmp(brigading_maties,1);\n        }\n        chronologize_declutch = ((char *)(ire_bisaltae - 5)[57]);\n  \n  \n  csv = fopen(chronologize_declutch,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "D.CWE-476:NULL Pointer Dereference|B.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149780"}
{"selection": "A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\nB.CWE-1390:Weak Authentication\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-498:Cloneable Class Containing Sensitive Information", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nint cornels_dawcock = 0;\nint global_variable;\nvoid pasturers_mtbrp(void **wilt_snowcap);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid nonmetamorphic_kaffiyehs(void (*lorianne_cadillac)(void **));\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    int (* before)(int);\n    char buffer[64];\n    int (* after)(int);\n};\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&cornels_dawcock,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      nonmetamorphic_kaffiyehs(pasturers_mtbrp);\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid pasturers_mtbrp(void **wilt_snowcap)\n{\n  void *dognaper_ochlocratical = 0;\n  int vartabed_highspire = 596;\n  char *reunited_farewelling;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&reunited_farewelling,\"8040\",vartabed_highspire);\n  if (reunited_farewelling != 0) {;\n    dognaper_ochlocratical = ((void *)reunited_farewelling);\n     *wilt_snowcap = dognaper_ochlocratical;\n  }\n}\n\nvoid nonmetamorphic_kaffiyehs(void (*lorianne_cadillac)(void **))\n{\n    int i = 0;\n    int opt_var;\n    struct struct data;\n  char *scallage_unadjacently = 0;\n  ++global_variable;\n  void *unpurported_scandalmonging = 0;\n  lorianne_cadillac(&unpurported_scandalmonging);\n  if (((char *)unpurported_scandalmonging) != 0) {;\n    scallage_unadjacently = ((char *)((char *)unpurported_scandalmonging));\n    \n    data.before = toupper;\n    for (i = 0; i < 64; i++) {\n        data.buffer[i] = 0;\n    }\n    data.after = toupper;\n    \n    \n    \n    \n    \n    \n\n    strcpy(data.buffer, scallage_unadjacently);\n    \n    \n\n    opt_var = strlen( data.buffer);\n    for (i = 0; i < opt_var; ++i) {\n        data.buffer[i] = toupper(data.buffer[i]);\n        printf(\"%c\",data.after(data.buffer[i]));\n    }\n    \n    \n    printf(\"\\n\");\n    \n;\n    if (((char *)unpurported_scandalmonging) != 0) \n      free(((char *)((char *)unpurported_scandalmonging)));\nclose_printf_context();\n  }\n}", "answer": "A.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|C.CWE-707:Improper Neutralization", "cwe": "120", "idx": "153535"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-344:Use of Invariant Value in Dynamically Changing Context\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-480:Use of Incorrect Operator", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_file_w32_execv_84\n{\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_file_w32_execv_84\n{\npublic:\n    _OS_Command_Injection__char_file_w32_execv_84(char * dataCopy);\n    ~_OS_Command_Injection__char_file_w32_execv_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_file_w32_execv_84G2B\n{\npublic:\n    _OS_Command_Injection__char_file_w32_execv_84G2B(char * dataCopy);\n    ~_OS_Command_Injection__char_file_w32_execv_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245746"}
{"selection": "A.CWE-492:Use of Inner Class Containing Sensitive Data\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1125:Excessive Attack Surface\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_31()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122867"}
{"selection": "A.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nB.CWE-297:Improper Validation of Certificate with Host Mismatch\nC.CWE-707:Improper Neutralization\nD.CWE-780:Use of RSA Algorithm without OAEP\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _OS_Command_Injection__char_environment_w32_execvp_34_unionType;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_34()\n{\n    char * data;\n    _OS_Command_Injection__char_environment_w32_execvp_34_unionType myUnion;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    _OS_Command_Injection__char_environment_w32_execvp_34_unionType myUnion;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-780:Use of RSA Algorithm without OAEP|C.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245202"}
{"selection": "A.CWE-434:Unrestricted Upload of File with Dangerous Type\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.CWE-684:Incorrect Provision of Specified Functionality", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66bSink(char * dataArray[]);\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    _OS_Command_Injection__char_console_w32_spawnv_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    dataArray[2] = data;\n    _OS_Command_Injection__char_console_w32_spawnv_66bG2BSink(dataArray);\n}\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32_spawnv_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32_spawnv_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "244841"}
{"selection": "A.CWE-207:Observable Behavioral Discrepancy With Equivalent Products\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1188:Initialization of a Resource with an Insecure Default\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_53bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_connect_socket_53()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_connect_socket_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_53bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_connect_socket_53bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122878"}
{"selection": "A.No Vulnerabilities\nB.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nC.CWE-1111:Incomplete I/O Documentation\nD.CWE-707:Improper Neutralization\nE.CWE-685:Function Call With Incorrect Number of Arguments", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define SYSTEM _wsystem\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63bSink(wchar_t * * dataPtr);\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_listen_socket_system_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_listen_socket_system_63bG2BSink(&data);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_system_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_system_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|D.CWE-707:Improper Neutralization", "cwe": "78", "idx": "248426"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.No Vulnerabilities\nC.CWE-1242:Inclusion of Undocumented Features or Chicken Bits\nD.CWE-267:Privilege Defined With Unsafe Actions\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_environment_ofstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_ofstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96138"}
{"selection": "A.CWE-349:Acceptance of Extraneous Untrusted Data With Trusted Data\nB.CWE-707:Improper Neutralization\nC.CWE-23:Relative Path Traversal\nD.CWE-1291:Public Key Re-Use for Signing both Debug and Production Code\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84G2B\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84G2B(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84G2B();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n}", "answer": "C.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91787"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-351:Insufficient Type Distinction\nC.CWE-1089:Large Data Table with Excessive Number of Indices\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_12()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123002"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-674:Uncontrolled Recursion\nC.No Vulnerabilities\nD.CWE-114:Process Control\nE.CWE-598:Use of GET Request Method With Sensitive Query Strings", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_listen_socket_14()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_listen_socket_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_listen_socket_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_listen_socket_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-114:Process Control|A.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62145"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-299:Improper Check for Certificate Revocation\nD.CWE-487:Reliance on Package-level Scope\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint hemimetamorphic_reindorsing = 0;\nint global_variable;\nvoid shivered_contubernial(char **attently_nessus);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid unthroaty_fried(void (*conched_resultantly)(char **));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&hemimetamorphic_reindorsing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      unthroaty_fried(shivered_contubernial);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid shivered_contubernial(char **attently_nessus)\n{\n  char *hilloa_rhotacistic;\n  ++global_variable;;\n  setup_printf_context();\n  hilloa_rhotacistic = getenv(\"CLOFF_ASTROMANCER\");\n  if (hilloa_rhotacistic != 0) {;\n     *attently_nessus = hilloa_rhotacistic;\n  }\n}\n\nvoid unthroaty_fried(void (*conched_resultantly)(char **))\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *wimlunge_mispractice = 0;\n  char **yikirgaulit_baccalaureates[79] = {0};\n  char **bronchotomy_painfullest = 0;\n  ++global_variable;\n  char *roughhewn_coyanosa = 0;\n  conched_resultantly(&roughhewn_coyanosa);\n  if (roughhewn_coyanosa != 0) {;\n    bronchotomy_painfullest = &roughhewn_coyanosa;\n    yikirgaulit_baccalaureates[45] = bronchotomy_painfullest;\n    wimlunge_mispractice = ((char *)( *yikirgaulit_baccalaureates[45]));\n    \n    if (strlen(wimlunge_mispractice) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,wimlunge_mispractice);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\nclose_printf_context();\n  }\n}", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|B.CWE-707:Improper Neutralization", "cwe": "78", "idx": "152541"}
{"selection": "A.CWE-1104:Use of Unmaintained Third Party Components\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-548:Exposure of Information Through Directory Listing\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef struct __LDAP_Injection__w32_wchar_t_connect_socket_67_structType\n{\n    wchar_t * structFirst;\n} _LDAP_Injection__w32_wchar_t_connect_socket_67_structType;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67bSink(_LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct);\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67bG2BSink(_LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67bG2BSink(myStruct);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123126"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-640:Weak Password Recovery Mechanism for Forgotten Password\nC.CWE-1270:Generation of Incorrect Security Tokens\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nint _LDAP_Injection__w32_char_file_22Global = 0;\n\nchar * _LDAP_Injection__w32_char_file_22Source(char * data);\n\nvoid _LDAP_Injection__w32_char_file_22()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_char_file_22Global = 1; \n    data = _LDAP_Injection__w32_char_file_22Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _LDAP_Injection__w32_char_file_22G2B1Global = 0;\nint _LDAP_Injection__w32_char_file_22G2B2Global = 0;\n\n\nchar * _LDAP_Injection__w32_char_file_22G2B1Source(char * data);\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_char_file_22G2B1Global = 0; \n    data = _LDAP_Injection__w32_char_file_22G2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nchar * _LDAP_Injection__w32_char_file_22G2B2Source(char * data);\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_char_file_22G2B2Global = 1; \n    data = _LDAP_Injection__w32_char_file_22G2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123010"}
{"selection": "A.CWE-1255:Comparison Logic is Vulnerable to Power Side-Channel Attacks\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-36:Absolute Path Traversal\nE.CWE-1251:Mirrored Regions with Different Values", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97731"}
{"selection": "A.CWE-407:Inefficient Algorithmic Complexity\nB.CWE-23:Relative Path Traversal\nC.No Vulnerabilities\nD.CWE-1390:Weak Authentication\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_console_ofstream_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * dataArray[]);\n\nvoid m()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_ofstream_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "89954"}
{"selection": "A.No Vulnerabilities\nB.CWE-212:Improper Removal of Sensitive Information Before Storage or Transfer\nC.CWE-707:Improper Neutralization\nD.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nE.CWE-581:Object Model Violation: Just One of Equals and Hashcode Defined", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_console_16()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_console_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_console_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_console_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "122910"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-367:Time-of-check Time-of-use (TOCTOU) Race Condition\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-414:Missing Lock Check", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    funcPtr(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123306"}
{"selection": "A.CWE-15:External Control of System or Configuration Setting\nB.CWE-307:Improper Restriction of Excessive Authentication Attempts\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-298:Improper Validation of Certificate Expiration", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_31()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-15:External Control of System or Configuration Setting|D.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81998"}
{"selection": "A.No Vulnerabilities\nB.CWE-707:Improper Neutralization\nC.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nD.CWE-561:Dead Code\nE.CWE-1083:Data Access from Outside Expected Data Manager Component", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_wchar_t_listen_socket_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_54bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123311"}
{"selection": "A.No Vulnerabilities\nB.CWE-156:Improper Neutralization of Whitespace\nC.CWE-87:Improper Neutralization of Alternate XSS Syntax\nD.CWE-834:Excessive Iteration\nE.CWE-691:Insufficient Control Flow Management", "code": "#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint rupees_alternant = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid cliv_nonreconcilably(char *gapingly_unmaneged);\nvoid cosaque_paeanism(char *aahing_intarsa);\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  char *stunning_antrums = 0;\n  int *gardant_elisa = 0;\n  int umbrere_pbs;\n  char *secondly_flittiness[10] = {0};\n  int unjacketed_glabrate = 0;\n  char *bailor_jumbles = 0;\n  char *terry_relighting;;\n  if (__sync_bool_compare_and_swap(&rupees_alternant,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      terry_relighting = getenv(\"OILPAPERS_AVERNUS\");\n      if (terry_relighting != 0) {;\n        unjacketed_glabrate = ((int )(strlen(terry_relighting)));\n        bailor_jumbles = ((char *)(malloc(unjacketed_glabrate + 1)));\n        if (bailor_jumbles == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(bailor_jumbles,0,unjacketed_glabrate + 1);\n        memcpy(bailor_jumbles,terry_relighting,unjacketed_glabrate);\n        umbrere_pbs = 5;\n        gardant_elisa = &umbrere_pbs;\n        secondly_flittiness[ *gardant_elisa] = bailor_jumbles;\n        stunning_antrums = secondly_flittiness[ *gardant_elisa];\n        cliv_nonreconcilably(stunning_antrums);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid cliv_nonreconcilably(char *gapingly_unmaneged)\n{\n  ++global_variable;;\n  cosaque_paeanism(gapingly_unmaneged);\n}\n\nvoid cosaque_paeanism(char *aahing_intarsa)\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *estherville_midstreet = 0;\n  ++global_variable;;\n  estherville_midstreet = ((char *)aahing_intarsa);\n    \n    in_val = atoll(estherville_midstreet);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (aahing_intarsa != 0) \n    free(((char *)aahing_intarsa));\nclose_printf_context();\n}", "answer": "D.CWE-834:Excessive Iteration|E.CWE-691:Insufficient Control Flow Management", "cwe": "834", "idx": "151972"}
{"selection": "A.CWE-598:Use of GET Request Method With Sensitive Query Strings\nB.CWE-579:J2EE Bad Practices: Non-serializable Object Stored in Session\nC.CWE-23:Relative Path Traversal\nD.No Vulnerabilities\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, wchar_t *> dataMap);\n\nvoid m()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, wchar_t *> dataMap);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_open_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91447"}
{"selection": "A.CWE-1279:Cryptographic Operations are run Before Supporting Units are Ready\nB.CWE-707:Improper Neutralization\nC.No Vulnerabilities\nD.CWE-560:Use of umask() with chmod-style Argument\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nint _LDAP_Injection__w32_wchar_t_environment_22Global = 0;\n\nwchar_t * _LDAP_Injection__w32_wchar_t_environment_22Source(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_environment_22()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_wchar_t_environment_22Global = 1; \n    data = _LDAP_Injection__w32_wchar_t_environment_22Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _LDAP_Injection__w32_wchar_t_environment_22G2B1Global = 0;\nint _LDAP_Injection__w32_wchar_t_environment_22G2B2Global = 0;\n\n\nwchar_t * _LDAP_Injection__w32_wchar_t_environment_22G2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_wchar_t_environment_22G2B1Global = 0; \n    data = _LDAP_Injection__w32_wchar_t_environment_22G2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nwchar_t * _LDAP_Injection__w32_wchar_t_environment_22G2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_wchar_t_environment_22G2B2Global = 1; \n    data = _LDAP_Injection__w32_wchar_t_environment_22G2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|B.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123202"}
{"selection": "A.CWE-707:Improper Neutralization\nB.No Vulnerabilities\nC.CWE-1055:Multiple Inheritance from Concrete Classes\nD.CWE-1110:Incomplete Design Documentation\nE.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_w32_spawnlp_06()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_file_w32_spawnlp_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32_spawnlp_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32_spawnlp_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245752"}
{"selection": "A.CWE-476:NULL Pointer Dereference\nB.CWE-115:Misinterpretation of Input\nC.No Vulnerabilities\nD.CWE-710:Improper Adherence to Coding Standards\nE.CWE-260:Password in Configuration File", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint munific_unpriceably = 0;\nint global_variable;\nvoid petauroides_paye(void **hoochinoo_ketchcraft);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid dunkling_homerid(void (*coction_reorientating)(void **));\nvoid *my_malloc(unsigned int size)\n{\n  if (size > 512)\n\n    return 0;\n  return malloc(size);\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&munific_unpriceably,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      dunkling_homerid(petauroides_paye);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid petauroides_paye(void **hoochinoo_ketchcraft)\n{\n  void *olinia_proegumenal = 0;\n  char *shamer_blunk;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&shamer_blunk,\"BRINEY_FURANOSIDE\");\n  if (shamer_blunk != 0) {;\n    olinia_proegumenal = ((void *)shamer_blunk);\n     *hoochinoo_ketchcraft = olinia_proegumenal;\n  }\n}\n\nvoid dunkling_homerid(void (*coction_reorientating)(void **))\n{\n  unsigned int size_buffer;\n  int buffer_value;\n  char *malloc_buffer = 0;\n  char *guadalcazarite_priestliest = 0;\n  void *iceland_warstles = 0;\n  int **********vergentness_pollaiuolo = 0;\n  int *********deadlines_antthrush = 0;\n  int ********clitoromaniacal_obturbinate = 0;\n  int *******bsee_pounding = 0;\n  int ******gaumed_grists = 0;\n  int *****spig_innuendoing = 0;\n  int ****discographies_owrecome = 0;\n  int ***overserenely_uruses = 0;\n  int **striolate_undebating = 0;\n  int *alada_skimming = 0;\n  int crotonic_bluelines;\n  void *chorobates_torrone[10] = {0};\n  ++global_variable;\n  void *sigrim_predelay = 0;\n  coction_reorientating(&sigrim_predelay);\n  if (((char *)sigrim_predelay) != 0) {;\n    crotonic_bluelines = 5;\n    alada_skimming = &crotonic_bluelines;\n    striolate_undebating = &alada_skimming;\n    overserenely_uruses = &striolate_undebating;\n    discographies_owrecome = &overserenely_uruses;\n    spig_innuendoing = &discographies_owrecome;\n    gaumed_grists = &spig_innuendoing;\n    bsee_pounding = &gaumed_grists;\n    clitoromaniacal_obturbinate = &bsee_pounding;\n    deadlines_antthrush = &clitoromaniacal_obturbinate;\n    vergentness_pollaiuolo = &deadlines_antthrush;\n    chorobates_torrone[ *( *( *( *( *( *( *( *( *( *vergentness_pollaiuolo)))))))))] = sigrim_predelay;\n    iceland_warstles = chorobates_torrone[ *( *( *( *( *( *( *( *( *( *vergentness_pollaiuolo)))))))))];\n    guadalcazarite_priestliest = ((char *)((char *)iceland_warstles));\n      \n      buffer_value = atoi(guadalcazarite_priestliest);\n      \n      if (buffer_value < 0)\n        buffer_value = 0;\n      size_buffer = ((unsigned int )buffer_value);\n      \n      malloc_buffer = my_malloc(size_buffer);\n      \n      \n      \n\n      memset(malloc_buffer,0,size_buffer);\n      printf(\"Buffer size is %d\\n\", size_buffer);\n      \n      if (malloc_buffer != 0) {\n        free(malloc_buffer);\n      }\n      \n;\n    if (((char *)iceland_warstles) != 0) \n      free(((char *)((char *)iceland_warstles)));\nclose_printf_context();\n  }\n}\n#endif", "answer": "A.CWE-476:NULL Pointer Dereference|D.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149567"}
{"selection": "A.CWE-428:Unquoted Search Path or Element\nB.CWE-36:Absolute Path Traversal\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-549:Missing Password Field Masking", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_67\n{\n\ntypedef struct _structType\n{\n    wchar_t * structFirst;\n} structType;\n\n#ifndef OMITM\n\n\nvoid mSink(structType myStruct);\n\nvoid m()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    mSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    myStruct.structFirst = data;\n    nG2BSink(myStruct);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_67; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "97737"}
{"selection": "A.CWE-1091:Use of Object without Invoking Destructor Method\nB.CWE-707:Improper Neutralization\nC.CWE-245:J2EE Bad Practices: Direct Management of Connections\nD.No Vulnerabilities\nE.CWE-15:External Control of System or Configuration Setting", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic char * mSource(char * data)\n{\n    if(mStatic)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    return data;\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_21()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic char * nG2B1Source(char * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic char * nG2B2Source(char * data)\n{\n    if(nG2B2Static)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81996"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1063:Creation of Class Instance within a Static Code Block\nC.CWE-705:Incorrect Control Flow Scoping\nD.No Vulnerabilities\nE.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint hotdogged_propulsory = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid falconries_loured(char *const ambigenal_sphygmoid);\nvoid fertileness_toscanini(int perceivers_scowlful,char *casease_outspokenly);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    int (* before)(int);\n    char buffer[64];\n    int (* after)(int);\n};\n\nSize PMSignalShmemSize()\n{\n  int aerie_breedbate = 596;\n  char *substitutes_moire;\n  Size size;\n  if (__sync_bool_compare_and_swap(&hotdogged_propulsory,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&substitutes_moire,\"3532\",aerie_breedbate);\n      if (substitutes_moire != 0) {;\n        falconries_loured(substitutes_moire);\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid falconries_loured(char *const ambigenal_sphygmoid)\n{\n  int vility_nasiei = 7;\n  ++global_variable;;\n  fertileness_toscanini(vility_nasiei,ambigenal_sphygmoid);\n}\n\nvoid fertileness_toscanini(int perceivers_scowlful,char *casease_outspokenly)\n{\n    int i = 0;\n    int opt_var;\n    struct struct data;\n  char *puture_saccorhiza = 0;\n  ++global_variable;\n  perceivers_scowlful--;\n  if (perceivers_scowlful > 0) {\n    fertileness_toscanini(perceivers_scowlful,casease_outspokenly);\n    return ;\n  }\n  puture_saccorhiza = ((char *)((char *)casease_outspokenly));\n    \n    data.before = toupper;\n    for (i = 0; i < 64; i++) {\n        data.buffer[i] = 0;\n    }\n    data.after = toupper;\n    \n    \n    \n    \n    \n    \n\n    strcpy(data.buffer, puture_saccorhiza);\n    \n    \n\n    opt_var = strlen( data.buffer);\n    for (i = 0; i < opt_var; ++i) {\n        data.buffer[i] = toupper(data.buffer[i]);\n        printf(\"%c\",data.after(data.buffer[i]));\n    }\n    \n    \n    printf(\"\\n\");\n    \n;\n  if (((char *)casease_outspokenly) != 0) \n    free(((char *)((char *)casease_outspokenly)));\nclose_printf_context();\n}", "answer": "E.CWE-120:Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')|A.CWE-707:Improper Neutralization", "cwe": "120", "idx": "153584"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-501:Trust Boundary Violation\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-203:Observable Discrepancy", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123199"}
{"selection": "A.CWE-682:Incorrect Calculation\nB.CWE-912:Hidden Functionality\nC.CWE-539:Use of Persistent Cookies Containing Sensitive Information\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint asteroidean_membranella = 0;\nint global_variable;\nvoid handle_taint(char *voltaire_magma);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid transfiltration_phosphene(int betel_tungus,void **tinges_befoulers);\nvoid function() {\n    \n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&asteroidean_membranella,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *voltaire_magma)\n{\n  int eumelanin_spermule = 7;\n  void **wayward_dorsosternal = 0;\n  void **chafers_ileuses = 0;\n  void *panophthalmitis_haemins = 0;\n  ++global_variable;;\n  if (voltaire_magma != 0) {;\n    panophthalmitis_haemins = ((void *)voltaire_magma);\n    wayward_dorsosternal = &panophthalmitis_haemins;\n    chafers_ileuses = wayward_dorsosternal + 5;\n    transfiltration_phosphene(eumelanin_spermule,chafers_ileuses);\n  }\n}\n\nvoid transfiltration_phosphene(int betel_tungus,void **tinges_befoulers)\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *polynaphthene_crossline = 0;\n  ++global_variable;\n  betel_tungus--;\n  if (betel_tungus > 0) {\n    transfiltration_phosphene(betel_tungus,tinges_befoulers);\n    return ;\n  }\n  polynaphthene_crossline = ((char *)((char *)( *(tinges_befoulers - 5))));\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(polynaphthene_crossline) >= 1 &&\n            polynaphthene_crossline[0] != '-') {\n        input_num = strtoul(polynaphthene_crossline,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(polynaphthene_crossline) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n  if (((char *)( *(tinges_befoulers - 5))) != 0) \n    free(((char *)((char *)( *(tinges_befoulers - 5)))));\nclose_printf_context();\n}", "answer": "A.CWE-682:Incorrect Calculation|D.CWE-707:Improper Neutralization", "cwe": "682", "idx": "151369"}
{"selection": "A.CWE-187:Partial String Comparison\nB.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nC.CWE-707:Improper Neutralization\nD.CWE-537:Java Runtime Error Message Containing Sensitive Information\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_console_41Sink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_console_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _LDAP_Injection__w32_wchar_t_console_41G2BSink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_console_41G2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|C.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123159"}
{"selection": "A.No Vulnerabilities\nB.CWE-271:Privilege Dropping / Lowering Errors\nC.CWE-773:Missing Reference to Active File Descriptor or Handle\nD.CWE-664:Improper Control of a Resource Through its Lifetime\nE.CWE-1114:Inappropriate Whitespace Style", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint skijoring_visualize = 0;\nint global_variable;\n\nstruct colorin_heterodyne \n{\n  char *shrived_thalamophora;\n  double aubyn_stylonichia;\n  char *decimator_newburg;\n  char regionals_bonbons;\n  int pushum_attainting;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid octothorp_portage(struct colorin_heterodyne *addi_scapoid);\nvoid cleanup(FILE **ptrs,int size)\n{\n  int i = 0;\n  \n  for (i = 0; i < size; i++) {\n    if (ptrs[i] != 0) {\n      fclose(ptrs[i]);\n    }\n  }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*virgules_cyndia)(struct colorin_heterodyne *) = octothorp_portage;\n  struct colorin_heterodyne *telfords_toughest = {0};\n  struct colorin_heterodyne trophonian_narrawood;\n  char *cranky_gugu;;\n  if (__sync_bool_compare_and_swap(&skijoring_visualize,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      cranky_gugu = getenv(\"THROWBACK_MOBCAP\");\n      if (cranky_gugu != 0) {;\n        trophonian_narrawood . shrived_thalamophora = ((char *)cranky_gugu);\n        telfords_toughest = &trophonian_narrawood;\n        virgules_cyndia(telfords_toughest);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid octothorp_portage(struct colorin_heterodyne *addi_scapoid)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[10];\n char filename[80];\n  char *micromembrane_bestuds = 0;\n  ++global_variable;;\n  micromembrane_bestuds = ((char *)( *addi_scapoid) . shrived_thalamophora);\n    \n files = fopen(micromembrane_bestuds,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n            if (file == 0) {\n    if (file == 0 && errno == 24) {\n     printf(\"Fopen error due to ulimit\\n\");\n                }\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n   \n   file_list[ssi % 10] = file;\n   ssi++;\n        }\n        \n        \n    }\n    if (files != 0)\n        fclose(files);\n cleanup(file_list, ((ssi-1)%10)+1);\n    \n;\nclose_printf_context();\n}", "answer": "C.CWE-773:Missing Reference to Active File Descriptor or Handle|D.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "773", "idx": "151860"}
{"selection": "A.CWE-1279:Cryptographic Operations are run Before Supporting Units are Ready\nB.CWE-806:Buffer Access Using Size of Source Buffer\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-1329:Reliance on Component That is Not Updateable", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint casseroled_palliest = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hyllus_unstrictly(char **devocalisation_depew);\nvoid carpos_radiale(char **desired_periodontics);\nint toupper(int c) {\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    char buffer[64];\n    char * buff_pointer;\n};\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  char *unartistlike_residencer[11] = {0};\n  int pyrgocephalic_falafel = 91;\n  char *ria_spik;;\n  if (__sync_bool_compare_and_swap(&casseroled_palliest,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&ria_spik,\"8625\",pyrgocephalic_falafel);\n      if (ria_spik != 0) {;\n        unartistlike_residencer[3] = ria_spik;\n        hyllus_unstrictly(unartistlike_residencer);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid hyllus_unstrictly(char **devocalisation_depew)\n{\n  ++global_variable;;\n  carpos_radiale(devocalisation_depew);\n}\n\nvoid carpos_radiale(char **desired_periodontics)\n{\n    int oc_i = 0;\n    int i;\n    int opt_var;\n    char source[1024];\n    struct struct data;\n  char *rutins_essenianism = 0;\n  ++global_variable;;\n  rutins_essenianism = ((char *)desired_periodontics[3]);\n    \n    for (i = 0; i < 1024; i++) {\n        source[i] = 0;\n    }\n    for (i = 0; i < 64; i++) {\n        data.buffer[i] = 65;\n    }\n    data.buffer[64 - 1] = '\\0';\n    data.buff_pointer = data.buffer;\n    strncpy(source, rutins_essenianism, sizeof(source));\n    source[1023] = '\\0';\n    if (strlen(source) + 1 <= 64) {\n        \n        \n        \n        \n        \n        \n        strncpy(data.buffer, source, sizeof(source));\n        \n        \n    }\n    opt_var = strlen( data.buff_pointer);\n    for (; oc_i < opt_var; ++oc_i) {\n        data.buffer[oc_i] =\n            toupper(data.buffer[oc_i]);\n    }\n    printf(\"%s\\n\", data.buffer);\n    \n;\n  if (desired_periodontics[3] != 0) \n    free(((char *)desired_periodontics[3]));\nclose_printf_context();\n}", "answer": "B.CWE-806:Buffer Access Using Size of Source Buffer|C.CWE-707:Improper Neutralization", "cwe": "806", "idx": "153609"}
{"selection": "A.CWE-332:Insufficient Entropy in PRNG\nB.CWE-707:Improper Neutralization\nC.CWE-642:External Control of Critical State Data\nD.No Vulnerabilities\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_ofstream_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_ofstream_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|B.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90172"}
{"selection": "A.CWE-258:Empty Password in Configuration File\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-1060:Excessive Number of Inefficient Server-Side Data Accesses\nE.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", "code": "#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint potbellied_timaru = 0;\n\nunion flatly_exosporous \n{\n  char *unreminiscently_endor;\n  double refinished_isolex;\n  char *aperulosid_agistator;\n  char leticia_garrisons;\n  int vowless_ternar;\n}\n;\nint global_variable;\nvoid handle_taint(char *cavillatory_bridgetin);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&potbellied_timaru,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -lmysqlclient -l:libmongoose.so.1 -lssl -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *cavillatory_bridgetin)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  char *upcoiled_wray = 0;\n  union flatly_exosporous *bryozoa_ulcer = {0};\n  union flatly_exosporous mokpo_backbitten;\n  ++global_variable;;\n  if (cavillatory_bridgetin != 0) {;\n    mokpo_backbitten . unreminiscently_endor = cavillatory_bridgetin;\n    bryozoa_ulcer = &mokpo_backbitten;\n    if (( *bryozoa_ulcer) . unreminiscently_endor != 0) {\n      goto coign_bisexed;\n    }\n    ++global_variable;\n    coign_bisexed:;\n    upcoiled_wray = ((char *)( *bryozoa_ulcer) . unreminiscently_endor);\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n                snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",upcoiled_wray);\n                \n                \n                \n\n                if (mysql_query(conn,query_buffer) == 0) {\n                  do {\n                    result = mysql_store_result(conn);\n                    if (result != 0) {\n                      num_rows = mysql_num_rows(result);\n                      if (num_rows != 0) {\n                        num_fields = mysql_num_fields(result);\n                        while((row = mysql_fetch_row(result))){\n                          for (i = 0; i < num_fields; ++i)\n                            printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n                          printf(\"\\n\");\n                        }\n                        mysql_free_result(result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(conn) == 0)\n                        printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n                      else {\n                        printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n                        break;\n                      }\n                    }\n                    status = mysql_next_result(conn);\n                    if (status > 0)\n                      printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n                  }while (status == 0);\n                }\n                else {\n                  \n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n    if (( *bryozoa_ulcer) . unreminiscently_endor != 0) \n      free(((char *)( *bryozoa_ulcer) . unreminiscently_endor));\nclose_printf_context();\n  }\n}", "answer": "E.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|C.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152178"}
{"selection": "A.CWE-576:EJB Bad Practices: Use of Java I/O\nB.CWE-834:Excessive Iteration\nC.CWE-691:Insufficient Control Flow Management\nD.CWE-336:Same Seed in Pseudo-Random Number Generator (PRNG)\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint personages_charsingha = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid sunglass_knowlesville(char **preprovoking_urohematin);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  int unvacillating_limerick;\n  char **viability_alopias = 0;\n  char **totquot_williamsville = 0;\n  char *poolrooms_culteranismo[4] = {0};\n  char *supraocular_grazia;;\n  if (__sync_bool_compare_and_swap(&personages_charsingha,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&supraocular_grazia,\"OVERPRONE_HYBRIDATION\");\n      if (supraocular_grazia != 0) {;\n        poolrooms_culteranismo[3] = supraocular_grazia;\n        unvacillating_limerick = 1;\n        viability_alopias = poolrooms_culteranismo;\n        totquot_williamsville = ((char **)(((unsigned long )viability_alopias) * unvacillating_limerick * unvacillating_limerick)) + 5;\n        sunglass_knowlesville(totquot_williamsville);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid sunglass_knowlesville(char **preprovoking_urohematin)\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *lamenter_horrorist = 0;\n  ++global_variable;;\n  lamenter_horrorist = ((char *)(preprovoking_urohematin - 5)[3]);\n    \n    in_val = atoll(lamenter_horrorist);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if ((preprovoking_urohematin - 5)[3] != 0) \n    free(((char *)(preprovoking_urohematin - 5)[3]));\nclose_printf_context();\n}", "answer": "B.CWE-834:Excessive Iteration|C.CWE-691:Insufficient Control Flow Management", "cwe": "834", "idx": "152121"}
{"selection": "A.CWE-271:Privilege Dropping / Lowering Errors\nB.CWE-36:Absolute Path Traversal\nC.CWE-346:Origin Validation Error\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_02\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96787"}
{"selection": "A.CWE-708:Incorrect Ownership Assignment\nB.CWE-674:Uncontrolled Recursion\nC.No Vulnerabilities\nD.CWE-691:Insufficient Control Flow Management\nE.CWE-1059:Insufficient Technical Documentation", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint undisplaceable_preenforcing = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n int found;\n  char *lavi_dreadly = 0;\n  jmp_buf driftwind_thalassal;\n  int diddies_destress;\n  void *ferriage_elkesaite = 0;\n  char *pungyi_matted;;\n  if (__sync_bool_compare_and_swap(&undisplaceable_preenforcing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      pungyi_matted = getenv(\"FEDERARIE_FRICANDEL\");\n      if (pungyi_matted != 0) {;\n        ferriage_elkesaite = ((void *)pungyi_matted);\n        diddies_destress = setjmp(driftwind_thalassal);\n        if (diddies_destress == 0) {\n          longjmp(driftwind_thalassal,1);\n        }\n        lavi_dreadly = ((char *)((char *)ferriage_elkesaite));\n    \n    \n    \n    found = search(&lavi_dreadly[1],lavi_dreadly[0]);\n    \n    \n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "B.CWE-674:Uncontrolled Recursion|D.CWE-691:Insufficient Control Flow Management", "cwe": "674", "idx": "151648"}
{"selection": "A.CWE-1291:Public Key Re-Use for Signing both Debug and Production Code\nB.CWE-767:Access to Critical Private Variable via Public Method\nC.CWE-707:Improper Neutralization\nD.No Vulnerabilities\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n#include <list>\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _Process_Control__w32_char_listen_socket_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_listen_socket_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62174"}
{"selection": "A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-149:Improper Neutralization of Quoting Syntax\nD.CWE-650:Trusting HTTP Permission Methods on the Server Side\nE.CWE-833:Deadlock", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <sys/stat.h> \nint marlpit_tasking = 0;\nint global_variable;\nvoid handle_taint(char *scourfishes_faki);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid shovelweed_decciare(char **chaffin_beplaster);\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex_0, mutex_1;\npthread_t t0, t1;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *replace (void *data) {\n    struct data *cusData = (struct data*)data;\n    int *qsort_arr;\n    int i = 0;\n    \n    \n    printf(\"replace: entering function\\n\");\n    \n    qsort_arr = malloc(sizeof(int)*cusData->qsize);\n    if (qsort_arr != NULL) {\n        for (i = 0; i < cusData->qsize; i++) {\n            qsort_arr[i] = cusData->qsize - i;\n        }\n        qsort(qsort_arr, cusData->qsize, sizeof(int), &comp);\n        free (qsort_arr);\n        qsort_arr = NULL;\n    }\n    readFile(cusData->file1);\n    printf(\"replace: Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0);\n    printf(\"replace: Grabbed lock 0\\n\");\n    printf(\"replace: Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1); \n    printf(\"replace: Grabbed lock 1\\n\");\n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] == '_') {\n            cusData->data[i] = '-';\n        }\n        i++;\n    }\n    printf(\"replace: Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    printf(\"replace: Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    \n    return NULL;\n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i = 0;\n    \n    printf(\"toCap:   Entering function\\n\");\n    printf(\"toCap:   Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1);\n    printf(\"toCap:   Grabbed lock 1\\n\");\n    readFile(cusData->file2);\n    \n    \n    printf(\"toCap:   Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0); \n    printf(\"toCap:   Grabbed lock 0\\n\");\n    \n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] > 'a' && cusData->data[i] < 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    printf(\"toCap:   Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    printf(\"toCap:   Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&marlpit_tasking,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n#define AMBROSE_ANAPHRODISIAC(x) shovelweed_decciare((char **) x)\n\nvoid handle_taint(char *scourfishes_faki)\n{\n  char **ugh_angelicness = 0;\n  ++global_variable;;\n  if (scourfishes_faki != 0) {;\n    ugh_angelicness = &scourfishes_faki;\n\tAMBROSE_ANAPHRODISIAC(ugh_angelicness);\n  }\n}\n\nvoid shovelweed_decciare(char **chaffin_beplaster)\n{\n    int hasUnderscores = 0;\n    int i = 0;\n    struct data* cusData;\n  char *cuddy_yemschik = 0;\n  ++global_variable;;\n  cuddy_yemschik = ((char *)( *chaffin_beplaster));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(cuddy_yemschik) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(cuddy_yemschik) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(cuddy_yemschik) + 1));\n        if (cusData->data) {\n            if ((sscanf(cuddy_yemschik, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                \n                \n                \n                \n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                while(cusData->data[i] != '\\0') { \n                    if (cusData->data[i++] == '_') { \n                        hasUnderscores = 1;\n                    }\n                }\n                \n                if (pthread_create(&t0, NULL, toCap, cusData) != 0) {\n                    printf(\"Thread 0 failed to spawn.\");\n                }\n                if (hasUnderscores == 1) {\n                    \n                    if (pthread_create(&t1, NULL, replace, cusData) != 0) {\n                        printf(\"Thread 1 failed to spawn.\");\n                    }\n                }\n                pthread_join(t0, NULL);\n                if (hasUnderscores == 1) {\n                    pthread_join(t1, NULL);\n                }\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n  if ( *chaffin_beplaster != 0) \n    free(((char *)( *chaffin_beplaster)));\nclose_printf_context();\n}", "answer": "E.CWE-833:Deadlock|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "833", "idx": "150588"}
{"selection": "A.CWE-647:Use of Non-Canonical URL Paths for Authorization Decisions\nB.No Vulnerabilities\nC.CWE-123:Write-what-where Condition\nD.CWE-476:NULL Pointer Dereference\nE.CWE-710:Improper Adherence to Coding Standards", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint featherwood_cornuting = 0;\nint global_variable;\n\nstruct rompish_siddons \n{\n  char *crackbrained_mia;\n  double subtrapezoidal_excellency;\n  char *punkeys_bioclimatician;\n  char foliiform_homomorphism;\n  int openly_lallans;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid prepurchases_szeged(struct rompish_siddons *unelbowed_bassia);\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  void (*branchiopoda_mismeets)(struct rompish_siddons *) = prepurchases_szeged;\n  struct rompish_siddons *predivide_scrappler = {0};\n  struct rompish_siddons sigillation_phalaenae;\n  int hypercalcaemia_semijuridical = 125;\n  char *alkoran_slipcases;;\n  if (__sync_bool_compare_and_swap(&featherwood_cornuting,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&alkoran_slipcases,\"8625\",hypercalcaemia_semijuridical);\n      if (alkoran_slipcases != 0) {;\n        sigillation_phalaenae . crackbrained_mia = ((char *)alkoran_slipcases);\n        predivide_scrappler = &sigillation_phalaenae;\n        branchiopoda_mismeets(predivide_scrappler);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid prepurchases_szeged(struct rompish_siddons *unelbowed_bassia)\n{\n  char *skip_malloc_buffer = 0;\n  char *paralgesia_phren = 0;\n  ++global_variable;;\n  paralgesia_phren = ((char *)( *unelbowed_bassia) . crackbrained_mia);\n      \n      \n\n      if (strlen(paralgesia_phren) < 63) {\n        skip_malloc_buffer = malloc(strlen(paralgesia_phren + 1));\n      }\n      \n      \n      \n\n      strcpy(skip_malloc_buffer,paralgesia_phren);\n      printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n      \n      if (skip_malloc_buffer != 0) {\n        free(skip_malloc_buffer);\n      }\n      \n;\n  if (( *unelbowed_bassia) . crackbrained_mia != 0) \n    free(((char *)( *unelbowed_bassia) . crackbrained_mia));\nclose_printf_context();\n}", "answer": "D.CWE-476:NULL Pointer Dereference|E.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149311"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-307:Improper Restriction of Excessive Authentication Attempts\nC.CWE-599:Missing Validation of OpenSSL Certificate\nD.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_popen_22Global = 0;\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_popen_22Source(wchar_t * data);\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_22()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_popen_22Source(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Global = 0;\nint _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Global = 0;\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Global = 0; \n    data = _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Source(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Source(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "246478"}
{"selection": "A.No Vulnerabilities\nB.CWE-114:Process Control\nC.CWE-188:Reliance on Data/Memory Layout\nD.CWE-295:Improper Certificate Validation\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_listen_socket_18()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_listen_socket_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_listen_socket_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_listen_socket_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-114:Process Control|E.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62149"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-248:Uncaught Exception\nC.CWE-36:Absolute Path Traversal\nD.No Vulnerabilities\nE.CWE-1090:Method Containing Access of a Member Element from Another Class", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_file_w32CreateFile_52\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_w32CreateFile_52; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-36:Absolute Path Traversal|A.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96480"}
{"selection": "A.No Vulnerabilities\nB.CWE-23:Relative Path Traversal\nC.CWE-509:Replicating Malicious Code (Virus or Worm)\nD.CWE-377:Insecure Temporary File\nE.CWE-707:Improper Neutralization", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_open_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * data = dataRef;\n        {\n            int fileDesc;\n            \n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    {\n        wchar_t * data = dataRef;\n        {\n            int fileDesc;\n            \n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_open_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-23:Relative Path Traversal|E.CWE-707:Improper Neutralization", "cwe": "23", "idx": "91906"}
{"selection": "A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-794:Incomplete Filtering of Multiple Instances of Special Elements\nC.CWE-7:J2EE Misconfiguration: Missing Custom Error Page\nD.CWE-476:NULL Pointer Dereference\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint unfrustrated_thomasite = 0;\ntypedef char *kaz_nonassignably;\nint global_variable;\nvoid handle_taint(char *nonrevoltingly_baldling);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid proscribable_zombie(kaz_nonassignably *ciceronian_effraction);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&unfrustrated_thomasite,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid handle_taint(char *nonrevoltingly_baldling)\n{\n  void (*unfallaciously_ingreve)(kaz_nonassignably *) = proscribable_zombie;\n  kaz_nonassignably *referring_wheatstalk = 0;\n  kaz_nonassignably *texon_mercator = 0;\n  kaz_nonassignably unattaining_enantiopathy = 0;\n  ++global_variable;;\n  if (nonrevoltingly_baldling != 0) {;\n    unattaining_enantiopathy = nonrevoltingly_baldling;\n    referring_wheatstalk = &unattaining_enantiopathy;\n    texon_mercator = referring_wheatstalk + 5;\n    unfallaciously_ingreve(texon_mercator);\n  }\n}\n\nvoid proscribable_zombie(kaz_nonassignably *ciceronian_effraction)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *sweeny_cafes = 0;\n  ++global_variable;;\n  sweeny_cafes = ((char *)( *(ciceronian_effraction - 5)));\n      \n      while(isalnum(sweeny_cafes[size]) && size < strlen(sweeny_cafes)){\n        ++size;\n      }\n      \n\n      if (size != strlen(sweeny_cafes)) {\n        sweeny_cafes = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,sweeny_cafes);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if ( *(ciceronian_effraction - 5) != 0) \n    free(((char *)( *(ciceronian_effraction - 5))));\nclose_printf_context();\n}", "answer": "D.CWE-476:NULL Pointer Dereference|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149623"}
{"selection": "A.No Vulnerabilities\nB.CWE-352:Cross-Site Request Forgery (CSRF)\nC.CWE-710:Improper Adherence to Coding Standards\nD.CWE-1229:Creation of Emergent Resource\nE.CWE-476:NULL Pointer Dereference", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint unoverleaped_participative = 0;\n\nunion subtractive_unpacker \n{\n  char *strikingly_stacked;\n  double ceratozamia_orthochlorite;\n  char *lefty_mininovel;\n  char uvitinic_muntiacus;\n  int intracardial_argufied;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *syringas_wallsend = 0;\n  int daboya_nonconsoling;\n  int opaion_pebrine;\n  union subtractive_unpacker outpeer_updrink = {0};\n  long wycoff_acierate[10];\n  union subtractive_unpacker safety_contentedly[10] = {0};\n  union subtractive_unpacker zoopaleontology_margarine;\n  char *promatrimonial_silicles;;\n  if (__sync_bool_compare_and_swap(&unoverleaped_participative,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      promatrimonial_silicles = getenv(\"ANAT_EXTENUATORY\");\n      if (promatrimonial_silicles != 0) {;\n        zoopaleontology_margarine . strikingly_stacked = promatrimonial_silicles;\n        safety_contentedly[5] = zoopaleontology_margarine;\n        wycoff_acierate[1] = 5;\n        outpeer_updrink =  *(safety_contentedly + wycoff_acierate[1]);\n        opaion_pebrine = 5;\n        while(1 == 1){\n          opaion_pebrine = opaion_pebrine * 2;\n          opaion_pebrine = opaion_pebrine + 2;\n          if (opaion_pebrine > 1000) {\n            break; \n          }\n        }\n        daboya_nonconsoling = opaion_pebrine;\n        syringas_wallsend = ((char *)outpeer_updrink . strikingly_stacked);\n      \n      \n\n      pFile = fopen(syringas_wallsend,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "E.CWE-476:NULL Pointer Dereference|C.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149686"}
{"selection": "A.CWE-36:Absolute Path Traversal\nB.CWE-268:Privilege Chaining\nC.CWE-1311:Improper Translation of Security Attributes by Fabric Bridge\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_file_ofstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_ofstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-36:Absolute Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96378"}
{"selection": "A.No Vulnerabilities\nB.CWE-303:Incorrect Implementation of Authentication Algorithm\nC.CWE-535:Exposure of Information Through Shell Error Message\nD.CWE-707:Improper Neutralization\nE.CWE-23:Relative Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_listen_socket_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90718"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-331:Insufficient Entropy\nC.CWE-639:Authorization Bypass Through User-Controlled Key\nD.No Vulnerabilities\nE.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')", "code": "#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic int staticFive = 5;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_07()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_07()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_07();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_07();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|A.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123189"}
{"selection": "A.CWE-430:Deployment of Wrong Handler\nB.CWE-190:Integer Overflow or Wraparound\nC.No Vulnerabilities\nD.CWE-707:Improper Neutralization\nE.CWE-1089:Large Data Table with Excessive Number of Indices", "code": "#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint yeuks_orderlinesses = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint 190_global_var = 0;\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *lemmy_alkylene = 0;\n  void *vexillarious_perturbs = 0;\n  int **cludder_phenylated = 0;\n  int *corny_antonio = 0;\n  int niteries_intoxicating;\n  void *guamuchil_nonnormal[10] = {0};\n  void *archaeoceti_brainiest = 0;\n  char *wab_pseudoeugenics;;\n  if (__sync_bool_compare_and_swap(&yeuks_orderlinesses,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&wab_pseudoeugenics,\"IPSWICH_OYSTERLING\");\n      if (wab_pseudoeugenics != 0) {;\n        archaeoceti_brainiest = ((void *)wab_pseudoeugenics);\n        niteries_intoxicating = 5;\n        corny_antonio = &niteries_intoxicating;\n        cludder_phenylated = &corny_antonio;\n        guamuchil_nonnormal[ *( *cludder_phenylated)] = archaeoceti_brainiest;\n        vexillarious_perturbs = guamuchil_nonnormal[ *( *cludder_phenylated)];\n        lemmy_alkylene = ((char *)((char *)vexillarious_perturbs));\n    \n    tainted_int = atoi(lemmy_alkylene);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n        if (((char *)vexillarious_perturbs) != 0) \n          free(((char *)((char *)vexillarious_perturbs)));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "B.CWE-190:Integer Overflow or Wraparound|D.CWE-707:Improper Neutralization", "cwe": "190", "idx": "150921"}
{"selection": "A.CWE-1111:Incomplete I/O Documentation\nB.CWE-114:Process Control\nC.CWE-707:Improper Neutralization\nD.CWE-267:Privilege Defined With Unsafe Actions\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_environment_02()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_environment_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_environment_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_environment_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "B.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62325"}
{"selection": "A.CWE-243:Creation of chroot Jail Without Changing Working Directory\nB.CWE-707:Improper Neutralization\nC.CWE-15:External Control of System or Configuration Setting\nD.No Vulnerabilities\nE.CWE-1223:Race Condition for Write-Once Attributes", "code": "#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-15:External Control of System or Configuration Setting|B.CWE-707:Improper Neutralization", "cwe": "15", "idx": "81978"}
{"selection": "A.No Vulnerabilities\nB.CWE-664:Improper Control of a Resource Through its Lifetime\nC.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime\nD.CWE-1259:Improper Restriction of Security Token Assignment\nE.CWE-1060:Excessive Number of Inefficient Server-Side Data Accesses", "code": "#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint hippopotamian_versative = 0;\n\nunion absalom_topnet \n{\n  char *hearselike_riatas;\n  double anthropophagy_fulful;\n  char *sketchist_proselike;\n  char theriomorph_uteroventral;\n  int terrier_aerosols;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nSize PMSignalShmemSize()\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *heterophaga_aggrieving = 0;\n  jmp_buf pylas_rejourn;\n  int abjudicator_narcomedusae;\n  union absalom_topnet rockhampton_centrums = {0};\n  int *oosporous_pickpocketism = 0;\n  int hackensack_gottingen;\n  union absalom_topnet inhoop_nonsalutation[10] = {0};\n  union absalom_topnet plur_magadis;\n  char *cogitabundly_writeoffs;\n  Size size;\n  if (__sync_bool_compare_and_swap(&hippopotamian_versative,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&cogitabundly_writeoffs,\"SPRYNESS_EULOGISATION\");\n      if (cogitabundly_writeoffs != 0) {;\n        plur_magadis . hearselike_riatas = cogitabundly_writeoffs;\n        inhoop_nonsalutation[5] = plur_magadis;\n        hackensack_gottingen = 5;\n        oosporous_pickpocketism = &hackensack_gottingen;\n        rockhampton_centrums =  *(inhoop_nonsalutation +  *oosporous_pickpocketism);\n        abjudicator_narcomedusae = setjmp(pylas_rejourn);\n        if (abjudicator_narcomedusae == 0) {\n          longjmp(pylas_rejourn,1);\n        }\n        heterophaga_aggrieving = ((char *)rockhampton_centrums . hearselike_riatas);\n    \n files = fopen(heterophaga_aggrieving,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n        if (rockhampton_centrums . hearselike_riatas != 0) \n          free(((char *)rockhampton_centrums . hearselike_riatas));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "C.CWE-775:Missing Release of File Descriptor or Handle after Effective Lifetime|B.CWE-664:Improper Control of a Resource Through its Lifetime", "cwe": "775", "idx": "151606"}
{"selection": "A.CWE-710:Improper Adherence to Coding Standards\nB.CWE-942:Permissive Cross-domain Policy with Untrusted Domains\nC.No Vulnerabilities\nD.CWE-476:NULL Pointer Dereference\nE.CWE-348:Use of Less Trusted Source", "code": "#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint foreseer_esocataphoria = 0;\ntypedef char *celibacies_rereel;\nint global_variable;\nvoid handle_taint(char *needly_tipsification);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid significator_retaker(const celibacies_rereel amphictyonies_eosine);\nvoid mnemonism_propanedioic(celibacies_rereel guttate_plagioclinal);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&foreseer_esocataphoria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *needly_tipsification)\n{\n  celibacies_rereel maugansville_ellington = 0;\n  ++global_variable;;\n  if (needly_tipsification != 0) {;\n    maugansville_ellington = needly_tipsification;\n    significator_retaker(maugansville_ellington);\n  }\n}\n\nvoid significator_retaker(const celibacies_rereel amphictyonies_eosine)\n{\n  void (*curtailing_denicotinizes)(celibacies_rereel ) = mnemonism_propanedioic;\n  ++global_variable;;\n  curtailing_denicotinizes(amphictyonies_eosine);\n}\n\nvoid mnemonism_propanedioic(celibacies_rereel guttate_plagioclinal)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *gomulka_tinty = 0;\n  ++global_variable;;\n  gomulka_tinty = ((char *)((celibacies_rereel )guttate_plagioclinal));\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(gomulka_tinty) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (gomulka_tinty[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &gomulka_tinty[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\n  if (((celibacies_rereel )guttate_plagioclinal) != 0) \n    free(((char *)((celibacies_rereel )guttate_plagioclinal)));\nclose_printf_context();\n}\n#endif", "answer": "D.CWE-476:NULL Pointer Dereference|A.CWE-710:Improper Adherence to Coding Standards", "cwe": "476", "idx": "149941"}
{"selection": "A.CWE-805:Buffer Access with Incorrect Length Value\nB.CWE-662:Improper Synchronization\nC.CWE-707:Improper Neutralization\nD.CWE-862:Missing Authorization\nE.No Vulnerabilities", "code": "#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint preventible_bimanual = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid impetrated_ossicular(void *const properdin_chieftaincies);\nvoid werewall_duty(void *rhizopodal_cryptanalyzed);\nvoid potentiated_nyctalope(void *lacune_unsufficiency);\nvoid titanous_phoh(void *microphonograph_clewgarnet);\nvoid chancellors_chiropractics(void *equinities_oxalaldehyde);\nvoid poort_overstrains(void *dehortatory_paysanne);\nvoid osprey_shirtless(void *developability_merchanteer);\nvoid beresford_savvying(void *acolyte_fibroareolar);\nvoid trumpetweed_cardiagraphy(void *hypersensitised_baedekerian);\nvoid preoverthrew_zilvia(void *forthcome_cathedras);\nvoid traceable_unserene(void *acetophenine_hornlike);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    char buffer[8];\n    char * buff_pointer;\n};\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  void *muggletonian_scaphism = 0;\n  char *blurry_pyrographies;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&preventible_bimanual,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&blurry_pyrographies,\"UNQUALIFIABLE_BILLITON\");\n      if (blurry_pyrographies != 0) {;\n        muggletonian_scaphism = ((void *)blurry_pyrographies);\n        impetrated_ossicular(muggletonian_scaphism);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid impetrated_ossicular(void *const properdin_chieftaincies)\n{\n  ++global_variable;;\n  werewall_duty(properdin_chieftaincies);\n}\n\nvoid werewall_duty(void *rhizopodal_cryptanalyzed)\n{\n  ++global_variable;;\n  potentiated_nyctalope(rhizopodal_cryptanalyzed);\n}\n\nvoid potentiated_nyctalope(void *lacune_unsufficiency)\n{\n  ++global_variable;;\n  titanous_phoh(lacune_unsufficiency);\n}\n\nvoid titanous_phoh(void *microphonograph_clewgarnet)\n{\n  ++global_variable;;\n  chancellors_chiropractics(microphonograph_clewgarnet);\n}\n\nvoid chancellors_chiropractics(void *equinities_oxalaldehyde)\n{\n  ++global_variable;;\n  poort_overstrains(equinities_oxalaldehyde);\n}\n\nvoid poort_overstrains(void *dehortatory_paysanne)\n{\n  ++global_variable;;\n  osprey_shirtless(dehortatory_paysanne);\n}\n\nvoid osprey_shirtless(void *developability_merchanteer)\n{\n  ++global_variable;;\n  beresford_savvying(developability_merchanteer);\n}\n\nvoid beresford_savvying(void *acolyte_fibroareolar)\n{\n  ++global_variable;;\n  trumpetweed_cardiagraphy(acolyte_fibroareolar);\n}\n\nvoid trumpetweed_cardiagraphy(void *hypersensitised_baedekerian)\n{\n  ++global_variable;;\n  preoverthrew_zilvia(hypersensitised_baedekerian);\n}\n\nvoid preoverthrew_zilvia(void *forthcome_cathedras)\n{\n  ++global_variable;;\n  traceable_unserene(forthcome_cathedras);\n}\n\nvoid traceable_unserene(void *acetophenine_hornlike)\n{\n    int oc_i = 0;\n    int ptr_deref;\n    struct struct data;\n  char *solemnly_mensa = 0;\n  ++global_variable;;\n  solemnly_mensa = ((char *)((char *)((void *)acetophenine_hornlike)));\n    \n    data.buff_pointer = data.buffer;\n    \n    \n    \n    \n    \n    strncpy(data.buffer, solemnly_mensa, strlen(solemnly_mensa) + 1);\n    ptr_deref = strlen( data.buff_pointer);\n    for (; oc_i < ptr_deref; ++oc_i) {\n        data.buffer[oc_i] = toupper(data.buffer[oc_i]);\n    }\n    printf(\"%s\\n\", data.buffer);\n    \n    \n    \n;\n  if (((char *)((void *)acetophenine_hornlike)) != 0) \n    free(((char *)((char *)((void *)acetophenine_hornlike))));\nclose_printf_context();\n}", "answer": "A.CWE-805:Buffer Access with Incorrect Length Value|C.CWE-707:Improper Neutralization", "cwe": "805", "idx": "153355"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-272:Least Privilege Violation\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.No Vulnerabilities\nE.CWE-489:Active Debug Code", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_31()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "C.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245199"}
{"selection": "A.No Vulnerabilities\nB.CWE-351:Insufficient Type Distinction\nC.CWE-707:Improper Neutralization\nD.CWE-1313:Hardware Allows Activation of Test or Debug Logic at Runtime\nE.CWE-36:Absolute Path Traversal", "code": "#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_42\n{\n\n#ifndef OMITM\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic wchar_t * nG2BSource(wchar_t * data)\n{\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_42; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-36:Absolute Path Traversal|C.CWE-707:Improper Neutralization", "cwe": "36", "idx": "96763"}
{"selection": "A.No Vulnerabilities\nB.CWE-594:J2EE Framework: Saving Unserializable Objects to Disk\nC.CWE-707:Improper Neutralization\nD.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nE.CWE-1113:Inappropriate Comment Style", "code": "#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint platus_nonworking = 0;\n\nunion redemptions_puntlatsh \n{\n  char *cavia_cadere;\n  double seminifical_lovering;\n  char *oarage_hitchel;\n  char hylomorphic_glandlike;\n  int tatou_sigmodontes;\n}\n;\nint global_variable;\nvoid handle_taint(char *maisie_unwrinkling);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&platus_nonworking,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *maisie_unwrinkling)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int nFields;\n    int i;\n    int j = 0;\n  char *tussive_consumption = 0;\n  union redemptions_puntlatsh caulinar_periboli = {0};\n  long overweaponed_azeotrope[10];\n  union redemptions_puntlatsh mackay_turmel[10] = {0};\n  union redemptions_puntlatsh hoazin_reattempting;\n  ++global_variable;;\n  if (maisie_unwrinkling != 0) {;\n    hoazin_reattempting . cavia_cadere = maisie_unwrinkling;\n    mackay_turmel[5] = hoazin_reattempting;\n    overweaponed_azeotrope[1] = 5;\n    caulinar_periboli =  *(mackay_turmel + overweaponed_azeotrope[1]);\n    tussive_consumption = ((char *)caulinar_periboli . cavia_cadere);\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", tussive_consumption);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            \n            printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        nFields = PQnfields(res);\n        for (i = 0; i < nFields; i++)\n            printf(\"%-15s\", PQfname(res, i));\n        printf(\"\\n\\n\");\n        \n        for (i = 0; i < PQntuples(res); i++)\n        {\n            for (j = 0; j < nFields; j++)\n                printf(\"%-15s\", PQgetvalue(res, i, j));\n            printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\n    if (caulinar_periboli . cavia_cadere != 0) \n      free(((char *)caulinar_periboli . cavia_cadere));\nclose_printf_context();\n  }\n}", "answer": "D.CWE-89:Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')|C.CWE-707:Improper Neutralization", "cwe": "89", "idx": "152406"}
{"selection": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\nB.CWE-623:Unsafe ActiveX Control Marked Safe For Scripting\nC.CWE-1253:Incorrect Selection of Fuse Values\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_console_52bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_console_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_console_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_console_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_console_52bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-90:Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')|D.CWE-707:Improper Neutralization", "cwe": "90", "idx": "123165"}
{"selection": "A.CWE-707:Improper Neutralization\nB.CWE-1094:Excessive Index Range Scan for a Data Resource\nC.CWE-78:Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\nD.CWE-789:Memory Allocation with Excessive Size Value\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_execlp_51bSink(char * data);\n\nvoid _OS_Command_Injection__char_environment_execlp_51()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__char_environment_execlp_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_execlp_51bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_environment_execlp_51bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_environment_execlp_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_execlp_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_execlp_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "D.CWE-789:Memory Allocation with Excessive Size Value|A.CWE-707:Improper Neutralization", "cwe": "78", "idx": "245024"}
{"selection": "A.CWE-23:Relative Path Traversal\nB.CWE-406:Insufficient Control of Network Message Volume (Network Amplification)\nC.CWE-1069:Empty Exception Block\nD.CWE-707:Improper Neutralization\nE.No Vulnerabilities", "code": "#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_fopen_41\n{\n\n#ifndef OMITM\n\nvoid mSink(wchar_t * data)\n{\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(wchar_t * data)\n{\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_fopen_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "A.CWE-23:Relative Path Traversal|D.CWE-707:Improper Neutralization", "cwe": "23", "idx": "90804"}
{"selection": "A.CWE-250:Execution with Unnecessary Privileges\nB.No Vulnerabilities\nC.CWE-707:Improper Neutralization\nD.CWE-779:Logging of Excessive Data\nE.CWE-114:Process Control", "code": "#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_relativePath_09()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(data, \"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_relativePath_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_relativePath_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_relativePath_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "E.CWE-114:Process Control|C.CWE-707:Improper Neutralization", "cwe": "114", "idx": "62188"}
