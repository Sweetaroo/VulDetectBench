{"code": "static const char *cgfs_canonical_path(void *hdata)\n{\n\tstruct cgfs_data *d = hdata;\n\tstruct cgroup_process_info *info_ptr;\n\tchar *path = NULL;\n\n\tif (!d)\n\t\treturn NULL;\n\n\tfor (info_ptr = d->info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!path)\n\t\t\tpath = info_ptr->cgroup_path;\n\t\telse if (strcmp(path, info_ptr->cgroup_path) != 0) {\n\t\t\tERROR(\"not all paths match %s, %s has path %s\", path,\n\t\t\t\tinfo_ptr->hierarchy->subsystems[0], info_ptr->cgroup_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn path;\n}", "answer": "NO", "cwe": "59", "idx": "44455"}
{"code": "static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t\tu8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_policy *xp;\n\tstruct sadb_x_policy *pol = (struct sadb_x_policy*)data;\n\tstruct sadb_x_sec_ctx *sec_ctx;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_IPSEC_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(struct sadb_x_policy) ||\n\t    pol->sadb_x_policy_len*8 > len ||\n\t    pol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||\n\t    (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\txp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\n\t\t      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\n\n\txp->lft.soft_byte_limit = XFRM_INF;\n\txp->lft.hard_byte_limit = XFRM_INF;\n\txp->lft.soft_packet_limit = XFRM_INF;\n\txp->lft.hard_packet_limit = XFRM_INF;\n\txp->family = sk->sk_family;\n\n\txp->xfrm_nr = 0;\n\tif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\n\t    (*dir = parse_ipsecrequests(xp, pol)) < 0)\n\t\tgoto out;\n\n\t\n\tif (len >= (pol->sadb_x_policy_len*8 +\n\t    sizeof(struct sadb_x_sec_ctx))) {\n\t\tchar *p = (char *)pol;\n\t\tstruct xfrm_user_sec_ctx *uctx;\n\n\t\tp += pol->sadb_x_policy_len*8;\n\t\tsec_ctx = (struct sadb_x_sec_ctx *)p;\n\t\tif (len < pol->sadb_x_policy_len*8 +\n\t\t    sec_ctx->sadb_x_sec_len) {\n\t\t\t*dir = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((*dir = verify_sec_ctx_len(p)))\n\t\t\tgoto out;\n\t\tuctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx);\n\t\t*dir = security_xfrm_policy_alloc(&xp->security, uctx);\n\t\tkfree(uctx);\n\n\t\tif (*dir)\n\t\t\tgoto out;\n\t}\n\n\t*dir = pol->sadb_x_policy_dir-1;\n\treturn xp;\n\nout:\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}", "answer": "NO", "cwe": "119", "idx": "31409"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    funcPtr(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123306"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97822"}
{"code": "static int einj_check_table(struct acpi_table_einj *einj_tab)\n{\n\tif ((einj_tab->header_length !=\n\t     (sizeof(struct acpi_table_einj) - sizeof(einj_tab->header)))\n\t    && (einj_tab->header_length != sizeof(struct acpi_table_einj)))\n\t\treturn -EINVAL;\n\tif (einj_tab->header.length < sizeof(struct acpi_table_einj))\n\t\treturn -EINVAL;\n\tif (einj_tab->entries !=\n\t    (einj_tab->header.length - sizeof(struct acpi_table_einj)) /\n\t    sizeof(struct acpi_einj_entry))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "answer": "NO", "cwe": "74", "idx": "73880"}
{"code": "\t~RuntimeConfigItem() { if (admin) free(admin); if (config) free(config); }", "answer": "NO", "cwe": "134", "idx": "16533"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define SYSTEM system\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_system_10()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\nvoid _OS_Command_Injection__char_file_system_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_system_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_system_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245568"}
{"code": "static int fsmRemove(const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(path) : fsmUnlink(path);\n}", "answer": "NO", "cwe": "59", "idx": "67495"}
{"code": "static int audio_decode_frame(VideoState *is, double *pts_ptr)\n\n{\n\n    AVPacket *pkt_temp = &is->audio_pkt_temp;\n\n    AVPacket *pkt = &is->audio_pkt;\n\n    AVCodecContext *dec = is->audio_st->codec;\n\n    int len1, len2, data_size, resampled_data_size;\n\n    int64_t dec_channel_layout;\n\n    int got_frame;\n\n    double pts;\n\n    int new_packet = 0;\n\n    int flush_complete = 0;\n\n    int wanted_nb_samples;\n\n\n\n    for (;;) {\n\n        \n\n        while (pkt_temp->size > 0 || (!pkt_temp->data && new_packet)) {\n\n            if (!is->frame) {\n\n                if (!(is->frame = avcodec_alloc_frame()))\n\n                    return AVERROR(ENOMEM);\n\n            } else\n\n                avcodec_get_frame_defaults(is->frame);\n\n\n\n            if (is->paused)\n\n                return -1;\n\n\n\n            if (flush_complete)\n\n                break;\n\n            new_packet = 0;\n\n            len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);\n\n            if (len1 < 0) {\n\n                \n\n                pkt_temp->size = 0;\n\n                break;\n\n            }\n\n\n\n            pkt_temp->data += len1;\n\n            pkt_temp->size -= len1;\n\n\n\n            if (!got_frame) {\n\n                \n\n                if (!pkt_temp->data && dec->codec->capabilities & CODEC_CAP_DELAY)\n\n                    flush_complete = 1;\n\n                continue;\n\n            }\n\n            data_size = av_samples_get_buffer_size(NULL, dec->channels,\n\n                                                   is->frame->nb_samples,\n\n                                                   dec->sample_fmt, 1);\n\n\n\n            dec_channel_layout = (dec->channel_layout && dec->channels == av_get_channel_layout_nb_channels(dec->channel_layout)) ? dec->channel_layout : av_get_default_channel_layout(dec->channels);\n\n            wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);\n\n\n\n            if (dec->sample_fmt != is->audio_src.fmt ||\n\n                dec_channel_layout != is->audio_src.channel_layout ||\n\n                dec->sample_rate != is->audio_src.freq ||\n\n                (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {\n\n                if (is->swr_ctx)\n\n                    swr_free(&is->swr_ctx);\n\n                is->swr_ctx = swr_alloc_set_opts(NULL,\n\n                                                 is->audio_tgt.channel_layout, is->audio_tgt.fmt, is->audio_tgt.freq,\n\n                                                 dec_channel_layout,           dec->sample_fmt,   dec->sample_rate,\n\n                                                 0, NULL);\n\n                if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {\n\n                    fprintf(stderr, \"Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\\n\",\n\n                        dec->sample_rate,\n\n                        av_get_sample_fmt_name(dec->sample_fmt),\n\n                        dec->channels,\n\n                        is->audio_tgt.freq,\n\n                        av_get_sample_fmt_name(is->audio_tgt.fmt),\n\n                        is->audio_tgt.channels);\n\n                    break;\n\n                }\n\n                is->audio_src.channel_layout = dec_channel_layout;\n\n                is->audio_src.channels = dec->channels;\n\n                is->audio_src.freq = dec->sample_rate;\n\n                is->audio_src.fmt = dec->sample_fmt;\n\n            }\n\n\n\n            resampled_data_size = data_size;\n\n            if (is->swr_ctx) {\n\n                const uint8_t *in[] = { is->frame->data[0] };\n\n                uint8_t *out[] = {is->audio_buf2};\n\n                if (wanted_nb_samples != is->frame->nb_samples) {\n\n                    if (swr_set_compensation(is->swr_ctx, (wanted_nb_samples - is->frame->nb_samples) * is->audio_tgt.freq / dec->sample_rate,\n\n                                                wanted_nb_samples * is->audio_tgt.freq / dec->sample_rate) < 0) {\n\n                        fprintf(stderr, \"swr_set_compensation() failed\\n\");\n\n                        break;\n\n                    }\n\n                }\n\n                len2 = swr_convert(is->swr_ctx, out, sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt),\n\n                                                in, is->frame->nb_samples);\n\n                if (len2 < 0) {\n\n                    fprintf(stderr, \"swr_convert() failed\\n\");\n\n                    break;\n\n                }\n\n                if (len2 == sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt)) {\n\n                    fprintf(stderr, \"warning: audio buffer is probably too small\\n\");\n\n                    swr_init(is->swr_ctx);\n\n                }\n\n                is->audio_buf = is->audio_buf2;\n\n                resampled_data_size = len2 * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);\n\n            } else {\n\n                is->audio_buf = is->frame->data[0];\n\n            }\n\n\n\n            \n\n            pts = is->audio_clock;\n\n            *pts_ptr = pts;\n\n            is->audio_clock += (double)data_size /\n\n                (dec->channels * dec->sample_rate * av_get_bytes_per_sample(dec->sample_fmt));\n\n#ifdef DEBUG\n\n            {\n\n                static double last_clock;\n\n                printf(\"audio: delay=%0.3f clock=%0.3f pts=%0.3f\\n\",\n\n                       is->audio_clock - last_clock,\n\n                       is->audio_clock, pts);\n\n                last_clock = is->audio_clock;\n\n            }\n\n#endif\n\n            return resampled_data_size;\n\n        }\n\n\n\n        \n\n        if (pkt->data)\n\n            av_free_packet(pkt);\n\n        memset(pkt_temp, 0, sizeof(*pkt_temp));\n\n\n\n        if (is->paused || is->audioq.abort_request) {\n\n            return -1;\n\n        }\n\n\n\n        \n\n        if ((new_packet = packet_queue_get(&is->audioq, pkt, 1)) < 0)\n\n            return -1;\n\n\n\n        if (pkt->data == flush_pkt.data) {\n\n            avcodec_flush_buffers(dec);\n\n            flush_complete = 0;\n\n        }\n\n\n\n        *pkt_temp = *pkt;\n\n\n\n        \n\n        if (pkt->pts != AV_NOPTS_VALUE) {\n\n            is->audio_clock = av_q2d(is->audio_st->time_base)*pkt->pts;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "4fd07b9366fb2f74b6af0dea8092d6bafa38f131"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_open_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_open_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91191"}
{"code": "int f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tif ((recover && f2fs_readonly(sbi->sb)) ||\n\t\t\t\tbdev_read_only(sbi->sb->s_bdev)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_SB_WRITE);\n\t\treturn -EROFS;\n\t}\n\n\t\n\tbh = sb_getblk(sbi->sb, sbi->valid_super_block ? 0: 1);\n\tif (!bh)\n\t\treturn -EIO;\n\terr = __f2fs_commit_super(bh, F2FS_RAW_SUPER(sbi));\n\tbrelse(bh);\n\n\t\n\tif (recover || err)\n\t\treturn err;\n\n\t\n\tbh = sb_getblk(sbi->sb, sbi->valid_super_block);\n\tif (!bh)\n\t\treturn -EIO;\n\terr = __f2fs_commit_super(bh, F2FS_RAW_SUPER(sbi));\n\tbrelse(bh);\n\treturn err;\n}", "answer": "NO", "cwe": "129", "idx": "63858"}
{"code": "static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}", "answer": "NO", "cwe": "0", "idx": "b3db211f3c80bb996a704d665fe275619f728bd4"}
{"code": "static void process_lock_setup_atfork(void)\n{\n\tpthread_atfork(cgm_lock, cgm_unlock, cgm_unlock);\n}", "answer": "NO", "cwe": "59", "idx": "44554"}
{"code": "static int snd_usb_audio_create(struct usb_interface *intf,\n\t\t\t\tstruct usb_device *dev, int idx,\n\t\t\t\tconst struct snd_usb_audio_quirk *quirk,\n\t\t\t\tunsigned int usb_id,\n\t\t\t\tstruct snd_usb_audio **rchip)\n{\n\tstruct snd_card *card;\n\tstruct snd_usb_audio *chip;\n\tint err, len;\n\tchar component[14];\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_usb_audio_dev_free,\n\t};\n\n\t*rchip = NULL;\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_WIRELESS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"unknown device speed %d\\n\", snd_usb_get_speed(dev));\n\t\treturn -ENXIO;\n\t}\n\n\terr = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"cannot create card instance %d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (! chip) {\n\t\tsnd_card_free(card);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->shutdown_wait);\n\tchip->index = idx;\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->setup = device_setup[idx];\n\tchip->autoclock = autoclock;\n\tatomic_set(&chip->active, 1); \n\tatomic_set(&chip->usage_count, 0);\n\tatomic_set(&chip->shutdown, 0);\n\n\tchip->usb_id = usb_id;\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_LIST_HEAD(&chip->ep_list);\n\tINIT_LIST_HEAD(&chip->midi_list);\n\tINIT_LIST_HEAD(&chip->mixer_list);\n\n\tif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\n\t\tsnd_usb_audio_free(chip);\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tstrcpy(card->driver, \"USB-Audio\");\n\tsprintf(component, \"USB%04x:%04x\",\n\t\tUSB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));\n\tsnd_component_add(card, component);\n\n\t\n\tif (quirk && quirk->product_name && *quirk->product_name) {\n\t\tstrlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));\n\t} else {\n\t\tif (!dev->descriptor.iProduct ||\n\t\t    usb_string(dev, dev->descriptor.iProduct,\n\t\t    card->shortname, sizeof(card->shortname)) <= 0) {\n\t\t\t\n\t\t\tsprintf(card->shortname, \"USB Device %#04x:%#04x\",\n\t\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t\t}\n\t}\n\tstrim(card->shortname);\n\n\t\n\tif (quirk && quirk->vendor_name && *quirk->vendor_name) {\n\t\tlen = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));\n\t} else {\n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tlen = usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t\t card->longname, sizeof(card->longname));\n\t\telse\n\t\t\tlen = 0;\n\t\t\n\t}\n\tif (len > 0) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsnd_usb_audio_create_proc(chip);\n\n\t*rchip = chip;\n\treturn 0;\n}", "answer": "NO", "cwe": "125", "idx": "59925"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint codisjunct_bureaucratese = 0;\nint global_variable;\nvoid handle_taint(char *defuzes_hydroiodic);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid multithreaded_traditionally(char *(*ritornellos_namare)[29]);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&codisjunct_bureaucratese,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n#define PHORONOMY_ANORECTOUS(x) multithreaded_traditionally((char *(*)[29]) x)\n\nvoid handle_taint(char *defuzes_hydroiodic)\n{\n  char *(*longrun_bridgemen)[29] = 0;\n  char **combustions_trochalopod = 0;\n  char *bobsleded_declassed[29] = {0};\n  ++global_variable;;\n  if (defuzes_hydroiodic != 0) {;\n    bobsleded_declassed[8] = defuzes_hydroiodic;\n    longrun_bridgemen = &bobsleded_declassed;\n\tPHORONOMY_ANORECTOUS(longrun_bridgemen);\n  }\n}\n\nvoid multithreaded_traditionally(char *(*ritornellos_namare)[29])\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *humorific_quadrilling = 0;\n  ++global_variable;;\n  humorific_quadrilling = ((char *)( *ritornellos_namare)[8]);\n    \n    in_val = atoll(humorific_quadrilling);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (( *ritornellos_namare)[8] != 0) \n    free(((char *)( *ritornellos_namare)[8]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "834", "idx": "151604"}
{"code": "static void simplify_merges(struct rev_info *revs)\n{\n\tstruct commit_list *list, *next;\n\tstruct commit_list *yet_to_do, **tail;\n\tstruct commit *commit;\n\n\tif (!revs->prune)\n\t\treturn;\n\n\t\n\tyet_to_do = NULL;\n\tfor (list = revs->commits; list; list = next) {\n\t\tcommit = list->item;\n\t\tnext = list->next;\n\t\t\n\t\tcommit_list_insert(commit, &yet_to_do);\n\t}\n\twhile (yet_to_do) {\n\t\tlist = yet_to_do;\n\t\tyet_to_do = NULL;\n\t\ttail = &yet_to_do;\n\t\twhile (list) {\n\t\t\tcommit = list->item;\n\t\t\tnext = list->next;\n\t\t\tfree(list);\n\t\t\tlist = next;\n\t\t\ttail = simplify_one(revs, commit, tail);\n\t\t}\n\t}\n\n\t\n\tlist = revs->commits;\n\trevs->commits = NULL;\n\ttail = &revs->commits;\n\twhile (list) {\n\t\tstruct merge_simplify_state *st;\n\n\t\tcommit = list->item;\n\t\tnext = list->next;\n\t\tfree(list);\n\t\tlist = next;\n\t\tst = locate_simplify_state(revs, commit);\n\t\tif (st->simplified == commit)\n\t\t\ttail = &commit_list_insert(commit, tail)->next;\n\t}\n}", "answer": "NO", "cwe": "119", "idx": "55176"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_relativePath_09()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(data, \"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_relativePath_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_relativePath_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_relativePath_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62188"}
{"code": "static uint32_t gic_dist_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            return ((s->num_irq / 32) - 1) | ((NUM_CPU(s) - 1) << 5);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            \n\n            return 0;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        \n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        \n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_PENDING(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        \n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        \n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        \n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            \n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        \n\n        irq = (offset - 0xc00) * 2 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else  {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    hw_error(\"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <stdarg.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint monacid_upheld = 0;\nint global_variable;\nvoid handle_taint(char *misreprint_tanh);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid inspections_triumphed(int lourd_depend,... );\nvoid sailflying_internunciatory(char **euthyneura_unlowly);\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&monacid_upheld,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *misreprint_tanh)\n{\n  char *matterfulness_gallicolous[72] = {0};\n  ++global_variable;;\n  if (misreprint_tanh != 0) {;\n    matterfulness_gallicolous[33] = misreprint_tanh;\n    inspections_triumphed(1,matterfulness_gallicolous);\n  }\n}\n\nvoid inspections_triumphed(int lourd_depend,... )\n{\n  void (*mctyre_nutritory)(char **) = sailflying_internunciatory;\n  char **scraigh_shotty = 0;\n  va_list hardfern_gristly;\n  ++global_variable;;\n  if (lourd_depend > 0) {\n    __builtin_va_start(hardfern_gristly,lourd_depend);\n    scraigh_shotty = (va_arg(hardfern_gristly,char **));\n    __builtin_va_end(hardfern_gristly);\n  }\n  mctyre_nutritory(scraigh_shotty);\n}\n\nvoid sailflying_internunciatory(char **euthyneura_unlowly)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  int random_int = 0;\n  char *scarps_polonnaruwa = 0;\n  ++global_variable;;\n  scarps_polonnaruwa = ((char *)euthyneura_unlowly[33]);\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n    srand(time(NULL));\n    random_int = (rand() % 1000) + 100;\n                snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, scarps_polonnaruwa);\n    \n                \n                \n\n                if (mysql_query(conn,query_buffer)) {\n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n    } else {\n      printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n  if (euthyneura_unlowly[33] != 0) \n    free(((char *)euthyneura_unlowly[33]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "89", "idx": "152218"}
{"code": "void mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\n\treturn;\n}", "answer": "NO", "cwe": "120", "idx": "88620"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_15\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcat(data, \"file.txt\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcat(data, \"file.txt\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_15; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89834"}
{"code": "static void usb_host_realize(USBDevice *udev, Error **errp)\n\n{\n\n    USBHostDevice *s = USB_HOST_DEVICE(udev);\n\n\n\n    if (s->match.vendor_id > 0xffff) {\n\n        error_setg(errp, \"vendorid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.product_id > 0xffff) {\n\n        error_setg(errp, \"productid out of range\");\n\n        return;\n\n    }\n\n    if (s->match.addr > 127) {\n\n        error_setg(errp, \"hostaddr out of range\");\n\n        return;\n\n    }\n\n\n\n    loglevel = s->loglevel;\n\n    udev->flags |= (1 << USB_DEV_FLAG_IS_HOST);\n\n    udev->auto_attach = 0;\n\n    QTAILQ_INIT(&s->requests);\n\n    QTAILQ_INIT(&s->isorings);\n\n\n\n    s->exit.notify = usb_host_exit_notifier;\n\n    qemu_add_exit_notifier(&s->exit);\n\n\n\n    QTAILQ_INSERT_TAIL(&hostdevs, s, next);\n\n    usb_host_auto_check(NULL);\n\n}", "answer": "NO", "cwe": "0", "idx": "e058fa2dd599ccc780d334558be9c1d155222b80"}
{"code": "error(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit_tcpdump(1);\n\t\n}", "answer": "NO", "cwe": "120", "idx": "93185"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_w32spawnl_03()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_console_w32spawnl_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_w32spawnl_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_w32spawnl_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247261"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_03\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_03; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96788"}
{"code": "static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "9f61abc8111c7c43f49ca012e957a108b9cc7610"}
{"code": "void ff_sbrdsp_init_x86(SBRDSPContext *s)\n\n{\n\n    if (HAVE_YASM) {\n\n        int mm_flags = av_get_cpu_flags();\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE) {\n\n            s->sum_square = ff_sbr_sum_square_sse;\n\n            s->hf_g_filt = ff_sbr_hf_g_filt_sse;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_environment_fopen_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_fopen_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96028"}
{"code": "static void nbd_accept(void *opaque)\n\n{\n\n    int server_fd = (uintptr_t) opaque;\n\n    struct sockaddr_in addr;\n\n    socklen_t addr_len = sizeof(addr);\n\n\n\n    int fd = accept(server_fd, (struct sockaddr *)&addr, &addr_len);\n\n    nbd_started = true;\n\n    if (fd >= 0 && nbd_client_new(exp, fd, nbd_client_closed)) {\n\n        nb_fds++;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "7860a380ac2a9fd09a6e8f31fd9db5318fc91285"}
{"code": "static inline void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int i, csize = 1;\n\n    void *src[3];\n\n\n\n    for (i = 1; i < 3; i++)\n\n        if (tile->codsty[0].transform != tile->codsty[i].transform) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Transforms mismatch, MCT not supported\\n\");\n\n            return;\n\n        }\n\n\n\n    for (i = 0; i < 3; i++)\n\n        if (tile->codsty[0].transform == FF_DWT97)\n\n            src[i] = tile->comp[i].f_data;\n\n        else\n\n            src[i] = tile->comp[i].i_data;\n\n\n\n    for (i = 0; i < 2; i++)\n\n        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];\n\n\n\n    s->dsp.mct_decode[tile->codsty[0].transform](src[0], src[1], src[2], csize);\n\n}", "answer": "NO", "cwe": "0", "idx": "12ba1b2b4d5592c0e27b0fcc83db929e8d6a8eee"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_file_ofstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_ofstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96378"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_16()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123102"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define SYSTEM system\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_connect_socket_system_52bSink(char * data);\n\nvoid _OS_Command_Injection__char_connect_socket_system_52()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__char_connect_socket_system_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_connect_socket_system_52bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_connect_socket_system_52bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_connect_socket_system_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_system_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_system_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244173"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <unistd.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint wrongheartedly_babroot = 0;\nint global_variable;\n\nunion theaceae_almadie \n{\n  char *leucoid_haapsalu;\n  double iter_tibiopopliteal;\n  char *traneen_salesin;\n  char bescorch_superman;\n  int polykaryocyte_lionet;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid whelve_totalling(union theaceae_almadie zaboglione_afterstorm);\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        \n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        \n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        \n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\nint isSymLink(char *file) {\n    struct stat statbuf;\n    \n    if (lstat(file, &statbuf) < 0) { \n        printf(\"Error accessing path.\\n\");\n        return 1; \n    }\n    if (S_ISLNK(statbuf.st_mode) == 1) {\n        printf(\"Path is symlink.\\n\");\n        return 1;\n    }\n    printf(\"Path is valid.\\n\");\n    return 0;\n}\nint path_is_not_symlink(char * abs_path) {\n    \n    return (isSymLink(abs_path) == 0);\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  void (*resupination_dermotropic)(union theaceae_almadie ) = whelve_totalling;\n  union theaceae_almadie resthouse_blurrier = {0};\n  int *thebaines_livor = 0;\n  int eleutheri_hoplonemertea;\n  union theaceae_almadie supernormality_overgrazed[10] = {0};\n  union theaceae_almadie neocyte_becomingness;\n  int malacopodous_bunchily = 50;\n  char *sledgemeter_librarian;;\n  if (__sync_bool_compare_and_swap(&wrongheartedly_babroot,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&sledgemeter_librarian,\"4009\",malacopodous_bunchily);\n      if (sledgemeter_librarian != 0) {;\n        neocyte_becomingness . leucoid_haapsalu = sledgemeter_librarian;\n        supernormality_overgrazed[5] = neocyte_becomingness;\n        eleutheri_hoplonemertea = 5;\n        thebaines_livor = &eleutheri_hoplonemertea;\n        resthouse_blurrier =  *(supernormality_overgrazed +  *thebaines_livor);\n        resupination_dermotropic(resthouse_blurrier);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid whelve_totalling(union theaceae_almadie zaboglione_afterstorm)\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *joffre_strapwort = 0;\n  ++global_variable;;\n  joffre_strapwort = ((char *)zaboglione_afterstorm . leucoid_haapsalu);\n    \n    str = malloc(sizeof(char) * (strlen(joffre_strapwort) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(joffre_strapwort) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(joffre_strapwort, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n                if (path_is_not_symlink(abs_path)) {\n                    \n                    \n                    waitForChange(abs_path, sleep_file);\n                    file = fopen(abs_path,\"rb\");\n                    \n                    if (file != 0) {\n                        fseek(file,0,2);\n                        size = ftell(file);\n                        rewind(file);\n                        buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                        if (buffer) {\n                            \n                            \n                            fread(buffer,sizeof(char ),size,file);\n                            buffer[size] = '\\0';\n                            printf(buffer);\n                            fclose(file);\n                            free(buffer);\n                            \n                        }\n                    }\n                }\n                free (abs_path);\n            }\n        }\n        free(str);\n    } else {\n        \n        printf(\"Error parsing input.\\n\");\n    }\n;\n  if (zaboglione_afterstorm . leucoid_haapsalu != 0) \n    free(((char *)zaboglione_afterstorm . leucoid_haapsalu));\nclose_printf_context();\n}", "answer": "YES", "cwe": "363", "idx": "150614"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_42()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic wchar_t * nG2BSource(wchar_t * data)\n{\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_42()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_42();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_42();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123304"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <vector>\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<char *> dataVector);\n\nvoid m()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<char *> dataVector);\n\nstatic void nG2B()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89813"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123193"}
{"code": "void kqemu_set_notdirty(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    LOG_INT(\"kqemu_set_notdirty: addr=%08lx\\n\", \n\n                (unsigned long)ram_addr);\n\n    \n\n    if (phys_ram_dirty[ram_addr >> TARGET_PAGE_BITS] != 0xff)\n\n        return;\n\n    if (nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE)\n\n        nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL;\n\n    else\n\n        ram_pages_to_update[nb_ram_pages_to_update++] = ram_addr;\n\n}", "answer": "NO", "cwe": "0", "idx": "4a1418e07bdcfaa3177739e04707ecaec75d89e1"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_68Data;\nchar * _External_Control_of_System_or_Configuration_Setting__w32_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68bSink();\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_68Data = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_68G2BData = data;\n    _External_Control_of_System_or_Configuration_Setting__w32_68bG2BSink();\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82018"}
{"code": "vrrp_no_accept_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->accept = false;\n}", "answer": "NO", "cwe": "59", "idx": "76018"}
{"code": "static void virtio_9p_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    if (v9fs_device_realize_common(s, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    v->config_size = sizeof(struct virtio_9p_config) + strlen(s->fsconf.tag);\n\n    virtio_init(vdev, \"virtio-9p\", VIRTIO_ID_9P, v->config_size);\n\n    v->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n    v9fs_register_transport(s, &virtio_9p_transport);\n\n\n\nout:\n\n    return;\n\n}", "answer": "NO", "cwe": "0", "idx": "bd3be4dbbf0491d6db8bf326706747b4629ace4b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_environment_ofstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(char * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_ofstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96138"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnv_13()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnv_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnv_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnv_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246279"}
{"code": "static int decode_exponents(AC3DecodeContext *ctx)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i;\n\n    uint8_t *exps;\n\n    uint8_t *dexps;\n\n\n\n    if (ab->flags & AC3_AB_CPLINU && ab->cplexpstr != AC3_EXPSTR_REUSE)\n\n        if (_decode_exponents(ab->cplexpstr, ab->ncplgrps, ab->cplabsexp,\n\n                    ab->cplexps, ab->dcplexps + ab->cplstrtmant))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (ab->chexpstr[i] != AC3_EXPSTR_REUSE) {\n\n            exps = ab->exps[i];\n\n            dexps = ab->dexps[i];\n\n            if (_decode_exponents(ab->chexpstr[i], ab->nchgrps[i], exps[0], exps + 1, dexps + 1))\n\n                return -1;\n\n        }\n\n    if (ctx->bsi.flags & AC3_BSI_LFEON && ab->lfeexpstr != AC3_EXPSTR_REUSE)\n\n        if (_decode_exponents(ab->lfeexpstr, 2, ab->lfeexps[0], ab->lfeexps + 1, ab->dlfeexps))\n\n            return -1;\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "0058584580b87feb47898e60e4b80c7f425882ad"}
{"code": "ReadUserLogStateAccess::ReadUserLogStateAccess(\n\tconst ReadUserLog::FileState &state)\n{\n\tm_state = new ReadUserLogFileState(state);\n}", "answer": "NO", "cwe": "134", "idx": "16636"}
{"code": "set_uid_gid(const char *username, const char *groupname, uid_t *uid_p, gid_t *gid_p, bool default_user)\n{\n\tuid_t uid;\n\tgid_t gid;\n\tstruct passwd pwd;\n\tstruct passwd *pwd_p;\n\tstruct group grp;\n\tstruct group *grp_p;\n\tint ret;\n\tbool using_default_default_user = false;\n\n\tif (!getpwnam_buf_len)\n\t\tset_pwnam_buf_len();\n\n\t{\n\t\tchar buf[getpwnam_buf_len];\n\n\t\tif (default_user && !username) {\n\t\t\tusing_default_default_user = true;\n\t\t\tusername = \"keepalived_script\";\n\t\t}\n\n\t\tif ((ret = getpwnam_r(username, &pwd, buf, sizeof(buf), &pwd_p))) {\n\t\t\tlog_message(LOG_INFO, \"Unable to resolve %sscript username '%s' - ignoring\", default_user ? \"default \" : \"\", username);\n\t\t\treturn true;\n\t\t}\n\t\tif (!pwd_p) {\n\t\t\tif (using_default_default_user)\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - default user '%s' for script execution does not exist - please create.\", username);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"%script user '%s' does not exist\", default_user ? \"Default s\" : \"S\", username);\n\t\t\treturn true;\n\t\t}\n\n\t\tuid = pwd.pw_uid;\n\t\tgid = pwd.pw_gid;\n\n\t\tif (groupname) {\n\t\t\tif ((ret = getgrnam_r(groupname, &grp, buf, sizeof(buf), &grp_p))) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to resolve %sscript group name '%s' - ignoring\", default_user ? \"default \" : \"\", groupname);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!grp_p) {\n\t\t\t\tlog_message(LOG_INFO, \"%script group '%s' does not exist\", default_user ? \"Default s\" : \"S\", groupname);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tgid = grp.gr_gid;\n\t\t}\n\n\t\t*uid_p = uid;\n\t\t*gid_p = gid;\n\t}\n\n\treturn false;\n}", "answer": "NO", "cwe": "59", "idx": "76140"}
{"code": "copy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister u_int len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == NULL)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}", "answer": "NO", "cwe": "120", "idx": "93181"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_42\n{\n\n#ifndef OMITM\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic wchar_t * nG2BSource(wchar_t * data)\n{\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_42; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96763"}
{"code": "static int cgroup_read_from_file(const char *fn, char buf[], size_t bufsize)\n{\n\tint ret = lxc_read_from_file(fn, buf, bufsize);\n\tif (ret < 0) {\n\t\tSYSERROR(\"failed to read %s\", fn);\n\t\treturn ret;\n\t}\n\tif (ret == bufsize) {\n\t\tif (bufsize > 0) {\n\t\t\t\n\t\t\tbuf[bufsize-1] = '\\0';\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tERROR(\"%s: was not expecting 0 bufsize\", __func__);\n\t\treturn -1;\n\t}\n\tbuf[ret] = '\\0';\n\treturn ret;\n}", "answer": "NO", "cwe": "59", "idx": "44465"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_listen_socket_open_54\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_open_54; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90716"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\nnamespace _Relative_Path_Traversal__char_listen_socket_w32CreateFile_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_w32CreateFile_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90741"}
{"code": "int hw_device_setup_for_encode(OutputStream *ost)\n\n{\n\n    enum AVHWDeviceType type;\n\n    HWDevice *dev;\n\n\n\n    type = hw_device_match_type_in_name(ost->enc->name);\n\n    if (type != AV_HWDEVICE_TYPE_NONE) {\n\n        dev = hw_device_get_by_type(type);\n\n        if (!dev) {\n\n            av_log(ost->enc_ctx, AV_LOG_WARNING, \"No device available \"\n\n                   \"for encoder (device type %s for codec %s).\\n\",\n\n                   av_hwdevice_get_type_name(type), ost->enc->name);\n\n            return 0;\n\n        }\n\n        ost->enc_ctx->hw_device_ctx = av_buffer_ref(dev->device_ref);\n\n        if (!ost->enc_ctx->hw_device_ctx)\n\n            return AVERROR(ENOMEM);\n\n        return 0;\n\n    } else {\n\n        \n\n        return 0;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "b0cd14fb1dab4b044f7fe6b53ac635409849de77"}
{"code": "ZEND_API int zend_delete_global_variable(zend_string *name) \n{\n    return zend_hash_del_ind(&EG(symbol_table), name);\n}\n", "answer": "NO", "cwe": "134", "idx": "57317"}
{"code": "type_init(pflash_cfi02_register_types)\n\n\n\npflash_t *pflash_cfi02_register(hwaddr base,\n\n                                DeviceState *qdev, const char *name,\n\n                                hwaddr size,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1,\n\n                                int be)\n\n{\n\n    DeviceState *dev = qdev_create(NULL, TYPE_CFI_PFLASH02);\n\n\n\n    if (bs && qdev_prop_set_drive(dev, \"drive\", bs)) {\n\n        abort();\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-blocks\", nb_blocs);\n\n    qdev_prop_set_uint32(dev, \"sector-length\", sector_len);\n\n    qdev_prop_set_uint8(dev, \"width\", width);\n\n    qdev_prop_set_uint8(dev, \"mappings\", nb_mappings);\n\n    qdev_prop_set_uint8(dev, \"big-endian\", !!be);\n\n    qdev_prop_set_uint16(dev, \"id0\", id0);\n\n    qdev_prop_set_uint16(dev, \"id1\", id1);\n\n    qdev_prop_set_uint16(dev, \"id2\", id2);\n\n    qdev_prop_set_uint16(dev, \"id3\", id3);\n\n    qdev_prop_set_uint16(dev, \"unlock-addr0\", unlock_addr0);\n\n    qdev_prop_set_uint16(dev, \"unlock-addr1\", unlock_addr1);\n\n    qdev_prop_set_string(dev, \"name\", name);\n\n    qdev_init_nofail(dev);\n\n\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, base);\n\n    return CFI_PFLASH02(dev);\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce)\n\n{\n\n    TemporalNoiseShaping *tns = &sce->tns;\n\n    int w, g, order, sfb_start, sfb_len, coef_start, shift[MAX_LPC_ORDER], count = 0;\n\n    const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;\n\n    const int tns_max_order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;\n\n    const float freq_mult = mpeg4audio_sample_rates[s->samplerate_index]/(1024.0f/sce->ics.num_windows)/2.0f;\n\n    float max_coef = 0.0f;\n\n\n\n    sce->tns.present = 0;\n\n    return;\n\n\n\n    for (coef_start = 0; coef_start < 1024; coef_start++)\n\n        max_coef = FFMAX(max_coef, sce->pcoeffs[coef_start]);\n\n\n\n    for (w = 0; w < sce->ics.num_windows; w++) {\n\n        int filters = 1, start = 0, coef_len = 0;\n\n        int32_t conv_coeff[1024] = {0};\n\n        int32_t coefs_t[MAX_LPC_ORDER][MAX_LPC_ORDER] = {{0}};\n\n\n\n        \n\n        for (g = 0;  g < sce->ics.num_swb; g++) {\n\n            if (start*freq_mult > TNS_LOW_LIMIT) {\n\n                sfb_start = w*16+g;\n\n                sfb_len   = (w+1)*16 + g - sfb_start;\n\n                coef_start = sce->ics.swb_offset[sfb_start];\n\n                coef_len  = sce->ics.swb_offset[sfb_start + sfb_len] - coef_start;\n\n                break;\n\n            }\n\n            start += sce->ics.swb_sizes[g];\n\n        }\n\n\n\n        if (coef_len <= 0)\n\n            continue;\n\n\n\n        conv_to_int32(conv_coeff, &sce->pcoeffs[coef_start], coef_len, max_coef);\n\n\n\n        \n\n        order = ff_lpc_calc_coefs(&s->lpc, conv_coeff, coef_len,\n\n                                  TNS_MIN_PRED_ORDER, tns_max_order,\n\n                                  32, coefs_t, shift,\n\n                                  FF_LPC_TYPE_LEVINSON, 10,\n\n                                  ORDER_METHOD_EST, MAX_LPC_SHIFT, 0) - 1;\n\n\n\n        \n\n        if (shift[order] > 3) {\n\n            int direction = 0;\n\n            float tns_coefs_raw[TNS_MAX_ORDER];\n\n            tns->n_filt[w] = filters++;\n\n            conv_to_float(tns_coefs_raw, coefs_t[order], order);\n\n            for (g = 0; g < tns->n_filt[w]; g++) {\n\n                process_tns_coeffs(tns, tns_coefs_raw, order, w, g);\n\n                apply_tns_filter(&sce->coeffs[coef_start], sce->pcoeffs, order, direction, tns->coef[w][g],\n\n                                 sce->ics.ltp.present, w, g, coef_start, coef_len);\n\n                tns->order[w][g]     = order;\n\n                tns->length[w][g]    = sfb_len;\n\n                tns->direction[w][g] = direction;\n\n            }\n\n            count++;\n\n        }\n\n    }\n\n\n\n    sce->tns.present = !!count;\n\n}", "answer": "NO", "cwe": "0", "idx": "f20b67173ca6a05b8c3dee02dad3b7243b96292b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_ofstream_54\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_ofstream_54; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91388"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifdef _WIN32\n#define POPEN _popen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_connect_socket_popen_09()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_connect_socket_popen_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_popen_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_popen_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244107"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _LDAP_Injection__w32_wchar_t_listen_socket_34_unionType;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_34()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123302"}
{"code": "static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "5d5de3eba4c7890c2e8077f5b4ae569671d11cf8"}
{"code": "static int vcr1_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    VCR1Context *const a      = avctx->priv_data;\n\n    AVFrame *const p          = data;\n\n    const uint8_t *bytestream = avpkt->data;\n\n    const uint8_t *bytestream_end = bytestream + avpkt->size;\n\n    int i, x, y, ret;\n\n\n\n    if(avpkt->size < 16 + avctx->height + avctx->width*avctx->height*5/8){\n\n        av_log(avctx, AV_LOG_ERROR, \"Insufficient input data.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n\n        return ret;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    p->key_frame = 1;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        a->delta[i] = *bytestream++;\n\n        bytestream++;\n\n    }\n\n\n\n    for (y = 0; y < avctx->height; y++) {\n\n        int offset;\n\n        uint8_t *luma = &p->data[0][y * p->linesize[0]];\n\n\n\n        if ((y & 3) == 0) {\n\n            uint8_t *cb = &p->data[1][(y >> 2) * p->linesize[1]];\n\n            uint8_t *cr = &p->data[2][(y >> 2) * p->linesize[2]];\n\n\n\n            av_assert0 (bytestream_end - bytestream >= 4 + avctx->width);\n\n\n\n            for (i = 0; i < 4; i++)\n\n                a->offset[i] = *bytestream++;\n\n\n\n            offset = a->offset[0] - a->delta[bytestream[2] & 0xF];\n\n            for (x = 0; x < avctx->width; x += 4) {\n\n                luma[0]     = offset += a->delta[bytestream[2] & 0xF];\n\n                luma[1]     = offset += a->delta[bytestream[2] >>  4];\n\n                luma[2]     = offset += a->delta[bytestream[0] & 0xF];\n\n                luma[3]     = offset += a->delta[bytestream[0] >>  4];\n\n                luma       += 4;\n\n\n\n                *cb++       = bytestream[3];\n\n                *cr++       = bytestream[1];\n\n\n\n                bytestream += 4;\n\n            }\n\n        } else {\n\n            av_assert0 (bytestream_end - bytestream >= avctx->width / 2);\n\n\n\n            offset = a->offset[y & 3] - a->delta[bytestream[2] & 0xF];\n\n\n\n            for (x = 0; x < avctx->width; x += 8) {\n\n                luma[0]     = offset += a->delta[bytestream[2] & 0xF];\n\n                luma[1]     = offset += a->delta[bytestream[2] >>  4];\n\n                luma[2]     = offset += a->delta[bytestream[3] & 0xF];\n\n                luma[3]     = offset += a->delta[bytestream[3] >>  4];\n\n                luma[4]     = offset += a->delta[bytestream[0] & 0xF];\n\n                luma[5]     = offset += a->delta[bytestream[0] >>  4];\n\n                luma[6]     = offset += a->delta[bytestream[1] & 0xF];\n\n                luma[7]     = offset += a->delta[bytestream[1] >>  4];\n\n                luma       += 8;\n\n                bytestream += 4;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return bytestream - avpkt->data;\n\n}", "answer": "NO", "cwe": "0", "idx": "77ef538818678fd8bcdf37b77923d52543b750f0"}
{"code": "param_without_default( const char *name )\n{\n\tchar\t\t*val = NULL;\n\tchar param_name[MAX_PARAM_LEN];\n\n\n\tconst char\t*local = get_mySubSystem()->getLocalName();\n\tif (  (NULL == val) && local ) {\n\t\tsnprintf(param_name,MAX_PARAM_LEN,\"%s.%s.%s\",\n\t\t\t\t get_mySubSystem()->getName(),\n\t\t\t\t local,\n\t\t\t\t name);\n\t\tparam_name[MAX_PARAM_LEN-1]='\\0';\n\t\tstrlwr(param_name);\n\t\tval = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );\n\t}\n\tif (  (NULL == val) && local ) {\n\t\tsnprintf(param_name,MAX_PARAM_LEN,\"%s.%s\",\n\t\t\t\t local,\n\t\t\t\t name);\n\t\tparam_name[MAX_PARAM_LEN-1]='\\0';\n\t\tstrlwr(param_name);\n\t\tval = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );\n\t}\n\tif ( NULL == val ) {\n\t\tsnprintf(param_name,MAX_PARAM_LEN,\"%s.%s\",\n\t\t\t\t get_mySubSystem()->getName(),\n\t\t\t\t name);\n\t\tparam_name[MAX_PARAM_LEN-1]='\\0';\n\t\tstrlwr(param_name);\n\t\tval = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );\n\t}\n\tif ( NULL == val ) {\n\t\tsnprintf(param_name,MAX_PARAM_LEN,\"%s\",name);\n\t\tparam_name[MAX_PARAM_LEN-1]='\\0';\n\t\tstrlwr(param_name);\n\t\tval = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );\n\t}\n\n\tif ( (NULL == val) || (*val=='\\0') ) {\n\t\treturn NULL;\n\t}\n\n\tif( DebugFlags & D_CONFIG ) {\n\t\tif( strlen(name) < strlen(param_name) ) {\n\t\t\tparam_name[strlen(param_name)-strlen(name)] = '\\0';\n\t\t\tdprintf( D_CONFIG, \"Config '%s': using prefix '%s' ==> '%s'\\n\",\n\t\t\t\t\t name, param_name, val );\n\t\t}\n\t\telse {\n\t\t\tdprintf( D_CONFIG, \"Config '%s': no prefix ==> '%s'\\n\", name, val );\n\t\t}\n\t}\n\n\tval = expand_macro( val, ConfigTab, TABLESIZE );\n\n\tif( val == NULL ) {\n\t\treturn NULL;\n\t} else if ( val[0] == '\\0' ) {\n\t\tfree( val );\n\t\treturn( NULL );\n\t} else {\n\t\treturn val;\n\t}\n}", "answer": "NO", "cwe": "134", "idx": "16520"}
{"code": "static int draw_text(AVFilterContext *ctx, AVFrame *frame,\n\n                     int width, int height)\n\n{\n\n    DrawTextContext *s = ctx->priv;\n\n    AVFilterLink *inlink = ctx->inputs[0];\n\n\n\n    uint32_t code = 0, prev_code = 0;\n\n    int x = 0, y = 0, i = 0, ret;\n\n    int max_text_line_w = 0, len;\n\n    int box_w, box_h;\n\n    char *text;\n\n    uint8_t *p;\n\n    int y_min = 32000, y_max = -32000;\n\n    int x_min = 32000, x_max = -32000;\n\n    FT_Vector delta;\n\n    Glyph *glyph = NULL, *prev_glyph = NULL;\n\n    Glyph dummy = { 0 };\n\n\n\n    time_t now = time(0);\n\n    struct tm ltime;\n\n    AVBPrint *bp = &s->expanded_text;\n\n\n\n    FFDrawColor fontcolor;\n\n    FFDrawColor shadowcolor;\n\n    FFDrawColor bordercolor;\n\n    FFDrawColor boxcolor;\n\n\n\n    av_bprint_clear(bp);\n\n\n\n    if(s->basetime != AV_NOPTS_VALUE)\n\n        now= frame->pts*av_q2d(ctx->inputs[0]->time_base) + s->basetime/1000000;\n\n\n\n    switch (s->exp_mode) {\n\n    case EXP_NONE:\n\n        av_bprintf(bp, \"%s\", s->text);\n\n        break;\n\n    case EXP_NORMAL:\n\n        if ((ret = expand_text(ctx, s->text, &s->expanded_text)) < 0)\n\n            return ret;\n\n        break;\n\n    case EXP_STRFTIME:\n\n        localtime_r(&now, &ltime);\n\n        av_bprint_strftime(bp, s->text, &ltime);\n\n        break;\n\n    }\n\n\n\n    if (s->tc_opt_string) {\n\n        char tcbuf[AV_TIMECODE_STR_SIZE];\n\n        av_timecode_make_string(&s->tc, tcbuf, inlink->frame_count);\n\n        av_bprint_clear(bp);\n\n        av_bprintf(bp, \"%s%s\", s->text, tcbuf);\n\n    }\n\n\n\n    if (!av_bprint_is_complete(bp))\n\n        return AVERROR(ENOMEM);\n\n    text = s->expanded_text.str;\n\n    if ((len = s->expanded_text.len) > s->nb_positions) {\n\n        if (!(s->positions =\n\n              av_realloc(s->positions, len*sizeof(*s->positions))))\n\n            return AVERROR(ENOMEM);\n\n        s->nb_positions = len;\n\n    }\n\n\n\n    if (s->fontcolor_expr[0]) {\n\n        \n\n        av_bprint_clear(&s->expanded_fontcolor);\n\n        if ((ret = expand_text(ctx, s->fontcolor_expr, &s->expanded_fontcolor)) < 0)\n\n            return ret;\n\n        if (!av_bprint_is_complete(&s->expanded_fontcolor))\n\n            return AVERROR(ENOMEM);\n\n        av_log(s, AV_LOG_DEBUG, \"Evaluated fontcolor is '%s'\\n\", s->expanded_fontcolor.str);\n\n        ret = av_parse_color(s->fontcolor.rgba, s->expanded_fontcolor.str, -1, s);\n\n        if (ret)\n\n            return ret;\n\n        ff_draw_color(&s->dc, &s->fontcolor, s->fontcolor.rgba);\n\n    }\n\n\n\n    x = 0;\n\n    y = 0;\n\n\n\n    \n\n    for (i = 0, p = text; *p; i++) {\n\n        GET_UTF8(code, *p++, continue;);\n\n\n\n        \n\n        dummy.code = code;\n\n        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);\n\n        if (!glyph) {\n\n            load_glyph(ctx, &glyph, code);\n\n        }\n\n\n\n        y_min = FFMIN(glyph->bbox.yMin, y_min);\n\n        y_max = FFMAX(glyph->bbox.yMax, y_max);\n\n        x_min = FFMIN(glyph->bbox.xMin, x_min);\n\n        x_max = FFMAX(glyph->bbox.xMax, x_max);\n\n    }\n\n    s->max_glyph_h = y_max - y_min;\n\n    s->max_glyph_w = x_max - x_min;\n\n\n\n    \n\n    glyph = NULL;\n\n    for (i = 0, p = text; *p; i++) {\n\n        GET_UTF8(code, *p++, continue;);\n\n\n\n        \n\n        if (prev_code == '\\r' && code == '\\n')\n\n            continue;\n\n\n\n        prev_code = code;\n\n        if (is_newline(code)) {\n\n\n\n            max_text_line_w = FFMAX(max_text_line_w, x);\n\n            y += s->max_glyph_h;\n\n            x = 0;\n\n            continue;\n\n        }\n\n\n\n        \n\n        prev_glyph = glyph;\n\n        dummy.code = code;\n\n        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);\n\n\n\n        \n\n        if (s->use_kerning && prev_glyph && glyph->code) {\n\n            FT_Get_Kerning(s->face, prev_glyph->code, glyph->code,\n\n                           ft_kerning_default, &delta);\n\n            x += delta.x >> 6;\n\n        }\n\n\n\n        \n\n        s->positions[i].x = x + glyph->bitmap_left;\n\n        s->positions[i].y = y - glyph->bitmap_top + y_max;\n\n        if (code == '\\t') x  = (x / s->tabsize + 1)*s->tabsize;\n\n        else              x += glyph->advance;\n\n    }\n\n\n\n    max_text_line_w = FFMAX(x, max_text_line_w);\n\n\n\n    s->var_values[VAR_TW] = s->var_values[VAR_TEXT_W] = max_text_line_w;\n\n    s->var_values[VAR_TH] = s->var_values[VAR_TEXT_H] = y + s->max_glyph_h;\n\n\n\n    s->var_values[VAR_MAX_GLYPH_W] = s->max_glyph_w;\n\n    s->var_values[VAR_MAX_GLYPH_H] = s->max_glyph_h;\n\n    s->var_values[VAR_MAX_GLYPH_A] = s->var_values[VAR_ASCENT ] = y_max;\n\n    s->var_values[VAR_MAX_GLYPH_D] = s->var_values[VAR_DESCENT] = y_min;\n\n\n\n    s->var_values[VAR_LINE_H] = s->var_values[VAR_LH] = s->max_glyph_h;\n\n\n\n    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);\n\n    s->y = s->var_values[VAR_Y] = av_expr_eval(s->y_pexpr, s->var_values, &s->prng);\n\n    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);\n\n\n\n    update_alpha(s);\n\n    update_color_with_alpha(s, &fontcolor  , s->fontcolor  );\n\n    update_color_with_alpha(s, &shadowcolor, s->shadowcolor);\n\n    update_color_with_alpha(s, &bordercolor, s->bordercolor);\n\n    update_color_with_alpha(s, &boxcolor   , s->boxcolor   );\n\n\n\n    box_w = FFMIN(width - 1 , max_text_line_w);\n\n    box_h = FFMIN(height - 1, y + s->max_glyph_h);\n\n\n\n    \n\n    if (s->draw_box)\n\n        ff_blend_rectangle(&s->dc, &boxcolor,\n\n                           frame->data, frame->linesize, width, height,\n\n                           s->x - s->boxborderw, s->y - s->boxborderw,\n\n                           box_w + s->boxborderw * 2, box_h + s->boxborderw * 2);\n\n\n\n    if (s->shadowx || s->shadowy) {\n\n        if ((ret = draw_glyphs(s, frame, width, height,\n\n                               &shadowcolor, s->shadowx, s->shadowy, 0)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if (s->borderw) {\n\n        if ((ret = draw_glyphs(s, frame, width, height,\n\n                               &bordercolor, 0, 0, s->borderw)) < 0)\n\n            return ret;\n\n    }\n\n    if ((ret = draw_glyphs(s, frame, width, height,\n\n                           &fontcolor, 0, 0, 0)) < 0)\n\n        return ret;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "2e67a99fbc6b99315925de40fc6fa7161576be10"}
{"code": "install_keyword_root(const char *string, void (*handler) (vector_t *), bool active)\n{\n\t\n\tkeyword_alloc(keywords, string, handler, active);\n}", "answer": "NO", "cwe": "59", "idx": "76165"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90958"}
{"code": "static int expand_rle_row16(SgiState *s, uint16_t *out_buf,\n\n                            int len, int pixelstride)\n\n{\n\n    unsigned short pixel;\n\n    unsigned char count;\n\n    unsigned short *orig = out_buf;\n\n    uint16_t *out_end = out_buf + len;\n\n\n\n    while (out_buf < out_end) {\n\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n\n            return AVERROR_INVALIDDATA;\n\n        pixel = bytestream2_get_be16u(&s->g);\n\n        if (!(count = (pixel & 0x7f)))\n\n            break;\n\n\n\n        \n\n        if (pixelstride * (count - 1) >= len) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid pixel count.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (pixel & 0x80) {\n\n            while (count--) {\n\n                pixel = bytestream2_get_ne16(&s->g);\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        } else {\n\n            pixel = bytestream2_get_ne16(&s->g);\n\n\n\n            while (count--) {\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        }\n\n    }\n\n    return (out_buf - orig) / pixelstride;\n\n}", "answer": "NO", "cwe": "0", "idx": "a050cf0c451bdf1c1bd512c4fce6b6f8a5e85102"}
{"code": "static void dv_decode_ac(DVVideoDecodeContext *s, \n\n                         BlockInfo *mb, DCTELEM *block, int last_index)\n\n{\n\n    int last_re_index;\n\n    int shift_offset = mb->shift_offset;\n\n    const UINT8 *scan_table = mb->scan_table;\n\n    const UINT8 *shift_table = mb->shift_table;\n\n    int pos = mb->pos;\n\n    int level, pos1, sign, run;\n\n    int partial_bit_count;\n\n\n\n    OPEN_READER(re, &s->gb);\n\n    \n\n#ifdef VLC_DEBUG\n\n    printf(\"start\\n\");\n\n#endif\n\n\n\n    \n\n    partial_bit_count = mb->partial_bit_count;\n\n    if (partial_bit_count > 0) {\n\n        UINT8 buf[4];\n\n        UINT32 v;\n\n        int l, l1;\n\n        GetBitContext gb1;\n\n\n\n        \n\n        l = 16 - partial_bit_count;\n\n        UPDATE_CACHE(re, &s->gb);\n\n#ifdef VLC_DEBUG\n\n        printf(\"show=%04x\\n\", SHOW_UBITS(re, &s->gb, 16));\n\n#endif\n\n        v = (mb->partial_bit_buffer << l) | SHOW_UBITS(re, &s->gb, l);\n\n        buf[0] = v >> 8;\n\n        buf[1] = v;\n\n#ifdef VLC_DEBUG\n\n        printf(\"v=%04x cnt=%d %04x\\n\", \n\n               v, partial_bit_count, (mb->partial_bit_buffer << l));\n\n#endif\n\n        \n\n        init_get_bits(&gb1, buf, 4);\n\n        {\n\n            OPEN_READER(re1, &gb1);\n\n            UPDATE_CACHE(re1, &gb1);\n\n            GET_RL_VLC(level, run, re1, &gb1, dv_rl_vlc[0], \n\n                       TEX_VLC_BITS, 2);\n\n            l = re1_index;\n\n            CLOSE_READER(re1, &gb1);\n\n        }\n\n#ifdef VLC_DEBUG\n\n        printf(\"****run=%d level=%d size=%d\\n\", run, level, l);\n\n#endif\n\n        \n\n        l1 = (level != 256 && level != 0);\n\n        \n\n        l -= partial_bit_count;\n\n        if ((re_index + l + l1) > last_index)\n\n            return;\n\n        \n\n        last_re_index = 0; \n\n        re_index += l;\n\n        \n\n        mb->partial_bit_count = 0;\n\n        UPDATE_CACHE(re, &s->gb);\n\n        goto handle_vlc;\n\n    }\n\n\n\n    \n\n    for(;;) {\n\n        UPDATE_CACHE(re, &s->gb);\n\n#ifdef VLC_DEBUG\n\n        printf(\"%2d: bits=%04x index=%d\\n\", \n\n               pos, SHOW_UBITS(re, &s->gb, 16), re_index);\n\n#endif\n\n        last_re_index = re_index;\n\n        GET_RL_VLC(level, run, re, &s->gb, dv_rl_vlc[0], \n\n                   TEX_VLC_BITS, 2);\n\n    handle_vlc:\n\n#ifdef VLC_DEBUG\n\n        printf(\"run=%d level=%d\\n\", run, level);\n\n#endif\n\n        if (level == 256) {\n\n            if (re_index > last_index) {\n\n            cannot_read:\n\n                \n\n                re_index = last_re_index;\n\n                mb->eob_reached = 0;\n\n                break;\n\n            }\n\n            \n\n            mb->eob_reached = 1;\n\n            break;\n\n        } else if (level != 0) {\n\n            if ((re_index + 1) > last_index)\n\n                goto cannot_read;\n\n            sign = SHOW_SBITS(re, &s->gb, 1);\n\n            level = (level ^ sign) - sign;\n\n            LAST_SKIP_BITS(re, &s->gb, 1);\n\n            pos += run;\n\n            \n\n            if (pos >= 64) {\n\n                goto read_error;\n\n            }\n\n            pos1 = scan_table[pos];\n\n            level = level << (shift_table[pos1] + shift_offset);\n\n            block[pos1] = level;\n\n            \n\n        } else {\n\n            if (re_index > last_index)\n\n                goto cannot_read;\n\n            \n\n            pos += run;\n\n            \n\n            if (pos >= 64) {\n\n            read_error:\n\n#if defined(VLC_DEBUG) || 1\n\n                printf(\"error pos=%d\\n\", pos);\n\n#endif\n\n                \n\n                mb->eob_reached = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n    mb->pos = pos;\n\n}", "answer": "NO", "cwe": "0", "idx": "68f593b48433842f3407586679fe07f3e5199ab9"}
{"code": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}", "answer": "NO", "cwe": "0", "idx": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4"}
{"code": "int ff_h2645_extract_rbsp(const uint8_t *src, int length,\n\n                          H2645NAL *nal)\n\n{\n\n    int i, si, di;\n\n    uint8_t *dst;\n\n\n\n    nal->skipped_bytes = 0;\n\n#define STARTCODE_TEST                                                  \\\n\n        if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \\\n\n            if (src[i + 2] != 3 && src[i + 2] != 0) {                   \\\n\n                             \\\n\n                length = i;                                             \\\n\n            }                                                           \\\n\n            break;                                                      \\\n\n        }\n\n#if HAVE_FAST_UNALIGNED\n\n#define FIND_FIRST_ZERO                                                 \\\n\n        if (i > 0 && !src[i])                                           \\\n\n            i--;                                                        \\\n\n        while (src[i])                                                  \\\n\n            i++\n\n#if HAVE_FAST_64BIT\n\n    for (i = 0; i + 1 < length; i += 9) {\n\n        if (!((~AV_RN64A(src + i) &\n\n               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &\n\n              0x8000800080008080ULL))\n\n            continue;\n\n        FIND_FIRST_ZERO;\n\n        STARTCODE_TEST;\n\n        i -= 7;\n\n    }\n\n#else\n\n    for (i = 0; i + 1 < length; i += 5) {\n\n        if (!((~AV_RN32A(src + i) &\n\n               (AV_RN32A(src + i) - 0x01000101U)) &\n\n              0x80008080U))\n\n            continue;\n\n        FIND_FIRST_ZERO;\n\n        STARTCODE_TEST;\n\n        i -= 3;\n\n    }\n\n#endif \n\n#else\n\n    for (i = 0; i + 1 < length; i += 2) {\n\n        if (src[i])\n\n            continue;\n\n        if (i > 0 && src[i - 1] == 0)\n\n            i--;\n\n        STARTCODE_TEST;\n\n    }\n\n#endif \n\n\n\n    if (i >= length - 1) { \n\n        nal->data     =\n\n        nal->raw_data = src;\n\n        nal->size     =\n\n        nal->raw_size = length;\n\n        return length;\n\n    }\n\n\n\n    av_fast_malloc(&nal->rbsp_buffer, &nal->rbsp_buffer_size,\n\n                   length + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!nal->rbsp_buffer)\n\n        return AVERROR(ENOMEM);\n\n\n\n    dst = nal->rbsp_buffer;\n\n\n\n    memcpy(dst, src, i);\n\n    si = di = i;\n\n    while (si + 2 < length) {\n\n        \n\n        if (src[si + 2] > 3) {\n\n            dst[di++] = src[si++];\n\n            dst[di++] = src[si++];\n\n        } else if (src[si] == 0 && src[si + 1] == 0 && src[si + 2] != 0) {\n\n            if (src[si + 2] == 3) { \n\n                dst[di++] = 0;\n\n                dst[di++] = 0;\n\n                si       += 3;\n\n\n\n                if (nal->skipped_bytes_pos) {\n\n                    nal->skipped_bytes++;\n\n                    if (nal->skipped_bytes_pos_size < nal->skipped_bytes) {\n\n                        nal->skipped_bytes_pos_size *= 2;\n\n                        av_assert0(nal->skipped_bytes_pos_size >= nal->skipped_bytes);\n\n                        av_reallocp_array(&nal->skipped_bytes_pos,\n\n                                nal->skipped_bytes_pos_size,\n\n                                sizeof(*nal->skipped_bytes_pos));\n\n                        if (!nal->skipped_bytes_pos) {\n\n                            nal->skipped_bytes_pos_size = 0;\n\n                            return AVERROR(ENOMEM);\n\n                        }\n\n                    }\n\n                    if (nal->skipped_bytes_pos)\n\n                        nal->skipped_bytes_pos[nal->skipped_bytes-1] = di - 1;\n\n                }\n\n                continue;\n\n            } else \n\n                goto nsc;\n\n        }\n\n\n\n        dst[di++] = src[si++];\n\n    }\n\n    while (si < length)\n\n        dst[di++] = src[si++];\n\n\n\nnsc:\n\n    memset(dst + di, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    nal->data = dst;\n\n    nal->size = di;\n\n    nal->raw_data = src;\n\n    nal->raw_size = si;\n\n    return si;\n\n}", "answer": "NO", "cwe": "0", "idx": "cc13bc8c4f0f4afa30d0b94c3f3a369ccd2aaf0b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    wcscat(data, L\"*.*\");\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_environment_w32_spawnvp_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247700"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\ntypedef struct __OS_Command_Injection__char_connect_socket_execlp_67_structType\n{\n    char * structFirst;\n} _OS_Command_Injection__char_connect_socket_execlp_67_structType;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67bSink(_OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct);\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67()\n{\n    char * data;\n    _OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    _OS_Command_Injection__char_connect_socket_execlp_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67bG2BSink(_OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct);\n\nstatic void nG2B()\n{\n    char * data;\n    _OS_Command_Injection__char_connect_socket_execlp_67_structType myStruct;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    myStruct.structFirst = data;\n    _OS_Command_Injection__char_connect_socket_execlp_67bG2BSink(myStruct);\n}\n\nvoid _OS_Command_Injection__char_connect_socket_execlp_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_execlp_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_execlp_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244090"}
{"code": "void ClipboardMessageFilter::OnReadImage(\n    ui::Clipboard::Buffer buffer, IPC::Message* reply_msg) {\n  SkBitmap bitmap = GetClipboard()->ReadImage(buffer);\n\n#if defined(USE_X11)\n  BrowserThread::PostTask(\n      BrowserThread::FILE, FROM_HERE,\n      NewRunnableMethod(\n          this, &ClipboardMessageFilter::OnReadImageReply, bitmap, reply_msg));\n#else\n  OnReadImageReply(bitmap, reply_msg);\n#endif\n }", "answer": "NO", "cwe": "119", "idx": "103329"}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumSamples(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_samples(file->mod);\n}", "answer": "NO", "cwe": "120", "idx": "87644"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    if(mStatic)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    return data;\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32spawnl_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic wchar_t * nG2B1Source(wchar_t * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic wchar_t * nG2B2Source(wchar_t * data)\n{\n    if(nG2B2Static)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32spawnl_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32spawnl_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32spawnl_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248501"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_environment_w32CreateFile_83\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_environment_w32CreateFile_83\n{\npublic:\n    _Relative_Path_Traversal__char_environment_w32CreateFile_83(char * dataCopy);\n    ~_Relative_Path_Traversal__char_environment_w32CreateFile_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_environment_w32CreateFile_83G2B\n{\npublic:\n    _Relative_Path_Traversal__char_environment_w32CreateFile_83G2B(char * dataCopy);\n    ~_Relative_Path_Traversal__char_environment_w32CreateFile_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "23", "idx": "90298"}
{"code": "static void *vring_map(MemoryRegion **mr, hwaddr phys, hwaddr len,\n\n                       bool is_write)\n\n{\n\n    MemoryRegionSection section = memory_region_find(get_system_memory(), phys, len);\n\n\n\n    if (!section.mr || int128_get64(section.size) < len) {\n\n        goto out;\n\n    }\n\n    if (is_write && section.readonly) {\n\n        goto out;\n\n    }\n\n    if (!memory_region_is_ram(section.mr)) {\n\n        goto out;\n\n    }\n\n\n\n    \n\n    if (memory_region_is_logging(section.mr)) {\n\n        goto out;\n\n    }\n\n\n\n    *mr = section.mr;\n\n    return memory_region_get_ram_ptr(section.mr) + section.offset_within_region;\n\n\n\nout:\n\n    memory_region_unref(section.mr);\n\n    *mr = NULL;\n\n    return NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "2d1a35bef0ed96b3f23535e459c552414ccdbafd"}
{"code": "static struct dentry *f2fs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    f2fs_nfs_get_inode);\n}", "answer": "NO", "cwe": "129", "idx": "63862"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_popen_22Global = 0;\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_popen_22Source(wchar_t * data);\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_22()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_popen_22Source(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Global = 0;\nint _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Global = 0;\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Global = 0; \n    data = _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B1Source(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_popen_22G2B2Source(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246478"}
{"code": "  mojo::PendingRemote<mojom::InputChannel> CreatePendingRemote() {\n    return receiver_.BindNewPipeAndPassRemote();\n   }", "answer": "NO", "cwe": "125", "idx": "150255"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nwchar_t * _Absolute_Path_Traversal__wchar_t_console_fopen_68Data;\nwchar_t * _Absolute_Path_Traversal__wchar_t_console_fopen_68G2BData;\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_68\n{\n\n#ifndef OMITM\n\n\nvoid mSink();\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    _Absolute_Path_Traversal__wchar_t_console_fopen_68Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink();\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    _Absolute_Path_Traversal__wchar_t_console_fopen_68G2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_68; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97018"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97011"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic char * mSource(char * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _LDAP_Injection__w32_char_file_21()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic char * nG2B1Source(char * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic char * nG2B2Source(char * data)\n{\n    if(nG2B2Static)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123009"}
{"code": "static loff_t max_file_blocks(void)\n{\n\tloff_t result = (DEF_ADDRS_PER_INODE - F2FS_INLINE_XATTR_ADDRS);\n\tloff_t leaf_count = ADDRS_PER_BLOCK;\n\n\t\n\tresult += (leaf_count * 2);\n\n\t\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += (leaf_count * 2);\n\n\t\n\tleaf_count *= NIDS_PER_BLOCK;\n\tresult += leaf_count;\n\n\treturn result;\n}", "answer": "NO", "cwe": "129", "idx": "63893"}
{"code": "void nonono(const char* file, int line, const char* msg) {\n\n    fprintf(stderr, \"Nonono! %s:%d %s\\n\", file, line, msg);\n\n    exit(-5);\n\n}", "answer": "NO", "cwe": "0", "idx": "7a6ab45e19b615b9285b9cfa2bbc1fee012bc8d7"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_14()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81991"}
{"code": "static void intra_predict_mad_cow_dc_l0t_8x8_msa(uint8_t *src, int32_t stride)\n\n{\n\n    uint8_t lp_cnt;\n\n    uint32_t src0, src1, src2 = 0;\n\n    uint32_t out0, out1, out2;\n\n    v16u8 src_top;\n\n    v8u16 add;\n\n    v4u32 sum;\n\n\n\n    src_top = LD_UB(src - stride);\n\n    add = __msa_hadd_u_h(src_top, src_top);\n\n    sum = __msa_hadd_u_w(add, add);\n\n    src0 = __msa_copy_u_w((v4i32) sum, 0);\n\n    src1 = __msa_copy_u_w((v4i32) sum, 1);\n\n\n\n    for (lp_cnt = 0; lp_cnt < 4; lp_cnt++) {\n\n        src2 += src[lp_cnt * stride - 1];\n\n    }\n\n    src2 = (src0 + src2 + 4) >> 3;\n\n    src0 = (src0 + 2) >> 2;\n\n    src1 = (src1 + 2) >> 2;\n\n    out0 = src0 * 0x01010101;\n\n    out1 = src1 * 0x01010101;\n\n    out2 = src2 * 0x01010101;\n\n\n\n    for (lp_cnt = 4; lp_cnt--;) {\n\n        SW(out2, src);\n\n        SW(out1, src + 4);\n\n        SW(out0, src + stride * 4);\n\n        SW(out1, src + stride * 4 + 4);\n\n        src += stride;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "d6737539e77e78fca9a04914d51996cfd1ccc55c"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_listen_socket_w32_spawnv_81\n{\n\nclass _OS_Command_Injection__char_listen_socket_w32_spawnv_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_listen_socket_w32_spawnv_81 : public _OS_Command_Injection__char_listen_socket_w32_spawnv_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_listen_socket_w32_spawnv_81G2B : public _OS_Command_Injection__char_listen_socket_w32_spawnv_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "246311"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define SYSTEM system\n#else \n#define SYSTEM system\n#endif\n\nchar * _OS_Command_Injection__char_listen_socket_system_68Data;\nchar * _OS_Command_Injection__char_listen_socket_system_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_listen_socket_system_68bSink();\n\nvoid _OS_Command_Injection__char_listen_socket_system_68()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__char_listen_socket_system_68Data = data;\n    _OS_Command_Injection__char_listen_socket_system_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_listen_socket_system_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_listen_socket_system_68G2BData = data;\n    _OS_Command_Injection__char_listen_socket_system_68bG2BSink();\n}\n\nvoid _OS_Command_Injection__char_listen_socket_system_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_system_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_system_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246071"}
{"code": "static void handle_2misc_fcmp_zero(DisasContext *s, int opcode,\n\n                                   bool is_scalar, bool is_u, bool is_q,\n\n                                   int size, int rn, int rd)\n\n{\n\n    bool is_double = (size == 3);\n\n    TCGv_ptr fpst = get_fpstatus_ptr();\n\n\n\n    if (is_double) {\n\n        TCGv_i64 tcg_op = tcg_temp_new_i64();\n\n        TCGv_i64 tcg_zero = tcg_const_i64(0);\n\n        TCGv_i64 tcg_res = tcg_temp_new_i64();\n\n        NeonGenTwoDoubleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: \n\n            swap = true;\n\n            \n\n        case 0x2c: \n\n            genfn = gen_helper_neon_cgt_f64;\n\n            break;\n\n        case 0x2d: \n\n            genfn = gen_helper_neon_ceq_f64;\n\n            break;\n\n        case 0x6d: \n\n            swap = true;\n\n            \n\n        case 0x6c: \n\n            genfn = gen_helper_neon_cge_f64;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        for (pass = 0; pass < (is_scalar ? 1 : 2); pass++) {\n\n            read_vec_element(s, tcg_op, rn, pass, MO_64);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            write_vec_element(s, tcg_res, rd, pass, MO_64);\n\n        }\n\n        if (is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n\n\n        tcg_temp_free_i64(tcg_res);\n\n        tcg_temp_free_i64(tcg_zero);\n\n        tcg_temp_free_i64(tcg_op);\n\n    } else {\n\n        TCGv_i32 tcg_op = tcg_temp_new_i32();\n\n        TCGv_i32 tcg_zero = tcg_const_i32(0);\n\n        TCGv_i32 tcg_res = tcg_temp_new_i32();\n\n        NeonGenTwoSingleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass, maxpasses;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: \n\n            swap = true;\n\n            \n\n        case 0x2c: \n\n            genfn = gen_helper_neon_cgt_f32;\n\n            break;\n\n        case 0x2d: \n\n            genfn = gen_helper_neon_ceq_f32;\n\n            break;\n\n        case 0x6d: \n\n            swap = true;\n\n            \n\n        case 0x6c: \n\n            genfn = gen_helper_neon_cge_f32;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        if (is_scalar) {\n\n            maxpasses = 1;\n\n        } else {\n\n            maxpasses = is_q ? 4 : 2;\n\n        }\n\n\n\n        for (pass = 0; pass < maxpasses; pass++) {\n\n            read_vec_element_i32(s, tcg_op, rn, pass, MO_32);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            if (is_scalar) {\n\n                write_fp_sreg(s, rd, tcg_res);\n\n            } else {\n\n                write_vec_element_i32(s, tcg_res, rd, pass, MO_32);\n\n            }\n\n        }\n\n        tcg_temp_free_i32(tcg_res);\n\n        tcg_temp_free_i32(tcg_zero);\n\n        tcg_temp_free_i32(tcg_op);\n\n        if (!is_q && !is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n    }\n\n\n\n    tcg_temp_free_ptr(fpst);\n\n}", "answer": "NO", "cwe": "0", "idx": "8c6afa6ab158467d1938cc92022135bc7a872006"}
{"code": "static int mmf_probe(AVProbeData *p)\n\n{\n\n    \n\n    if (p->buf_size <= 32)\n\n        return 0;\n\n    if (p->buf[0] == 'M' && p->buf[1] == 'M' &&\n\n        p->buf[2] == 'M' && p->buf[3] == 'D' &&\n\n        p->buf[8] == 'C' && p->buf[9] == 'N' &&\n\n        p->buf[10] == 'T' && p->buf[11] == 'I')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "87e8788680e16c51f6048af26f3f7830c35207a5"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_ofstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(wchar_t * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(wchar_t * data)\n{\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_ofstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91380"}
{"code": "int qcow2_zero_clusters(BlockDriverState *bs, uint64_t offset, int nb_sectors)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    unsigned int nb_clusters;\n\n    int ret;\n\n\n\n    \n\n    if (s->qcow_version < 3) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    \n\n    nb_clusters = size_to_clusters(s, nb_sectors << BDRV_SECTOR_BITS);\n\n\n\n    s->cache_discards = true;\n\n\n\n    while (nb_clusters > 0) {\n\n        ret = zero_single_l2(bs, offset, nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        nb_clusters -= ret;\n\n        offset += (ret * s->cluster_size);\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    s->cache_discards = false;\n\n    qcow2_process_discards(bs, ret);\n\n\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "b6d36def6d9e9fd187327182d0abafc9b7085d8f"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_fopen_45\n{\n\nstatic char * mData;\nstatic char * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    char * data = mData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    char * data = nG2BData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_fopen_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95806"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint honorariums_missourian = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid capman_gape(char **nonrendition_barotseland);\nvoid facemark_counterlath(char **vergences_impassionedness);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  char **neither_stepping = 0;\n  char *effectualize_wizardly = 0;\n  char *schmelzes_subglabrous;;\n  if (__sync_bool_compare_and_swap(&honorariums_missourian,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      schmelzes_subglabrous = getenv(\"HOROLOGIUM_HEIGHTENING\");\n      if (schmelzes_subglabrous != 0) {;\n        neither_stepping = &schmelzes_subglabrous;\n        capman_gape(neither_stepping);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid capman_gape(char **nonrendition_barotseland)\n{\n  ++global_variable;;\n  facemark_counterlath(nonrendition_barotseland);\n}\n\nvoid facemark_counterlath(char **vergences_impassionedness)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *dischase_stanks = 0;\n  ++global_variable;;\n  dischase_stanks = ((char *)( *vergences_impassionedness));\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(dischase_stanks) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (dischase_stanks[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &dischase_stanks[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\nclose_printf_context();\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149480"}
{"code": "static inline void gen_op_eval_bge(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_V(cpu_tmp0, src);\n\n    gen_mov_reg_N(dst, src);\n\n    tcg_gen_xor_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}", "answer": "NO", "cwe": "0", "idx": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0"}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n    if (size <= 0 || nmemb >= INT_MAX / size)\n\n        return AVERROR(ENOMEM);\n\n    if (nmemb <= 0) {\n\n        av_freep(ptr);\n\n        return 0;\n\n    }\n\n    ret = av_realloc(*ptrptr, nmemb * size);\n\n    if (!ret) {\n\n        av_freep(ptr);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    *ptrptr = ret;\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "c3e6e8f06c42499bd020fd0b37f9542150e6067b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_file_execl_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_execl_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_execl_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_execl_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247789"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82\n{\n\nclass _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82 : public _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82_base\n{\npublic:\n    void action(wchar_t * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82G2B : public _OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_82_base\n{\npublic:\n    void action(wchar_t * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "248672"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint syngenesia_subshaft = 0;\ntypedef char *mood_baittle;\nint global_variable;\nvoid quakily_auriculares(mood_baittle *osteitis_ectopistes);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid buttercups_tovar(void (*anisogamous_myotalpa)(mood_baittle *));\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&syngenesia_subshaft,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      buttercups_tovar(quakily_auriculares);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid quakily_auriculares(mood_baittle *osteitis_ectopistes)\n{\n  mood_baittle durezza_coarrangement = 0;\n  char *kalis_richers;\n  ++global_variable;;\n  setup_printf_context();\n  kalis_richers = getenv(\"KURGANS_LAMUS\");\n  if (kalis_richers != 0) {;\n    durezza_coarrangement = kalis_richers;\n     *osteitis_ectopistes = durezza_coarrangement;\n  }\n}\n\nvoid buttercups_tovar(void (*anisogamous_myotalpa)(mood_baittle *))\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *quinamin_eldwen = 0;\n  ++global_variable;\n  mood_baittle forsee_russify = 0;\n  anisogamous_myotalpa(&forsee_russify);\n  if (forsee_russify != 0) {;\n    quinamin_eldwen = ((char *)forsee_russify);\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, quinamin_eldwen);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, quinamin_eldwen, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\nclose_printf_context();\n  }\n}\n#endif", "answer": "YES", "cwe": "195", "idx": "151227"}
{"code": "void tmp_proc_unmount(struct lxc_conf *lxc_conf)\n{\n\tif (lxc_conf->tmp_umount_proc == 1) {\n\t\tumount(\"/proc\");\n\t\tlxc_conf->tmp_umount_proc = 0;\n\t}\n}", "answer": "NO", "cwe": "59", "idx": "44659"}
{"code": "static int segment_info_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tunsigned int total_segs =\n\t\t\tle32_to_cpu(sbi->raw_super->segment_count_main);\n\tint i;\n\n\tseq_puts(seq, \"format: segment_type|valid_blocks\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\");\n\n\tfor (i = 0; i < total_segs; i++) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, i);\n\n\t\tif ((i % 10) == 0)\n\t\t\tseq_printf(seq, \"%-10d\", i);\n\t\tseq_printf(seq, \"%d|%-3u\", se->type,\n\t\t\t\t\tget_valid_blocks(sbi, i, false));\n\t\tif ((i % 10) == 9 || i == (total_segs - 1))\n\t\t\tseq_putc(seq, '\\n');\n\t\telse\n\t\t\tseq_putc(seq, ' ');\n\t}\n\n\treturn 0;\n}", "answer": "NO", "cwe": "129", "idx": "63898"}
{"code": "xilinx_axidma_data_stream_push(StreamSlave *obj, unsigned char *buf, size_t len,\n\n                               uint32_t *app)\n\n{\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(obj);\n\n    struct Stream *s = &ds->dma->streams[1];\n\n    size_t ret;\n\n\n\n    if (!app) {\n\n        hw_error(\"No stream app data!\\n\");\n\n    }\n\n    ret = stream_process_s2mem(s, buf, len, app);\n\n    stream_update_irq(s);\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6"}
{"code": "static ssize_t f2fs_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->store ? a->store(a, sbi, buf, len) : 0;\n}", "answer": "NO", "cwe": "129", "idx": "63856"}
{"code": "void mutt_rfc2047_decode(char **pd)\n{\n  if (!pd || !*pd)\n    return;\n\n  struct Buffer buf = { 0 }; \n  char *s = *pd;             \n  char *beg;                 \n  enum ContentEncoding enc;  \n  char *charset;             \n  size_t charsetlen;         \n  char *text;                \n  size_t textlen;            \n\n  \n  struct Buffer prev = { 0 }; \n  char *prev_charset = NULL;  \n  size_t prev_charsetlen = 0; \n\n  while (*s)\n  {\n    beg = parse_encoded_word(s, &enc, &charset, &charsetlen, &text, &textlen);\n    if (beg != s)\n    {\n      \n      size_t holelen = beg ? beg - s : mutt_str_strlen(s);\n\n      \n      if (beg && mutt_str_lws_len(s, holelen) == holelen)\n      {\n        s = beg;\n        continue;\n      }\n\n      \n      if (prev.data)\n      {\n        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n      }\n\n      \n      {\n        if (AssumedCharset && *AssumedCharset)\n        {\n          char *conv = mutt_str_substr_dup(s, s + holelen);\n          mutt_ch_convert_nonmime_string(&conv);\n          mutt_buffer_addstr(&buf, conv);\n          FREE(&conv);\n        }\n        else\n        {\n          mutt_buffer_add(&buf, s, holelen);\n        }\n      }\n      s += holelen;\n    }\n    if (beg)\n    {\n      \n      text[textlen] = '\\0';\n      char *decoded = rfc2047_decode_word(text, textlen, enc);\n      if (decoded == NULL)\n      {\n        return;\n      }\n      if (prev.data && ((prev_charsetlen != charsetlen) ||\n                        (strncmp(prev_charset, charset, charsetlen) != 0)))\n      {\n        \n        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n      }\n\n      mutt_buffer_addstr(&prev, decoded);\n      FREE(&decoded);\n      prev_charset = charset;\n      prev_charsetlen = charsetlen;\n      s = text + textlen + 2; \n    }\n  }\n\n  \n  if (prev.data)\n  {\n    finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n  }\n\n  mutt_buffer_addch(&buf, '\\0');\n  *pd = buf.data;\n}", "answer": "NO", "cwe": "119", "idx": "79521"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32spawnl_02()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_environment_w32spawnl_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32spawnl_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32spawnl_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245372"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint circumambages_cartmaker = 0;\nint global_variable;\n#define ROTARIANIZE_OVERRIPELY(x) hegumen_outpipe((char **) x)\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hegumen_outpipe(char **surveillant_undunged);\nint 190_global_var = 0;\n\nunsigned int avdevice_version()\n{\n  char **chiropractors_unwetted = 0;\n  char **sympathizing_akeldama = 0;\n  char *sedimetric_pyramidic[53] = {0};\n  char *leckrone_lotis;;\n  if (__sync_bool_compare_and_swap(&circumambages_cartmaker,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&leckrone_lotis,\"CONGLOMERATIC_DOUANES\");\n      if (leckrone_lotis != 0) {;\n        sedimetric_pyramidic[8] = leckrone_lotis;\n        chiropractors_unwetted = sedimetric_pyramidic;\n        sympathizing_akeldama = chiropractors_unwetted + 5;\n\tROTARIANIZE_OVERRIPELY(sympathizing_akeldama);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid hegumen_outpipe(char **surveillant_undunged)\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *josephinite_withercraft = 0;\n  ++global_variable;;\n  josephinite_withercraft = ((char *)(surveillant_undunged - 5)[8]);\n    \n    tainted_int = atoi(josephinite_withercraft);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if ((surveillant_undunged - 5)[8] != 0) \n    free(((char *)(surveillant_undunged - 5)[8]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "190", "idx": "151219"}
{"code": "static void h264_h_loop_filter_luma_intra_c(uint8_t *pix, int stride, int alpha, int beta)\n\n{\n\n    h264_loop_filter_luma_intra_c(pix, 1, stride, alpha, beta);\n\n}", "answer": "NO", "cwe": "0", "idx": "dd561441b1e849df7d8681c6f32af82d4088dafd"}
{"code": "querySiteconf(const ParsedURL *query_pu, int field)\n{\n    const struct siteconf_rec *ent;\n    Str u;\n    char *firstp, *lastp;\n\n    if (field < 0 || field >= SCONF_N_FIELD)\n\treturn NULL;\n    if (!query_pu || IS_EMPTY_PARSED_URL(query_pu))\n\treturn NULL;\n    u = parsedURL2Str((ParsedURL *)query_pu);\n    if (u->length == 0)\n\treturn NULL;\n\n    for (ent = siteconf_head; ent; ent = ent->next) {\n\tif (!SCONF_TEST(ent, field))\n\t    continue;\n\tif (ent->re_url) {\n\t    if (RegexMatch(ent->re_url, u->ptr, u->length, 1)) {\n\t\tMatchedPosition(ent->re_url, &firstp, &lastp);\n\t\tif (!ent->url_exact)\n\t\t    goto url_found;\n\t\tif (firstp != u->ptr || lastp == firstp)\n\t\t    continue;\n\t\tif (*lastp == 0 || *lastp == '?' || *(lastp - 1) == '?' ||\n\t\t    *lastp == '#' || *(lastp - 1) == '#')\n\t\t    goto url_found;\n\t    }\n\t} else {\n\t    int matchlen = strmatchlen(ent->url, u->ptr, u->length);\n\t    if (matchlen == 0 || ent->url[matchlen] != 0)\n\t\tcontinue;\n\t    firstp = u->ptr;\n\t    lastp = u->ptr + matchlen;\n\t    if (*lastp == 0 || *lastp == '?' || *(lastp - 1) == '?' ||\n\t\t*lastp == '#' || *(lastp - 1) == '#')\n\t\tgoto url_found;\n\t    if (!ent->url_exact && (*lastp == '/' || *(lastp - 1) == '/'))\n\t\tgoto url_found;\n\t}\n    }\n    return NULL;\n\nurl_found:\n    switch (field) {\n    case SCONF_SUBSTITUTE_URL:\n\tif (ent->substitute_url && *ent->substitute_url) {\n\t    Str tmp = Strnew_charp_n(u->ptr, firstp - u->ptr);\n\t    Strcat_charp(tmp, ent->substitute_url);\n\t    Strcat_charp(tmp, lastp);\n\t    return tmp->ptr;\n\t}\n\treturn NULL;\n#ifdef USE_M17N\n    case SCONF_URL_CHARSET:\n\treturn &ent->url_charset;\n#endif\n    case SCONF_NO_REFERER_FROM:\n\treturn &ent->no_referer_from;\n    case SCONF_NO_REFERER_TO:\n\treturn &ent->no_referer_to;\n    }\n    return NULL;\n}", "answer": "NO", "cwe": "59", "idx": "84567"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nstatic void mSink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_44()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    funcPtr(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122874"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_02\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96787"}
{"code": "static void test_primitive_lists(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    PrimitiveType *pt = args->test_data;\n\n    PrimitiveList pl = { .value = { NULL } };\n\n    PrimitiveList pl_copy = { .value = { NULL } };\n\n    PrimitiveList *pl_copy_ptr = &pl_copy;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    void *cur_head = NULL;\n\n    int i;\n\n\n\n    pl.type = pl_copy.type = pt->type;\n\n\n\n    \n\n    for (i = 0; i < 32; i++) {\n\n        switch (pl.type) {\n\n        case PTYPE_STRING: {\n\n            strList *tmp = g_new0(strList, 1);\n\n            tmp->value = g_strdup(pt->value.string);\n\n            if (pl.value.strings == NULL) {\n\n                pl.value.strings = tmp;\n\n            } else {\n\n                tmp->next = pl.value.strings;\n\n                pl.value.strings = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_INTEGER: {\n\n            intList *tmp = g_new0(intList, 1);\n\n            tmp->value = pt->value.integer;\n\n            if (pl.value.integers == NULL) {\n\n                pl.value.integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.integers;\n\n                pl.value.integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S8: {\n\n            int8List *tmp = g_new0(int8List, 1);\n\n            tmp->value = pt->value.s8;\n\n            if (pl.value.s8_integers == NULL) {\n\n                pl.value.s8_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s8_integers;\n\n                pl.value.s8_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S16: {\n\n            int16List *tmp = g_new0(int16List, 1);\n\n            tmp->value = pt->value.s16;\n\n            if (pl.value.s16_integers == NULL) {\n\n                pl.value.s16_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s16_integers;\n\n                pl.value.s16_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S32: {\n\n            int32List *tmp = g_new0(int32List, 1);\n\n            tmp->value = pt->value.s32;\n\n            if (pl.value.s32_integers == NULL) {\n\n                pl.value.s32_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s32_integers;\n\n                pl.value.s32_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_S64: {\n\n            int64List *tmp = g_new0(int64List, 1);\n\n            tmp->value = pt->value.s64;\n\n            if (pl.value.s64_integers == NULL) {\n\n                pl.value.s64_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.s64_integers;\n\n                pl.value.s64_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U8: {\n\n            uint8List *tmp = g_new0(uint8List, 1);\n\n            tmp->value = pt->value.u8;\n\n            if (pl.value.u8_integers == NULL) {\n\n                pl.value.u8_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u8_integers;\n\n                pl.value.u8_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U16: {\n\n            uint16List *tmp = g_new0(uint16List, 1);\n\n            tmp->value = pt->value.u16;\n\n            if (pl.value.u16_integers == NULL) {\n\n                pl.value.u16_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u16_integers;\n\n                pl.value.u16_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U32: {\n\n            uint32List *tmp = g_new0(uint32List, 1);\n\n            tmp->value = pt->value.u32;\n\n            if (pl.value.u32_integers == NULL) {\n\n                pl.value.u32_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u32_integers;\n\n                pl.value.u32_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_U64: {\n\n            uint64List *tmp = g_new0(uint64List, 1);\n\n            tmp->value = pt->value.u64;\n\n            if (pl.value.u64_integers == NULL) {\n\n                pl.value.u64_integers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.u64_integers;\n\n                pl.value.u64_integers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_NUMBER: {\n\n            numberList *tmp = g_new0(numberList, 1);\n\n            tmp->value = pt->value.number;\n\n            if (pl.value.numbers == NULL) {\n\n                pl.value.numbers = tmp;\n\n            } else {\n\n                tmp->next = pl.value.numbers;\n\n                pl.value.numbers = tmp;\n\n            }\n\n            break;\n\n        }\n\n        case PTYPE_BOOLEAN: {\n\n            boolList *tmp = g_new0(boolList, 1);\n\n            tmp->value = pt->value.boolean;\n\n            if (pl.value.booleans == NULL) {\n\n                pl.value.booleans = tmp;\n\n            } else {\n\n                tmp->next = pl.value.booleans;\n\n                pl.value.booleans = tmp;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n\n\n    ops->serialize((void **)&pl, &serialize_data, visit_primitive_list, &err);\n\n    ops->deserialize((void **)&pl_copy_ptr, serialize_data, visit_primitive_list, &err);\n\n\n\n    g_assert(err == NULL);\n\n    i = 0;\n\n\n\n    \n\n    do {\n\n        switch (pl_copy.type) {\n\n        case PTYPE_STRING: {\n\n            strList *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.strings;\n\n            }\n\n            g_assert_cmpstr(pt->value.string, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_INTEGER: {\n\n            intList *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.integers;\n\n            }\n\n            g_assert_cmpint(pt->value.integer, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S8: {\n\n            int8List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s8_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s8, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S16: {\n\n            int16List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s16_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s16, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S32: {\n\n            int32List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s32_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s32, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_S64: {\n\n            int64List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.s64_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.s64, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U8: {\n\n            uint8List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u8_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u8, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U16: {\n\n            uint16List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u16_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u16, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U32: {\n\n            uint32List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u32_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u32, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_U64: {\n\n            uint64List *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.u64_integers;\n\n            }\n\n            g_assert_cmpint(pt->value.u64, ==, ptr->value);\n\n            break;\n\n        }\n\n        case PTYPE_NUMBER: {\n\n            numberList *ptr;\n\n            GString *double_expected = g_string_new(\"\");\n\n            GString *double_actual = g_string_new(\"\");\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.numbers;\n\n            }\n\n            \n\n            g_string_printf(double_expected, \"%.6f\", pt->value.number);\n\n            g_string_printf(double_actual, \"%.6f\", ptr->value);\n\n            g_assert_cmpstr(double_actual->str, ==, double_expected->str);\n\n            g_string_free(double_expected, true);\n\n            g_string_free(double_actual, true);\n\n            break;\n\n        }\n\n        case PTYPE_BOOLEAN: {\n\n            boolList *ptr;\n\n            if (cur_head) {\n\n                ptr = cur_head;\n\n                cur_head = ptr->next;\n\n            } else {\n\n                cur_head = ptr = pl_copy.value.booleans;\n\n            }\n\n            g_assert_cmpint(!!pt->value.boolean, ==, !!ptr->value);\n\n            break;\n\n        }\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n        i++;\n\n    } while (cur_head);\n\n\n\n    g_assert_cmpint(i, ==, 33);\n\n\n\n    ops->cleanup(serialize_data);\n\n    dealloc_helper(&pl, visit_primitive_list, &err);\n\n    g_assert(!err);\n\n    dealloc_helper(&pl_copy, visit_primitive_list, &err);\n\n    g_assert(!err);\n\n    g_free(args);\n\n}", "answer": "NO", "cwe": "0", "idx": "3f66f764ee25f10d3e1144ebc057a949421b7728"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint deregulate_systemized = 0;\nint global_variable;\ntypedef char *kechi_udometry;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nkechi_udometry vaudoux_triton(kechi_udometry richton_semistriate);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *minstrelship_cse = 0;\n  kechi_udometry quaters_longeval = 0;\n  kechi_udometry gemless_sourdoughs = 0;\n  char *excavating_infestivity;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&deregulate_systemized,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      excavating_infestivity = getenv(\"MONOLINGUIST_SANDCULTURE\");\n      if (excavating_infestivity != 0) {;\n        gemless_sourdoughs = excavating_infestivity;\n        quaters_longeval = vaudoux_triton(gemless_sourdoughs);\n        if (quaters_longeval != 0) {\n          goto manutius_serjeantry;\n        }\n        ++global_variable;\n        manutius_serjeantry:;\n        minstrelship_cse = ((char *)quaters_longeval);\n    \n    if (strlen(minstrelship_cse) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,minstrelship_cse);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nkechi_udometry vaudoux_triton(kechi_udometry richton_semistriate)\n{\n  ++global_variable;\n  return richton_semistriate;\n}", "answer": "YES", "cwe": "78", "idx": "152698"}
{"code": "void MidiManagerUsb::Initialize(\n    base::Callback<void(MidiResult result)> callback) {\n  initialize_callback_ = callback;\n  device_factory_->EnumerateDevices(\n      this,\n      base::Bind(&MidiManagerUsb::OnEnumerateDevicesDone,\n                 base::Unretained(this)));\n}", "answer": "NO", "cwe": "119", "idx": "139883"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_connect_socket_ofstream_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_ofstream_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89705"}
{"code": "yuv2rgba64_2_c_template(SwsContext *c, const int32_t *buf[2],\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf[2], uint16_t *dest, int dstW,\n\n                       int yalpha, int uvalpha, int y,\n\n                       enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int uvalpha1 = 4096 - uvalpha;\n\n    int i;\n\n    int A1 = 0xffff<<14, A2 = 0xffff<<14;\n\n\n\n    for (i = 0; i < ((dstW + 1) >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha) >> 14;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha) >> 14;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha + (-128 << 23)) >> 14;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha + (-128 << 23)) >> 14;\n\n        int R, G, B;\n\n\n\n        Y1 -= c->yuv2rgb_y_offset;\n\n        Y2 -= c->yuv2rgb_y_offset;\n\n        Y1 *= c->yuv2rgb_y_coeff;\n\n        Y2 *= c->yuv2rgb_y_coeff;\n\n        Y1 += 1 << 13;\n\n        Y2 += 1 << 13;\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 1;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 1;\n\n\n\n            A1 += 1 << 13;\n\n            A2 += 1 << 13;\n\n        }\n\n\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n            output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n            output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n            output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n            output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n            dest += 8;\n\n        } else {\n\n            output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n            output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n            output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n            dest += 6;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "7cf22c79706d23d40d16cee37eb32d5797adcc2c"}
{"code": "void ExtensionInstalledBubbleGtk::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  if (type == chrome::NOTIFICATION_EXTENSION_LOADED) {\n    const Extension* extension =\n        content::Details<const Extension>(details).ptr();\n    if (extension == extension_) {\n      MessageLoopForUI::current()->PostTask(\n          FROM_HERE,\n          base::Bind(&ExtensionInstalledBubbleGtk::ShowInternal, this));\n    }\n  } else if (type == chrome::NOTIFICATION_EXTENSION_UNLOADED) {\n    const Extension* extension =\n        content::Details<UnloadedExtensionInfo>(details)->extension;\n    if (extension == extension_)\n      extension_ = NULL;\n  } else {\n    NOTREACHED() << L\"Received unexpected notification\";\n  }\n}", "answer": "NO", "cwe": "119", "idx": "116017"}
{"code": "static int ffmmal_read_frame(AVCodecContext *avctx, AVFrame *frame, int *got_frame)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    MMAL_BUFFER_HEADER_T *buffer = NULL;\n\n    MMAL_STATUS_T status = 0;\n\n    int ret = 0;\n\n\n\n    if (ctx->eos_received)\n\n        goto done;\n\n\n\n    while (1) {\n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        if (ctx->frames_output || ctx->packets_sent > MAX_DELAYED_FRAMES || ctx->eos_sent) {\n\n            buffer = mmal_queue_wait(ctx->queue_decoded_frames);\n\n        } else {\n\n            buffer = mmal_queue_get(ctx->queue_decoded_frames);\n\n        }\n\n        if (!buffer)\n\n            goto done;\n\n\n\n        ctx->eos_received |= !!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS);\n\n        if (ctx->eos_received)\n\n            goto done;\n\n\n\n        if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {\n\n            MMAL_COMPONENT_T *decoder = ctx->decoder;\n\n            MMAL_EVENT_FORMAT_CHANGED_T *ev = mmal_event_format_changed_get(buffer);\n\n            MMAL_BUFFER_HEADER_T *stale_buffer;\n\n\n\n            av_log(avctx, AV_LOG_INFO, \"Changing output format.\\n\");\n\n\n\n            if ((status = mmal_port_disable(decoder->output[0])))\n\n                goto done;\n\n\n\n            while ((stale_buffer = mmal_queue_get(ctx->queue_decoded_frames)))\n\n                mmal_buffer_header_release(stale_buffer);\n\n\n\n            mmal_format_copy(decoder->output[0]->format, ev->format);\n\n\n\n            if ((ret = ffmal_update_format(avctx)) < 0)\n\n                goto done;\n\n\n\n            if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n\n                goto done;\n\n\n\n            if ((ret = ffmmal_fill_output_port(avctx)) < 0)\n\n                goto done;\n\n\n\n            if ((ret = ffmmal_fill_input_port(avctx)) < 0)\n\n                goto done;\n\n\n\n            mmal_buffer_header_release(buffer);\n\n            continue;\n\n        } else if (buffer->cmd) {\n\n            char s[20];\n\n            av_get_codec_tag_string(s, sizeof(s), buffer->cmd);\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown MMAL event %s on output port\\n\", s);\n\n            goto done;\n\n        } else if (buffer->length == 0) {\n\n            \n\n            mmal_buffer_header_release(buffer);\n\n            continue;\n\n        }\n\n\n\n        ctx->frames_output++;\n\n\n\n        if ((ret = ffmal_copy_frame(avctx, frame, buffer)) < 0)\n\n            goto done;\n\n\n\n        *got_frame = 1;\n\n        break;\n\n    }\n\n\n\ndone:\n\n    if (buffer)\n\n        mmal_buffer_header_release(buffer);\n\n    if (status && ret >= 0)\n\n        ret = AVERROR_UNKNOWN;\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "b84675d63aaede8f6944b901250a10456c5477e6"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_64bSink(void * dataVoidPtr);\n\nvoid _LDAP_Injection__w32_wchar_t_file_64()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_64bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_64bG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_64bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_64()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_64();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_64();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123267"}
{"code": "static char *regname(uint32_t addr)\n\n{\n\n    static char buf[16];\n\n    if (addr < PCI_IO_SIZE) {\n\n        const char *r = reg[addr / 4];\n\n        if (r != 0) {\n\n            sprintf(buf, \"%s+%u\", r, addr % 4);\n\n        } else {\n\n            sprintf(buf, \"0x%02x\", addr);\n\n        }\n\n    } else {\n\n        sprintf(buf, \"??? 0x%08x\", addr);\n\n    }\n\n    return buf;\n\n}", "answer": "NO", "cwe": "0", "idx": "41cbc23c5ca37a8b841915d7d252a02106d58b1e"}
{"code": "CSSComputedStyleDeclaration::~CSSComputedStyleDeclaration()\n{\n}", "answer": "NO", "cwe": "119", "idx": "104397"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic wchar_t * nG2B1Source(wchar_t * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic wchar_t * nG2B2Source(wchar_t * data)\n{\n    if(nG2B2Static)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123249"}
{"code": "static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    \n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}", "answer": "NO", "cwe": "0", "idx": "c2b38b277a7882a592f4f2ec955084b2b756daaa"}
{"code": "LIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentOrder(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_order(file->mod);\n}", "answer": "NO", "cwe": "120", "idx": "87627"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ofstream_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * * dataPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ofstream_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91631"}
{"code": "static struct inode *f2fs_alloc_inode(struct super_block *sb)\n{\n\tstruct f2fs_inode_info *fi;\n\n\tfi = kmem_cache_alloc(f2fs_inode_cachep, GFP_F2FS_ZERO);\n\tif (!fi)\n\t\treturn NULL;\n\n\tinit_once((void *) fi);\n\n\t\n\tfi->vfs_inode.i_version = 1;\n\tatomic_set(&fi->dirty_pages, 0);\n\tfi->i_current_depth = 1;\n\tfi->i_advise = 0;\n\tinit_rwsem(&fi->i_sem);\n\tINIT_LIST_HEAD(&fi->dirty_list);\n\tINIT_LIST_HEAD(&fi->gdirty_list);\n\tINIT_LIST_HEAD(&fi->inmem_pages);\n\tmutex_init(&fi->inmem_lock);\n\tinit_rwsem(&fi->dio_rwsem[READ]);\n\tinit_rwsem(&fi->dio_rwsem[WRITE]);\n\n\t\n\tfi->i_dir_level = F2FS_SB(sb)->dir_level;\n\treturn &fi->vfs_inode;\n}", "answer": "NO", "cwe": "129", "idx": "63854"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_13()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62480"}
{"code": "static int hdcd_envelope(int32_t *samples, int count, int stride, int gain, int target_gain, int extend)\n\n{\n\n    int i;\n\n    int32_t *samples_end = samples + stride * count;\n\n\n\n    if (extend) {\n\n        for (i = 0; i < count; i++) {\n\n            int32_t sample = samples[i * stride];\n\n            int32_t asample = abs(sample) - 0x5981;\n\n            if (asample >= 0)\n\n                sample = sample >= 0 ? peaktab[asample] : -peaktab[asample];\n\n            else\n\n                sample <<= 15;\n\n\n\n            samples[i * stride] = sample;\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++)\n\n            samples[i * stride] <<= 15;\n\n    }\n\n\n\n    if (gain <= target_gain) {\n\n        int len = FFMIN(count, target_gain - gain);\n\n        \n\n        for (i = 0; i < len; i++) {\n\n            ++gain;\n\n            APPLY_GAIN(*samples, gain);\n\n            samples += stride;\n\n        }\n\n        count -= len;\n\n    } else {\n\n        int len = FFMIN(count, (gain - target_gain) >> 3);\n\n        \n\n        for (i = 0; i < len; i++) {\n\n            gain -= 8;\n\n            APPLY_GAIN(*samples, gain);\n\n            samples += stride;\n\n        }\n\n        if (gain - 8 < target_gain)\n\n            gain = target_gain;\n\n        count -= len;\n\n    }\n\n\n\n    \n\n    if (gain == 0) {\n\n        if (count > 0)\n\n            samples += count * stride;\n\n    } else {\n\n        while (--count >= 0) {\n\n            APPLY_GAIN(*samples, gain);\n\n            samples += stride;\n\n        }\n\n    }\n\n\n\n    av_assert0(samples == samples_end);\n\n\n\n    return gain;\n\n}", "answer": "NO", "cwe": "0", "idx": "0e0f8859ba0af33e1145a4c4022e964011e2d75b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_w32_spawnvp_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_console_w32_spawnvp_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_w32_spawnvp_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_w32_spawnvp_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247227"}
{"code": "static void tcg_out_brcond(TCGContext *s, TCGCond cond, TCGReg arg1,\n\n                           TCGReg arg2, int label_index)\n\n{\n\n    static const MIPSInsn b_zero[16] = {\n\n        [TCG_COND_LT] = OPC_BLTZ,\n\n        [TCG_COND_GT] = OPC_BGTZ,\n\n        [TCG_COND_LE] = OPC_BLEZ,\n\n        [TCG_COND_GE] = OPC_BGEZ,\n\n    };\n\n\n\n    TCGLabel *l;\n\n    MIPSInsn s_opc = OPC_SLTU;\n\n    MIPSInsn b_opc;\n\n    int cmp_map;\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n        b_opc = OPC_BEQ;\n\n        break;\n\n    case TCG_COND_NE:\n\n        b_opc = OPC_BNE;\n\n        break;\n\n\n\n    case TCG_COND_LT:\n\n    case TCG_COND_GT:\n\n    case TCG_COND_LE:\n\n    case TCG_COND_GE:\n\n        if (arg2 == 0) {\n\n            b_opc = b_zero[cond];\n\n            arg2 = arg1;\n\n            arg1 = 0;\n\n            break;\n\n        }\n\n        s_opc = OPC_SLT;\n\n        \n\n\n\n    case TCG_COND_LTU:\n\n    case TCG_COND_GTU:\n\n    case TCG_COND_LEU:\n\n    case TCG_COND_GEU:\n\n        cmp_map = mips_cmp_map[cond];\n\n        if (cmp_map & MIPS_CMP_SWAP) {\n\n            TCGReg t = arg1;\n\n            arg1 = arg2;\n\n            arg2 = t;\n\n        }\n\n        tcg_out_opc_reg(s, s_opc, TCG_TMP0, arg1, arg2);\n\n        b_opc = (cmp_map & MIPS_CMP_INV ? OPC_BEQ : OPC_BNE);\n\n        arg1 = TCG_TMP0;\n\n        arg2 = TCG_REG_ZERO;\n\n        break;\n\n\n\n    default:\n\n        tcg_abort();\n\n        break;\n\n    }\n\n\n\n    tcg_out_opc_br(s, b_opc, arg1, arg2);\n\n    l = &s->labels[label_index];\n\n    if (l->has_value) {\n\n        reloc_pc16(s->code_ptr - 1, l->u.value_ptr);\n\n    } else {\n\n        tcg_out_reloc(s, s->code_ptr - 1, R_MIPS_PC16, label_index, 0);\n\n    }\n\n    tcg_out_nop(s);\n\n}", "answer": "NO", "cwe": "0", "idx": "bec1631100323fac0900aea71043d5c4e22fc2fa"}
{"code": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop & MO_SIZE,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    \n\n\n\n    \n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    \n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    \n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        \n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    \n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    \n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    \n\n    if (SPARC64) {\n\n        \n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            \n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif \n\n}", "answer": "NO", "cwe": "0", "idx": "eabb7b91b36b202b4dac2df2d59d698e3aff197a"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n#define EXECVP _wexecvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_execvp_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248451"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <list>\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ifstream_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<wchar_t *> dataList);\n\nvoid m()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<wchar_t *> dataList);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ifstream_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91590"}
{"code": "bool error_is_type(Error *err, const char *fmt)\n\n{\n\n    const char *error_class;\n\n    char *ptr;\n\n    char *end;\n\n\n\n    if (!err) {\n\n        return false;\n\n    }\n\n\n\n    ptr = strstr(fmt, \"'class': '\");\n\n    assert(ptr != NULL);\n\n    ptr += strlen(\"'class': '\");\n\n\n\n    end = strchr(ptr, '\\'');\n\n    assert(end != NULL);\n\n\n\n    error_class = error_get_field(err, \"class\");\n\n    if (strlen(error_class) != end - ptr) {\n\n        return false;\n\n    }\n\n\n\n    return strncmp(ptr, error_class, end - ptr) == 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "13f59ae8157e8ec238fa8aefe5309909a1eeb7e2"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_67\n{\n\ntypedef struct _structType\n{\n    wchar_t * structFirst;\n} structType;\n\n#ifndef OMITM\n\n\nvoid mSink(structType myStruct);\n\nvoid m()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    mSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    myStruct.structFirst = data;\n    nG2BSink(myStruct);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_67; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97737"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_08()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_08()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_08();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_08();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81985"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_file_w32spawnl_09()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_w32spawnl_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_w32spawnl_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_w32spawnl_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248211"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint hoolihan_ingenerate = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *chronologize_declutch = 0;\n  jmp_buf brigading_maties;\n  int ophioglossum_thermolysis;\n  char **lejeune_registrars = 0;\n  char **ire_bisaltae = 0;\n  char *draughtman_astragalomancy[58] = {0};\n  char *chancrous_lettermen;;\n  if (__sync_bool_compare_and_swap(&hoolihan_ingenerate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      chancrous_lettermen = getenv(\"UNTEMPLED_TRESSIER\");\n      if (chancrous_lettermen != 0) {;\n        draughtman_astragalomancy[57] = chancrous_lettermen;\n        lejeune_registrars = draughtman_astragalomancy;\n        ire_bisaltae = lejeune_registrars + 5;\n        ophioglossum_thermolysis = setjmp(brigading_maties);\n        if (ophioglossum_thermolysis == 0) {\n          longjmp(brigading_maties,1);\n        }\n        chronologize_declutch = ((char *)(ire_bisaltae - 5)[57]);\n  \n  \n  csv = fopen(chronologize_declutch,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149780"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_console_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_console_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_console_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_console_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "61988"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_w32CreateFile_81\n{\n\nclass _Relative_Path_Traversal__char_console_w32CreateFile_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_console_w32CreateFile_81 : public _Relative_Path_Traversal__char_console_w32CreateFile_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_console_w32CreateFile_81G2B : public _Relative_Path_Traversal__char_console_w32CreateFile_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "23", "idx": "90056"}
{"code": "OMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch ((OMX_U32) index) {\n case OMX_IndexParamAudioPortFormat:\n {\n            OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n\n if (!isValidOMXParam(formatParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (formatParams->nPortIndex > 1) {\n return OMX_ErrorUndefined;\n }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n            OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n\n if (!isValidOMXParam(aacParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (aacParams->nPortIndex != 1) {\n return OMX_ErrorUndefined;\n }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n switch (mSBRMode) {\n case 1: \n switch (mSBRRatio) {\n case 0:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                    ALOGE(\"invalid SBR ratio %d\", mSBRRatio);\n                    TRESPASS();\n }\n break;\n case 0: \n case -1: \n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                ALOGE(\"invalid SBR mode %d\", mSBRMode);\n                TRESPASS();\n }\n\n\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n\n if (!isValidOMXParam(pcmParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (pcmParams->nPortIndex != 0) {\n return OMX_ErrorUndefined;\n }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioProfileQuerySupported:\n {\n            OMX_AUDIO_PARAM_ANDROID_PROFILETYPE *profileParams =\n (OMX_AUDIO_PARAM_ANDROID_PROFILETYPE *)params;\n\n if (!isValidOMXParam(profileParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (profileParams->nPortIndex != 1) {\n return OMX_ErrorUndefined;\n }\n\n if (profileParams->nProfileIndex >= NELEM(kSupportedProfiles)) {\n return OMX_ErrorNoMore;\n }\n\n            profileParams->eProfile =\n                kSupportedProfiles[profileParams->nProfileIndex];\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}", "answer": "NO", "cwe": "120", "idx": "175667"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Relative_Path_Traversal__char_file_w32CreateFile_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_file_w32CreateFile_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90499"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_16()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123246"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_54bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_connect_socket_54()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_connect_socket_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_connect_socket_54bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122879"}
{"code": "static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\t\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n\t\tpi->resno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif (!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}", "answer": "NO", "cwe": "125", "idx": "50051"}
{"code": "GF_Err leva_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *p = (GF_LevelAssignmentBox *)a;\n\tgf_isom_box_dump_start(a, \"LevelAssignmentBox\", trace);\n\n\tfprintf(trace, \"level_count=\\\"%d\\\" >\\n\", p->level_count);\n\tfor (i = 0; i < p->level_count; i++) {\n\t\tfprintf(trace, \"<Assignement track_id=\\\"%d\\\" padding_flag=\\\"%d\\\" assignement_type=\\\"%d\\\" grouping_type=\\\"%s\\\" grouping_type_parameter=\\\"%d\\\" sub_track_id=\\\"%d\\\" />\\n\", p->levels[i].track_id, p->levels[i].padding_flag, p->levels[i].type, gf_4cc_to_str(p->levels[i].grouping_type) , p->levels[i].grouping_type_parameter, p->levels[i].sub_track_id);\n\t}\n\tif (!p->size) {\n\t\tfprintf(trace, \"<Assignement track_id=\\\"\\\" padding_flag=\\\"\\\" assignement_type=\\\"\\\" grouping_type=\\\"\\\" grouping_type_parameter=\\\"\\\" sub_track_id=\\\"\\\" />\\n\");\n\t}\n\tgf_isom_box_dump_done(\"LevelAssignmentBox\", a, trace);\n\treturn GF_OK;\n}", "answer": "NO", "cwe": "125", "idx": "80781"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint paracusic_jesuitizing = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid lamellary_birder(char *semitism_wil);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*wean_finings)(char *) = lamellary_birder;\n  int eudoxia_presufficiently = 51;\n  char *seamlike_ratement;;\n  if (__sync_bool_compare_and_swap(&paracusic_jesuitizing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&seamlike_ratement,\"1885\",eudoxia_presufficiently);\n      if (seamlike_ratement != 0) {;\n        wean_finings(seamlike_ratement);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid lamellary_birder(char *semitism_wil)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *dalecarlian_reassigning = 0;\n  ++global_variable;;\n  dalecarlian_reassigning = ((char *)semitism_wil);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(dalecarlian_reassigning)+ 1));\n        if (cusData->data &&\n            (sscanf(dalecarlian_reassigning, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if (semitism_wil != 0) \n    free(((char *)semitism_wil));\nclose_printf_context();\n}", "answer": "YES", "cwe": "663", "idx": "150591"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_open_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_open_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89732"}
{"code": "void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    int i;\n\n\n\n    vnc_jobs_join(vs); \n\n\n\n    vnc_lock_output(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);\n\n\n\n    buffer_free(&vs->input);\n\n    buffer_free(&vs->output);\n\n#ifdef CONFIG_VNC_WS\n\n    buffer_free(&vs->ws_input);\n\n    buffer_free(&vs->ws_output);\n\n#endif \n\n\n\n    qapi_free_VncClientInfo(vs->info);\n\n\n\n    vnc_zlib_clear(vs);\n\n    vnc_tight_clear(vs);\n\n    vnc_zrle_clear(vs);\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif \n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif \n\n    audio_del(vs);\n\n    vnc_release_modifiers(vs);\n\n\n\n    if (vs->initialized) {\n\n        QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n\n        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n\n    }\n\n\n\n    if (vs->vd->lock_key_sync)\n\n        qemu_remove_led_event_handler(vs->led);\n\n    vnc_unlock_output(vs);\n\n\n\n    qemu_mutex_destroy(&vs->output_mutex);\n\n    if (vs->bh != NULL) {\n\n        qemu_bh_delete(vs->bh);\n\n    }\n\n    buffer_free(&vs->jobs_buffer);\n\n\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        g_free(vs->lossy_rect[i]);\n\n    }\n\n    g_free(vs->lossy_rect);\n\n    g_free(vs);\n\n}", "answer": "NO", "cwe": "0", "idx": "8e9b0d24fb986d4241ae3b77752eca5dab4cb486"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_console_66bSink(char * dataArray[]);\n\nvoid _LDAP_Injection__w32_char_console_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    _LDAP_Injection__w32_char_console_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_console_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    dataArray[2] = data;\n    _LDAP_Injection__w32_char_console_66bG2BSink(dataArray);\n}\n\nvoid _LDAP_Injection__w32_char_console_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_console_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_console_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122933"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_ifstream_83\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_connect_socket_ifstream_83\n{\npublic:\n    _Relative_Path_Traversal__char_connect_socket_ifstream_83(char * dataCopy);\n    ~_Relative_Path_Traversal__char_connect_socket_ifstream_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_connect_socket_ifstream_83G2B\n{\npublic:\n    _Relative_Path_Traversal__char_connect_socket_ifstream_83G2B(char * dataCopy);\n    ~_Relative_Path_Traversal__char_connect_socket_ifstream_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "23", "idx": "89674"}
{"code": "static av_cold int ffv1_encode_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    int i, j, k, m, ret;\n\n\n\n    ffv1_common_init(avctx);\n\n\n\n    s->version = 0;\n\n\n\n    if ((avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) ||\n\n        avctx->slices > 1)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    if (avctx->level == 3) {\n\n        s->version = 3;\n\n    }\n\n\n\n    if (s->ec < 0) {\n\n        s->ec = (s->version >= 3);\n\n    }\n\n\n\n    if (s->version >= 2 &&\n\n        avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Version %d requested, please set -strict experimental in \"\n\n               \"order to enable it\\n\",\n\n               s->version);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->ac = avctx->coder_type > 0 ? 2 : 0;\n\n\n\n    s->plane_count = 3;\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV420P9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n        s->packed_at_lsb = 1;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = 16;\n\n        } else if (!s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        }\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (!s->ac && avctx->coder_type == -1) {\n\n            av_log(avctx, AV_LOG_INFO,\n\n                   \"bits_per_raw_sample > 8, forcing coder 1\\n\");\n\n            s->ac = 2;\n\n        }\n\n        if (!s->ac) {\n\n            av_log(\n\n                avctx, AV_LOG_ERROR,\n\n                \"bits_per_raw_sample of more than 8 needs -coder 1 currently\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV410P:\n\n        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;\n\n        s->colorspace    = 0;\n\n        break;\n\n    case AV_PIX_FMT_YUVA444P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n        s->chroma_planes = 1;\n\n        s->colorspace    = 0;\n\n        s->transparency  = 1;\n\n        break;\n\n    case AV_PIX_FMT_RGB32:\n\n        s->colorspace   = 1;\n\n        s->transparency = 1;\n\n        break;\n\n    case AV_PIX_FMT_GBRP9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GBRP10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GBRP16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 16;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        s->colorspace    = 1;\n\n        s->chroma_planes = 1;\n\n        s->version       = FFMAX(s->version, 1);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (s->transparency) {\n\n        av_log(\n\n            avctx, AV_LOG_WARNING,\n\n            \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");\n\n    }\n\n    if (avctx->context_model > 1U) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Invalid context model %d, valid values are 0 and 1\\n\",\n\n               avctx->context_model);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->ac > 1)\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = ffv1_ver2_state[i];\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        s->quant_table_count = 2;\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            s->quant_tables[0][0][i] = ffv1_quant11[i];\n\n            s->quant_tables[0][1][i] = ffv1_quant11[i] * 11;\n\n            s->quant_tables[0][2][i] = ffv1_quant11[i] * 11 * 11;\n\n            s->quant_tables[1][0][i] = ffv1_quant11[i];\n\n            s->quant_tables[1][1][i] = ffv1_quant11[i] * 11;\n\n            s->quant_tables[1][2][i] = ffv1_quant5[i]  * 11 * 11;\n\n            s->quant_tables[1][3][i] = ffv1_quant5[i]  *  5 * 11 * 11;\n\n            s->quant_tables[1][4][i] = ffv1_quant5[i]  *  5 *  5 * 11 * 11;\n\n        } else {\n\n            s->quant_tables[0][0][i] = ffv1_quant9_10bit[i];\n\n            s->quant_tables[0][1][i] = ffv1_quant9_10bit[i] * 11;\n\n            s->quant_tables[0][2][i] = ffv1_quant9_10bit[i] * 11 * 11;\n\n            s->quant_tables[1][0][i] = ffv1_quant9_10bit[i];\n\n            s->quant_tables[1][1][i] = ffv1_quant9_10bit[i] * 11;\n\n            s->quant_tables[1][2][i] = ffv1_quant5_10bit[i] * 11 * 11;\n\n            s->quant_tables[1][3][i] = ffv1_quant5_10bit[i] *  5 * 11 * 11;\n\n            s->quant_tables[1][4][i] = ffv1_quant5_10bit[i] *  5 *  5 * 11 * 11;\n\n        }\n\n    }\n\n    s->context_count[0] = (11 * 11 * 11        + 1) / 2;\n\n    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;\n\n    memcpy(s->quant_table, s->quant_tables[avctx->context_model],\n\n           sizeof(s->quant_table));\n\n\n\n    for (i = 0; i < s->plane_count; i++) {\n\n        PlaneContext *const p = &s->plane[i];\n\n\n\n        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));\n\n        p->quant_table_index = avctx->context_model;\n\n        p->context_count     = s->context_count[p->quant_table_index];\n\n    }\n\n\n\n    if ((ret = ffv1_allocate_initial_states(s)) < 0)\n\n        return ret;\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (!s->transparency)\n\n        s->plane_count = 2;\n\n\n\n    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift,\n\n                                     &s->chroma_v_shift);\n\n\n\n    s->picture_number = 0;\n\n\n\n    if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            s->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                        sizeof(*s->rc_stat2[i]));\n\n            if (!s->rc_stat2[i])\n\n                return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    if (avctx->stats_in) {\n\n        char *p = avctx->stats_in;\n\n        uint8_t best_state[256][256];\n\n        int gob_count = 0;\n\n        char *next;\n\n\n\n        av_assert0(s->version >= 2);\n\n\n\n        for (;; ) {\n\n            for (j = 0; j < 256; j++)\n\n                for (i = 0; i < 2; i++) {\n\n                    s->rc_stat[j][i] = strtol(p, &next, 0);\n\n                    if (next == p) {\n\n                        av_log(avctx, AV_LOG_ERROR,\n\n                               \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    p = next;\n\n                }\n\n            for (i = 0; i < s->quant_table_count; i++)\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    for (k = 0; k < 32; k++)\n\n                        for (m = 0; m < 2; m++) {\n\n                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);\n\n                            if (next == p) {\n\n                                av_log(avctx, AV_LOG_ERROR,\n\n                                       \"2Pass file invalid at %d %d %d %d [%s]\\n\",\n\n                                       i, j, k, m, p);\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            p = next;\n\n                        }\n\n                }\n\n            gob_count = strtol(p, &next, 0);\n\n            if (next == p || gob_count <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            p = next;\n\n            while (*p == '\\n' || *p == ' ')\n\n                p++;\n\n            if (p[0] == 0)\n\n                break;\n\n        }\n\n        sort_stt(s, s->state_transition);\n\n\n\n        find_best_state(best_state, s->state_transition);\n\n\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            for (j = 0; j < s->context_count[i]; j++)\n\n                for (k = 0; k < 32; k++) {\n\n                    double p = 128;\n\n                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) {\n\n                        p = 256.0 * s->rc_stat2[i][j][k][1] /\n\n                            (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]);\n\n                    }\n\n                    s->initial_states[i][j][k] =\n\n                        best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] +\n\n                                                                       s->rc_stat2[i][j][k][1]) /\n\n                                                                      gob_count, 0, 255)];\n\n                }\n\n        }\n\n    }\n\n\n\n    if (s->version > 1) {\n\n        for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++)\n\n            for (s->num_h_slices = s->num_v_slices;\n\n                 s->num_h_slices < 2 * s->num_v_slices; s->num_h_slices++)\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices &&\n\n                    avctx->slices <= 64 || !avctx->slices)\n\n                    goto slices_ok;\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        write_extradata(s);\n\n    }\n\n\n\n    if ((ret = ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    if ((ret = init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "d6604b29ef544793479d7fb4e05ef6622bb3e534"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nchar * _Absolute_Path_Traversal__char_environment_fopen_68Data;\nchar * _Absolute_Path_Traversal__char_environment_fopen_68G2BData;\n\nnamespace _Absolute_Path_Traversal__char_environment_fopen_68\n{\n\n#ifndef OMITM\n\n\nvoid mSink();\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    _Absolute_Path_Traversal__char_environment_fopen_68Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    _Absolute_Path_Traversal__char_environment_fopen_68G2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_fopen_68; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96058"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\nchar * _OS_Command_Injection__char_file_w32_spawnv_68Data;\nchar * _OS_Command_Injection__char_file_w32_spawnv_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68bSink();\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _OS_Command_Injection__char_file_w32_spawnv_68Data = data;\n    _OS_Command_Injection__char_file_w32_spawnv_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_file_w32_spawnv_68G2BData = data;\n    _OS_Command_Injection__char_file_w32_spawnv_68bG2BSink();\n}\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245835"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_09()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123287"}
{"code": "static int check_pow_970 (CPUPPCState *env)\n\n{\n\n    if (env->spr[SPR_HID0] & 0x00600000)\n\n        return 1;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "bbc01ca7f265f2c5be8aee7c9ce1d10aa26063f5"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__char_environment_ofstream_81\n{\n\nclass _Absolute_Path_Traversal__char_environment_ofstream_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__char_environment_ofstream_81 : public _Absolute_Path_Traversal__char_environment_ofstream_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__char_environment_ofstream_81G2B : public _Absolute_Path_Traversal__char_environment_ofstream_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "36", "idx": "96158"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97006"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_open_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_open_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97150"}
{"code": "static void f2fs_build_fault_attr(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int rate)\n{\n\tstruct f2fs_fault_info *ffi = &sbi->fault_info;\n\n\tif (rate) {\n\t\tatomic_set(&ffi->inject_ops, 0);\n\t\tffi->inject_rate = rate;\n\t\tffi->inject_type = (1 << FAULT_MAX) - 1;\n\t} else {\n\t\tmemset(ffi, 0, sizeof(struct f2fs_fault_info));\n\t}\n}", "answer": "NO", "cwe": "129", "idx": "63857"}
{"code": "mwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_pwk_cipher *pwk_cipher;\n\tstruct host_cmd_tlv_gwk_cipher *gwk_cipher;\n\tstruct host_cmd_tlv_passphrase *passphrase;\n\tstruct host_cmd_tlv_akmp *tlv_akmp;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tu16 cmd_size = *param_size;\n\tu8 *tlv = *tlv_buf;\n\n\ttlv_akmp = (struct host_cmd_tlv_akmp *)tlv;\n\ttlv_akmp->header.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);\n\ttlv_akmp->header.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\ttlv_akmp->key_mgmt_operation = cpu_to_le16(bss_cfg->key_mgmt_operation);\n\ttlv_akmp->key_mgmt = cpu_to_le16(bss_cfg->key_mgmt);\n\tcmd_size += sizeof(struct host_cmd_tlv_akmp);\n\ttlv += sizeof(struct host_cmd_tlv_akmp);\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa2 & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA2);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa2;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.group_cipher & VALID_CIPHER_BITMAP) {\n\t\tgwk_cipher = (struct host_cmd_tlv_gwk_cipher *)tlv;\n\t\tgwk_cipher->header.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);\n\t\tgwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_gwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tgwk_cipher->cipher = bss_cfg->wpa_cfg.group_cipher;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.length) {\n\t\tpassphrase = (struct host_cmd_tlv_passphrase *)tlv;\n\t\tpassphrase->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);\n\t\tpassphrase->header.len = cpu_to_le16(bss_cfg->wpa_cfg.length);\n\t\tmemcpy(passphrase->passphrase, bss_cfg->wpa_cfg.passphrase,\n\t\t       bss_cfg->wpa_cfg.length);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->wpa_cfg.length;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->wpa_cfg.length;\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}", "answer": "NO", "cwe": "120", "idx": "88623"}
{"code": "const AVOption *av_opt_find(void *obj, const char *name, const char *unit,\n\n                            int opt_flags, int search_flags)\n\n{\n\n    AVClass *c = *(AVClass**)obj;\n\n    const AVOption *o = NULL;\n\n\n\n    if (c->opt_find && search_flags & AV_OPT_SEARCH_CHILDREN &&\n\n        (o = c->opt_find(obj, name, unit, opt_flags, search_flags)))\n\n        return o;\n\n\n\n    while (o = av_next_option(obj, o)) {\n\n        if (!strcmp(o->name, name) && (!unit || (o->unit && !strcmp(o->unit, unit))) &&\n\n            (o->flags & opt_flags) == opt_flags)\n\n            return o;\n\n    }\n\n    return NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "a726d7fd4e0b112b276678ea9da9c9b3097e8b8f"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint acclimates_repropitiation = 0;\n\nstruct taurean_physostigma \n{\n  char *precolonial_theomachy;\n  double anaglyphical_overexcitements;\n  char *zapu_cuartillo;\n  char fourmile_procapital;\n  int mountainy_laggins;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *deathful_batters = 0;\n  int phenylated_rutaceae;\n  int sambos_inverson;\n  struct taurean_physostigma *geoduck_peroxidase = {0};\n  struct taurean_physostigma *imperialisation_usrc = {0};\n  struct taurean_physostigma novellike_gemma;\n  char *gardant_apparens;;\n  if (__sync_bool_compare_and_swap(&acclimates_repropitiation,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&gardant_apparens,\"VERNAL_UNTRESPASSING\");\n      if (gardant_apparens != 0) {;\n        novellike_gemma . precolonial_theomachy = ((char *)gardant_apparens);\n        geoduck_peroxidase = &novellike_gemma;\n        imperialisation_usrc = geoduck_peroxidase + 5;\n        sambos_inverson = 5;\n        while(1 == 1){\n          sambos_inverson = sambos_inverson * 2;\n          sambos_inverson = sambos_inverson + 2;\n          if (sambos_inverson > 1000) {\n            break; \n          }\n        }\n        phenylated_rutaceae = sambos_inverson;\n        deathful_batters = ((char *)( *(imperialisation_usrc - 5)) . precolonial_theomachy);\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(deathful_batters) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(deathful_batters) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(deathful_batters) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(deathful_batters, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\n        if (( *(imperialisation_usrc - 5)) . precolonial_theomachy != 0) \n          free(((char *)( *(imperialisation_usrc - 5)) . precolonial_theomachy));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "YES", "cwe": "820", "idx": "150689"}
{"code": "static void alloc_picture(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int64_t bufferdiff;\n\n\n\n    vp = &is->pictq[is->pictq_windex];\n\n\n\n    if (vp->bmp)\n\n        SDL_FreeYUVOverlay(vp->bmp);\n\n\n\n    video_open(is, 0, vp);\n\n\n\n    vp->bmp = SDL_CreateYUVOverlay(vp->width, vp->height,\n\n                                   SDL_YV12_OVERLAY,\n\n                                   screen);\n\n    bufferdiff = vp->bmp ? FFMAX(vp->bmp->pixels[0], vp->bmp->pixels[1]) - FFMIN(vp->bmp->pixels[0], vp->bmp->pixels[1]) : 0;\n\n    if (!vp->bmp || vp->bmp->pitches[0] < vp->width || bufferdiff < vp->height * vp->bmp->pitches[0]) {\n\n        \n\n        av_log(NULL, AV_LOG_FATAL,\n\n               \"Error: the video system does not support an image\\n\"\n\n                        \"size of %dx%d pixels. Try using -lowres or -vf \\\"scale=w:h\\\"\\n\"\n\n                        \"to reduce the image size.\\n\", vp->width, vp->height );\n\n        do_exit(is);\n\n    }\n\n\n\n    SDL_LockMutex(is->pictq_mutex);\n\n    vp->allocated = 1;\n\n    SDL_CondSignal(is->pictq_cond);\n\n    SDL_UnlockMutex(is->pictq_mutex);\n\n}", "answer": "NO", "cwe": "0", "idx": "f73d6d2af7a2b30a647d945b590962a2ab54ff3b"}
{"code": "static void megasas_handle_frame(MegasasState *s, uint64_t frame_addr,\n\n                                 uint32_t frame_count)\n\n{\n\n    uint8_t frame_status = MFI_STAT_INVALID_CMD;\n\n    uint64_t frame_context;\n\n    MegasasCmd *cmd;\n\n\n\n    \n\n    frame_context = megasas_frame_get_context(s, frame_addr);\n\n\n\n    cmd = megasas_enqueue_frame(s, frame_addr, frame_context, frame_count);\n\n    if (!cmd) {\n\n        \n\n        trace_megasas_frame_busy(frame_addr);\n\n        megasas_frame_set_scsi_status(s, frame_addr, BUSY);\n\n        megasas_frame_set_cmd_status(s, frame_addr, MFI_STAT_SCSI_DONE_WITH_ERROR);\n\n        megasas_complete_frame(s, frame_context);\n\n        s->event_count++;\n\n        return;\n\n    }\n\n    switch (cmd->frame->header.frame_cmd) {\n\n    case MFI_CMD_INIT:\n\n        frame_status = megasas_init_firmware(s, cmd);\n\n        break;\n\n    case MFI_CMD_DCMD:\n\n        frame_status = megasas_handle_dcmd(s, cmd);\n\n        break;\n\n    case MFI_CMD_ABORT:\n\n        frame_status = megasas_handle_abort(s, cmd);\n\n        break;\n\n    case MFI_CMD_PD_SCSI_IO:\n\n        frame_status = megasas_handle_scsi(s, cmd, 0);\n\n        break;\n\n    case MFI_CMD_LD_SCSI_IO:\n\n        frame_status = megasas_handle_scsi(s, cmd, 1);\n\n        break;\n\n    case MFI_CMD_LD_READ:\n\n    case MFI_CMD_LD_WRITE:\n\n        frame_status = megasas_handle_io(s, cmd);\n\n        break;\n\n    default:\n\n        trace_megasas_unhandled_frame_cmd(cmd->index,\n\n                                          cmd->frame->header.frame_cmd);\n\n        s->event_count++;\n\n        break;\n\n    }\n\n    if (frame_status != MFI_STAT_INVALID_STATUS) {\n\n        if (cmd->frame) {\n\n            cmd->frame->header.cmd_status = frame_status;\n\n        } else {\n\n            megasas_frame_set_cmd_status(s, frame_addr, frame_status);\n\n        }\n\n        megasas_unmap_frame(s, cmd);\n\n        megasas_complete_frame(s, cmd->context);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "8cc46787b5b58f01a11c919c7ff939ed009e27fc"}
{"code": "MagickExport MagickBooleanType LevelImageColors(Image *image,\n  const PixelInfo *black_color,const PixelInfo *white_color,\n  const MagickBooleanType invert,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  MagickStatusType\n    status;\n\n  \n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&\n      ((IsGrayColorspace(black_color->colorspace) == MagickFalse) ||\n       (IsGrayColorspace(white_color->colorspace) == MagickFalse)))\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  if (invert == MagickFalse)\n    {\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        {\n          channel_mask=SetImageChannelMask(image,RedChannel);\n          status&=LevelImage(image,black_color->red,white_color->red,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        {\n          channel_mask=SetImageChannelMask(image,GreenChannel);\n          status&=LevelImage(image,black_color->green,white_color->green,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        {\n          channel_mask=SetImageChannelMask(image,BlueChannel);\n          status&=LevelImage(image,black_color->blue,white_color->blue,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n          channel_mask=SetImageChannelMask(image,BlackChannel);\n          status&=LevelImage(image,black_color->black,white_color->black,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->alpha_trait != UndefinedPixelTrait))\n        {\n          channel_mask=SetImageChannelMask(image,AlphaChannel);\n          status&=LevelImage(image,black_color->alpha,white_color->alpha,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n    }\n  else\n    {\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        {\n          channel_mask=SetImageChannelMask(image,RedChannel);\n          status&=LevelizeImage(image,black_color->red,white_color->red,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        {\n          channel_mask=SetImageChannelMask(image,GreenChannel);\n          status&=LevelizeImage(image,black_color->green,white_color->green,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        {\n          channel_mask=SetImageChannelMask(image,BlueChannel);\n          status&=LevelizeImage(image,black_color->blue,white_color->blue,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if (((GetPixelBlackTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->colorspace == CMYKColorspace))\n        {\n          channel_mask=SetImageChannelMask(image,BlackChannel);\n          status&=LevelizeImage(image,black_color->black,white_color->black,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n      if (((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0) &&\n          (image->alpha_trait != UndefinedPixelTrait))\n        {\n          channel_mask=SetImageChannelMask(image,AlphaChannel);\n          status&=LevelizeImage(image,black_color->alpha,white_color->alpha,1.0,\n            exception);\n          (void) SetImageChannelMask(image,channel_mask);\n        }\n    }\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "answer": "NO", "cwe": "125", "idx": "50554"}
{"code": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        \n\n        \n\n        \n\n        \n\n        if (sbr->num_patches > 5) {\n\n            av_log(ac->avctx, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n            return -1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "c2340831b8e9032716acb0aab4893d3cc500213a"}
{"code": "void tcg_gen_mb(TCGBar mb_type)\n\n{\n\n    if (parallel_cpus) {\n\n        tcg_gen_op1(INDEX_op_mb, mb_type);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "e82d5a2460b0e176128027651ff9b104e4bdf5cc"}
{"code": "static inline double InverseScaledSigmoidal(const double a,const double b,\n  const double x)\n{\n  const double sig0=Sigmoidal(a,b,0.0);\n  const double sig1=Sigmoidal(a,b,1.0);\n  const double argument=(sig1-sig0)*x+sig0;\n  const double clamped=\n    (\n#if defined(MAGICKCORE_HAVE_ATANH)\n      argument < -1+MagickEpsilon\n      ?\n      -1+MagickEpsilon\n      :\n      ( argument > 1-MagickEpsilon ? 1-MagickEpsilon : argument )\n    );\n  return(b+(2.0/a)*atanh(clamped));\n#else\n      argument < MagickEpsilon\n      ?\n      MagickEpsilon\n      :\n      ( argument > 1-MagickEpsilon ? 1-MagickEpsilon : argument )\n    );\n  return(b-log(1.0/clamped-1.0)/a);\n#endif\n}", "answer": "NO", "cwe": "125", "idx": "50552"}
{"code": "static SpiceCharDeviceMsgToClient *vdi_port_read_one_msg_from_device(SpiceCharDeviceInstance *sin,\n                                                                     void *opaque)\n{\n    VDIPortState *state = &reds->agent_state;\n    SpiceCharDeviceInterface *sif;\n    VDIReadBuf *dispatch_buf;\n    int n;\n\n    if (!vdagent) {\n        return NULL;\n    }\n    spice_assert(vdagent == sin);\n    sif = SPICE_CONTAINEROF(vdagent->base.sif, SpiceCharDeviceInterface, base);\n    while (vdagent) {\n        switch (state->read_state) {\n        case VDI_PORT_READ_STATE_READ_HEADER:\n            n = sif->read(vdagent, state->receive_pos, state->receive_len);\n            if (!n) {\n                return NULL;\n            }\n            if ((state->receive_len -= n)) {\n                state->receive_pos += n;\n                return NULL;\n            }\n            state->message_receive_len = state->vdi_chunk_header.size;\n            state->read_state = VDI_PORT_READ_STATE_GET_BUFF;\n        case VDI_PORT_READ_STATE_GET_BUFF: {\n            if (!(state->current_read_buf = vdi_port_read_buf_get())) {\n                return NULL;\n            }\n            state->receive_pos = state->current_read_buf->data;\n            state->receive_len = MIN(state->message_receive_len,\n                                    sizeof(state->current_read_buf->data));\n            state->current_read_buf->len = state->receive_len;\n            state->message_receive_len -= state->receive_len;\n            state->read_state = VDI_PORT_READ_STATE_READ_DATA;\n        }\n        case VDI_PORT_READ_STATE_READ_DATA:\n            n = sif->read(vdagent, state->receive_pos, state->receive_len);\n            if (!n) {\n                return NULL;\n            }\n            if ((state->receive_len -= n)) {\n                state->receive_pos += n;\n                break;\n            }\n            dispatch_buf = state->current_read_buf;\n            state->current_read_buf = NULL;\n            state->receive_pos = NULL;\n            if (state->message_receive_len == 0) {\n                state->read_state = VDI_PORT_READ_STATE_READ_HEADER;\n                state->receive_pos = (uint8_t *)&state->vdi_chunk_header;\n                state->receive_len = sizeof(state->vdi_chunk_header);\n            } else {\n                state->read_state = VDI_PORT_READ_STATE_GET_BUFF;\n            }\n            if (vdi_port_read_buf_process(state->vdi_chunk_header.port, dispatch_buf)) {\n                return dispatch_buf;\n            } else {\n                vdi_port_read_buf_unref(dispatch_buf);\n            }\n        } \n    } \n    return NULL;\n}", "answer": "NO", "cwe": "119", "idx": "2014"}
{"code": "static int __einj_get_available_error_type(u32 *type)\n{\n\tstruct apei_exec_context ctx;\n\tint rc;\n\n\teinj_exec_ctx_init(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_ERROR_TYPE);\n\tif (rc)\n\t\treturn rc;\n\t*type = apei_exec_ctx_get_output(&ctx);\n\n\treturn 0;\n}", "answer": "NO", "cwe": "74", "idx": "73876"}
{"code": "void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)\n\n{\n\n    unsigned char *end;\n\n    int filter_value;\n\n    const int nstride= -stride;\n\n\n\n    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {\n\n        filter_value =\n\n            (first_pixel[2 * nstride] - first_pixel[ stride])\n\n         +3*(first_pixel[0          ] - first_pixel[nstride]);\n\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n\n        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);\n\n        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "28f9ab7029bd1a02f659995919f899f84ee7361b"}
{"code": "static void qdev_prop_set(DeviceState *dev, const char *name, void *src, enum PropertyType type)\n\n{\n\n    Property *prop;\n\n\n\n    prop = qdev_prop_find(dev, name);\n\n    if (!prop) {\n\n        fprintf(stderr, \"%s: property \\\"%s.%s\\\" not found\\n\",\n\n                __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n\n        abort();\n\n    }\n\n    if (prop->info->type != type) {\n\n        fprintf(stderr, \"%s: property \\\"%s.%s\\\" type mismatch\\n\",\n\n                __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n\n        abort();\n\n    }\n\n    qdev_prop_cpy(dev, prop, src);\n\n}", "answer": "NO", "cwe": "0", "idx": "7a7aae21ccab06606cee9aba846d2e30cb616763"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_console_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123138"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * dataArray[]);\n\nvoid m()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89858"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_18\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    wcscat(data, L\"file.txt\");\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_18; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91853"}
{"code": "static PHP_FUNCTION(session_regenerate_id)\n{\n\tzend_bool del_ses = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &del_ses) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SG(headers_sent) && PS(use_cookies)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot regenerate session id - headers already sent\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (PS(session_status) == php_session_active) {\n\t\tif (PS(id)) {\n\t\t\tif (del_ses && PS(mod)->s_destroy(&PS(mod_data), PS(id) TSRMLS_CC) == FAILURE) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Session object destruction failed\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tefree(PS(id));\n\t\t}\n\n\t\tPS(id) = PS(mod)->s_create_sid(&PS(mod_data), NULL TSRMLS_CC);\n\t\tif (PS(id)) {\n\t\t\tPS(send_cookie) = 1;\n\t\t\tphp_session_reset_id(TSRMLS_C);\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tPS(id) = STR_EMPTY_ALLOC();\n\t\t}\n\t}\n\tRETURN_FALSE;\n}", "answer": "NO", "cwe": "74", "idx": "50216"}
{"code": "static inline void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    \n\n                pix[0]        = av_clip_uint8( q0 - delta );    \n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "3f50965b28d0c4ef10dde0bf2f7a9f78fa36b378"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_listen_socket_fopen_34\n{\n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} unionType;\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            FILE *pFile = NULL;\n            \n            pFile = FOPEN(data, \"wb+\");\n            if (pFile != NULL)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            FILE *pFile = NULL;\n            \n            pFile = FOPEN(data, \"wb+\");\n            if (pFile != NULL)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_fopen_34; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90563"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_fopen_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_fopen_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95807"}
{"code": "void avcodec_get_channel_layout_string(char *buf, int buf_size, int nb_channels, int64_t channel_layout)\n\n{\n\n    int i;\n\n\n\n    if (channel_layout==0)\n\n        channel_layout = avcodec_guess_channel_layout(nb_channels, CODEC_ID_NONE, NULL);\n\n\n\n    for (i=0; channel_layout_map[i].name; i++)\n\n        if (nb_channels    == channel_layout_map[i].nb_channels &&\n\n            channel_layout == channel_layout_map[i].layout) {\n\n            snprintf(buf, buf_size, channel_layout_map[i].name);\n\n            return;\n\n        }\n\n\n\n    snprintf(buf, buf_size, \"%d channels\", nb_channels);\n\n    if (channel_layout) {\n\n        int i,ch;\n\n        av_strlcat(buf, \" (\", buf_size);\n\n        for(i=0,ch=0; i<64; i++) {\n\n            if ((channel_layout & (1L<<i))) {\n\n                const char *name = get_channel_name(i);\n\n                if (name) {\n\n                    if (ch>0) av_strlcat(buf, \"|\", buf_size);\n\n                    av_strlcat(buf, name, buf_size);\n\n                }\n\n                ch++;\n\n            }\n\n        }\n\n        av_strlcat(buf, \")\", buf_size);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "862c1d2f0573c81ed0929b685c55959906b4300c"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint reunited_semiminess = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *pebworth_woolwich = 0;\n  jmp_buf commemorable_muliebrity;\n  int suppedit_forfeited;\n  char *outrapped_lesli = 0;\n  int *postvorta_stolkjaerre = 0;\n  int animalizing_verdure;\n  char *kopeks_superlunar[10] = {0};\n  int vetchiest_unavoidableness = 0;\n  char *handicrafts_khis = 0;\n  char *comedo_cephalology;;\n  if (__sync_bool_compare_and_swap(&reunited_semiminess,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      comedo_cephalology = getenv(\"SATSUMA_BLAMES\");\n      if (comedo_cephalology != 0) {;\n        vetchiest_unavoidableness = ((int )(strlen(comedo_cephalology)));\n        handicrafts_khis = ((char *)(malloc(vetchiest_unavoidableness + 1)));\n        if (handicrafts_khis == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(handicrafts_khis,0,vetchiest_unavoidableness + 1);\n        memcpy(handicrafts_khis,comedo_cephalology,vetchiest_unavoidableness);\n        animalizing_verdure = 5;\n        postvorta_stolkjaerre = &animalizing_verdure;\n        kopeks_superlunar[ *postvorta_stolkjaerre] = handicrafts_khis;\n        outrapped_lesli = kopeks_superlunar[ *postvorta_stolkjaerre];\n        suppedit_forfeited = setjmp(commemorable_muliebrity);\n        if (suppedit_forfeited == 0) {\n          longjmp(commemorable_muliebrity,1);\n        }\n        pebworth_woolwich = ((char *)outrapped_lesli);\n    \n    taint_size = strlen(pebworth_woolwich);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,pebworth_woolwich,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n        if (outrapped_lesli != 0) \n          free(((char *)outrapped_lesli));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "401", "idx": "151475"}
{"code": "static ssize_t lifetime_write_kbytes_show(struct f2fs_attr *a,\n\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->sb;\n\n\tif (!sb->s_bdev->bd_part)\n\t\treturn snprintf(buf, PAGE_SIZE, \"0\\n\");\n\n\treturn snprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t(unsigned long long)(sbi->kbytes_written +\n\t\t\tBD_PART_WRITTEN(sbi)));\n}", "answer": "NO", "cwe": "129", "idx": "63892"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54bSink(char * data);\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__char_environment_w32_execvp_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_environment_w32_execvp_54bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245211"}
{"code": "static int vmdk_write(BlockDriverState *bs, int64_t sector_num,\n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent = NULL;\n\n    int n;\n\n    int64_t index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    VmdkMetaData m_data;\n\n\n\n    if (sector_num > bs->total_sectors) {\n\n        fprintf(stderr,\n\n                \"(VMDK) Wrong offset: sector_num=0x%\" PRIx64\n\n                \" total_sectors=0x%\" PRIx64 \"\\n\",\n\n                sector_num, bs->total_sectors);\n\n        return -1;\n\n    }\n\n\n\n    while (nb_sectors > 0) {\n\n        extent = find_extent(s, sector_num, extent);\n\n        if (!extent) {\n\n            return -EIO;\n\n        }\n\n        cluster_offset = get_cluster_offset(\n\n                                bs,\n\n                                extent,\n\n                                &m_data,\n\n                                sector_num << 9, 1);\n\n        if (!cluster_offset) {\n\n            return -1;\n\n        }\n\n        index_in_cluster = sector_num % extent->cluster_sectors;\n\n        n = extent->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (bdrv_pwrite(bs->file,\n\n                        cluster_offset + index_in_cluster * 512,\n\n                        buf, n * 512)\n\n                != n * 512) {\n\n            return -1;\n\n        }\n\n        if (m_data.valid) {\n\n            \n\n            if (vmdk_L2update(extent, &m_data) == -1) {\n\n                return -1;\n\n            }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n\n\n        \n\n        if (!s->cid_updated) {\n\n            vmdk_write_cid(bs, time(NULL));\n\n            s->cid_updated = true;\n\n        }\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "91b85bd388c3767e6b63aaf33851dbfe87ea24d1"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_environment_63bSink(char * * dataPtr);\n\nvoid _LDAP_Injection__w32_char_environment_63()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_char_environment_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_environment_63bG2BSink(char * * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_environment_63bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_char_environment_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122978"}
{"code": "static int ext4_run_li_request(struct ext4_li_request *elr)\n{\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t group, ngroups;\n\tstruct super_block *sb;\n\tunsigned long timeout = 0;\n\tint ret = 0;\n\n\tsb = elr->lr_super;\n\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tfor (group = elr->lr_next_group; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tbreak;\n\t}\n\n\tif (group >= ngroups)\n\t\tret = 1;\n\n\tif (!ret) {\n\t\ttimeout = jiffies;\n\t\tret = ext4_init_inode_table(sb, group,\n\t\t\t\t\t    elr->lr_timeout ? 0 : 1);\n\t\tif (elr->lr_timeout == 0) {\n\t\t\ttimeout = (jiffies - timeout) *\n\t\t\t\t  elr->lr_sbi->s_li_wait_mult;\n\t\t\telr->lr_timeout = timeout;\n\t\t}\n\t\telr->lr_next_sched = jiffies + elr->lr_timeout;\n\t\telr->lr_next_group = group + 1;\n\t}\n\treturn ret;\n}", "answer": "NO", "cwe": "125", "idx": "70546"}
{"code": "static void nfs_process_write(void *arg)\n\n{\n\n    NFSClient *client = arg;\n\n\n\n    aio_context_acquire(client->aio_context);\n\n    nfs_service(client->context, POLLOUT);\n\n    nfs_set_events(client);\n\n    aio_context_release(client->aio_context);\n\n}", "answer": "NO", "cwe": "0", "idx": "37d1e4d9bfac846a1331375aab3d13b54a048c01"}
{"code": "notify_fifo_open(notify_fifo_t* global_fifo, notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\t\n\tif (global_fifo->name)\n\t\tfifo_open(global_fifo, script_exit, \"\");\n\n\t\n\tif (fifo->name)\n\t\tfifo_open(fifo, script_exit, type);\n}", "answer": "NO", "cwe": "59", "idx": "76128"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint reba_brussel = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid trilloes_arranger(char **arterialization_jebel);\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  void (*unwarely_carbin)(char **) = trilloes_arranger;\n  char **cancers_vesuvian = 0;\n  char **lum_ammocoetoid = 0;\n  int thalian_malleating = 0;\n  char *preciosities_protomorph = 0;\n  char *magnetons_ice;;\n  if (__sync_bool_compare_and_swap(&reba_brussel,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&magnetons_ice,\"WESKER_ZAPS\");\n      if (magnetons_ice != 0) {;\n        thalian_malleating = ((int )(strlen(magnetons_ice)));\n        preciosities_protomorph = ((char *)(malloc(thalian_malleating + 1)));\n        if (preciosities_protomorph == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(preciosities_protomorph,0,thalian_malleating + 1);\n        memcpy(preciosities_protomorph,magnetons_ice,thalian_malleating);\n        if (magnetons_ice != 0) \n          free(((char *)magnetons_ice));\n        cancers_vesuvian = &preciosities_protomorph;\n        lum_ammocoetoid = cancers_vesuvian + 5;\n        unwarely_carbin(lum_ammocoetoid);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid trilloes_arranger(char **arterialization_jebel)\n{\n char *buffer = 0;\n  char *temesv_threefolded = 0;\n  ++global_variable;;\n  temesv_threefolded = ((char *)( *(arterialization_jebel - 5)));\n    \n    buffer = malloc((strlen(temesv_threefolded) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,temesv_threefolded);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n  if ( *(arterialization_jebel - 5) != 0) \n    free(((char *)( *(arterialization_jebel - 5))));\nclose_printf_context();\n}\n#endif", "answer": "YES", "cwe": "415", "idx": "153245"}
{"code": "static void elcr_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    s->elcr = val & s->elcr_mask;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "static int piix3_post_load(void *opaque, int version_id)\n\n{\n\n    PIIX3State *piix3 = opaque;\n\n    int pirq;\n\n\n\n    \n\n    piix3->pic_levels = 0;\n\n    for (pirq = 0; pirq < PIIX_NUM_PIRQS; pirq++) {\n\n        piix3_set_irq_level_internal(piix3, pirq,\n\n                            pci_bus_get_irq_level(piix3->dev.bus, pirq));\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "fd56e0612b6454a282fa6a953fdb09281a98c589"}
{"code": "LIBOPENMPT_MODPLUG_API int ModPlug_GetPlayingChannels(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_playing_channels(file->mod);\n}", "answer": "NO", "cwe": "120", "idx": "87638"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <unistd.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint rebilling_parallelable = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n int oc_i = 0;\n int opt_var;\n  char *usherian_fontinas = 0;\n  jmp_buf tungus_unseduced;\n  int labdanum_liber;\n  char **droopiness_chiniks = 0;\n  long tswanas_orthopyramid[10];\n  char **unirritableness_furrily[10] = {0};\n  char *muscularities_balistraria[32] = {0};\n  char *urinoscopy_papulan;;\n  if (__sync_bool_compare_and_swap(&rebilling_parallelable,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      urinoscopy_papulan = getenv(\"VIOLATER_PAPISTICAL\");\n      if (urinoscopy_papulan != 0) {;\n        muscularities_balistraria[7] = urinoscopy_papulan;\n        unirritableness_furrily[5] = muscularities_balistraria;\n        tswanas_orthopyramid[1] = 5;\n        droopiness_chiniks =  *(unirritableness_furrily + tswanas_orthopyramid[1]);\n        labdanum_liber = setjmp(tungus_unseduced);\n        if (labdanum_liber == 0) {\n          longjmp(tungus_unseduced,1);\n        }\n        usherian_fontinas = ((char *)droopiness_chiniks[7]);\n    \n size_t (*canary_pointer[1])(const char *);\n char base_path[20];\n    if (strlen(usherian_fontinas) < 20) {\n        canary_pointer[0] = strlen;\n        memset(base_path,0,20);\n        \n        \n        \n        \n        \n        \n        \n  \n  \n        realpath(usherian_fontinas,base_path);\n        opt_var = canary_pointer[0](base_path);\n        \n        for (; oc_i < opt_var; ++oc_i) {\n   base_path[oc_i] = toupper(base_path[oc_i]);\n        }\n        printf(\"%s\\n\",base_path);\n        \n        \n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "YES", "cwe": "785", "idx": "153602"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_17()\n{\n    int i;\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81994"}
{"code": "static int32_t modplugresamplingmode_to_filterlength(int mode)\n{\n\tif(mode<0){\n\t\treturn 1;\n\t}\n\tswitch(mode){\n\tcase MODPLUG_RESAMPLE_NEAREST: return 1; break;\n\tcase MODPLUG_RESAMPLE_LINEAR: return 2; break;\n\tcase MODPLUG_RESAMPLE_SPLINE: return 4; break;\n\tcase MODPLUG_RESAMPLE_FIR: return 8; break;\n\t}\n\treturn 8;\n}", "answer": "NO", "cwe": "120", "idx": "87652"}
{"code": "static void trigger_access_exception(CPUS390XState *env, uint32_t type,\n\n                                     uint32_t ilen, uint64_t tec)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_s390_access_exception(cpu, type, tec);\n\n    } else {\n\n        CPUState *cs = CPU(cpu);\n\n        stq_phys(cs->as, env->psa + offsetof(LowCore, trans_exc_code), tec);\n\n        trigger_pgm_exception(env, type, ilen);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "820613b1c1c76cb77a15313eb333a710972614ec"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint rodie_mall = 0;\n\nstruct aerologists_budgereegah \n{\n  char *jori_piggins;\n  double hypoparia_theologal;\n  char *stahlhelm_inspections;\n  char unsucculently_sororate;\n  int valera_aleichem;\n}\n;\nint global_variable;\nvoid handle_taint(char *uncareful_migrate);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid nonelaborate_semmit(struct aerologists_budgereegah brief_unhit);\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&rodie_mall,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *uncareful_migrate)\n{\n  struct aerologists_budgereegah sulpician_shufflers = {0};\n  long impatiens_lustrical[10];\n  struct aerologists_budgereegah shippens_orotinan[10] = {0};\n  struct aerologists_budgereegah taliacotian_hypertoxic;\n  ++global_variable;;\n  if (uncareful_migrate != 0) {;\n    taliacotian_hypertoxic . jori_piggins = ((char *)uncareful_migrate);\n    shippens_orotinan[5] = taliacotian_hypertoxic;\n    impatiens_lustrical[1] = 5;\n    sulpician_shufflers =  *(shippens_orotinan + impatiens_lustrical[1]);\n    nonelaborate_semmit(sulpician_shufflers);\n  }\n}\n\nvoid nonelaborate_semmit(struct aerologists_budgereegah brief_unhit)\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *seamlessly_uniangulate = 0;\n  ++global_variable;;\n  seamlessly_uniangulate = ((char *)brief_unhit . jori_piggins);\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(seamlessly_uniangulate,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\n  if (brief_unhit . jori_piggins != 0) \n    free(((char *)brief_unhit . jori_piggins));\nclose_printf_context();\n}", "answer": "YES", "cwe": "771", "idx": "151694"}
{"code": "static RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev_raw(const ut8 *obuf, size_t len, int mode) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, spec1, spec2, offset;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tr_bin_dwarf_init_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp);\n\t\tif (!buf || !tmp) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->length == da->capacity) {\n\t\t\tr_bin_dwarf_expand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->length];\n\t\tr_bin_dwarf_init_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->length == tmpdecl->capacity) {\n\t\t\t\tr_bin_dwarf_expand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &spec1);\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &spec2);\n\t\t\ttmpdecl->specs[tmpdecl->length].attr_name = spec1;\n\t\t\ttmpdecl->specs[tmpdecl->length].attr_form = spec2;\n\t\t\ttmpdecl->length++;\n\t\t} while (spec1 && spec2);\n\n\t\tda->length++;\n\t}\n\n\tif (mode == R_CORE_BIN_PRINT) {\n\t\tdump_r_bin_dwarf_debug_abbrev (stdout, da);\n\t}\n\treturn da;\n}", "answer": "NO", "cwe": "125", "idx": "59707"}
{"code": "void UrlmonUrlRequestManager::StopAll() {\n  DVLOG(1) << __FUNCTION__;\n  if (stopping_)\n    return;\n\n  stopping_ = true;\n\n  DVLOG(1) << __FUNCTION__ << \" stopping \" << request_map_.size()\n           << \" requests\";\n\n  for (RequestMap::iterator it = request_map_.begin();\n       it != request_map_.end(); ++it) {\n    DCHECK(it->second != NULL);\n    it->second->Stop();\n  }\n\n  request_map_.clear();\n}", "answer": "NO", "cwe": "119", "idx": "105850"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_connect_socket_w32_spawnlp_16()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcat(data, \"*.*\");\n        break;\n    }\n    \n    \n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_connect_socket_w32_spawnlp_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_connect_socket_w32_spawnlp_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_connect_socket_w32_spawnlp_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244298"}
{"code": "static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        \n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "8b34a9dbc3f2c0afe3450cb20b94cc30f450e77b"}
{"code": "static unsigned f2fs_max_namelen(struct inode *inode)\n{\n\treturn S_ISLNK(inode->i_mode) ?\n\t\t\tinode->i_sb->s_blocksize : F2FS_NAME_LEN;\n}", "answer": "NO", "cwe": "129", "idx": "63870"}
{"code": "SocketAddress *socket_local_address(int fd, Error **errp)\n\n{\n\n    struct sockaddr_storage ss;\n\n    socklen_t sslen = sizeof(ss);\n\n\n\n    if (getsockname(fd, (struct sockaddr *)&ss, &sslen) < 0) {\n\n        error_setg_errno(errp, errno, \"%s\",\n\n                         \"Unable to query local socket address\");\n\n        return NULL;\n\n    }\n\n\n\n    return socket_sockaddr_to_address(&ss, sslen, errp);\n\n}", "answer": "NO", "cwe": "0", "idx": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc"}
{"code": "bool DownloadItemImpl::IsPaused() const { return is_paused_; }", "answer": "NO", "cwe": "119", "idx": "113076"}
{"code": "ReadUserLogState::ReadUserLogState(\n\tconst char\t\t*path,\n\tint\t\t\t\t max_rotations,\n\tint\t\t\t\t recent_thresh )\n\t: ReadUserLogFileState( )\n{\n\tReset( RESET_INIT );\n\tm_max_rotations = max_rotations;\n\tm_recent_thresh = recent_thresh;\n\tif ( path ) {\n\t\tm_base_path = path;\n\t}\n\tm_initialized = true;\n\tm_update_time = 0;\n}", "answer": "NO", "cwe": "134", "idx": "16633"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nint _LDAP_Injection__w32_wchar_t_environment_22Global = 0;\n\nwchar_t * _LDAP_Injection__w32_wchar_t_environment_22Source(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_environment_22()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_wchar_t_environment_22Global = 1; \n    data = _LDAP_Injection__w32_wchar_t_environment_22Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _LDAP_Injection__w32_wchar_t_environment_22G2B1Global = 0;\nint _LDAP_Injection__w32_wchar_t_environment_22G2B2Global = 0;\n\n\nwchar_t * _LDAP_Injection__w32_wchar_t_environment_22G2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_wchar_t_environment_22G2B1Global = 0; \n    data = _LDAP_Injection__w32_wchar_t_environment_22G2B1Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nwchar_t * _LDAP_Injection__w32_wchar_t_environment_22G2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    _LDAP_Injection__w32_wchar_t_environment_22G2B2Global = 1; \n    data = _LDAP_Injection__w32_wchar_t_environment_22G2B2Source(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123202"}
{"code": "av_cold int ff_h264_decode_init(AVCodecContext *avctx)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    int ret;\n\n\n\n    ret = h264_init_context(avctx, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n\n    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));\n\n\n\n    \n\n    \n\n    if (!avctx->has_b_frames)\n\n        h->low_delay = 1;\n\n\n\n    ff_h264_decode_init_vlc();\n\n\n\n    ff_init_cabac_states();\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_H264) {\n\n        if (avctx->ticks_per_frame == 1)\n\n            h->avctx->framerate.num *= 2;\n\n        avctx->ticks_per_frame = 2;\n\n    }\n\n\n\n    if (avctx->extradata_size > 0 && avctx->extradata) {\n\n       ret = ff_h264_decode_extradata(h);\n\n       if (ret < 0) {\n\n           ff_h264_free_context(h);\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    if (h->sps.bitstream_restriction_flag &&\n\n        h->avctx->has_b_frames < h->sps.num_reorder_frames) {\n\n        h->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n        h->low_delay           = 0;\n\n    }\n\n\n\n    avctx->internal->allocate_progress = 1;\n\n\n\n    if (h->enable_er) {\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Error resilience is enabled. It is unsafe and unsupported and may crash. \"\n\n               \"Use it at your own risk\\n\");\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "65afa65e7393e7745427e267d6c6ca814c7c8b45"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_18\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    wcscat(data, L\"file.txt\");\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_18; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90989"}
{"code": "static void hns_gmac_get_port_mode(void *mac_drv, enum hns_port_mode *port_mode)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\t*port_mode = (enum hns_port_mode)dsaf_get_dev_field(\n\t\tdrv, GMAC_PORT_MODE_REG, GMAC_PORT_MODE_M, GMAC_PORT_MODE_S);\n}", "answer": "NO", "cwe": "119", "idx": "85542"}
{"code": "static UserDefNested *nested_struct_create(void)\n\n{\n\n    UserDefNested *udnp = g_malloc0(sizeof(*udnp));\n\n    udnp->string0 = strdup(\"test_string0\");\n\n    udnp->dict1.string1 = strdup(\"test_string1\");\n\n    udnp->dict1.dict2.userdef1 = g_malloc0(sizeof(UserDefOne));\n\n    udnp->dict1.dict2.userdef1->base = g_new0(UserDefZero, 1);\n\n    udnp->dict1.dict2.userdef1->base->integer = 42;\n\n    udnp->dict1.dict2.userdef1->string = strdup(\"test_string\");\n\n    udnp->dict1.dict2.string2 = strdup(\"test_string2\");\n\n    udnp->dict1.has_dict3 = true;\n\n    udnp->dict1.dict3.userdef2 = g_malloc0(sizeof(UserDefOne));\n\n    udnp->dict1.dict3.userdef2->base = g_new0(UserDefZero, 1);\n\n    udnp->dict1.dict3.userdef2->base->integer = 43;\n\n    udnp->dict1.dict3.userdef2->string = strdup(\"test_string\");\n\n    udnp->dict1.dict3.string3 = strdup(\"test_string3\");\n\n    return udnp;\n\n}", "answer": "NO", "cwe": "0", "idx": "b6fcf32d9b851a83dedcb609091236b97cc4a985"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_10()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246468"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_open_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_open_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89761"}
{"code": "void *address_space_map(AddressSpace *as,\n\n                        target_phys_addr_t addr,\n\n                        target_phys_addr_t *plen,\n\n                        bool is_write)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n    target_phys_addr_t len = *plen;\n\n    target_phys_addr_t todo = 0;\n\n    int l;\n\n    target_phys_addr_t page;\n\n    MemoryRegionSection *section;\n\n    ram_addr_t raddr = RAM_ADDR_MAX;\n\n    ram_addr_t rlen;\n\n    void *ret;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        section = phys_page_find(d, page >> TARGET_PAGE_BITS);\n\n\n\n        if (!(memory_region_is_ram(section->mr) && !section->readonly)) {\n\n            if (todo || bounce.buffer) {\n\n                break;\n\n            }\n\n            bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, TARGET_PAGE_SIZE);\n\n            bounce.addr = addr;\n\n            bounce.len = l;\n\n            if (!is_write) {\n\n                address_space_read(as, addr, bounce.buffer, l);\n\n            }\n\n\n\n            *plen = l;\n\n            return bounce.buffer;\n\n        }\n\n        if (!todo) {\n\n            raddr = memory_region_get_ram_addr(section->mr)\n\n                + memory_region_section_addr(section, addr);\n\n        }\n\n\n\n        len -= l;\n\n        addr += l;\n\n        todo += l;\n\n    }\n\n    rlen = todo;\n\n    ret = qemu_ram_ptr_length(raddr, &rlen);\n\n    *plen = rlen;\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint amyrol_reintrude = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid debatter_lawproof(char **const richers_recusancy);\nvoid drepanaspis_veneti(char **beele_volatilized);\nint toupper(int c) {\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nvoid free_func(char *buff) {\n  \n  if (buff[0] >= 79) {\n    \n    \n    \n    \n    free(buff);\n    \n    \n  }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char *collineation_anatomising[84] = {0};\n  char *anticentralism_droner;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&amyrol_reintrude,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      anticentralism_droner = getenv(\"CARBOLXYLOL_NONPACIFICATORY\");\n      if (anticentralism_droner != 0) {;\n        collineation_anatomising[60] = anticentralism_droner;\n        debatter_lawproof(collineation_anatomising);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid debatter_lawproof(char **const richers_recusancy)\n{\n  ++global_variable;;\n  drepanaspis_veneti(richers_recusancy);\n}\n\nvoid drepanaspis_veneti(char **beele_volatilized)\n{\n int oc_i = 0;\n char function_buff[64];\n  char *uniatism_aplustra = 0;\n  ++global_variable;;\n  uniatism_aplustra = ((char *)((char **)beele_volatilized)[60]);\n    \n strncpy(function_buff,uniatism_aplustra,63);\n    function_buff[63] = '\\0';\n    for (; oc_i < 64; ++oc_i) {\n        function_buff[oc_i] = toupper(function_buff[oc_i]);\n    }\n    printf(\"%s\\n\",function_buff);\n    free_func(function_buff);\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "590", "idx": "153310"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \nint stingbull_muscidae = 0;\nint global_variable;\n\nstruct presocialism_particularised \n{\n  char *deletive_unsupplicating;\n  double neurotropy_forepeak;\n  char *calyptriform_unrejoicing;\n  char reenlighten_gonadectomy;\n  int posteens_skeins;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nstruct presocialism_particularised debugged_nonrelativeness(struct presocialism_particularised wroken_hool);\n#define GRAPTOLITOIDEA_CATEGORIZATION(x) cleansers_zacata((struct presocialism_particularised) x)\nvoid cleansers_zacata(struct presocialism_particularised bebouldered_tubinares);\n\nunsigned int avdevice_version()\n{\n  struct presocialism_particularised barghests_nominated = {0};\n  struct presocialism_particularised rewelcome_schizophrene;\n  char *cakchikel_ensculpture;;\n  if (__sync_bool_compare_and_swap(&stingbull_muscidae,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      cakchikel_ensculpture = getenv(\"GUMBOILS_CARES\");\n      if (cakchikel_ensculpture != 0) {;\n        rewelcome_schizophrene . deletive_unsupplicating = ((char *)cakchikel_ensculpture);\n        barghests_nominated = debugged_nonrelativeness(rewelcome_schizophrene);\n\tGRAPTOLITOIDEA_CATEGORIZATION(barghests_nominated);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lssl -lpq -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nstruct presocialism_particularised debugged_nonrelativeness(struct presocialism_particularised wroken_hool)\n{\n  ++global_variable;\n  return wroken_hool;\n}\n\nvoid cleansers_zacata(struct presocialism_particularised bebouldered_tubinares)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int nFields;\n    int i;\n    int j = 0;\n  char *soliloquacious_alep = 0;\n  ++global_variable;;\n  soliloquacious_alep = ((char *)bebouldered_tubinares . deletive_unsupplicating);\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", soliloquacious_alep);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            \n            printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        nFields = PQnfields(res);\n        for (i = 0; i < nFields; i++)\n            printf(\"%-15s\", PQfname(res, i));\n        printf(\"\\n\\n\");\n        \n        for (i = 0; i < PQntuples(res); i++)\n        {\n            for (j = 0; j < nFields; j++)\n                printf(\"%-15s\", PQgetvalue(res, i, j));\n            printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "89", "idx": "152704"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_open_81\n{\n\nclass _Absolute_Path_Traversal__wchar_t_console_open_81_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__wchar_t_console_open_81 : public _Absolute_Path_Traversal__wchar_t_console_open_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__wchar_t_console_open_81G2B : public _Absolute_Path_Traversal__wchar_t_console_open_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "36", "idx": "97166"}
{"code": "static int xmv_read_header(AVFormatContext *s)\n\n{\n\n    XMVDemuxContext *xmv = s->priv_data;\n\n    AVIOContext     *pb  = s->pb;\n\n\n\n    uint32_t file_version;\n\n    uint32_t this_packet_size;\n\n    uint16_t audio_track;\n\n    int ret;\n\n\n\n    s->ctx_flags |= AVFMTCTX_NOHEADER;\n\n\n\n    avio_skip(pb, 4); \n\n\n\n    this_packet_size = avio_rl32(pb);\n\n\n\n    avio_skip(pb, 4); \n\n    avio_skip(pb, 4); \n\n\n\n    file_version = avio_rl32(pb);\n\n    if ((file_version != 4) && (file_version != 2))\n\n        avpriv_request_sample(s, \"Uncommon version %\"PRIu32\"\", file_version);\n\n\n\n    \n\n\n\n    xmv->video_width    = avio_rl32(pb);\n\n    xmv->video_height   = avio_rl32(pb);\n\n    xmv->video_duration = avio_rl32(pb);\n\n\n\n    \n\n\n\n    xmv->audio_track_count = avio_rl16(pb);\n\n\n\n    avio_skip(pb, 2); \n\n\n\n    xmv->audio = av_mallocz_array(xmv->audio_track_count, sizeof(XMVAudioPacket));\n\n    if (!xmv->audio) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    for (audio_track = 0; audio_track < xmv->audio_track_count; audio_track++) {\n\n        XMVAudioPacket *packet = &xmv->audio[audio_track];\n\n\n\n        packet->compression     = avio_rl16(pb);\n\n        packet->channels        = avio_rl16(pb);\n\n        packet->sample_rate     = avio_rl32(pb);\n\n        packet->bits_per_sample = avio_rl16(pb);\n\n        packet->flags           = avio_rl16(pb);\n\n\n\n        packet->bit_rate      = packet->bits_per_sample *\n\n                                packet->sample_rate *\n\n                                packet->channels;\n\n        packet->block_align   = XMV_BLOCK_ALIGN_SIZE * packet->channels;\n\n        packet->block_samples = 64;\n\n        packet->codec_id      = ff_wav_codec_get_id(packet->compression,\n\n                                                    packet->bits_per_sample);\n\n\n\n        packet->stream_index = -1;\n\n\n\n        packet->frame_size  = 0;\n\n        packet->block_count = 0;\n\n\n\n        \n\n        if (packet->flags & XMV_AUDIO_ADPCM51)\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported 5.1 ADPCM audio stream \"\n\n                                      \"(0x%04X)\\n\", packet->flags);\n\n\n\n        if (!packet->channels || !packet->sample_rate ||\n\n             packet->channels >= UINT16_MAX / XMV_BLOCK_ALIGN_SIZE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid parameters for audio track %\"PRIu16\".\\n\",\n\n                   audio_track);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n\n\n    \n\n\n\n    xmv->next_packet_offset = avio_tell(pb);\n\n    xmv->next_packet_size   = this_packet_size - xmv->next_packet_offset;\n\n    xmv->stream_count       = xmv->audio_track_count + 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    xmv_read_close(s);\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "34aeb5dbc4fe7267df5f0ebe2ec84c5a8d36a896"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint zink_caricographer = 0;\ntypedef char *palingenesian_countour;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\ntypedef int (*fct_ptr)(const char *, const char *);\nfct_ptr switch_func(char *param)\n{\n  \n  int var_len = 0;\n  fct_ptr fct_ptr_addr = (fct_ptr )0;\n  var_len = strlen(param) % 3;\n  if (var_len == 0) {\n    return strcmp;\n  }\n  else if (var_len == 1) {\n    return strcoll;\n  }\n  else {\n    sscanf(param,\"%p\",&fct_ptr_addr);\n    return fct_ptr_addr;\n  }\n}\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n int cmp_flag = 0;\n  char *genetyllis_procure = 0;\n  palingenesian_countour carnified_muddlement = 0;\n  char *lectionary_metallist;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&zink_caricographer,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&lectionary_metallist,\"PHOTOETCHING_INQUILINISM\");\n      if (lectionary_metallist != 0) {;\n        carnified_muddlement = lectionary_metallist;\n        genetyllis_procure = ((char *)carnified_muddlement);\n    \n    \n \n fct_ptr fp;\n const char *rand_word = \"criticisms_metallide\";\n fp = switch_func(genetyllis_procure);\n    \n    \n \n    \n    cmp_flag = ( *fp)(rand_word,genetyllis_procure);\n    \n    if (cmp_flag == 0)\n        printf(\"strings are equal\\n\");\n    else\n        printf(\"strings are not equal\\n\");\n    \n;\n        if (carnified_muddlement != 0) \n          free(((char *)carnified_muddlement));\nclose_printf_context();\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#endif \n#endif ", "answer": "YES", "cwe": "822", "idx": "153708"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint lovelass_xanthocyanopsy = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid periosteal_noncorporative(char *bushbody_cocopans);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n#define HONEYMOONSHINE_BLABBED(x) periosteal_noncorporative((char *) x)\n\nint timestamp_get_precision()\n{\n  char *clapper_tenography = 0;\n  long bayreuth_induvial[10];\n  char *formations_skiv[10] = {0};\n  char *geraniaceous_exomphalous;;\n  if (__sync_bool_compare_and_swap(&lovelass_xanthocyanopsy,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&geraniaceous_exomphalous,\"LOOKING_FACHINI\");\n      if (geraniaceous_exomphalous != 0) {;\n        formations_skiv[5] = geraniaceous_exomphalous;\n        bayreuth_induvial[1] = 5;\n        clapper_tenography =  *(formations_skiv + bayreuth_induvial[1]);\n\tHONEYMOONSHINE_BLABBED(clapper_tenography);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid periosteal_noncorporative(char *bushbody_cocopans)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *turgescent_nonvindication = 0;\n  ++global_variable;;\n  turgescent_nonvindication = ((char *)bushbody_cocopans);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(turgescent_nonvindication)+ 1));\n        if (cusData->data &&\n            (sscanf(turgescent_nonvindication, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if (bushbody_cocopans != 0) \n    free(((char *)bushbody_cocopans));\nclose_printf_context();\n}", "answer": "YES", "cwe": "663", "idx": "150170"}
{"code": "MODRET set_maxconnectsperhost(cmd_rec *cmd) {\n  int max;\n  config_rec *c;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[1], \"none\") == 0)\n    max = 0;\n\n  else {\n    char *tmp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &tmp, 10);\n\n    if ((tmp && *tmp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else\n    c = add_config_param(cmd->argv[0], 1, NULL);\n\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n  *((unsigned int *) c->argv[0]) = max;\n\n  return PR_HANDLED(cmd);\n}", "answer": "NO", "cwe": "59", "idx": "67616"}
{"code": "static int fsmRmdir(const char *path)\n{\n    int rc = rmdir(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}", "answer": "NO", "cwe": "59", "idx": "67497"}
{"code": "void **lxc_append_null_to_array(void **array, size_t count)\n{\n\tvoid **temp;\n\n\t\n\tif (count) {\n\t\ttemp = realloc(array, (count + 1) * sizeof(*array));\n\t\tif (!temp) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tfree(array[i]);\n\t\t\tfree(array);\n\t\t\treturn NULL;\n\t\t}\n\t\tarray = temp;\n\t\tarray[count] = NULL;\n\t}\n\treturn array;\n}", "answer": "NO", "cwe": "59", "idx": "44680"}
{"code": "static void labels_to_offsets(void)\n{\n   struct unfold_elm *ue;\n   struct unfold_elm *s;\n   u_int32 offset = 0;\n\n   fprintf(stdout, \" Converting labels to real offsets \");\n   fflush(stdout);\n   \n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      \n      if (ue->fop.opcode == FOP_JMP || \n          ue->fop.opcode == FOP_JTRUE ||\n          ue->fop.opcode == FOP_JFALSE) {\n        \n         switch (ue->fop.opcode) {\n            case FOP_JMP:\n               ef_debug(1, \"*\"); \n               break;\n            case FOP_JTRUE:\n               ef_debug(1, \"+\");\n               break;\n            case FOP_JFALSE:\n               ef_debug(1, \"-\");\n               break;\n         }\n         \n         \n         TAILQ_FOREACH(s, &unfolded_tree, next) {\n            if (s->label == ue->fop.op.jmp) {\n               ue->fop.op.jmp = offset;\n               \n               offset = 0;\n               break;\n            }\n            \n            if (s->label == 0)\n               offset++;\n         }\n      }\n   }\n\n   fprintf(stdout, \" done.\\n\\n\");\n}", "answer": "NO", "cwe": "125", "idx": "68067"}
{"code": "static void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}", "answer": "NO", "cwe": "59", "idx": "36368"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint montford_polymastodon = 0;\nint global_variable;\nvoid handle_taint(char *homeotherapy_depones);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&montford_polymastodon,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *homeotherapy_depones)\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *musked_derivations = 0;\n  char **evener_empasm = 0;\n  char **fliers_unemasculative = 0;\n  char *recommit_unrecited[100] = {0};\n  ++global_variable;;\n  if (homeotherapy_depones != 0) {;\n    recommit_unrecited[40] = homeotherapy_depones;\n    evener_empasm = recommit_unrecited;\n    fliers_unemasculative = evener_empasm + 5;\n    if ((fliers_unemasculative - 5)[40] != 0) {\n      goto migonitis_soothful;\n    }\n    ++global_variable;\n    migonitis_soothful:;\n    musked_derivations = ((char *)(fliers_unemasculative - 5)[40]);\n  \n  \n  csv = fopen(musked_derivations,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\n    if ((fliers_unemasculative - 5)[40] != 0) \n      free(((char *)(fliers_unemasculative - 5)[40]));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "476", "idx": "149841"}
{"code": "static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr = NULL;\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\tint err = -EINVAL;\n\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (!cfg80211_regdomain)\n\t\tgoto out;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\tNLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2,\n\t\tcfg80211_regdomain->alpha2);\n\n\tnl_reg_rules = nla_nest_start(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < cfg80211_regdomain->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\n\t\treg_rule = &cfg80211_regdomain->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\treg_rule->flags);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\tfreq_range->start_freq_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\tfreq_range->end_freq_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\tfreq_range->max_bandwidth_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\tpower_rule->max_antenna_gain);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\tpower_rule->max_eirp);\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\n\tgenlmsg_end(msg, hdr);\n\terr = genlmsg_reply(msg, info);\n\tgoto out;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\nput_failure:\n\tnlmsg_free(msg);\n\terr = -EMSGSIZE;\nout:\n\tmutex_unlock(&cfg80211_mutex);\n\treturn err;\n}", "answer": "NO", "cwe": "119", "idx": "26691"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_06\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_fopen_06; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96983"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nstatic char * _External_Control_of_System_or_Configuration_Setting__w32_45Data;\nstatic char * _External_Control_of_System_or_Configuration_Setting__w32_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    char * data = _External_Control_of_System_or_Configuration_Setting__w32_45Data;\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_45()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    char * data = _External_Control_of_System_or_Configuration_Setting__w32_45G2BData;\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82006"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint overmagnified_subdeaconship = 0;\nint global_variable;\nvoid lossenite_sella(void **sinarquist_stichter);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **));\nvoid *erythrophage_bourdis(void *lenotre_amputation);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&overmagnified_subdeaconship,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      receptible_recruitors(lossenite_sella);\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid lossenite_sella(void **sinarquist_stichter)\n{\n  void *runfish_catalyzing = 0;\n  char *cohere_monaghan;\n  ++global_variable;;\n  setup_printf_context();\n  cohere_monaghan = getenv(\"PREFABRICATES_DOORSTEPS\");\n  if (cohere_monaghan != 0) {;\n    runfish_catalyzing = ((void *)cohere_monaghan);\n     *sinarquist_stichter = runfish_catalyzing;\n  }\n}\n\nvoid receptible_recruitors(void (*unestranged_bivalves)(void **))\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *ariadne_recent = 0;\n  void *rimpi_arrode = 0;\n  ++global_variable;\n  void *math_epithelioma = 0;\n  unestranged_bivalves(&math_epithelioma);\n  if (((char *)math_epithelioma) != 0) {;\n    rimpi_arrode = erythrophage_bourdis(math_epithelioma);\n    ariadne_recent = ((char *)((char *)rimpi_arrode));\n    \n    input = atoi(ariadne_recent);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\nclose_printf_context();\n  }\n}\n\nvoid *erythrophage_bourdis(void *lenotre_amputation)\n{\n  ++global_variable;\n  return lenotre_amputation;\n}", "answer": "YES", "cwe": "369", "idx": "151154"}
{"code": "int ff_get_cpu_flags_x86(void)\n\n{\n\n    int rval = 0;\n\n\n\n#ifdef cpuid\n\n\n\n    int eax, ebx, ecx, edx;\n\n    int max_std_level, max_ext_level, std_caps = 0, ext_caps = 0;\n\n    int family = 0, model = 0;\n\n    union { int i[3]; char c[12]; } vendor;\n\n\n\n    if (!cpuid_test())\n\n        return 0; \n\n\n\n    cpuid(0, max_std_level, vendor.i[0], vendor.i[2], vendor.i[1]);\n\n\n\n    if (max_std_level >= 1) {\n\n        cpuid(1, eax, ebx, ecx, std_caps);\n\n        family = ((eax >> 8) & 0xf) + ((eax >> 20) & 0xff);\n\n        model  = ((eax >> 4) & 0xf) + ((eax >> 12) & 0xf0);\n\n        if (std_caps & (1 << 15))\n\n            rval |= AV_CPU_FLAG_CMOV;\n\n        if (std_caps & (1 << 23))\n\n            rval |= AV_CPU_FLAG_MMX;\n\n        if (std_caps & (1 << 25))\n\n            rval |= AV_CPU_FLAG_MMXEXT;\n\n#if HAVE_SSE\n\n        if (std_caps & (1 << 25))\n\n            rval |= AV_CPU_FLAG_SSE;\n\n        if (std_caps & (1 << 26))\n\n            rval |= AV_CPU_FLAG_SSE2;\n\n        if (ecx & 1)\n\n            rval |= AV_CPU_FLAG_SSE3;\n\n        if (ecx & 0x00000200 )\n\n            rval |= AV_CPU_FLAG_SSSE3;\n\n        if (ecx & 0x00080000 )\n\n            rval |= AV_CPU_FLAG_SSE4;\n\n        if (ecx & 0x00100000 )\n\n            rval |= AV_CPU_FLAG_SSE42;\n\n#if HAVE_AVX\n\n        \n\n        if ((ecx & 0x18000000) == 0x18000000) {\n\n            \n\n            xgetbv(0, eax, edx);\n\n            if ((eax & 0x6) == 0x6) {\n\n                rval |= AV_CPU_FLAG_AVX;\n\n                if (ecx & 0x00001000)\n\n                    rval |= AV_CPU_FLAG_FMA3;\n\n            }\n\n        }\n\n#endif \n\n#endif \n\n    }\n\n    if (max_std_level >= 7) {\n\n        cpuid(7, eax, ebx, ecx, edx);\n\n#if HAVE_AVX2\n\n        if (ebx & 0x00000020)\n\n            rval |= AV_CPU_FLAG_AVX2;\n\n#endif \n\n        \n\n        if (ebx & 0x00000008) {\n\n            rval |= AV_CPU_FLAG_BMI1;\n\n            if (ebx & 0x00000100)\n\n                rval |= AV_CPU_FLAG_BMI2;\n\n        }\n\n    }\n\n\n\n    cpuid(0x80000000, max_ext_level, ebx, ecx, edx);\n\n\n\n    if (max_ext_level >= 0x80000001) {\n\n        cpuid(0x80000001, eax, ebx, ecx, ext_caps);\n\n        if (ext_caps & (1U << 31))\n\n            rval |= AV_CPU_FLAG_3DNOW;\n\n        if (ext_caps & (1 << 30))\n\n            rval |= AV_CPU_FLAG_3DNOWEXT;\n\n        if (ext_caps & (1 << 23))\n\n            rval |= AV_CPU_FLAG_MMX;\n\n        if (ext_caps & (1 << 22))\n\n            rval |= AV_CPU_FLAG_MMXEXT;\n\n\n\n        \n\n        if (!strncmp(vendor.c, \"AuthenticAMD\", 12) &&\n\n            rval & AV_CPU_FLAG_SSE2 && !(ecx & 0x00000040)) {\n\n            rval |= AV_CPU_FLAG_SSE2SLOW;\n\n        }\n\n\n\n        \n\n        if (rval & AV_CPU_FLAG_AVX) {\n\n            if (ecx & 0x00000800)\n\n                rval |= AV_CPU_FLAG_XOP;\n\n            if (ecx & 0x00010000)\n\n                rval |= AV_CPU_FLAG_FMA4;\n\n        }\n\n    }\n\n\n\n    if (!strncmp(vendor.c, \"GenuineIntel\", 12)) {\n\n        if (family == 6 && (model == 9 || model == 13 || model == 14)) {\n\n            \n\n            if (rval & AV_CPU_FLAG_SSE2)\n\n                rval ^= AV_CPU_FLAG_SSE2SLOW | AV_CPU_FLAG_SSE2;\n\n            if (rval & AV_CPU_FLAG_SSE3)\n\n                rval ^= AV_CPU_FLAG_SSE3SLOW | AV_CPU_FLAG_SSE3;\n\n        }\n\n        \n\n        if (family == 6 && model == 28)\n\n            rval |= AV_CPU_FLAG_ATOM;\n\n    }\n\n\n\n#endif \n\n\n\n    return rval;\n\n}", "answer": "NO", "cwe": "0", "idx": "2d9821a2081aff5dca253386c6e7e71a04509cff"}
{"code": "void qemu_chr_info(Monitor *mon)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    TAILQ_FOREACH(chr, &chardevs, next) {\n\n        monitor_printf(mon, \"%s: filename=%s\\n\", chr->label, chr->filename);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "72cf2d4f0e181d0d3a3122e04129c58a95da713e"}
{"code": "static int ppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    \n\n    if ((env->insns_flags & ~PPC_TCG_INSNS)\n\n        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {\n\n        fprintf(stderr, \"Warning: Disabling some instructions which are not \"\n\n                \"emulated by TCG (0x%\" PRIx64 \", 0x%\" PRIx64 \")\\n\",\n\n                env->insns_flags & ~PPC_TCG_INSNS,\n\n                env->insns_flags2 & ~PPC_TCG_INSNS2);\n\n    }\n\n    env->insns_flags &= PPC_TCG_INSNS;\n\n    env->insns_flags2 &= PPC_TCG_INSNS2;\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_03()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123281"}
{"code": "static int einj_get_available_error_type(u32 *type)\n{\n\tint rc;\n\n\tmutex_lock(&einj_mutex);\n\trc = __einj_get_available_error_type(type);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}", "answer": "NO", "cwe": "74", "idx": "73884"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_char_environment_84\n{\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_char_environment_84\n{\npublic:\n    _LDAP_Injection__w32_char_environment_84(char * dataCopy);\n    ~_LDAP_Injection__w32_char_environment_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_char_environment_84G2B\n{\npublic:\n    _LDAP_Injection__w32_char_environment_84G2B(char * dataCopy);\n    ~_LDAP_Injection__w32_char_environment_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "90", "idx": "122990"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90979"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint brilliantine_tribrachs = 0;\ntypedef char *sculpturesque_cofounder;\nint global_variable;\nvoid jurez_fowl(sculpturesque_cofounder *thirstless_viably);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid noncitizens_turboalternator(void (*unplannedly_midsummerish)(sculpturesque_cofounder *));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&brilliantine_tribrachs,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      noncitizens_turboalternator(jurez_fowl);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid jurez_fowl(sculpturesque_cofounder *thirstless_viably)\n{\n  sculpturesque_cofounder capman_vespoid = 0;\n  char *muscadels_gymnotoka;\n  ++global_variable;;\n  setup_printf_context();\n  muscadels_gymnotoka = getenv(\"GRIZEL_ARCHON\");\n  if (muscadels_gymnotoka != 0) {;\n    capman_vespoid = muscadels_gymnotoka;\n     *thirstless_viably = capman_vespoid;\n  }\n}\n\nvoid noncitizens_turboalternator(void (*unplannedly_midsummerish)(sculpturesque_cofounder *))\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *myringomycosis_avower = 0;\n  sculpturesque_cofounder unevasiveness_peripheroceptor = 0;\n  int *panaceas_uralian = 0;\n  int phrenopathy_entertake;\n  sculpturesque_cofounder firsts_hexade[10] = {0};\n  ++global_variable;\n  sculpturesque_cofounder boldnesses_endecha = 0;\n  unplannedly_midsummerish(&boldnesses_endecha);\n  if (boldnesses_endecha != 0) {;\n    firsts_hexade[5] = boldnesses_endecha;\n    phrenopathy_entertake = 5;\n    panaceas_uralian = &phrenopathy_entertake;\n    unevasiveness_peripheroceptor =  *(firsts_hexade +  *panaceas_uralian);\n    myringomycosis_avower = ((char *)unevasiveness_peripheroceptor);\n    \n    input = atoi(myringomycosis_avower);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "369", "idx": "150759"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint counterdraft_tanta = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid guinean_eto(char *const alehouse_ligula);\nvoid reelsville_underswamp(int phytophagic_mesopodial,char *solea_aethylla);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  int cavern_bivouacked = 1600;\n  char *carphiophiops_artukovic;;\n  if (__sync_bool_compare_and_swap(&counterdraft_tanta,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&carphiophiops_artukovic,\"7946\",cavern_bivouacked);\n      if (carphiophiops_artukovic != 0) {;\n        guinean_eto(carphiophiops_artukovic);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid guinean_eto(char *const alehouse_ligula)\n{\n  int confirmations_auguster = 7;\n  ++global_variable;;\n  reelsville_underswamp(confirmations_auguster,alehouse_ligula);\n}\n\nvoid reelsville_underswamp(int phytophagic_mesopodial,char *solea_aethylla)\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *sarrazin_plagiostomatous = 0;\n  ++global_variable;\n  phytophagic_mesopodial--;\n  if (phytophagic_mesopodial > 0) {\n    reelsville_underswamp(phytophagic_mesopodial,solea_aethylla);\n    return ;\n  }\n  sarrazin_plagiostomatous = ((char *)((char *)solea_aethylla));\n    \n    taint_size = strlen(sarrazin_plagiostomatous);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,sarrazin_plagiostomatous,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n  if (((char *)solea_aethylla) != 0) \n    free(((char *)((char *)solea_aethylla)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "401", "idx": "151485"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_52\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_52; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89802"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <list>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_ifstream_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<wchar_t *> dataList);\n\nvoid m()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<wchar_t *> dataList);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_ifstream_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97548"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_open_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91437"}
{"code": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); \n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    \n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    \n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    \n\n\n\n    \n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); \n\n        return;\n\n    }\n\n    \n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; \n\n        goto out;\n\n    }\n\n\n\n    \n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    \n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    \n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}", "answer": "NO", "cwe": "0", "idx": "d4a63ac8b19eb208465f27fde63f3cff7018fdfd"}
{"code": "static const AVClass *urlcontext_child_class_next(const AVClass *prev)\n\n{\n\n    URLProtocol *p = NULL;\n\n\n\n    \n\n    while (prev && (p = ffurl_protocol_next(p)))\n\n        if (p->priv_data_class == prev)\n\n            break;\n\n\n\n    \n\n    while (p = ffurl_protocol_next(p))\n\n        if (p->priv_data_class)\n\n            return p->priv_data_class;\n\n    return NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_10()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81987"}
{"code": "void main_loop_wait(int timeout)\n\n{\n\n    IOHandlerRecord *ioh;\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n\n\n    qemu_bh_update_timeout(&timeout);\n\n\n\n    host_main_loop_wait(&timeout);\n\n\n\n    \n\n    \n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {\n\n        if (ioh->deleted)\n\n            continue;\n\n        if (ioh->fd_read &&\n\n            (!ioh->fd_read_poll ||\n\n             ioh->fd_read_poll(ioh->opaque) != 0)) {\n\n            FD_SET(ioh->fd, &rfds);\n\n            if (ioh->fd > nfds)\n\n                nfds = ioh->fd;\n\n        }\n\n        if (ioh->fd_write) {\n\n            FD_SET(ioh->fd, &wfds);\n\n            if (ioh->fd > nfds)\n\n                nfds = ioh->fd;\n\n        }\n\n    }\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n    if (ret > 0) {\n\n        IOHandlerRecord **pioh;\n\n\n\n        for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {\n\n            if (!ioh->deleted && ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {\n\n                ioh->fd_read(ioh->opaque);\n\n            }\n\n            if (!ioh->deleted && ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {\n\n                ioh->fd_write(ioh->opaque);\n\n            }\n\n        }\n\n\n\n\t\n\n\tpioh = &first_io_handler;\n\n\twhile (*pioh) {\n\n            ioh = *pioh;\n\n            if (ioh->deleted) {\n\n                *pioh = ioh->next;\n\n                qemu_free(ioh);\n\n            } else\n\n                pioh = &ioh->next;\n\n        }\n\n    }\n\n\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    \n\n    if (alarm_timer->flags & ALARM_FLAG_EXPIRED) {\n\n        alarm_timer->flags &= ~ALARM_FLAG_EXPIRED;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    \n\n    if (vm_running) {\n\n        if (!cur_cpu || likely(!(cur_cpu->singlestep_enabled & SSTEP_NOTIMER)))\n\n            qemu_run_timers(&active_timers[QEMU_TIMER_VIRTUAL],\n\n                qemu_get_clock(vm_clock));\n\n    }\n\n\n\n    \n\n    qemu_run_timers(&active_timers[QEMU_TIMER_REALTIME],\n\n                    qemu_get_clock(rt_clock));\n\n\n\n    \n\n    qemu_bh_poll();\n\n\n\n}", "answer": "NO", "cwe": "0", "idx": "0fdddf80a88ac2efe068990d1878f472bb6b95d9"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_open_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_open_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95698"}
{"code": "GF_Err edts_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tif (ptr->editList) return GF_BAD_PARAM;\n\t\tptr->editList = (GF_EditListBox *)a;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}", "answer": "NO", "cwe": "125", "idx": "80076"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_w32CreateFile_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_w32CreateFile_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97206"}
{"code": "static int mwifiex_uap_parse_tail_ies(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct mwifiex_ie *gen_ie;\n\tstruct ieee_types_header *hdr;\n\tstruct ieee80211_vendor_ie *vendorhdr;\n\tu16 gen_idx = MWIFIEX_AUTO_IDX_MASK, ie_len = 0;\n\tint left_len, parsed_len = 0;\n\tunsigned int token_len;\n\tint err = 0;\n\n\tif (!info->tail || !info->tail_len)\n\t\treturn 0;\n\n\tgen_ie = kzalloc(sizeof(*gen_ie), GFP_KERNEL);\n\tif (!gen_ie)\n\t\treturn -ENOMEM;\n\n\tleft_len = info->tail_len;\n\n\t\n\twhile (left_len > sizeof(struct ieee_types_header)) {\n\t\thdr = (void *)(info->tail + parsed_len);\n\t\ttoken_len = hdr->len + sizeof(struct ieee_types_header);\n\t\tif (token_len > left_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (hdr->element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_ERP_INFO:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t\n\t\t\tif (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t\t    (const u8 *)hdr,\n\t\t\t\t\t\t    token_len))\n\t\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr, token_len);\n\t\t\tie_len += token_len;\n\t\t\tbreak;\n\t\t}\n\t\tleft_len -= token_len;\n\t\tparsed_len += token_len;\n\t}\n\n\t\n\tvendorhdr = (void *)cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t    info->tail, info->tail_len);\n\tif (vendorhdr) {\n\t\ttoken_len = vendorhdr->len + sizeof(struct ieee_types_header);\n\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr, token_len);\n\t\tie_len += token_len;\n\t}\n\n\tif (!ie_len)\n\t\tgoto out;\n\n\tgen_ie->ie_index = cpu_to_le16(gen_idx);\n\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MGMT_MASK_BEACON |\n\t\t\t\t\t\tMGMT_MASK_PROBE_RESP |\n\t\t\t\t\t\tMGMT_MASK_ASSOC_RESP);\n\tgen_ie->ie_length = cpu_to_le16(ie_len);\n\n\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &gen_idx, NULL, NULL,\n\t\t\t\t\t NULL, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->gen_idx = gen_idx;\n\n out:\n\tkfree(gen_ie);\n\treturn err;\n}", "answer": "NO", "cwe": "120", "idx": "88608"}
{"code": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        \n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}", "answer": "NO", "cwe": "0", "idx": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_listen_socket_ofstream_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_ofstream_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90673"}
{"code": "av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "2df0c32ea12ddfa72ba88309812bfb13b674130f"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint prolegomenist_intwist = 0;\nint global_variable;\nvoid handle_taint(char *wanshape_messianically);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid updiving_spinner(char **vicissitudinous_aphoristic);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&prolegomenist_intwist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *wanshape_messianically)\n{\n  char **opisthoparia_jahvism = 0;\n  char **pyrola_forecastles = 0;\n  ++global_variable;;\n  if (wanshape_messianically != 0) {;\n    opisthoparia_jahvism = &wanshape_messianically;\n    pyrola_forecastles = opisthoparia_jahvism + 5;\n    updiving_spinner(pyrola_forecastles);\n  }\n}\n\nvoid updiving_spinner(char **vicissitudinous_aphoristic)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  int is_valid = 1;\n  int i = 0;\n  char cmd_str[1000] = {0};\n  char *rhetorical_desterilize = 0;\n  ++global_variable;;\n  rhetorical_desterilize = ((char *)( *(vicissitudinous_aphoristic - 5)));\n    \n    \n\n    snprintf(cmd_str, 1000, \"vim -s \" \"/opt/cus/workspace/testData/\" \"vim_scripts/hello.vim %s\", rhetorical_desterilize);\n    \n    for (; i < strlen(rhetorical_desterilize); ++i) {\n        if (rhetorical_desterilize[i] == ';') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '|') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '|') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '|') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '&') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n        if (rhetorical_desterilize[i] == '&') {\n          if (i == 0 || rhetorical_desterilize[i - 1] != '&') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      \n      if (is_valid == 1) {\n        \n\n        fpipe = popen(cmd_str, \"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n  if ( *(vicissitudinous_aphoristic - 5) != 0) \n    free(((char *)( *(vicissitudinous_aphoristic - 5))));\nclose_printf_context();\n}", "answer": "YES", "cwe": "88", "idx": "152804"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_listen_socket_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_listen_socket_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_listen_socket_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_listen_socket_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62436"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_file_w32spawnl_82\n{\n\nclass _OS_Command_Injection__char_file_w32spawnl_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_file_w32spawnl_82 : public _OS_Command_Injection__char_file_w32spawnl_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_file_w32spawnl_82G2B : public _OS_Command_Injection__char_file_w32spawnl_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "245696"}
{"code": "static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst struct net_offload *ops;\n\tstruct sk_buff **pp = NULL;\n\tstruct sk_buff *p;\n\tstruct ipv6hdr *iph;\n\tunsigned int nlen;\n\tunsigned int hlen;\n\tunsigned int off;\n\tu16 flush = 1;\n\tint proto;\n\n\toff = skb_gro_offset(skb);\n\thlen = off + sizeof(*iph);\n\tiph = skb_gro_header_fast(skb, off);\n\tif (skb_gro_header_hard(skb, hlen)) {\n\t\tiph = skb_gro_header_slow(skb, hlen, off);\n\t\tif (unlikely(!iph))\n\t\t\tgoto out;\n\t}\n\n\tskb_set_network_header(skb, off);\n\tskb_gro_pull(skb, sizeof(*iph));\n\tskb_set_transport_header(skb, skb_gro_offset(skb));\n\n\tflush += ntohs(iph->payload_len) != skb_gro_len(skb);\n\n\trcu_read_lock();\n\tproto = iph->nexthdr;\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (!ops || !ops->callbacks.gro_receive) {\n\t\t__pskb_pull(skb, skb_gro_offset(skb));\n\t\tskb_gro_frag0_invalidate(skb);\n\t\tproto = ipv6_gso_pull_exthdrs(skb, proto);\n\t\tskb_gro_pull(skb, -skb_transport_offset(skb));\n\t\tskb_reset_transport_header(skb);\n\t\t__skb_push(skb, skb_gro_offset(skb));\n\n\t\tops = rcu_dereference(inet6_offloads[proto]);\n\t\tif (!ops || !ops->callbacks.gro_receive)\n\t\t\tgoto out_unlock;\n\n\t\tiph = ipv6_hdr(skb);\n\t}\n\n\tNAPI_GRO_CB(skb)->proto = proto;\n\n\tflush--;\n\tnlen = skb_network_header_len(skb);\n\n\tfor (p = *head; p; p = p->next) {\n\t\tconst struct ipv6hdr *iph2;\n\t\t__be32 first_word; \n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tiph2 = (struct ipv6hdr *)(p->data + off);\n\t\tfirst_word = *(__be32 *)iph ^ *(__be32 *)iph2;\n\n\t\t\n\t\t if ((first_word & htonl(0xF00FFFFF)) ||\n\t\t    memcmp(&iph->nexthdr, &iph2->nexthdr,\n\t\t\t   nlen - offsetof(struct ipv6hdr, nexthdr))) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tNAPI_GRO_CB(p)->flush |= !!(first_word & htonl(0x0FF00000));\n\t\tNAPI_GRO_CB(p)->flush |= flush;\n\n\t\t\n\t\tif (NAPI_GRO_CB(skb)->is_atomic)\n\t\t\tNAPI_GRO_CB(p)->flush_id = 0;\n\t}\n\n\tNAPI_GRO_CB(skb)->is_atomic = true;\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\n\tskb_gro_postpull_rcsum(skb, iph, nlen);\n\n\tpp = call_gro_receive(ops->callbacks.gro_receive, head, skb);\n\nout_unlock:\n\trcu_read_unlock();\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}", "answer": "NO", "cwe": "125", "idx": "65176"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ifstream_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ifstream_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91576"}
{"code": "static void pci_bridge_region_del(PCIBridge *br, PCIBridgeWindows *w)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n\n\n    memory_region_del_subregion(parent->address_space_io, &w->alias_io);\n\n    memory_region_del_subregion(parent->address_space_mem, &w->alias_mem);\n\n    memory_region_del_subregion(parent->address_space_mem, &w->alias_pref_mem);\n\n    pci_unregister_vga(pd);\n\n}", "answer": "NO", "cwe": "0", "idx": "fd56e0612b6454a282fa6a953fdb09281a98c589"}
{"code": "GahpClient::unicore_job_destroy(const char * job_contact)\n{\n\tstatic const char* command = \"UNICORE_JOB_DESTROY\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!job_contact) job_contact=NULLSTRING;\n\tstd::string reqline;\n\tint x = sprintf(reqline,\"%s\",escapeGahpString(job_contact));\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,normal_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 3) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = 1;\n\t\tif ( result->argv[1][0] == 'S' ) {\n\t\t\trc = 0;\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}", "answer": "NO", "cwe": "134", "idx": "16233"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_10()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245948"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81978"}
{"code": "int ff_xvmc_field_start(MpegEncContext*s, AVCodecContext *avctx)\n\n{\n\n    struct xvmc_pixfmt_render *last, *next, *render = (struct xvmc_pixfmt_render*)s->current_picture.data[2];\n\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n\n\n    assert(avctx);\n\n    if (!render || render->magic_id != AV_XVMC_RENDER_MAGIC ||\n\n        !render->data_blocks || !render->mv_blocks){\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Render token doesn't look as expected.\\n\");\n\n        return -1; \n\n    }\n\n\n\n    render->picture_structure = s->picture_structure;\n\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n\n\n\n    if (render->filled_mv_blocks_num) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n\n               render->filled_mv_blocks_num);\n\n        return -1;\n\n    }\n\n    if (render->total_number_of_mv_blocks   < 1 ||\n\n        render->total_number_of_data_blocks < mb_block_count) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n    if (render->total_number_of_mv_blocks   < 1 ||\n\n        render->total_number_of_data_blocks < mb_block_count) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    render->p_future_surface = NULL;\n\n    render->p_past_surface   = NULL;\n\n\n\n    switch(s->pict_type) {\n\n        case  FF_I_TYPE:\n\n            return 0; \n\n        case  FF_B_TYPE:\n\n            next = (struct xvmc_pixfmt_render*)s->next_picture.data[2];\n\n            if (!next)\n\n                return -1;\n\n            if (next->magic_id != AV_XVMC_RENDER_MAGIC)\n\n                return -1;\n\n            render->p_future_surface = next->p_surface;\n\n            \n\n        case  FF_P_TYPE:\n\n            last = (struct xvmc_pixfmt_render*)s->last_picture.data[2];\n\n            if (!last)\n\n                last = render; \n\n            if (last->magic_id != AV_XVMC_RENDER_MAGIC)\n\n                return -1;\n\n            render->p_past_surface = last->p_surface;\n\n            return 0;\n\n    }\n\n\n\nreturn -1;\n\n}", "answer": "NO", "cwe": "0", "idx": "d76c5ed574faac1aa1533378e35ff78730dcc2ab"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_16()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcpy(data, \"hostname\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81993"}
{"code": "  render_state_set_file( RenderState  state,\n                         int          idx )\n  {\n    const char*  filepath;\n\n\n    if ( idx < 0 )\n      idx = state->num_faces - 1;\n    else if ( idx >= state->num_faces )\n      idx = 0;\n\n    if ( idx >= state->num_faces )\n      return -2;\n\n    state->face_index = idx;\n    filepath = state->faces[idx].filepath;\n\n    if ( state->face )\n    {\n      FT_Done_Face( state->face );\n      state->face         = NULL;\n      state->size         = NULL;\n      state->need_rescale = 1;\n    }\n\n    if ( filepath != NULL && filepath[0] != 0 )\n    {\n      FT_Error  error;\n\n\n      error = FT_New_Face( state->library, filepath,\n                           state->faces[idx].index, &state->face );\n      if ( error )\n        return -1;\n\n      {\n        unsigned int  len = strlen( filepath );\n        char*         p;\n\n\n        if ( len + 1 > sizeof ( state->filepath0 ) )\n        {\n          state->filepath = (const char*)malloc( len + 1 );\n          if ( state->filepath == NULL )\n          {\n            state->filepath = state->filepath0;\n            return -1;\n          }\n        }\n        memcpy( (char*)state->filepath, filepath, len + 1 );\n        p = strrchr( state->filepath, '\\\\' );\n        if ( p == NULL )\n          p = strrchr( state->filepath, '/' );\n\n        state->filename = p ? p + 1 : state->filepath;\n      }\n\n      state->size         = state->face->size;\n      state->need_rescale = 1;\n    }\n\n    return 0;\n  }", "answer": "NO", "cwe": "119", "idx": "10001"}
{"code": "static PHP_FUNCTION(session_reset)\n{\n\tphp_session_reset(TSRMLS_C);\n}", "answer": "NO", "cwe": "74", "idx": "50218"}
{"code": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\t\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\n\t\t\t\t\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}", "answer": "NO", "cwe": "119", "idx": "72467"}
{"code": "LIBOPENMPT_MODPLUG_API void ModPlug_InitMixerCallback(ModPlugFile* file,ModPlugMixerProc proc)\n{\n\tif(!file) return;\n\tif(!file->mixerbuf){\n\t\tfile->mixerbuf = malloc(BUFFER_COUNT*sizeof(signed int)*4);\n\t}\n\tfile->mixerproc = proc;\n}", "answer": "NO", "cwe": "120", "idx": "87640"}
{"code": "void qdev_prop_set_drive_nofail(DeviceState *dev, const char *name,\n\n                                BlockDriverState *value)\n\n{\n\n    if (qdev_prop_set_drive(dev, name, value) < 0) {\n\n        exit(1);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91824"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_console_41Sink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_console_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _LDAP_Injection__w32_wchar_t_console_41G2BSink(wchar_t * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_console_41G2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123159"}
{"code": "static int mjpeg_decode_frame(AVCodecContext *avctx, \n\n                              void *data, int *data_size,\n\n                              UINT8 *buf, int buf_size)\n\n{\n\n    MJpegDecodeContext *s = avctx->priv_data;\n\n    UINT8 *buf_end, *buf_ptr;\n\n    int i, start_code;\n\n    AVPicture *picture = data;\n\n\n\n    *data_size = 0;\n\n\n\n    \n\n    if (buf_size == 0)\n\n        return 0;\n\n\n\n    buf_ptr = buf;\n\n    buf_end = buf + buf_size;\n\n    while (buf_ptr < buf_end) {\n\n        \n\n        start_code = find_marker(&buf_ptr, buf_end);\n\n\t{\n\n\t    \n\n            if (start_code < 0) {\n\n\t\tgoto the_end;\n\n            } else {\n\n                dprintf(\"marker=%x avail_size_in_buf=%d\\n\", start_code, buf_end - buf_ptr);\n\n\t\t\n\n\t\tif ((buf_end - buf_ptr) > s->buffer_size)\n\n\t\t{\n\n\t\t    av_free(s->buffer);\n\n\t\t    s->buffer_size = buf_end-buf_ptr;\n\n\t\t    s->buffer = av_malloc(s->buffer_size);\n\n\t\t    dprintf(\"buffer too small, expanding to %d bytes\\n\",\n\n\t\t\ts->buffer_size);\n\n\t\t}\n\n\t\t\n\n\t\t\n\n\t\tif (start_code == SOS)\n\n\t\t{\n\n\t\t    UINT8 *src = buf_ptr;\n\n\t\t    UINT8 *dst = s->buffer;\n\n\n\n\t\t    while (src<buf_end)\n\n\t\t    {\n\n\t\t\tUINT8 x = *(src++);\n\n\n\n\t\t\t*(dst++) = x;\n\n\t\t\tif (x == 0xff)\n\n\t\t\t{\n\n\t\t\t    while(*src == 0xff) src++;\n\n\n\n\t\t\t    x = *(src++);\n\n\t\t\t    if (x >= 0xd0 && x <= 0xd7)\n\n\t\t\t\t*(dst++) = x;\n\n\t\t\t    else if (x)\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t    }\n\n\t\t    init_get_bits(&s->gb, s->buffer, dst - s->buffer);\n\n\t\t    \n\n\t\t    dprintf(\"escaping removed %d bytes\\n\",\n\n\t\t\t(buf_end - buf_ptr) - (dst - s->buffer));\n\n\t\t}\n\n\t\telse\n\n\t\t    init_get_bits(&s->gb, buf_ptr, buf_end - buf_ptr);\n\n\t\t\n\n\t\ts->start_code = start_code;\n\n\n\n\t\t\n\n\t\tif (start_code >= 0xd0 && start_code <= 0xd7) {\n\n\t\t    dprintf(\"restart marker: %d\\n\", start_code&0x0f);\n\n\t\t} else if (s->first_picture) {\n\n\t\t    \n\n\t\t    if (start_code >= 0xe0 && start_code <= 0xef)\n\n\t\t\tmjpeg_decode_app(s);\n\n\t\t    \n\n\t\t    else if (start_code == COM)\n\n\t\t\tmjpeg_decode_com(s);\n\n\t\t}\n\n\n\n                switch(start_code) {\n\n                case SOI:\n\n\t\t    s->restart_interval = 0;\n\n                    \n\n                    break;\n\n                case DQT:\n\n                    mjpeg_decode_dqt(s);\n\n                    break;\n\n                case DHT:\n\n                    mjpeg_decode_dht(s);\n\n                    break;\n\n                case SOF0:\n\n                    if (mjpeg_decode_sof0(s) < 0)\n\n\t\t\treturn -1;\n\n                    break;\n\n\t\tcase EOI:\n\neoi_parser:\n\n\t\t    {\n\n                        if (s->interlaced) {\n\n                            s->bottom_field ^= 1;\n\n                            \n\n                            if (s->bottom_field)\n\n                                goto not_the_end;\n\n                        }\n\n                        for(i=0;i<3;i++) {\n\n                            picture->data[i] = s->current_picture[i];\n\n\t\t\t    picture->linesize[i] = (s->interlaced) ?\n\n\t\t\t\ts->linesize[i] >> 1 : s->linesize[i];\n\n                        }\n\n                        *data_size = sizeof(AVPicture);\n\n                        avctx->height = s->height;\n\n                        if (s->interlaced)\n\n                            avctx->height *= 2;\n\n                        avctx->width = s->width;\n\n                        \n\n                        switch((s->h_count[0] << 4) | s->v_count[0]) {\n\n                        case 0x11:\n\n                            avctx->pix_fmt = PIX_FMT_YUV444P;\n\n                            break;\n\n                        case 0x21:\n\n                            avctx->pix_fmt = PIX_FMT_YUV422P;\n\n                            break;\n\n                        default:\n\n                        case 0x22:\n\n                            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n                            break;\n\n                        }\n\n                        \n\n                        \n\n\n\n                        goto the_end;\n\n                    }\n\n\t\t    break;\n\n                case SOS:\n\n                    mjpeg_decode_sos(s);\n\n\t\t    \n\n\t\t    \n\n\t\t    if ((s->buggy_avid && !s->interlaced) || s->restart_interval)\n\n\t\t\tgoto eoi_parser;\n\n                    break;\n\n\t\tcase DRI:\n\n\t\t    mjpeg_decode_dri(s);\n\n\t\t    break;\n\n\t\tcase SOF1:\n\n\t\tcase SOF2:\n\n\t\tcase SOF3:\n\n\t\tcase SOF5:\n\n\t\tcase SOF6:\n\n\t\tcase SOF7:\n\n\t\tcase SOF9:\n\n\t\tcase SOF10:\n\n\t\tcase SOF11:\n\n\t\tcase SOF13:\n\n\t\tcase SOF14:\n\n\t\tcase SOF15:\n\n\t\tcase JPG:\n\n\t\t    printf(\"mjpeg: unsupported coding type (%x)\\n\", start_code);\n\n\t\t    break;\n\n\n\n\n\n\n\n                }\n\n\n\nnot_the_end:\n\n\t\t\n\n\t\tbuf_ptr += (get_bits_count(&s->gb)+7)/8;\n\n\t\tdprintf(\"marker parser used %d bytes (%d bits)\\n\",\n\n\t\t    (get_bits_count(&s->gb)+7)/8, get_bits_count(&s->gb));\n\n            }\n\n        }\n\n    }\n\nthe_end:\n\n    dprintf(\"mjpeg decode frame unused %d bytes\\n\", buf_end - buf_ptr);\n\n\n\n    return buf_ptr - buf;\n\n}", "answer": "NO", "cwe": "0", "idx": "68f593b48433842f3407586679fe07f3e5199ab9"}
{"code": "static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    \n\n    buf += 3;\n\n\n\n    \n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        \n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    \n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    \n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    \n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "d150a147dac67faeaf6b1f25a523ae330168ee1e"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint validatable_shootist = 0;\nint global_variable;\nvoid handle_taint(char *triplopy_mollycoddle);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid atelomyelia_snecket(int mesophyllic_caneton,... );\nstruct struct {\n    int before[200];\n    int buffer[128];\n    int after[200];\n};\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&validatable_shootist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *triplopy_mollycoddle)\n{\n  char *airmailed_hyperploid[97] = {0};\n  ++global_variable;;\n  if (triplopy_mollycoddle != 0) {;\n    airmailed_hyperploid[22] = triplopy_mollycoddle;\n    atelomyelia_snecket(1,airmailed_hyperploid);\n  }\n}\n\nvoid atelomyelia_snecket(int mesophyllic_caneton,... )\n{\n    signed char *input_string = 0;\n    struct struct data;\n    int i = 0;\n  char *innocuity_samsam = 0;\n  char **bicarbureted_justling = 0;\n  va_list noninhibitory_aplanatism;\n  ++global_variable;;\n  if (mesophyllic_caneton > 0) {\n    __builtin_va_start(noninhibitory_aplanatism,mesophyllic_caneton);\n    bicarbureted_justling = (va_arg(noninhibitory_aplanatism,char **));\n    __builtin_va_end(noninhibitory_aplanatism);\n  }\n  innocuity_samsam = ((char *)bicarbureted_justling[22]);\n    \n    input_string = (signed char *) getenv(\"INPUT_STRING\");\n    \n    \n    if (input_string != 0) {\n        for (i = 0; i < 128; ++i) {\n            data.buffer[i] = 0;\n        }\n        for (i = 0; i < 200; ++i) {\n            data.before[i] = 5555;\n            data.after[i] = 5555;\n        }\n        for (i = 0; i < strlen((char *) input_string); ++i) {\n            if (input_string[i] < 0)\n                continue;\n            ++data.buffer[input_string[i]];\n        }\n        \n        \n        for (i = 0; i < strlen(innocuity_samsam); ++i) {\n            \n            \n            printf(\"value %c appears: %d times\\n\",\n                innocuity_samsam[i],\n                data.buffer[(int) innocuity_samsam[i]]);\n        }\n        \n        \n        \n    }\n;\n  if (bicarbureted_justling[22] != 0) \n    free(((char *)bicarbureted_justling[22]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "127", "idx": "153390"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <list>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_file_w32CreateFile_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_w32CreateFile_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96492"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_char_console_81\n{\n\nclass _LDAP_Injection__w32_char_console_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_char_console_81 : public _LDAP_Injection__w32_char_console_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_char_console_81G2B : public _LDAP_Injection__w32_char_console_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "90", "idx": "122939"}
{"code": "ThreadPool *thread_pool_new(AioContext *ctx)\n\n{\n\n    ThreadPool *pool = g_new(ThreadPool, 1);\n\n    thread_pool_init_one(pool, ctx);\n\n    return pool;\n\n}", "answer": "NO", "cwe": "0", "idx": "c2b38b277a7882a592f4f2ec955084b2b756daaa"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint niobrara_eyn = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid fredi_outyelping(int hydrophore_punkas,char **preweigh_bushey);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  int revenants_bragi = 7;\n  int overtechnical_macadamized;\n  char **korntonder_grim = 0;\n  char **elfishly_baculite = 0;\n  char *unhinged_eccrinology[85] = {0};\n  char *unmarbleize_procne;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&niobrara_eyn,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      unmarbleize_procne = getenv(\"RETIED_SUGGIL\");\n      if (unmarbleize_procne != 0) {;\n        unhinged_eccrinology[64] = unmarbleize_procne;\n        overtechnical_macadamized = 1;\n        korntonder_grim = unhinged_eccrinology;\n        elfishly_baculite = ((char **)(((unsigned long )korntonder_grim) * overtechnical_macadamized * overtechnical_macadamized)) + 5;\n        fredi_outyelping(revenants_bragi,elfishly_baculite);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid fredi_outyelping(int hydrophore_punkas,char **preweigh_bushey)\n{\n int ss_i = 0;\n  char *cutlerr_caprificator = 0;\n  ++global_variable;\n  hydrophore_punkas--;\n  if (hydrophore_punkas > 0) {\n    fredi_outyelping(hydrophore_punkas,preweigh_bushey);\n    return ;\n  }\n  cutlerr_caprificator = ((char *)(preweigh_bushey - 5)[64]);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(cutlerr_caprificator)){\n  \n        if (cutlerr_caprificator[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "835", "idx": "151942"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_listen_socket_18()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_listen_socket_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_listen_socket_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_listen_socket_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62149"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_file_execlp_66bSink(char * dataArray[]);\n\nvoid _OS_Command_Injection__char_file_execlp_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    _OS_Command_Injection__char_file_execlp_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_file_execlp_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    dataArray[2] = data;\n    _OS_Command_Injection__char_file_execlp_66bG2BSink(dataArray);\n}\n\nvoid _OS_Command_Injection__char_file_execlp_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_execlp_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_execlp_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245505"}
{"code": "int showVerifyPackage(QVA_t qva, rpmts ts, Header h)\n{\n    rpmVerifyAttrs omitMask = ((qva->qva_flags & VERIFY_ATTRS) ^ VERIFY_ATTRS);\n    int ec = 0;\n    int rc;\n\n    if (qva->qva_flags & VERIFY_DEPS) {\n\tif ((rc = verifyDependencies(ts, h)) != 0)\n\t    ec = rc;\n    }\n    if (qva->qva_flags & VERIFY_FILES) {\n\tif ((rc = verifyHeader(ts, h, omitMask, qva->qva_fflags)) != 0)\n\t    ec = rc;\n    }\n    if (qva->qva_flags & VERIFY_SCRIPT) {\n\tif ((rc = rpmVerifyScript(ts, h)) != 0)\n\t    ec = rc;\n    }\n\n    return ec;\n}", "answer": "NO", "cwe": "59", "idx": "86488"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_char_file_53bSink(char * data);\n\nvoid _Process_Control__w32_char_file_53()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _Process_Control__w32_char_file_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_char_file_53bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_char_file_53bG2BSink(data);\n}\n\nvoid _Process_Control__w32_char_file_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62115"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_63bSink(wchar_t * * dataPtr);\n\nvoid _Process_Control__w32_wchar_t_relativePath_63()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_63bG2BSink(&data);\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62503"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_31\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HANDLE hFile;\n            \n            hFile = CreateFileA(data,\n                                (GENERIC_WRITE|GENERIC_READ),\n                                0,\n                                NULL,\n                                OPEN_ALWAYS,\n                                FILE_ATTRIBUTE_NORMAL,\n                                NULL);\n            if (hFile != INVALID_HANDLE_VALUE)\n            {\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HANDLE hFile;\n            \n            hFile = CreateFileA(data,\n                                (GENERIC_WRITE|GENERIC_READ),\n                                0,\n                                NULL,\n                                OPEN_ALWAYS,\n                                FILE_ATTRIBUTE_NORMAL,\n                                NULL);\n            if (hFile != INVALID_HANDLE_VALUE)\n            {\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_31; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89792"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint osteophytic_algometrically = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hirelings_valew(int kelyphite_muscidae,char **subdiapente_caulkings);\nvoid hyla_goosing(int marela_automorphism,char **avosets_vizirates);\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  int nankingese_epistasies = 7;\n  char **mainauer_weent = 0;\n  char **epiopticon_solenne = 0;\n  char *rais_spouses[86] = {0};\n  char *nockerl_levining;;\n  if (__sync_bool_compare_and_swap(&osteophytic_algometrically,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&nockerl_levining,\"ACCOLATED_BLAME\");\n      if (nockerl_levining != 0) {;\n        rais_spouses[34] = nockerl_levining;\n        mainauer_weent = rais_spouses;\n        epiopticon_solenne = mainauer_weent + 5;\n        hirelings_valew(nankingese_epistasies,epiopticon_solenne);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid hirelings_valew(int kelyphite_muscidae,char **subdiapente_caulkings)\n{\n int found;\n  char *whiskyfied_conners = 0;\n  ++global_variable;\n  kelyphite_muscidae--;\n  if (kelyphite_muscidae > 0) {\n    hyla_goosing(kelyphite_muscidae,subdiapente_caulkings);\n    return ;\n  }\n  whiskyfied_conners = ((char *)(subdiapente_caulkings - 5)[34]);\n    \n    \n    \n    found = search(&whiskyfied_conners[1],whiskyfied_conners[0]);\n    \n    \n    \n;\n  if ((subdiapente_caulkings - 5)[34] != 0) \n    free(((char *)(subdiapente_caulkings - 5)[34]));\nclose_printf_context();\n}\n\nvoid hyla_goosing(int marela_automorphism,char **avosets_vizirates)\n{\n  ++global_variable;\n  hirelings_valew(marela_automorphism,avosets_vizirates);\n}", "answer": "YES", "cwe": "674", "idx": "151451"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_file_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96436"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint erath_sublacustrine = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty);\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  int faithbreach_warrigals = 7;\n  char **overcherished_unprovide = 0;\n  char **merribush_spraggs = 0;\n  int townships_navete = 0;\n  char *voltages_sjenicki = 0;\n  char *electrotrephine_offend;;\n  if (__sync_bool_compare_and_swap(&erath_sublacustrine,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      electrotrephine_offend = getenv(\"KAOHSIUNG_GRAUBUNDEN\");\n      if (electrotrephine_offend != 0) {;\n        townships_navete = ((int )(strlen(electrotrephine_offend)));\n        voltages_sjenicki = ((char *)(malloc(townships_navete + 1)));\n        if (voltages_sjenicki == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(voltages_sjenicki,0,townships_navete + 1);\n        memcpy(voltages_sjenicki,electrotrephine_offend,townships_navete);\n        overcherished_unprovide = &voltages_sjenicki;\n        merribush_spraggs = overcherished_unprovide + 5;\n        philomythic_bronchotomy(faithbreach_warrigals,merribush_spraggs);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid philomythic_bronchotomy(int receiptless_unroasted,char **minsteryard_megadonty)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *posher_vitreouslike = 0;\n  ++global_variable;\n  receiptless_unroasted--;\n  if (receiptless_unroasted > 0) {\n    ficuses_hornswoggled(receiptless_unroasted,minsteryard_megadonty);\n    return ;\n  }\n  posher_vitreouslike = ((char *)( *(minsteryard_megadonty - 5)));\n      \n      while(isalnum(posher_vitreouslike[size]) && size < strlen(posher_vitreouslike)){\n        ++size;\n      }\n      \n\n      if (size != strlen(posher_vitreouslike)) {\n        posher_vitreouslike = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,posher_vitreouslike);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if ( *(minsteryard_megadonty - 5) != 0) \n    free(((char *)( *(minsteryard_megadonty - 5))));\nclose_printf_context();\n}\n\nvoid ficuses_hornswoggled(int polygene_mutable,char **modishly_knowableness)\n{\n  ++global_variable;\n  philomythic_bronchotomy(polygene_mutable,modishly_knowableness);\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149284"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint potbellied_timaru = 0;\n\nunion flatly_exosporous \n{\n  char *unreminiscently_endor;\n  double refinished_isolex;\n  char *aperulosid_agistator;\n  char leticia_garrisons;\n  int vowless_ternar;\n}\n;\nint global_variable;\nvoid handle_taint(char *cavillatory_bridgetin);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&potbellied_timaru,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -lmysqlclient -l:libmongoose.so.1 -lssl -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *cavillatory_bridgetin)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  char *upcoiled_wray = 0;\n  union flatly_exosporous *bryozoa_ulcer = {0};\n  union flatly_exosporous mokpo_backbitten;\n  ++global_variable;;\n  if (cavillatory_bridgetin != 0) {;\n    mokpo_backbitten . unreminiscently_endor = cavillatory_bridgetin;\n    bryozoa_ulcer = &mokpo_backbitten;\n    if (( *bryozoa_ulcer) . unreminiscently_endor != 0) {\n      goto coign_bisexed;\n    }\n    ++global_variable;\n    coign_bisexed:;\n    upcoiled_wray = ((char *)( *bryozoa_ulcer) . unreminiscently_endor);\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n                snprintf(query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",upcoiled_wray);\n                \n                \n                \n\n                if (mysql_query(conn,query_buffer) == 0) {\n                  do {\n                    result = mysql_store_result(conn);\n                    if (result != 0) {\n                      num_rows = mysql_num_rows(result);\n                      if (num_rows != 0) {\n                        num_fields = mysql_num_fields(result);\n                        while((row = mysql_fetch_row(result))){\n                          for (i = 0; i < num_fields; ++i)\n                            printf(\"%s \",(row[i]?row[i] : \"NULL\"));\n                          printf(\"\\n\");\n                        }\n                        mysql_free_result(result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(conn) == 0)\n                        printf(\"%lld rows affected\\n\",mysql_affected_rows(conn));\n                      else {\n                        printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(conn),mysql_error(conn));\n                        break;\n                      }\n                    }\n                    status = mysql_next_result(conn);\n                    if (status > 0)\n                      printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(conn),mysql_error(conn));\n                  }while (status == 0);\n                }\n                else {\n                  \n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n    if (( *bryozoa_ulcer) . unreminiscently_endor != 0) \n      free(((char *)( *bryozoa_ulcer) . unreminiscently_endor));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "89", "idx": "152178"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint cometaria_antimedically = 0;\nint global_variable;\ntypedef char *elapsing_enneahedra;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid brackney_embira(const elapsing_enneahedra schtick_caddised);\nvoid factional_electees(elapsing_enneahedra ostariophysi_milliarium);\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  elapsing_enneahedra flexible_nociassociation = 0;\n  char *copartnerships_thermostat;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&cometaria_antimedically,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      copartnerships_thermostat = getenv(\"HYDRACORAL_DRYBRAINED\");\n      if (copartnerships_thermostat != 0) {;\n        flexible_nociassociation = copartnerships_thermostat;\n        brackney_embira(flexible_nociassociation);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#define MONKEYRONY_SORCERIES(x) factional_electees((elapsing_enneahedra) x)\n\nvoid brackney_embira(const elapsing_enneahedra schtick_caddised)\n{\n  ++global_variable;;\n\tMONKEYRONY_SORCERIES(schtick_caddised);\n}\n\nvoid factional_electees(elapsing_enneahedra ostariophysi_milliarium)\n{\n    int fd;\n    char *extension = \".lck\";\n    char *thelockfile;\n  char *herdsman_encrown = 0;\n  ++global_variable;;\n  herdsman_encrown = ((char *)((elapsing_enneahedra )ostariophysi_milliarium));\n    \n    thelockfile = (char *)malloc(strlen(\"/opt/cus/workspace/testData/\") + strlen(herdsman_encrown) +\n                                  strlen(extension) + 1);\n    \n    if (thelockfile) {\n        \n        \n  strcpy(thelockfile, \"/opt/cus/workspace/testData/\");\n     strcat(thelockfile, herdsman_encrown);\n     strcat(thelockfile, extension);\n        \n     \n     if (access(\"/opt/cus/workspace/testData/\", R_OK && W_OK) == -1) {\n      printf(\"Error accessing testData directory\\n\");\n     } else {\n            printf(\"Grabbing lock file: %s\\n\", thelockfile);\n            \n            \n      \n            while ((fd = open(thelockfile, O_CREAT | O_EXCL, 0644) == -1) ) {\n                sleep(0);\n            }\n            \n            printf(\"Made it to the critical section\\n\");\n            if (fd != -1) {\n                close(fd);\n                unlink(thelockfile);\n            }\n            free (thelockfile);\n        }\n    }\n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "YES", "cwe": "412", "idx": "150115"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\nnamespace _OS_Command_Injection__wchar_t_console_popen_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    mSource(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    nG2BSource(data);\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _OS_Command_Injection__wchar_t_console_popen_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246965"}
{"code": "ALWAYS_INLINE void jspDebuggerLoopIfCtrlC() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute & EXEC_CTRL_C_WAIT && JSP_SHOULD_EXECUTE)\n    jsiDebuggerLoop();\n#endif\n}", "answer": "NO", "cwe": "125", "idx": "82284"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint syllogize_mucosae = 0;\ntypedef char *tubicolous_kumis;\nint global_variable;\nvoid conli_microfilming(tubicolous_kumis *phytophylogeny_avocet);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid blowen_hayward(void (*alloa_mesosome)(tubicolous_kumis *));\nvoid moonflower_needlebook(const tubicolous_kumis whitmonday_bleck);\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&syllogize_mucosae,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      blowen_hayward(conli_microfilming);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid conli_microfilming(tubicolous_kumis *phytophylogeny_avocet)\n{\n  tubicolous_kumis acton_squeakproof = 0;\n  char *irrefutably_mauby;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&irrefutably_mauby,\"PRECULE_CHOOSES\");\n  if (irrefutably_mauby != 0) {;\n    acton_squeakproof = irrefutably_mauby;\n     *phytophylogeny_avocet = acton_squeakproof;\n  }\n}\n\nvoid blowen_hayward(void (*alloa_mesosome)(tubicolous_kumis *))\n{\n  ++global_variable;\n  tubicolous_kumis grammarless_poppied = 0;\n  alloa_mesosome(&grammarless_poppied);\n  if (grammarless_poppied != 0) {;\n    moonflower_needlebook(grammarless_poppied);\n  }\n}\n\nvoid moonflower_needlebook(const tubicolous_kumis whitmonday_bleck)\n{\n    long number;\n    struct struct_data *data = 0;\n  char *tightnesses_nudge = 0;\n  ++global_variable;;\n  tightnesses_nudge = ((char *)((tubicolous_kumis )whitmonday_bleck));\n    \n    number = strtol(tightnesses_nudge,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n  if (((tubicolous_kumis )whitmonday_bleck) != 0) \n    free(((char *)((tubicolous_kumis )whitmonday_bleck)));\nclose_printf_context();\n}\n#endif", "answer": "YES", "cwe": "197", "idx": "151046"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_wchar_t_environment_81\n{\n\nclass _Process_Control__w32_wchar_t_environment_81_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Process_Control__w32_wchar_t_environment_81 : public _Process_Control__w32_wchar_t_environment_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_wchar_t_environment_81G2B : public _Process_Control__w32_wchar_t_environment_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "114", "idx": "62368"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nstatic char * _LDAP_Injection__w32_char_file_45Data;\nstatic char * _LDAP_Injection__w32_char_file_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    char * data = _LDAP_Injection__w32_char_file_45Data;\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_45()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_char_file_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    char * data = _LDAP_Injection__w32_char_file_45G2BData;\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_file_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _LDAP_Injection__w32_char_file_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123019"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint selenodonta_sponger = 0;\nint global_variable;\ntypedef char *propitiating_phociform;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid ackton_humphreys(int currencies_pickiest,propitiating_phociform *fellahin_gove);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  int podophyllum_melosa = 7;\n  propitiating_phociform *redisputed_gyratory = 0;\n  propitiating_phociform *yagourundi_nonpendency = 0;\n  propitiating_phociform relandscaping_incogitance = 0;\n  char *japanization_triformous;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&selenodonta_sponger,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      japanization_triformous = getenv(\"COINFINITE_MONOSOME\");\n      if (japanization_triformous != 0) {;\n        relandscaping_incogitance = japanization_triformous;\n        redisputed_gyratory = &relandscaping_incogitance;\n        yagourundi_nonpendency = redisputed_gyratory + 5;\n        ackton_humphreys(podophyllum_melosa,yagourundi_nonpendency);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n\nvoid ackton_humphreys(int currencies_pickiest,propitiating_phociform *fellahin_gove)\n{\n    int oc_i = 0;\n    char * data = 0;\n  char *cobstone_zostera = 0;\n  ++global_variable;\n  currencies_pickiest--;\n  if (currencies_pickiest > 0) {\n    ackton_humphreys(currencies_pickiest,fellahin_gove);\n    return ;\n  }\n  cobstone_zostera = ((char *)( *(fellahin_gove - 5)));\n    \n    data = (char*) malloc(8 * sizeof(char));\n    if (data != NULL) {\n        \n        \n        \n        \n        \n        strncpy(data, cobstone_zostera, strlen(cobstone_zostera) + 1);\n        for (; oc_i < strlen(data); ++oc_i) {\n            data[oc_i] = toupper(data[oc_i]);\n        }\n        printf(\"%s\\n\", data);\n        \n        \n        free(data);\n    }\n    \n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "YES", "cwe": "805", "idx": "153480"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_open_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * data = dataRef;\n        {\n            int fileDesc;\n            \n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    {\n        wchar_t * data = dataRef;\n        {\n            int fileDesc;\n            \n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_open_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91906"}
{"code": "static void RENAME(yuv2yuyv422_1)(SwsContext *c, const uint16_t *buf0,\n\n                                  const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                                  const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                                  const uint16_t *abuf0, uint8_t *dest,\n\n                                  int dstW, int uvalpha, enum PixelFormat dstFormat,\n\n                                  int flags, int y)\n\n{\n\n    const uint16_t *buf1= buf0; \n\n\n\n    if (uvalpha < 2048) { \n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2PACKED1(%%REGBP, %5)\n\n            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2PACKED1b(%%REGBP, %5)\n\n            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "13a099799e89a76eb921ca452e1b04a7a28a9855"}
{"code": "static int config_input(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    PadContext *s = ctx->priv;\n    int ret;\n    double var_values[VARS_NB], res;\n    char *expr;\n\n    ff_draw_init(&s->draw, inlink->format, 0);\n    ff_draw_color(&s->draw, &s->color, s->rgba_color);\n\n    var_values[VAR_IN_W]  = var_values[VAR_IW] = inlink->w;\n    var_values[VAR_IN_H]  = var_values[VAR_IH] = inlink->h;\n    var_values[VAR_OUT_W] = var_values[VAR_OW] = NAN;\n    var_values[VAR_OUT_H] = var_values[VAR_OH] = NAN;\n    var_values[VAR_A]     = (double) inlink->w / inlink->h;\n    var_values[VAR_SAR]   = inlink->sample_aspect_ratio.num ?\n        (double) inlink->sample_aspect_ratio.num / inlink->sample_aspect_ratio.den : 1;\n    var_values[VAR_DAR]   = var_values[VAR_A] * var_values[VAR_SAR];\n    var_values[VAR_HSUB]  = 1 << s->draw.hsub_max;\n    var_values[VAR_VSUB]  = 1 << s->draw.vsub_max;\n\n    \n    av_expr_parse_and_eval(&res, (expr = s->w_expr),\n                           var_names, var_values,\n                           NULL, NULL, NULL, NULL, NULL, 0, ctx);\n    s->w = var_values[VAR_OUT_W] = var_values[VAR_OW] = res;\n    if ((ret = av_expr_parse_and_eval(&res, (expr = s->h_expr),\n                                      var_names, var_values,\n                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)\n        goto eval_fail;\n    s->h = var_values[VAR_OUT_H] = var_values[VAR_OH] = res;\n    \n    if ((ret = av_expr_parse_and_eval(&res, (expr = s->w_expr),\n                                      var_names, var_values,\n                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)\n        goto eval_fail;\n    s->w = var_values[VAR_OUT_W] = var_values[VAR_OW] = res;\n\n    \n    av_expr_parse_and_eval(&res, (expr = s->x_expr),\n                           var_names, var_values,\n                           NULL, NULL, NULL, NULL, NULL, 0, ctx);\n    s->x = var_values[VAR_X] = res;\n    if ((ret = av_expr_parse_and_eval(&res, (expr = s->y_expr),\n                                      var_names, var_values,\n                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)\n        goto eval_fail;\n    s->y = var_values[VAR_Y] = res;\n    \n    if ((ret = av_expr_parse_and_eval(&res, (expr = s->x_expr),\n                                      var_names, var_values,\n                                      NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0)\n        goto eval_fail;\n    s->x = var_values[VAR_X] = res;\n\n    \n    if (s->w < 0 || s->h < 0 || s->x < 0 || s->y < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"Negative values are not acceptable.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (!s->w)\n        s->w = inlink->w;\n    if (!s->h)\n        s->h = inlink->h;\n\n    s->w    = ff_draw_round_to_sub(&s->draw, 0, -1, s->w);\n    s->h    = ff_draw_round_to_sub(&s->draw, 1, -1, s->h);\n    s->x    = ff_draw_round_to_sub(&s->draw, 0, -1, s->x);\n    s->y    = ff_draw_round_to_sub(&s->draw, 1, -1, s->y);\n    s->in_w = ff_draw_round_to_sub(&s->draw, 0, -1, inlink->w);\n    s->in_h = ff_draw_round_to_sub(&s->draw, 1, -1, inlink->h);\n\n    av_log(ctx, AV_LOG_VERBOSE, \"w:%d h:%d -> w:%d h:%d x:%d y:%d color:0x%02X%02X%02X%02X\\n\",\n           inlink->w, inlink->h, s->w, s->h, s->x, s->y,\n           s->rgba_color[0], s->rgba_color[1], s->rgba_color[2], s->rgba_color[3]);\n\n    if (s->x <  0 || s->y <  0                      ||\n        s->w <= 0 || s->h <= 0                      ||\n        (unsigned)s->x + (unsigned)inlink->w > s->w ||\n        (unsigned)s->y + (unsigned)inlink->h > s->h) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Input area %d:%d:%d:%d not within the padded area 0:0:%d:%d or zero-sized\\n\",\n               s->x, s->y, s->x + inlink->w, s->y + inlink->h, s->w, s->h);\n        return AVERROR(EINVAL);\n    }\n\n    return 0;\n\neval_fail:\n    av_log(NULL, AV_LOG_ERROR,\n           \"Error when evaluating the expression '%s'\\n\", expr);\n    return ret;\n\n}", "answer": "NO", "cwe": "119", "idx": "29771"}
{"code": "bool get_mapped_rootid(struct lxc_conf *conf, enum idtype idtype,\n\t\t\tunsigned long *val)\n{\n\tstruct lxc_list *it;\n\tstruct id_map *map;\n\n\tlxc_list_for_each(it, &conf->id_map) {\n\t\tmap = it->elem;\n\t\tif (map->idtype != idtype)\n\t\t\tcontinue;\n\t\tif (map->nsid != 0)\n\t\t\tcontinue;\n\t\t*val = map->hostid;\n\t\treturn true;\n\t}\n\treturn false;\n}", "answer": "NO", "cwe": "59", "idx": "44567"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_fopen_01\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_fopen_01; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91020"}
{"code": "static int virtser_port_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    VirtIOSerialPort *port = DO_UPCAST(VirtIOSerialPort, dev, qdev);\n\n    VirtIOSerialPortInfo *info = DO_UPCAST(VirtIOSerialPortInfo, qdev, base);\n\n    VirtIOSerialBus *bus = DO_UPCAST(VirtIOSerialBus, qbus, qdev->parent_bus);\n\n    int ret, max_nr_ports;\n\n    bool plugging_port0;\n\n\n\n    port->vser = bus->vser;\n\n    port->bh = qemu_bh_new(flush_queued_data_bh, port);\n\n\n\n    \n\n    plugging_port0 = port->is_console && !find_port_by_id(port->vser, 0);\n\n\n\n    if (find_port_by_id(port->vser, port->id)) {\n\n        error_report(\"virtio-serial-bus: A port already exists at id %u\\n\",\n\n                     port->id);\n\n        return -1;\n\n    }\n\n\n\n    if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n\n        if (plugging_port0) {\n\n            port->id = 0;\n\n        } else {\n\n            port->id = find_free_port_id(port->vser);\n\n            if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n\n                error_report(\"virtio-serial-bus: Maximum port limit for this device reached\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    max_nr_ports = tswap32(port->vser->config.max_nr_ports);\n\n    if (port->id >= max_nr_ports) {\n\n        error_report(\"virtio-serial-bus: Out-of-range port id specified, max. allowed: %u\\n\",\n\n                     max_nr_ports - 1);\n\n        return -1;\n\n    }\n\n\n\n    port->info = info;\n\n    ret = info->init(port);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (!use_multiport(port->vser)) {\n\n        \n\n        port->guest_connected = true;\n\n    }\n\n\n\n    port->elem.out_num = 0;\n\n\n\n    QTAILQ_INSERT_TAIL(&port->vser->ports, port, next);\n\n    port->ivq = port->vser->ivqs[port->id];\n\n    port->ovq = port->vser->ovqs[port->id];\n\n\n\n    add_port(port->vser, port->id);\n\n\n\n    \n\n    virtio_notify_config(&port->vser->vdev);\n\n\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "2a3d57ce4278dfd898d8b5639ace21fa4a4fb9bd"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_ifstream_31\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_ifstream_31; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95606"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_52bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_listen_socket_52()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_listen_socket_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_52bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_listen_socket_52bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123069"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_console_ifstream_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_ifstream_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89877"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint acoelomous_superintended = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar *inhabitation_retaliate(char *veblen_maidism);\nvoid valinch_forums(int arteriometer_inordinacy,char *calusa_pacate);\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int kists_oxyhydric = 7;\n  char *melancholy_dauded = 0;\n  int pazia_boroglycerine = 0;\n  char *unsticked_hoplonemertea = 0;\n  char *causeways_proprietarian;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&acoelomous_superintended,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&causeways_proprietarian,\"PACIFYING_LEISURELESS\");\n      if (causeways_proprietarian != 0) {;\n        pazia_boroglycerine = ((int )(strlen(causeways_proprietarian)));\n        unsticked_hoplonemertea = ((char *)(malloc(pazia_boroglycerine + 1)));\n        if (unsticked_hoplonemertea == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(unsticked_hoplonemertea,0,pazia_boroglycerine + 1);\n        memcpy(unsticked_hoplonemertea,causeways_proprietarian,pazia_boroglycerine);\n        if (causeways_proprietarian != 0) \n          free(((char *)causeways_proprietarian));\n        melancholy_dauded = inhabitation_retaliate(unsticked_hoplonemertea);\n        valinch_forums(kists_oxyhydric,melancholy_dauded);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nchar *inhabitation_retaliate(char *veblen_maidism)\n{\n  ++global_variable;\n  return veblen_maidism;\n}\n\nvoid valinch_forums(int arteriometer_inordinacy,char *calusa_pacate)\n{\n char *buffer = 0;\n  char *premen_abstrude = 0;\n  ++global_variable;\n  arteriometer_inordinacy--;\n  if (arteriometer_inordinacy > 0) {\n    valinch_forums(arteriometer_inordinacy,calusa_pacate);\n    return ;\n  }\n  premen_abstrude = ((char *)calusa_pacate);\n    \n    buffer = malloc((strlen(premen_abstrude) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,premen_abstrude);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n  if (calusa_pacate != 0) \n    free(((char *)calusa_pacate));\nclose_printf_context();\n}", "answer": "YES", "cwe": "415", "idx": "152882"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_31\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            ofstream outputFile;\n            \n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            ofstream outputFile;\n            \n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_31; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91856"}
{"code": "tstamp_precision_from_string(const char *precision)\n{\n\tif (strncmp(precision, \"nano\", strlen(\"nano\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_NANO;\n\n\tif (strncmp(precision, \"micro\", strlen(\"micro\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn -EINVAL;\n}", "answer": "NO", "cwe": "120", "idx": "93202"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_41\n{\n\n#ifndef OMITM\n\nvoid mSink(char * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(char * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95994"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <limits.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint maas_deathwatches = 0;\n\nstruct enterprise_quackle \n{\n  char *eventognathous_eucairite;\n  double piculule_esthesio;\n  char *hungered_pearlbush;\n  char spears_gammoner;\n  int vigilation_hematolysis;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint 190_global_var = 0;\n\nSize PMSignalShmemSize()\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *forechoose_kookri = 0;\n  struct enterprise_quackle ventriloquisms_methylaniline;\n  char *champion_neurocelian;\n  Size size;\n  if (__sync_bool_compare_and_swap(&maas_deathwatches,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      champion_neurocelian = getenv(\"ACCESSARILY_TWINBERRY\");\n      if (champion_neurocelian != 0) {;\n        ventriloquisms_methylaniline . eventognathous_eucairite = ((char *)champion_neurocelian);\n        forechoose_kookri = ((char *)ventriloquisms_methylaniline . eventognathous_eucairite);\n    \n    tainted_int = atoi(forechoose_kookri);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "YES", "cwe": "190", "idx": "151158"}
{"code": "BaseShadow::logEvictEvent( int exitReason )\n{\n\tstruct rusage run_remote_rusage;\n\tmemset( &run_remote_rusage, 0, sizeof(struct rusage) );\n\n\trun_remote_rusage = getRUsage();\n\n\tswitch( exitReason ) {\n\tcase JOB_CKPTED:\n\tcase JOB_NOT_CKPTED:\n\tcase JOB_KILLED:\n\t\tbreak;\n\tdefault:\n\t\tdprintf( D_ALWAYS, \n\t\t\t\t \"logEvictEvent with unknown reason (%d), aborting\\n\",\n\t\t\t\t exitReason ); \n\t\treturn;\n\t}\n\n\tJobEvictedEvent event;\n\tevent.checkpointed = (exitReason == JOB_CKPTED);\n\t\n\t\t\t\n\tevent.run_remote_rusage = run_remote_rusage;\n\t\n\t\t\n\tevent.recvd_bytes = bytesSent();\n\tevent.sent_bytes = bytesReceived();\n\t\n\tif (!uLog.writeEvent (&event,jobAd)) {\n\t\tdprintf (D_ALWAYS, \"Unable to log ULOG_JOB_EVICTED event\\n\");\n\t}\n}", "answer": "NO", "cwe": "134", "idx": "16338"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_console_16()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_console_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_console_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_console_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122910"}
{"code": "int _yr_emit_split(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    int* code_size)\n{\n  assert(opcode == RE_OPCODE_SPLIT_A || opcode == RE_OPCODE_SPLIT_B);\n\n  if (emit_context->next_split_id == RE_MAX_SPLIT_ID)\n    return ERROR_REGULAR_EXPRESSION_TOO_COMPLEX;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &emit_context->next_split_id,\n      sizeof(RE_SPLIT_ID_TYPE),\n      NULL));\n\n  emit_context->next_split_id++;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(RE_SPLIT_ID_TYPE) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}", "answer": "NO", "cwe": "125", "idx": "66315"}
{"code": "int ppc_hash32_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                                int mmu_idx)\n\n{\n\n    struct mmu_ctx_hash32 ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        \n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        \n\n        access_type = env->access_type;\n\n    }\n\n    ret = ppc_hash32_get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                \n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x40000000;\n\n                break;\n\n            case -2:\n\n                \n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                \n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                \n\n                \n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                \n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                if (rw == 1) {\n\n                    env->spr[SPR_DSISR] = 0x42000000;\n\n                } else {\n\n                    env->spr[SPR_DSISR] = 0x40000000;\n\n                }\n\n                break;\n\n            case -2:\n\n                \n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                env->spr[SPR_DAR] = address;\n\n                if (rw == 1) {\n\n                    env->spr[SPR_DSISR] = 0x0A000000;\n\n                } else {\n\n                    env->spr[SPR_DSISR] = 0x08000000;\n\n                }\n\n                break;\n\n            case -4:\n\n                \n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    \n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    \n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    \n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "91cda45b69e45a089f9989979a65db3f710c9925"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_41Sink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _Process_Control__w32_wchar_t_relativePath_41G2BSink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_41G2BSink(data);\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62492"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41Sink(wchar_t * data)\n{\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41G2BSink(wchar_t * data)\n{\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41G2BSink(data);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248699"}
{"code": "  TestAudioObserver() : output_mute_changed_count_(0) {\n  }", "answer": "NO", "cwe": "119", "idx": "170272"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_environment_open_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_open_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90240"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint chopped_giftie = 0;\nint global_variable;\nvoid handle_taint(char *unrecriminative_apologizer);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid *extractively_heterologically(void *sanctioned_aune);\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&chopped_giftie,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *unrecriminative_apologizer)\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *xiphosuran_cossas = 0;\n  void *squirreling_intrenching = 0;\n  void *shorteners_amphiploid = 0;\n  ++global_variable;;\n  if (unrecriminative_apologizer != 0) {;\n    shorteners_amphiploid = ((void *)unrecriminative_apologizer);\n    squirreling_intrenching = extractively_heterologically(shorteners_amphiploid);\n    xiphosuran_cossas = ((char *)((char *)squirreling_intrenching));\n    \n    if (strlen(xiphosuran_cossas) > 0 &&\n        xiphosuran_cossas[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(xiphosuran_cossas);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n    if (((char *)squirreling_intrenching) != 0) \n      free(((char *)((char *)squirreling_intrenching)));\nclose_printf_context();\n  }\n}\n\nvoid *extractively_heterologically(void *sanctioned_aune)\n{\n  ++global_variable;\n  return sanctioned_aune;\n}", "answer": "YES", "cwe": "196", "idx": "150788"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define SYSTEM _wsystem\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_file_system_63bSink(wchar_t * * dataPtr);\n\nvoid _OS_Command_Injection__wchar_t_file_system_63()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _OS_Command_Injection__wchar_t_file_system_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_file_system_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_file_system_63bG2BSink(&data);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_system_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_system_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_system_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247954"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__wchar_t_console_w32CreateFile_14\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_w32CreateFile_14; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91225"}
{"code": "dispincsrch(int ch, Str buf, Lineprop *prop)\n{\n    static Buffer sbuf;\n    static Line *currentLine;\n    static int pos;\n    char *str;\n    int do_next_search = FALSE;\n\n    if (ch == 0 && buf == NULL) {\n\tSAVE_BUFPOSITION(&sbuf);\t\n\tcurrentLine = sbuf.currentLine;\n\tpos = sbuf.pos;\n\treturn -1;\n    }\n\n    str = buf->ptr;\n    switch (ch) {\n    case 022:\t\t\t\n\tsearchRoutine = backwardSearch;\n\tdo_next_search = TRUE;\n\tbreak;\n    case 023:\t\t\t\n\tsearchRoutine = forwardSearch;\n\tdo_next_search = TRUE;\n\tbreak;\n\n#ifdef USE_MIGEMO\n    case 034:\n\tmigemo_active = -migemo_active;\n\tgoto done;\n#endif\n\n    default:\n\tif (ch >= 0)\n\t    return ch;\t\t\n    }\n\n    if (do_next_search) {\n\tif (*str) {\n\t    if (searchRoutine == forwardSearch)\n\t\tCurrentbuf->pos += 1;\n\t    SAVE_BUFPOSITION(&sbuf);\n\t    if (srchcore(str, searchRoutine) == SR_NOTFOUND\n\t\t&& searchRoutine == forwardSearch) {\n\t\tCurrentbuf->pos -= 1;\n\t\tSAVE_BUFPOSITION(&sbuf);\n\t    }\n\t    arrangeCursor(Currentbuf);\n\t    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n\t    clear_mark(Currentbuf->currentLine);\n\t    return -1;\n\t}\n\telse\n\t    return 020;\t\t\n    }\n    else if (*str) {\n\tRESTORE_BUFPOSITION(&sbuf);\n\tarrangeCursor(Currentbuf);\n\tsrchcore(str, searchRoutine);\n\tarrangeCursor(Currentbuf);\n\tcurrentLine = Currentbuf->currentLine;\n\tpos = Currentbuf->pos;\n    }\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n    clear_mark(Currentbuf->currentLine);\n#ifdef USE_MIGEMO\n  done:\n    while (*str++ != '\\0') {\n\tif (migemo_active > 0)\n\t    *prop++ |= PE_UNDER;\n\telse\n\t    *prop++ &= ~PE_UNDER;\n    }\n#endif\n    return -1;\n}", "answer": "NO", "cwe": "59", "idx": "84486"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_wchar_t_connect_socket_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_53bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123118"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint flypast_punctualist = 0;\nint global_variable;\n\nstruct tangier_vfea \n{\n  char *iliopelvic_tristisonous;\n  double spirable_hyperdemocracy;\n  char *bucchero_valera;\n  char cytophysiology_hallsy;\n  int fleabanes_smattery;\n}\n;\n#define ILO_CYANASTRACEAE(x) pillowed_beefishness((struct tangier_vfea *) x)\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid pillowed_beefishness(struct tangier_vfea *preintone_stonify);\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex_0, mutex_1;\npthread_t t0, t1;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *replace (void *data) {\n    struct data *cusData = (struct data*)data;\n    int *qsort_arr;\n    int i = 0;\n    \n    \n    printf(\"replace: entering function\\n\");\n    \n    qsort_arr = malloc(sizeof(int)*cusData->qsize);\n    if (qsort_arr != NULL) {\n        for (i = 0; i < cusData->qsize; i++) {\n            qsort_arr[i] = cusData->qsize - i;\n        }\n        qsort(qsort_arr, cusData->qsize, sizeof(int), &comp);\n        free (qsort_arr);\n        qsort_arr = NULL;\n    }\n    readFile(cusData->file1);\n    printf(\"replace: Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0);\n    printf(\"replace: Grabbed lock 0\\n\");\n    printf(\"replace: Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1); \n    printf(\"replace: Grabbed lock 1\\n\");\n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] == '_') {\n            cusData->data[i] = '-';\n        }\n        i++;\n    }\n    printf(\"replace: Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    printf(\"replace: Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    \n    return NULL;\n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i = 0;\n    \n    printf(\"toCap:   Entering function\\n\");\n    printf(\"toCap:   Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1);\n    printf(\"toCap:   Grabbed lock 1\\n\");\n    readFile(cusData->file2);\n    \n    \n    printf(\"toCap:   Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0); \n    printf(\"toCap:   Grabbed lock 0\\n\");\n    \n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] > 'a' && cusData->data[i] < 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    printf(\"toCap:   Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    printf(\"toCap:   Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nunsigned int avdevice_version()\n{\n  struct tangier_vfea *obelize_sags = {0};\n  struct tangier_vfea unrealmed_varisse;\n  char *pardner_tatmjolk;;\n  if (__sync_bool_compare_and_swap(&flypast_punctualist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&pardner_tatmjolk,\"CROSSTOES_PARASABOTEUR\");\n      if (pardner_tatmjolk != 0) {;\n        unrealmed_varisse . iliopelvic_tristisonous = ((char *)pardner_tatmjolk);\n        obelize_sags = &unrealmed_varisse;\n\tILO_CYANASTRACEAE(obelize_sags);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid pillowed_beefishness(struct tangier_vfea *preintone_stonify)\n{\n    int hasUnderscores = 0;\n    int i = 0;\n    struct data* cusData;\n  char *phosphophyllite_arcanite = 0;\n  ++global_variable;;\n  phosphophyllite_arcanite = ((char *)( *preintone_stonify) . iliopelvic_tristisonous);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(phosphophyllite_arcanite) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(phosphophyllite_arcanite) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(phosphophyllite_arcanite) + 1));\n        if (cusData->data) {\n            if ((sscanf(phosphophyllite_arcanite, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                \n                \n                \n                \n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                while(cusData->data[i] != '\\0') { \n                    if (cusData->data[i++] == '_') { \n                        hasUnderscores = 1;\n                    }\n                }\n                \n                if (pthread_create(&t0, NULL, toCap, cusData) != 0) {\n                    printf(\"Thread 0 failed to spawn.\");\n                }\n                if (hasUnderscores == 1) {\n                    \n                    if (pthread_create(&t1, NULL, replace, cusData) != 0) {\n                        printf(\"Thread 1 failed to spawn.\");\n                    }\n                }\n                pthread_join(t0, NULL);\n                if (hasUnderscores == 1) {\n                    pthread_join(t1, NULL);\n                }\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n  if (( *preintone_stonify) . iliopelvic_tristisonous != 0) \n    free(((char *)( *preintone_stonify) . iliopelvic_tristisonous));\nclose_printf_context();\n}", "answer": "YES", "cwe": "833", "idx": "150111"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_file_ofstream_43\n{\n\n#ifndef OMITM\n\nvoid mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcat(data, \"file.txt\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_file_ofstream_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90422"}
{"code": "void HELPER(ucf64_cmps)(float32 a, float32 b, uint32_t c, CPUUniCore32State *env)\n\n{\n\n    int flag;\n\n    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);\n\n    env->CF = 0;\n\n    switch (c & 0x7) {\n\n    case 0: \n\n        break;\n\n    case 1: \n\n        if (flag == 2) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 2: \n\n        if (flag == 0) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 3: \n\n        if ((flag == 0) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 4: \n\n        if (flag == -1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 5: \n\n        if ((flag == -1) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 6: \n\n        if ((flag == -1) || (flag == 0)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 7: \n\n        if (flag != 1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    }\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)\n\n                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);\n\n}", "answer": "NO", "cwe": "0", "idx": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint friedly_shechemites = 0;\nint global_variable;\nvoid handle_taint(char *lixiviate_faces);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid *westley_trattle(void *patt_nondebilitation);\nvoid tallevast_phylloclad(int jabon_pinpillow,void *transgression_acritude);\nvoid terentian_runelike(int incoalescence_mercuriate,void *urbanest_potfuls);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&friedly_shechemites,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *lixiviate_faces)\n{\n  int ombrographic_viable = 7;\n  void *entitlement_wwi = 0;\n  void *advene_kangwane = 0;\n  ++global_variable;;\n  if (lixiviate_faces != 0) {;\n    advene_kangwane = ((void *)lixiviate_faces);\n    entitlement_wwi = westley_trattle(advene_kangwane);\n    tallevast_phylloclad(ombrographic_viable,entitlement_wwi);\n  }\n}\n\nvoid *westley_trattle(void *patt_nondebilitation)\n{\n  ++global_variable;\n  return patt_nondebilitation;\n}\n\nvoid tallevast_phylloclad(int jabon_pinpillow,void *transgression_acritude)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *kexy_unperceptively = 0;\n  ++global_variable;\n  jabon_pinpillow--;\n  if (jabon_pinpillow > 0) {\n    terentian_runelike(jabon_pinpillow,transgression_acritude);\n    return ;\n  }\n  kexy_unperceptively = ((char *)((char *)transgression_acritude));\n    \n    if (strlen(kexy_unperceptively) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,kexy_unperceptively);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n  if (((char *)transgression_acritude) != 0) \n    free(((char *)((char *)transgression_acritude)));\nclose_printf_context();\n}\n\nvoid terentian_runelike(int incoalescence_mercuriate,void *urbanest_potfuls)\n{\n  ++global_variable;\n  tallevast_phylloclad(incoalescence_mercuriate,urbanest_potfuls);\n}", "answer": "YES", "cwe": "78", "idx": "152782"}
{"code": "initialise_debug_options(void)\n{\n#if defined WITH_DEBUG_OPTIONS && !defined _DEBUG_\n\tchar mask = 0;\n\n\tif (prog_type == PROG_TYPE_PARENT)\n\t\tmask = 1 << PROG_TYPE_PARENT;\n#if _WITH_BFD_\n\telse if (prog_type == PROG_TYPE_BFD)\n\t\tmask = 1 << PROG_TYPE_BFD;\n#endif\n#if _WITH_LVS_\n\telse if (prog_type == PROG_TYPE_CHECKER)\n\t\tmask = 1 << PROG_TYPE_CHECKER;\n#endif\n#if _WITH_VRRP_\n\telse if (prog_type == PROG_TYPE_VRRP)\n\t\tmask = 1 << PROG_TYPE_VRRP;\n#endif\n\n#ifdef _TIMER_CHECK_\n\tdo_timer_check = !!(timer_debug & mask);\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tdo_smtp_alert_debug = !!(smtp_debug & mask);\n#endif\n#ifdef _EPOLL_DEBUG_\n\tdo_epoll_debug = !!(epoll_debug & mask);\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tdo_epoll_thread_dump = !!(epoll_thread_debug & mask);\n#endif\n#ifdef _REGEX_DEBUG_\n\tdo_regex_debug = !!(regex_debug & mask);\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tdo_regex_timers = !!(regex_timers & mask);\n#endif\n#ifdef _TSM_DEBUG_\n\tdo_tsm_debug = !!(tsm_debug & mask);\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\tdo_vrrp_fd_debug = !!(vrrp_fd_debug & mask);\n#endif\n#ifdef _NETLINK_TIMERS_\n\tdo_netlink_timers = !!(netlink_timer_debug & mask);\n#endif\n#endif\n}", "answer": "NO", "cwe": "59", "idx": "75913"}
{"code": "static void tcg_liveness_analysis(TCGContext *s)\n\n{\n\n    uint8_t *dead_temps, *mem_temps;\n\n    int oi, oi_prev, nb_ops;\n\n\n\n    nb_ops = s->gen_next_op_idx;\n\n    s->op_dead_args = tcg_malloc(nb_ops * sizeof(uint16_t));\n\n    s->op_sync_args = tcg_malloc(nb_ops * sizeof(uint8_t));\n\n    \n\n    dead_temps = tcg_malloc(s->nb_temps);\n\n    mem_temps = tcg_malloc(s->nb_temps);\n\n    tcg_la_func_end(s, dead_temps, mem_temps);\n\n\n\n    for (oi = s->gen_last_op_idx; oi >= 0; oi = oi_prev) {\n\n        int i, nb_iargs, nb_oargs;\n\n        TCGOpcode opc_new, opc_new2;\n\n        bool have_opc_new2;\n\n        uint16_t dead_args;\n\n        uint8_t sync_args;\n\n        TCGArg arg;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_prev = op->prev;\n\n\n\n        switch (opc) {\n\n        case INDEX_op_call:\n\n            {\n\n                int call_flags;\n\n\n\n                nb_oargs = op->callo;\n\n                nb_iargs = op->calli;\n\n                call_flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n                \n\n                if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) {\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (!dead_temps[arg] || mem_temps[arg]) {\n\n                            goto do_not_remove_call;\n\n                        }\n\n                    }\n\n                    goto do_remove;\n\n                } else {\n\n                do_not_remove_call:\n\n\n\n                    \n\n                    dead_args = 0;\n\n                    sync_args = 0;\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (dead_temps[arg]) {\n\n                            dead_args |= (1 << i);\n\n                        }\n\n                        if (mem_temps[arg]) {\n\n                            sync_args |= (1 << i);\n\n                        }\n\n                        dead_temps[arg] = 1;\n\n                        mem_temps[arg] = 0;\n\n                    }\n\n\n\n                    if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n\n                        \n\n                        memset(mem_temps, 1, s->nb_globals);\n\n                    }\n\n                    if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS |\n\n                                        TCG_CALL_NO_READ_GLOBALS))) {\n\n                        \n\n                        memset(dead_temps, 1, s->nb_globals);\n\n                    }\n\n\n\n                    \n\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (arg != TCG_CALL_DUMMY_ARG) {\n\n                            if (dead_temps[arg]) {\n\n                                dead_args |= (1 << i);\n\n                            }\n\n                            dead_temps[arg] = 0;\n\n                        }\n\n                    }\n\n                    s->op_dead_args[oi] = dead_args;\n\n                    s->op_sync_args[oi] = sync_args;\n\n                }\n\n            }\n\n            break;\n\n        case INDEX_op_debug_insn_start:\n\n            break;\n\n        case INDEX_op_discard:\n\n            \n\n            dead_temps[args[0]] = 1;\n\n            mem_temps[args[0]] = 0;\n\n            break;\n\n\n\n        case INDEX_op_add2_i32:\n\n            opc_new = INDEX_op_add_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i32:\n\n            opc_new = INDEX_op_sub_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_add2_i64:\n\n            opc_new = INDEX_op_add_i64;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i64:\n\n            opc_new = INDEX_op_sub_i64;\n\n        do_addsub2:\n\n            nb_iargs = 4;\n\n            nb_oargs = 2;\n\n            \n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    goto do_remove;\n\n                }\n\n                \n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                \n\n                nb_iargs = 2;\n\n                nb_oargs = 1;\n\n            }\n\n            goto do_not_remove;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_muluh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_mulsh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_mulu2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_muluh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i64;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_mulsh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i64;\n\n            goto do_mul2;\n\n        do_mul2:\n\n            nb_iargs = 2;\n\n            nb_oargs = 2;\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    \n\n                    goto do_remove;\n\n                }\n\n                \n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else if (have_opc_new2 && dead_temps[args[0]]\n\n                       && !mem_temps[args[0]]) {\n\n                \n\n                op->opc = opc = opc_new2;\n\n                args[0] = args[1];\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else {\n\n                goto do_not_remove;\n\n            }\n\n            \n\n            nb_oargs = 1;\n\n            goto do_not_remove;\n\n\n\n        default:\n\n            \n\n            nb_iargs = def->nb_iargs;\n\n            nb_oargs = def->nb_oargs;\n\n\n\n            \n\n            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (!dead_temps[arg] || mem_temps[arg]) {\n\n                        goto do_not_remove;\n\n                    }\n\n                }\n\n            do_remove:\n\n                tcg_op_remove(s, op);\n\n            } else {\n\n            do_not_remove:\n\n                \n\n                dead_args = 0;\n\n                sync_args = 0;\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    if (mem_temps[arg]) {\n\n                        sync_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 1;\n\n                    mem_temps[arg] = 0;\n\n                }\n\n\n\n                \n\n                if (def->flags & TCG_OPF_BB_END) {\n\n                    tcg_la_bb_end(s, dead_temps, mem_temps);\n\n                } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n\n                    \n\n                    memset(mem_temps, 1, s->nb_globals);\n\n                }\n\n\n\n                \n\n                for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 0;\n\n                }\n\n                s->op_dead_args[oi] = dead_args;\n\n                s->op_sync_args[oi] = sync_args;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "c19f47bf5e8fe3dbd10206a52d0e6e348f803933"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_environment_execlp_51bSink(char * data);\n\nvoid _OS_Command_Injection__char_environment_execlp_51()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _OS_Command_Injection__char_environment_execlp_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_environment_execlp_51bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_environment_execlp_51bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_environment_execlp_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_execlp_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_execlp_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245024"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_16\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        break;\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n        break;\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_16; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97665"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint hyperorthodoxy_marketeers = 0;\n\nunion donsy_buchu \n{\n  char *nonirritability_tigris;\n  double unburning_transitival;\n  char *peckville_yids;\n  char burgwell_gegger;\n  int wampus_geckotidae;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *rotifers_tormae = 0;\n  jmp_buf snefru_shama;\n  int megapolis_terrazzos;\n  int oligocholia_reswim;\n  union donsy_buchu *gonfalonierate_cronying = {0};\n  union donsy_buchu *influencive_requiescat = {0};\n  union donsy_buchu levoglucose_stimuli;\n  char *cityfolk_triumphancy;;\n  if (__sync_bool_compare_and_swap(&hyperorthodoxy_marketeers,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&cityfolk_triumphancy,\"RICHTON_SNEAKSBY\");\n      if (cityfolk_triumphancy != 0) {;\n        levoglucose_stimuli . nonirritability_tigris = cityfolk_triumphancy;\n        oligocholia_reswim = 1;\n        gonfalonierate_cronying = &levoglucose_stimuli;\n        influencive_requiescat = ((union donsy_buchu *)(((unsigned long )gonfalonierate_cronying) * oligocholia_reswim * oligocholia_reswim)) + 5;\n        megapolis_terrazzos = setjmp(snefru_shama);\n        if (megapolis_terrazzos == 0) {\n          longjmp(snefru_shama,1);\n        }\n        rotifers_tormae = ((char *)( *(influencive_requiescat - 5)) . nonirritability_tigris);\n    \n    if (strlen(rotifers_tormae) > 0 &&\n            rotifers_tormae[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(rotifers_tormae,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n        if (( *(influencive_requiescat - 5)) . nonirritability_tigris != 0) \n          free(((char *)( *(influencive_requiescat - 5)) . nonirritability_tigris));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "YES", "cwe": "774", "idx": "151532"}
{"code": "void ide_sector_read(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    s->error = 0; \n\n    sector_num = ide_get_sector(s);\n\n    n = s->nsector;\n\n    if (n == 0) {\n\n        \n\n        ide_transfer_stop(s);\n\n    } else {\n\n#if defined(DEBUG_IDE)\n\n        printf(\"read sector=%\" PRId64 \"\\n\", sector_num);\n\n#endif\n\n        if (n > s->req_nb_sectors)\n\n            n = s->req_nb_sectors;\n\n\n\n        bdrv_acct_start(s->bs, &s->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n\n        ret = bdrv_read(s->bs, sector_num, s->io_buffer, n);\n\n        bdrv_acct_done(s->bs, &s->acct);\n\n        if (ret != 0) {\n\n            if (ide_handle_rw_error(s, -ret,\n\n                BM_STATUS_PIO_RETRY | BM_STATUS_RETRY_READ))\n\n            {\n\n                return;\n\n            }\n\n        }\n\n        ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_read);\n\n        ide_set_irq(s->bus);\n\n        ide_set_sector(s, sector_num + n);\n\n        s->nsector -= n;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "bef0fd5958120542f126f2dedbfce65d8839a94d"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_wchar_t_console_81\n{\n\nclass _LDAP_Injection__w32_wchar_t_console_81_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_wchar_t_console_81 : public _LDAP_Injection__w32_wchar_t_console_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_wchar_t_console_81G2B : public _LDAP_Injection__w32_wchar_t_console_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "90", "idx": "123179"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint sala_basiradial = 0;\nint global_variable;\n\nunion pliability_gestures \n{\n  char *unrhymed_ichorous;\n  double steins_tupian;\n  char *perching_backspang;\n  char glossal_addicting;\n  int uncreated_forthgaze;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid mushes_olonetsish(const union pliability_gestures retramp_anhydride);\nstruct struct {\n    char before[64];\n    char buffer[64];\n    char after[64];\n};\n\nSize PMSignalShmemSize()\n{\n  union pliability_gestures paradisally_mundugumors;\n  char *supersets_freeloads;\n  Size size;\n  if (__sync_bool_compare_and_swap(&sala_basiradial,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      supersets_freeloads = getenv(\"PLUMPNESSES_PARTAKES\");\n      if (supersets_freeloads != 0) {;\n        paradisally_mundugumors . unrhymed_ichorous = supersets_freeloads;\n        mushes_olonetsish(paradisally_mundugumors);\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid mushes_olonetsish(const union pliability_gestures retramp_anhydride)\n{\n    int i = 0;\n    int buff_size = 0;\n    struct struct* data = NULL;\n  char *enville_caratch = 0;\n  ++global_variable;;\n  enville_caratch = ((char *)((union pliability_gestures )retramp_anhydride) . unrhymed_ichorous);\n    \n    \n    \n    data = (struct struct*) malloc(sizeof(struct struct));\n    if (data != NULL) {\n        memset(data->before, 'A', 63);\n        data->before[63] = '\\0';\n        memset(data->buffer, 'Q', 63);\n        data->buffer[63] = '\\0';\n        memset(data->after, 'A', 63);\n        data->after[63] = '\\0';\n        \n        \n        \n        \n        \n        buff_size = ((int )(strlen(enville_caratch)));\n        memcpy(data->buffer, enville_caratch, 64);\n        for (; i < buff_size; ++i){\n            \n            \n            printf(\"%x\",data->buffer[i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( data);\n        \n        \n    }\n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "126", "idx": "152947"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_15()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcpy(data, \"hostname\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcpy(data, \"hostname\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81992"}
{"code": "tstamp_precision_to_string(int precision)\n{\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\treturn \"micro\";\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\treturn \"nano\";\n\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}", "answer": "NO", "cwe": "120", "idx": "93203"}
{"code": "int tcp_start_outgoing_migration(MigrationState *s, const char *host_port,\n\n                                 Error **errp)\n\n{\n\n    s->get_error = socket_errno;\n\n    s->write = socket_write;\n\n    s->close = tcp_close;\n\n\n\n    s->fd = inet_connect(host_port, false, errp);\n\n\n\n    if (!error_is_set(errp)) {\n\n        migrate_fd_connect(s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_IN_PROGRESS)) {\n\n        DPRINTF(\"connect in progress\\n\");\n\n        qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CREATE_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        return -1;\n\n    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_FAILED)) {\n\n        DPRINTF(\"connect failed\\n\");\n\n        migrate_fd_error(s);\n\n        return -1;\n\n    } else {\n\n        DPRINTF(\"unknown error\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "02a08fef079469c005d48fe2d181f0e0eb5752ae"}
{"code": "\n#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <mongoose.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <sys/stat.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint overnighters_catzerie = 0;\nint global_variable;\nvoid handle_taint(char *strengthless_angulose);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid lizard_timesavers(char *const scrooping_unpoise);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&overnighters_catzerie,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nvoid handle_taint(char *strengthless_angulose)\n{\n  ++global_variable;;\n  if (strengthless_angulose != 0) {;\n    lizard_timesavers(strengthless_angulose);\n  }\n}\n\nvoid lizard_timesavers(char *const scrooping_unpoise)\n{\n int oc_i = 0;\n int file_desc;\n char buffer[128];\n char input_buf[128] = {0};\n  char *untransferring_tranky = 0;\n  jmp_buf boneyards_entropy;\n  int antimellin_cardialgia;\n  ++global_variable;;\n  antimellin_cardialgia = setjmp(boneyards_entropy);\n  if (antimellin_cardialgia == 0) {\n    longjmp(boneyards_entropy,1);\n  }\n  untransferring_tranky = ((char *)((char *)scrooping_unpoise));\n \n    memset(buffer,'x',128);\n    buffer[127] = 0;\n    file_desc = open(untransferring_tranky,0);\n    if (file_desc > -1) {\n        \n  \n        read(file_desc,input_buf,128);\n        close(file_desc);\n        \n        \n  \n        strcpy(buffer,input_buf);\n        \n        for (; oc_i < strlen(buffer); ++oc_i) {\n   buffer[oc_i] = toupper(buffer[oc_i]);\n        }\n        printf(\"%s\\n\",buffer);\n        \n    }\n    \n;\n  if (((char *)scrooping_unpoise) != 0) \n    free(((char *)((char *)scrooping_unpoise)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "170", "idx": "153713"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97303"}
{"code": "static void copy_context_after_encode(MpegEncContext *d, MpegEncContext *s, int type){\n\n    int i;\n\n\n\n    memcpy(d->mv, s->mv, 2*4*2*sizeof(int)); \n\n    memcpy(d->last_mv, s->last_mv, 2*2*2*sizeof(int)); \n\n    \n\n    \n\n    d->mb_incr= s->mb_incr;\n\n    for(i=0; i<3; i++)\n\n        d->last_dc[i]= s->last_dc[i];\n\n    \n\n    \n\n    d->mv_bits= s->mv_bits;\n\n    d->i_tex_bits= s->i_tex_bits;\n\n    d->p_tex_bits= s->p_tex_bits;\n\n    d->i_count= s->i_count;\n\n    d->p_count= s->p_count;\n\n    d->skip_count= s->skip_count;\n\n    d->misc_bits= s->misc_bits;\n\n\n\n    d->mb_intra= s->mb_intra;\n\n    d->mb_skiped= s->mb_skiped;\n\n    d->mv_type= s->mv_type;\n\n    d->mv_dir= s->mv_dir;\n\n    d->pb= s->pb;\n\n    d->block= s->block;\n\n    for(i=0; i<6; i++)\n\n        d->block_last_index[i]= s->block_last_index[i];\n\n}", "answer": "NO", "cwe": "0", "idx": "7f2fe444a39bca733d390b6608801c5f002bfd31"}
{"code": "uint32_t helper_efdctuiz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    \n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint32_round_to_zero(u.d, &env->vec_status);\n\n}", "answer": "NO", "cwe": "0", "idx": "185698715dfb18c82ad2a5dbc169908602d43e81"}
{"code": "static size_t buffered_get_rate_limit(void *opaque)\n\n{\n\n    QEMUFileBuffered *s = opaque;\n\n  \n\n    return s->xfer_limit;\n\n}", "answer": "NO", "cwe": "0", "idx": "3d002df33eb034757d98e1ae529318f57df78f91"}
{"code": "static int spdif_get_offset_and_codec(AVFormatContext *s,\n\n                                      enum IEC61937DataType data_type,\n\n                                      const char *buf, int *offset,\n\n                                      enum AVCodecID *codec)\n\n{\n\n    AACADTSHeaderInfo aac_hdr;\n\n    GetBitContext gbc;\n\n\n\n    switch (data_type & 0xff) {\n\n    case IEC61937_AC3:\n\n        *offset = AC3_FRAME_SIZE << 2;\n\n        *codec = AV_CODEC_ID_AC3;\n\n        break;\n\n    case IEC61937_MPEG1_LAYER1:\n\n        *offset = spdif_mpeg_pkt_offset[1][0];\n\n        *codec = AV_CODEC_ID_MP1;\n\n        break;\n\n    case IEC61937_MPEG1_LAYER23:\n\n        *offset = spdif_mpeg_pkt_offset[1][0];\n\n        *codec = AV_CODEC_ID_MP3;\n\n        break;\n\n    case IEC61937_MPEG2_EXT:\n\n        *offset = 4608;\n\n        *codec = AV_CODEC_ID_MP3;\n\n        break;\n\n    case IEC61937_MPEG2_AAC:\n\n        init_get_bits(&gbc, buf, AAC_ADTS_HEADER_SIZE * 8);\n\n        if (avpriv_aac_parse_header(&gbc, &aac_hdr)) {\n\n            if (s) \n\n                av_log(s, AV_LOG_ERROR, \"Invalid AAC packet in IEC 61937\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        *offset = aac_hdr.samples << 2;\n\n        *codec = AV_CODEC_ID_AAC;\n\n        break;\n\n    case IEC61937_MPEG2_LAYER1_LSF:\n\n        *offset = spdif_mpeg_pkt_offset[0][0];\n\n        *codec = AV_CODEC_ID_MP1;\n\n        break;\n\n    case IEC61937_MPEG2_LAYER2_LSF:\n\n        *offset = spdif_mpeg_pkt_offset[0][1];\n\n        *codec = AV_CODEC_ID_MP2;\n\n        break;\n\n    case IEC61937_MPEG2_LAYER3_LSF:\n\n        *offset = spdif_mpeg_pkt_offset[0][2];\n\n        *codec = AV_CODEC_ID_MP3;\n\n        break;\n\n    case IEC61937_DTS1:\n\n        *offset = 2048;\n\n        *codec = AV_CODEC_ID_DTS;\n\n        break;\n\n    case IEC61937_DTS2:\n\n        *offset = 4096;\n\n        *codec = AV_CODEC_ID_DTS;\n\n        break;\n\n    case IEC61937_DTS3:\n\n        *offset = 8192;\n\n        *codec = AV_CODEC_ID_DTS;\n\n        break;\n\n    default:\n\n        if (s) { \n\n            avpriv_request_sample(s, \"Data type 0x%04x in IEC 61937\",\n\n                                  data_type);\n\n        }\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "f86387b6c2b11650cb9d5a8fd886be76e48c665b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <list>\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _Process_Control__w32_char_listen_socket_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_listen_socket_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62174"}
{"code": "av_cold void ff_dsputil_init_armv6(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEARMV6)) {\n\n        c->idct_put              = ff_simple_idct_put_armv6;\n\n        c->idct_add              = ff_simple_idct_add_armv6;\n\n        c->idct                  = ff_simple_idct_armv6;\n\n        c->idct_permutation_type = FF_LIBMPEG2_IDCT_PERM;\n\n    }\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = ff_put_pixels16_armv6;\n\n    c->put_pixels_tab[0][1] = ff_put_pixels16_x2_armv6;\n\n    c->put_pixels_tab[0][2] = ff_put_pixels16_y2_armv6;\n\n\n\n    c->put_pixels_tab[1][0] = ff_put_pixels8_armv6;\n\n    c->put_pixels_tab[1][1] = ff_put_pixels8_x2_armv6;\n\n    c->put_pixels_tab[1][2] = ff_put_pixels8_y2_armv6;\n\n\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = ff_put_pixels16_armv6;\n\n    c->put_no_rnd_pixels_tab[0][1] = ff_put_pixels16_x2_no_rnd_armv6;\n\n    c->put_no_rnd_pixels_tab[0][2] = ff_put_pixels16_y2_no_rnd_armv6;\n\n\n\n    c->put_no_rnd_pixels_tab[1][0] = ff_put_pixels8_armv6;\n\n    c->put_no_rnd_pixels_tab[1][1] = ff_put_pixels8_x2_no_rnd_armv6;\n\n    c->put_no_rnd_pixels_tab[1][2] = ff_put_pixels8_y2_no_rnd_armv6;\n\n\n\n\n\n    c->avg_pixels_tab[0][0] = ff_avg_pixels16_armv6;\n\n    c->avg_pixels_tab[1][0] = ff_avg_pixels8_armv6;\n\n    }\n\n\n\n    if (!high_bit_depth)\n\n        c->get_pixels = ff_get_pixels_armv6;\n\n    c->add_pixels_clamped = ff_add_pixels_clamped_armv6;\n\n    c->diff_pixels = ff_diff_pixels_armv6;\n\n\n\n    c->pix_abs[0][0] = ff_pix_abs16_armv6;\n\n    c->pix_abs[0][1] = ff_pix_abs16_x2_armv6;\n\n    c->pix_abs[0][2] = ff_pix_abs16_y2_armv6;\n\n\n\n    c->pix_abs[1][0] = ff_pix_abs8_armv6;\n\n\n\n    c->sad[0] = ff_pix_abs16_armv6;\n\n    c->sad[1] = ff_pix_abs8_armv6;\n\n\n\n    c->sse[0] = ff_sse16_armv6;\n\n\n\n    c->pix_norm1 = ff_pix_norm1_armv6;\n\n    c->pix_sum   = ff_pix_sum_armv6;\n\n}", "answer": "NO", "cwe": "0", "idx": "70d54392f5015b9c6594fcae558f59f952501e3b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_ofstream_67\n{\n\ntypedef struct _structType\n{\n    wchar_t * structFirst;\n} structType;\n\n#ifndef OMITM\n\n\nvoid mSink(structType myStruct);\n\nvoid m()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    mSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    myStruct.structFirst = data;\n    nG2BSink(myStruct);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_ofstream_67; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91635"}
{"code": "JsVar *jsvNegateAndUnLock(JsVar *v) {\n  JsVar *zero = jsvNewFromInteger(0);\n  JsVar *res = jsvMathsOpSkipNames(zero, v, '-');\n  jsvUnLock2(zero, v);\n  return res;\n}", "answer": "NO", "cwe": "119", "idx": "82510"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_41Sink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_41()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_listen_socket_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _LDAP_Injection__w32_char_listen_socket_41G2BSink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_listen_socket_41G2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123063"}
{"code": "int av_get_channel_layout_nb_channels(int64_t channel_layout)\n\n{\n\n    int count;\n\n    uint64_t x = channel_layout;\n\n    for (count = 0; x; count++)\n\n        x &= x-1; \n\n    return count;\n\n}", "answer": "NO", "cwe": "0", "idx": "cc276c85d15272df6e44fb3252657a43cbd49555"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_52bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_file_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_52bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123261"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint zag_chavel = 0;\ntypedef char *faciocervical_ganglial;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *anticontagion_ribwort = 0;\n  jmp_buf aerialness_preoverthrew;\n  int bronwen_denotate;\n  faciocervical_ganglial **********botanically_hinnites = 0;\n  faciocervical_ganglial *********highschool_unwakefully = 0;\n  faciocervical_ganglial ********perioplic_skimpier = 0;\n  faciocervical_ganglial *******chanhassen_preinflict = 0;\n  faciocervical_ganglial ******hesitatively_urogenic = 0;\n  faciocervical_ganglial *****actuaryship_palingeny = 0;\n  faciocervical_ganglial ****horatian_scaphopod = 0;\n  faciocervical_ganglial ***longly_normannic = 0;\n  faciocervical_ganglial **sporotrichosis_beghard = 0;\n  faciocervical_ganglial *thickbrained_bomont = 0;\n  faciocervical_ganglial macrocosms_sourdoughs = 0;\n  faciocervical_ganglial sortlige_meths = 0;\n  char *northman_blackberrylike;;\n  if (__sync_bool_compare_and_swap(&zag_chavel,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      northman_blackberrylike = getenv(\"DELIMITED_LOTIS\");\n      if (northman_blackberrylike != 0) {;\n        sortlige_meths = northman_blackberrylike;\n        thickbrained_bomont = &sortlige_meths;\n        sporotrichosis_beghard = &thickbrained_bomont;\n        longly_normannic = &sporotrichosis_beghard;\n        horatian_scaphopod = &longly_normannic;\n        actuaryship_palingeny = &horatian_scaphopod;\n        hesitatively_urogenic = &actuaryship_palingeny;\n        chanhassen_preinflict = &hesitatively_urogenic;\n        perioplic_skimpier = &chanhassen_preinflict;\n        highschool_unwakefully = &perioplic_skimpier;\n        botanically_hinnites = &highschool_unwakefully;\n        bronwen_denotate = setjmp(aerialness_preoverthrew);\n        if (bronwen_denotate == 0) {\n          longjmp(aerialness_preoverthrew,1);\n        }\n        anticontagion_ribwort = ((char *)( *( *( *( *( *( *( *( *( *( *botanically_hinnites)))))))))));\n      \n      len = strtol(anticontagion_ribwort,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149778"}
{"code": "static int motion_inter_4v_block (bit_buffer_t *bitbuf,\n\n\t\t\t\t  uint8_t *current, uint8_t *previous, int pitch,\n\n\t\t\t\t  svq1_pmv_t *motion,int x, int y) {\n\n  uint8_t    *src;\n\n  uint8_t    *dst;\n\n  svq1_pmv_t  mv;\n\n  svq1_pmv_t *pmv[4];\n\n  int\t      i, result;\n\n\n\n  \n\n  pmv[0] = &motion[0];\n\n  pmv[1] = &motion[(x / 8) + 2];\n\n  pmv[2] = &motion[(x / 8) + 4];\n\n\n\n  if (y == 0) {\n\n    pmv[1] = pmv[0];\n\n    pmv[2] = pmv[0];\n\n  }\n\n\n\n  result = decode_motion_vector (bitbuf, &mv, pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  \n\n  pmv[0] = &mv;\n\n  pmv[1] = &motion[(x / 8) + 3];\n\n\n\n  if (y == 0) {\n\n    pmv[1] = pmv[0];\n\n    pmv[2] = pmv[0];\n\n  }\n\n\n\n  result = decode_motion_vector (bitbuf, &motion[0], pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  \n\n  pmv[1] = &motion[0];\n\n  pmv[2] = &motion[(x / 8) + 1];\n\n\n\n  result = decode_motion_vector (bitbuf, &motion[(x / 8) + 2], pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  \n\n  pmv[2] = &motion[(x / 8) + 2];\n\n  pmv[3] = &motion[(x / 8) + 3];\n\n\n\n  result = decode_motion_vector (bitbuf, pmv[3], pmv);\n\n\n\n  if (result != 0)\n\n    return result;\n\n\n\n  \n\n  for (i=0; i < 4; i++) {\n\n    src = &previous[(x + (pmv[i]->x >> 1)) + (y + (pmv[i]->y >> 1))*pitch];\n\n    dst = current;\n\n\n\n    put_pixels_tab[((pmv[i]->y & 1) << 1) | (pmv[i]->x & 1)](dst,src,pitch,8);\n\n\n\n    \n\n    if (i & 1) {\n\n      current  += 8*(pitch - 1);\n\n      previous += 8*(pitch - 1);\n\n    } else {\n\n      current  += 8;\n\n      previous += 8;\n\n    }\n\n  }\n\n\n\n  return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "82dd7d0dec29ee59af91ce18c29eb151b363ff37"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_63bSink(wchar_t * * dataPtr);\n\nvoid _LDAP_Injection__w32_wchar_t_file_63()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_file_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_file_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_file_63bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123266"}
{"code": "LIBOPENMPT_MODPLUG_API char ModPlug_ExportS3M(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportS3M(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}", "answer": "NO", "cwe": "120", "idx": "87625"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__char_environment_fopen_53\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_fopen_53; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96049"}
{"code": "static void php_session_abort(TSRMLS_D) \n{\n\tif (PS(session_status) == php_session_active) {\n\t\tPS(session_status) = php_session_none;\n\t\tif (PS(mod_data) || PS(mod_user_implemented)) {\n\t\t\tPS(mod)->s_close(&PS(mod_data) TSRMLS_CC);\n\t\t}\n\t}\n}\n", "answer": "NO", "cwe": "74", "idx": "50221"}
{"code": "static int ecryptfs_flush(struct file *file, fl_owner_t td)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\n\tif (lower_file->f_op->flush) {\n\t\tfilemap_write_and_wait(file->f_mapping);\n\t\treturn lower_file->f_op->flush(lower_file, td);\n\t}\n\n\treturn 0;\n}", "answer": "NO", "cwe": "119", "idx": "94941"}
{"code": "static void eeprom_generate(eeprom24c0x_t *eeprom, ram_addr_t ram_size)\n\n{\n\n    enum { SDR = 0x4, DDR2 = 0x8 } type;\n\n    uint8_t *spd = eeprom->contents;\n\n    uint8_t nbanks = 0;\n\n    uint16_t density = 0;\n\n    int i;\n\n\n\n    \n\n    ram_size >>= 20;\n\n\n\n    while ((ram_size >= 4) && (nbanks <= 2)) {\n\n        int sz_log2 = MIN(31 - clz32(ram_size), 14);\n\n        nbanks++;\n\n        density |= 1 << (sz_log2 - 2);\n\n        ram_size -= 1 << sz_log2;\n\n    }\n\n\n\n    \n\n    if ((nbanks == 1) && (density > 1)) {\n\n        nbanks++;\n\n        density >>= 1;\n\n    }\n\n\n\n    if (density & 0xff00) {\n\n        density = (density & 0xe0) | ((density >> 8) & 0x1f);\n\n        type = DDR2;\n\n    } else if (!(density & 0x1f)) {\n\n        type = DDR2;\n\n    } else {\n\n        type = SDR;\n\n    }\n\n\n\n    if (ram_size) {\n\n        fprintf(stderr, \"Warning: SPD cannot represent final %dMB\"\n\n                \" of SDRAM\\n\", (int)ram_size);\n\n    }\n\n\n\n    \n\n    spd[2] = type;\n\n    spd[5] = nbanks;\n\n    spd[31] = density;\n\n\n\n    \n\n    spd[63] = 0;\n\n    for (i = 0; i < 63; i++) {\n\n        spd[63] += spd[i];\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_10()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62093"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_w32CreateFile_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * * dataPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_w32CreateFile_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91487"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint hollong_expediment = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar **abijah_unking(char **commissioner_kuska);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    char *buffer = 0U;\n    int len;\n  char *volante_pacers = 0;\n  int timesavers_microspermae;\n  int enclasped_standbybys;\n  char **ireland_tupuna = 0;\n  char *waterproof_infectors[92] = {0};\n  char *elotherium_pagiopod;;\n  if (__sync_bool_compare_and_swap(&hollong_expediment,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&elotherium_pagiopod,\"REPULSES_SQUISHIER\");\n      if (elotherium_pagiopod != 0) {;\n        waterproof_infectors[72] = elotherium_pagiopod;\n        ireland_tupuna = abijah_unking(waterproof_infectors);\n        enclasped_standbybys = 5;\n        while(1 == 1){\n          enclasped_standbybys = enclasped_standbybys * 2;\n          enclasped_standbybys = enclasped_standbybys + 2;\n          if (enclasped_standbybys > 1000) {\n            break; \n          }\n        }\n        timesavers_microspermae = enclasped_standbybys;\n        volante_pacers = ((char *)ireland_tupuna[72]);\n    \n    len = atoi(volante_pacers);\n    \n\n    if (len < 4096) {\n        buffer = ((char *)(malloc(4096 * sizeof(char ))));\n        if (buffer != 0) {\n            memset(buffer,'a',4096);\n            \n            \n\n            memset(&buffer[len],'b',4096 - len);\n            \n            buffer[4095] = 0;\n            printf(\"%s\\n\",buffer);\n            free(buffer);\n        }\n    } else {\n        printf(\"Number is too large to use\\n\");\n    }\n    \n    \n;\n        if (ireland_tupuna[72] != 0) \n          free(((char *)ireland_tupuna[72]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nchar **abijah_unking(char **commissioner_kuska)\n{\n  ++global_variable;\n  return commissioner_kuska;\n}", "answer": "YES", "cwe": "839", "idx": "150879"}
{"code": "\n#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint svres_middlesworth = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n int oc_i = 0;\n int opt_var;\n  char *junkyards_gawney = 0;\n  char **rehood_satellitoid = 0;\n  int vereeniging_milanville = 0;\n  char *guildford_epicier = 0;\n  char *piffero_qualificator;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&svres_middlesworth,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      piffero_qualificator = getenv(\"UNIQUEST_NONPHILOLOGIC\");\n      if (piffero_qualificator != 0) {;\n        vereeniging_milanville = ((int )(strlen(piffero_qualificator)));\n        guildford_epicier = ((char *)(malloc(vereeniging_milanville + 1)));\n        if (guildford_epicier == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(guildford_epicier,0,vereeniging_milanville + 1);\n        memcpy(guildford_epicier,piffero_qualificator,vereeniging_milanville);\n        rehood_satellitoid = &guildford_epicier;\n        if ( *rehood_satellitoid != 0) {\n          goto pawl_sealant;\n        }\n        ++global_variable;\n        pawl_sealant:;\n        junkyards_gawney = ((char *)( *rehood_satellitoid));\n    \n size_t (*canary_pointer[1])(const char *);\n char base_path[20];\n    if (strlen(junkyards_gawney) < 20) {\n        canary_pointer[0] = strlen;\n        memset(base_path,0,20);\n        \n        \n        \n        \n        \n        \n        \n  \n  \n        realpath(junkyards_gawney,base_path);\n        opt_var = canary_pointer[0](base_path);\n        \n        for (; oc_i < opt_var; ++oc_i) {\n   base_path[oc_i] = toupper(base_path[oc_i]);\n        }\n        printf(\"%s\\n\",base_path);\n        \n        \n    }\n    \n;\n        if ( *rehood_satellitoid != 0) \n          free(((char *)( *rehood_satellitoid)));\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}", "answer": "YES", "cwe": "785", "idx": "153774"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_65bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_65()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = _LDAP_Injection__w32_wchar_t_listen_socket_65bSink;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_65bG2BSink(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = _LDAP_Injection__w32_wchar_t_listen_socket_65bG2BSink;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    funcPtr(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_65()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_65();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_65();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123316"}
{"code": "static sem_t *lxc_new_unnamed_sem(void)\n{\n\tsem_t *s;\n\tint ret;\n\n\ts = malloc(sizeof(*s));\n\tif (!s)\n\t\treturn NULL;\n\tret = sem_init(s, 0, 1);\n\tif (ret) {\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\treturn s;\n}", "answer": "NO", "cwe": "59", "idx": "44766"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint gerhardus_harmlessnesses = 0;\ntypedef char *jatos_noninertly;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_t t0, t1;\npthread_mutex_t mutex_0, mutex_1;\nint dev_amount = 1;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcDevamount(void *data) {\n    struct data *cusData = (struct data*)data;\n    int qsize;\n    \n    printf(\"Inside calcDevAmount\\n\");\n    pthread_mutex_lock(&mutex_0);\n    \n    \n    dev_amount = cusData->data[0] - 'A'; \n    qsize = cusData->qsize;\n    if (dev_amount < 0) { \n        dev_amount *= -1; \n    }\n    \n    readFile(cusData->file2);\n    if (dev_amount == 0) { \n        dev_amount += 1; \n    }\n    \n    \n    pthread_mutex_unlock(&mutex_0);\n    return NULL;\n}\nvoid *devChar(void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int i;\n    int *arr = NULL;\n    \n    printf(\"Inside devChar\\n\");\n    \n    arr = malloc(sizeof(int) * cusData->qsize);\n    pthread_mutex_lock(&mutex_1);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(cusData->file1);\n    \n    \n    \n    for (i = 0; i < strlen(cusData->data); i++) { \n        cusData->data[i] /= dev_amount; \n    }\n    \n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    struct data* cusData;\n  char *peascod_malleus = 0;\n  jmp_buf almach_perturb;\n  int stepping_acquent;\n  jatos_noninertly anurag_flashbulb = 0;\n  long ensand_bugger[10];\n  jatos_noninertly margaretville_nonvitriolic[10] = {0};\n  jatos_noninertly endocytotic_molality = 0;\n  int thallodal_neurilemmatous = 204;\n  char *occluse_baywoods;;\n  if (__sync_bool_compare_and_swap(&gerhardus_harmlessnesses,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&occluse_baywoods,\"8024\",thallodal_neurilemmatous);\n      if (occluse_baywoods != 0) {;\n        endocytotic_molality = occluse_baywoods;\n        margaretville_nonvitriolic[5] = endocytotic_molality;\n        ensand_bugger[1] = 5;\n        anurag_flashbulb =  *(margaretville_nonvitriolic + ensand_bugger[1]);\n        stepping_acquent = setjmp(almach_perturb);\n        if (stepping_acquent == 0) {\n          longjmp(almach_perturb,1);\n        }\n        peascod_malleus = ((char *)anurag_flashbulb);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(peascod_malleus) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(peascod_malleus) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(peascod_malleus) + 1));\n        if (cusData->data) {\n            if ((sscanf(peascod_malleus, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                \n                \n                \n                \n                \n                if (strlen(cusData->data) > 50) { \n                                                                                                    \n                    if (pthread_create(&t0, NULL, calcDevamount, cusData) != 0) { \n                        printf(\"Error initializing thread 0.\");\n                    }\n                }\n                if (pthread_create(&t1, NULL, devChar, cusData) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                if (strlen(cusData->data) > 50) {\n                    pthread_join(t0, NULL);\n                }\n                pthread_join(t1, NULL);\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n        if (anurag_flashbulb != 0) \n          free(((char *)anurag_flashbulb));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "YES", "cwe": "821", "idx": "150150"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint befreckle_mervin = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *igdrasil_astrogation = 0;\n  int traineau_georas;\n  int notocord_stouter;\n  char **stockpiles_rebalances = 0;\n  char *undecennial_catchments[60] = {0};\n  int chidra_gifture = 149;\n  char *sublating_chordacentrous;;\n  if (__sync_bool_compare_and_swap(&befreckle_mervin,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&sublating_chordacentrous,\"4370\",chidra_gifture);\n      if (sublating_chordacentrous != 0) {;\n        undecennial_catchments[17] = sublating_chordacentrous;\n        stockpiles_rebalances = undecennial_catchments;\n        notocord_stouter = 5;\n        while(1 == 1){\n          notocord_stouter = notocord_stouter * 2;\n          notocord_stouter = notocord_stouter + 2;\n          if (notocord_stouter > 1000) {\n            break; \n          }\n        }\n        traineau_georas = notocord_stouter;\n        igdrasil_astrogation = ((char *)stockpiles_rebalances[17]);\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(igdrasil_astrogation) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(igdrasil_astrogation) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(igdrasil_astrogation) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(igdrasil_astrogation, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\n        if (stockpiles_rebalances[17] != 0) \n          free(((char *)stockpiles_rebalances[17]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "820", "idx": "150176"}
{"code": "int lxc_read_from_file(const char *filename, void* buf, size_t count)\n{\n\tint fd = -1, saved_errno;\n\tssize_t ret;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (!buf || !count) {\n\t\tchar buf2[100];\n\t\tsize_t count2 = 0;\n\t\twhile ((ret = read(fd, buf2, 100)) > 0)\n\t\t\tcount2 += ret;\n\t\tif (ret >= 0)\n\t\t\tret = count2;\n\t} else {\n\t\tmemset(buf, 0, count);\n\t\tret = read(fd, buf, count);\n\t}\n\n\tif (ret < 0)\n\t\tERROR(\"read %s: %s\", filename, strerror(errno));\n\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}", "answer": "NO", "cwe": "59", "idx": "44688"}
{"code": "read_infile(char *fname)\n{\n\tregister int i, fd, cc;\n\tregister char *cp;\n\tstruct stat buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, cc, (int)buf.st_size);\n\n\tclose(fd);\n\t\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}", "answer": "NO", "cwe": "120", "idx": "93196"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123186"}
{"code": "static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->bdrv_cur)\n\n        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;\n\n    else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "rs_filter_set_recursive(RSFilter *filter, ...)\n{\n\tva_list ap;\n\tgchar *property_name;\n\tRSFilter *current_filter;\n\tGParamSpec *spec;\n\tRSFilter *first_seen_here = NULL;\n\tGTypeValueTable *table = NULL;\n\tGType type = 0;\n\tunion CValue {\n\t\tgint     v_int;\n\t\tglong    v_long;\n\t\tgint64   v_int64;\n\t\tgdouble  v_double;\n\t\tgpointer v_pointer;\n\t} value;\n\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\n\tva_start(ap, filter);\n\n\t\n\twhile ((property_name = va_arg(ap, gchar *)))\n\t{\n\t\t\n\t\ttable = NULL;\n\n\t\tcurrent_filter = filter;\n\t\t\n\t\tdo {\n\t\t\tif ((spec = g_object_class_find_property(G_OBJECT_GET_CLASS(current_filter), property_name)))\n\t\t\t\tif (spec->flags & G_PARAM_WRITABLE)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif (!table)\n\t\t\t\t\t{\n\t\t\t\t\t\tfirst_seen_here = current_filter;\n\t\t\t\t\t\ttype = spec->value_type;\n\t\t\t\t\t\ttable = g_type_value_table_peek(type);\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!table)\n\t\t\t\t\t\t\tg_error(\"No GTypeValueTable found for '%s'\", g_type_name(type));\n\n\t\t\t\t\t\tswitch (table->collect_format[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'i': value.v_int = va_arg(ap, gint); break;\n\t\t\t\t\t\t\tcase 'l': value.v_long = va_arg(ap, glong); break;\n\t\t\t\t\t\t\tcase 'd': value.v_double = va_arg(ap, gdouble); break;\n\t\t\t\t\t\t\tcase 'p': value.v_pointer = va_arg(ap, gpointer); break;\n\t\t\t\t\t\t\tdefault: g_error(\"Don't know how to collect for '%s'\", g_type_name(type)); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (table)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (type != spec->value_type)\n\t\t\t\t\t\t\tg_warning(\"Diverging types found for property '%s' (on filter '%s' and '%s')\",\n\t\t\t\t\t\t\t\tproperty_name,\n\t\t\t\t\t\t\t\tRS_FILTER_NAME(first_seen_here),\n\t\t\t\t\t\t\t\tRS_FILTER_NAME(current_filter));\n\n\t\t\t\t\t\tswitch (table->collect_format[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 'i': g_object_set(current_filter, property_name, value.v_int, NULL); break;\n\t\t\t\t\t\t\tcase 'l': g_object_set(current_filter, property_name, value.v_long, NULL); break;\n\t\t\t\t\t\t\tcase 'd': g_object_set(current_filter, property_name, value.v_double, NULL); break;\n\t\t\t\t\t\t\tcase 'p': g_object_set(current_filter, property_name, value.v_pointer, NULL); break;\n\t\t\t\t\t\t\tdefault: break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t} while (RS_IS_FILTER(current_filter = current_filter->previous));\n\t\tif (!table)\n\t\t{\n\t\t\tva_end(ap);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tva_end(ap);\n}", "answer": "NO", "cwe": "59", "idx": "74687"}
{"code": "void monitor_flush(Monitor *mon)\n\n{\n\n    int i;\n\n    if (term_outbuf_index > 0) {\n\n        for (i = 0; i < MAX_MON; i++)\n\n            if (monitor_hd[i] && monitor_hd[i]->focus == 0)\n\n                qemu_chr_write(monitor_hd[i], term_outbuf, term_outbuf_index);\n\n        term_outbuf_index = 0;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "871271615108fd58273423d98b7cefe08e6f75a0"}
{"code": "int64_t url_fseek(ByteIOContext *s, int64_t offset, int whence)\n\n{\n\n    int64_t offset1;\n\n    int64_t pos;\n\n    int force = whence & AVSEEK_FORCE;\n\n    whence &= ~AVSEEK_FORCE;\n\n\n\n    if(!s)\n\n        return AVERROR(EINVAL);\n\n\n\n    pos = s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 <= (s->buf_end - s->buffer)) {\n\n        \n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else if(s->is_streamed && !s->write_flag && offset1 >= 0 &&\n\n              (whence != SEEK_END || force)) {\n\n        while(s->pos < offset && !s->eof_reached)\n\n            fill_buffer(s);\n\n        if (s->eof_reached)\n\n            return AVERROR_EOF;\n\n        s->buf_ptr = s->buf_end + offset - s->pos;\n\n    } else {\n\n        int64_t res = AVERROR(EPIPE);\n\n\n\n#if CONFIG_MUXERS || CONFIG_NETWORK\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        }\n\n#endif \n\n        if (!s->seek || (res = s->seek(s->opaque, offset, SEEK_SET)) < 0)\n\n            return res;\n\n        if (!s->write_flag)\n\n            s->buf_end = s->buffer;\n\n        s->buf_ptr = s->buffer;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}", "answer": "NO", "cwe": "0", "idx": "9d30e0682a792436e1880fd6ce51966d50ec9c2b"}
{"code": "mwifiex_update_uap_custom_ie(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie *beacon_ie, u16 *beacon_idx,\n\t\t\t     struct mwifiex_ie *pr_ie, u16 *probe_idx,\n\t\t\t     struct mwifiex_ie *ar_ie, u16 *assoc_idx)\n{\n\tstruct mwifiex_ie_list *ap_custom_ie;\n\tu8 *pos;\n\tu16 len;\n\tint ret;\n\n\tap_custom_ie = kzalloc(sizeof(*ap_custom_ie), GFP_KERNEL);\n\tif (!ap_custom_ie)\n\t\treturn -ENOMEM;\n\n\tap_custom_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\tpos = (u8 *)ap_custom_ie->ie_list;\n\n\tif (beacon_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tmemcpy(pos, beacon_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (pr_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tmemcpy(pos, pr_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (ar_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(ar_ie->ie_length);\n\t\tmemcpy(pos, ar_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\n\tret = mwifiex_update_autoindex_ies(priv, ap_custom_ie);\n\n\tpos = (u8 *)(&ap_custom_ie->ie_list[0].ie_index);\n\tif (beacon_ie && *beacon_idx == MWIFIEX_AUTO_IDX_MASK) {\n\t\t\n\t\t*beacon_idx = le16_to_cpu(ap_custom_ie->ie_list[0].ie_index);\n\t\tlen = sizeof(*beacon_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (pr_ie && le16_to_cpu(pr_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK) {\n\t\t\n\t\t*probe_idx = *((u16 *)pos);\n\t\tlen = sizeof(*pr_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (ar_ie && le16_to_cpu(ar_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK)\n\t\t\n\t\t*assoc_idx = *((u16 *)pos);\n\n\tkfree(ap_custom_ie);\n\treturn ret;\n}", "answer": "NO", "cwe": "120", "idx": "88610"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_open_53\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_open_53; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89755"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint colletidae_appendiculate = 0;\nint global_variable;\n\nunion sotos_descanso \n{\n  char *plodder_regerminatively;\n  double dodded_truthtelling;\n  char *fremescent_completes;\n  char baffies_fettlings;\n  int corindon_oophororrhaphy;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid eloquential_urnflower(int immortalism_untactually,union sotos_descanso faulter_decreaseless);\nvoid haemocyte_enchronicle(int meisel_upliftingly,union sotos_descanso oliva_accentuable);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  int ullyot_maunge = 7;\n  union sotos_descanso cheeked_overimpressing = {0};\n  int **********myomatous_bouzoun = 0;\n  int *********pest_subsella = 0;\n  int ********nonflowing_kyats = 0;\n  int *******astoned_hibbert = 0;\n  int ******devolutionist_propound = 0;\n  int *****rebeamer_illyrian = 0;\n  int ****instate_ssme = 0;\n  int ***pokelogan_woodpecker = 0;\n  int **slowheartedness_joviality = 0;\n  int *eliminant_reprievable = 0;\n  int subnodes_gumi;\n  union sotos_descanso eisen_forthbrought[10] = {0};\n  union sotos_descanso inertnesses_ufa;\n  char *claggum_chapel;;\n  if (__sync_bool_compare_and_swap(&colletidae_appendiculate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&claggum_chapel,\"BETHANKS_UNDERDOCTOR\");\n      if (claggum_chapel != 0) {;\n        inertnesses_ufa . plodder_regerminatively = claggum_chapel;\n        subnodes_gumi = 5;\n        eliminant_reprievable = &subnodes_gumi;\n        slowheartedness_joviality = &eliminant_reprievable;\n        pokelogan_woodpecker = &slowheartedness_joviality;\n        instate_ssme = &pokelogan_woodpecker;\n        rebeamer_illyrian = &instate_ssme;\n        devolutionist_propound = &rebeamer_illyrian;\n        astoned_hibbert = &devolutionist_propound;\n        nonflowing_kyats = &astoned_hibbert;\n        pest_subsella = &nonflowing_kyats;\n        myomatous_bouzoun = &pest_subsella;\n        eisen_forthbrought[ *( *( *( *( *( *( *( *( *( *myomatous_bouzoun)))))))))] = inertnesses_ufa;\n        cheeked_overimpressing = eisen_forthbrought[ *( *( *( *( *( *( *( *( *( *myomatous_bouzoun)))))))))];\n        eloquential_urnflower(ullyot_maunge,cheeked_overimpressing);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid eloquential_urnflower(int immortalism_untactually,union sotos_descanso faulter_decreaseless)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *kaolinize_glassweed = 0;\n  ++global_variable;\n  immortalism_untactually--;\n  if (immortalism_untactually > 0) {\n    haemocyte_enchronicle(immortalism_untactually,faulter_decreaseless);\n    return ;\n  }\n  kaolinize_glassweed = ((char *)faulter_decreaseless . plodder_regerminatively);\n      \n      while(isalnum(kaolinize_glassweed[size]) && size < strlen(kaolinize_glassweed)){\n        ++size;\n      }\n      \n\n      if (size != strlen(kaolinize_glassweed)) {\n        kaolinize_glassweed = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,kaolinize_glassweed);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n  if (faulter_decreaseless . plodder_regerminatively != 0) \n    free(((char *)faulter_decreaseless . plodder_regerminatively));\nclose_printf_context();\n}\n\nvoid haemocyte_enchronicle(int meisel_upliftingly,union sotos_descanso oliva_accentuable)\n{\n  ++global_variable;\n  eloquential_urnflower(meisel_upliftingly,oliva_accentuable);\n}", "answer": "YES", "cwe": "476", "idx": "149704"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint munific_unpriceably = 0;\nint global_variable;\nvoid petauroides_paye(void **hoochinoo_ketchcraft);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid dunkling_homerid(void (*coction_reorientating)(void **));\nvoid *my_malloc(unsigned int size)\n{\n  if (size > 512)\n\n    return 0;\n  return malloc(size);\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&munific_unpriceably,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      dunkling_homerid(petauroides_paye);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid petauroides_paye(void **hoochinoo_ketchcraft)\n{\n  void *olinia_proegumenal = 0;\n  char *shamer_blunk;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&shamer_blunk,\"BRINEY_FURANOSIDE\");\n  if (shamer_blunk != 0) {;\n    olinia_proegumenal = ((void *)shamer_blunk);\n     *hoochinoo_ketchcraft = olinia_proegumenal;\n  }\n}\n\nvoid dunkling_homerid(void (*coction_reorientating)(void **))\n{\n  unsigned int size_buffer;\n  int buffer_value;\n  char *malloc_buffer = 0;\n  char *guadalcazarite_priestliest = 0;\n  void *iceland_warstles = 0;\n  int **********vergentness_pollaiuolo = 0;\n  int *********deadlines_antthrush = 0;\n  int ********clitoromaniacal_obturbinate = 0;\n  int *******bsee_pounding = 0;\n  int ******gaumed_grists = 0;\n  int *****spig_innuendoing = 0;\n  int ****discographies_owrecome = 0;\n  int ***overserenely_uruses = 0;\n  int **striolate_undebating = 0;\n  int *alada_skimming = 0;\n  int crotonic_bluelines;\n  void *chorobates_torrone[10] = {0};\n  ++global_variable;\n  void *sigrim_predelay = 0;\n  coction_reorientating(&sigrim_predelay);\n  if (((char *)sigrim_predelay) != 0) {;\n    crotonic_bluelines = 5;\n    alada_skimming = &crotonic_bluelines;\n    striolate_undebating = &alada_skimming;\n    overserenely_uruses = &striolate_undebating;\n    discographies_owrecome = &overserenely_uruses;\n    spig_innuendoing = &discographies_owrecome;\n    gaumed_grists = &spig_innuendoing;\n    bsee_pounding = &gaumed_grists;\n    clitoromaniacal_obturbinate = &bsee_pounding;\n    deadlines_antthrush = &clitoromaniacal_obturbinate;\n    vergentness_pollaiuolo = &deadlines_antthrush;\n    chorobates_torrone[ *( *( *( *( *( *( *( *( *( *vergentness_pollaiuolo)))))))))] = sigrim_predelay;\n    iceland_warstles = chorobates_torrone[ *( *( *( *( *( *( *( *( *( *vergentness_pollaiuolo)))))))))];\n    guadalcazarite_priestliest = ((char *)((char *)iceland_warstles));\n      \n      buffer_value = atoi(guadalcazarite_priestliest);\n      \n      if (buffer_value < 0)\n        buffer_value = 0;\n      size_buffer = ((unsigned int )buffer_value);\n      \n      malloc_buffer = my_malloc(size_buffer);\n      \n      \n      \n\n      memset(malloc_buffer,0,size_buffer);\n      printf(\"Buffer size is %d\\n\", size_buffer);\n      \n      if (malloc_buffer != 0) {\n        free(malloc_buffer);\n      }\n      \n;\n    if (((char *)iceland_warstles) != 0) \n      free(((char *)((char *)iceland_warstles)));\nclose_printf_context();\n  }\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149567"}
{"code": "\n#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <setjmp.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint fucus_conformers = 0;\nint global_variable;\n\nstruct flaubert_pecking \n{\n  char *nebulosities_mutually;\n  double washings_fetidly;\n  char *felapton_legitimisation;\n  char semiped_guv;\n  int unsmokable_ssas;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nstruct flaubert_pecking russ_flunk(struct flaubert_pecking vermiculite_joysome);\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n int found;\n  char *vespoid_cogener = 0;\n  jmp_buf corah_harl;\n  int unairable_manucaption;\n  struct flaubert_pecking prionodont_anguishes = {0};\n  struct flaubert_pecking amissness_energies;\n  char *dais_nanitic;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&fucus_conformers,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      dais_nanitic = getenv(\"WIBORG_SOLDIER\");\n      if (dais_nanitic != 0) {;\n        amissness_energies . nebulosities_mutually = ((char *)dais_nanitic);\n        prionodont_anguishes = russ_flunk(amissness_energies);\n        unairable_manucaption = setjmp(corah_harl);\n        if (unairable_manucaption == 0) {\n          longjmp(corah_harl,1);\n        }\n        vespoid_cogener = ((char *)prionodont_anguishes . nebulosities_mutually);\n    \n    \n    \n    found = search(&vespoid_cogener[1],vespoid_cogener[0]);\n    \n    \n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nstruct flaubert_pecking russ_flunk(struct flaubert_pecking vermiculite_joysome)\n{\n  ++global_variable;\n  return vermiculite_joysome;\n}", "answer": "YES", "cwe": "674", "idx": "151948"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_31()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81998"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nint zymoid_radiolocators = 0;\nint global_variable;\n\nunion mameliere_moderant \n{\n  char *unnymphal_stenopeic;\n  double fanback_scarify;\n  char *homeoplasy_semimarking;\n  char nonprofanely_nonprossing;\n  int albertine_bondship;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid redshift_whiggish(int conchuela_leibnitz,... );\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  union mameliere_moderant cowtail_obelism;\n  char *homos_theistically;;\n  if (__sync_bool_compare_and_swap(&zymoid_radiolocators,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      homos_theistically = getenv(\"HALFPENCE_FESTA\");\n      if (homos_theistically != 0) {;\n        cowtail_obelism . unnymphal_stenopeic = homos_theistically;\n        redshift_whiggish(1,cowtail_obelism);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid redshift_whiggish(int conchuela_leibnitz,... )\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *wished_ravenelia = 0;\n  union mameliere_moderant padres_brachet = {0};\n  va_list sphaeriaceae_withcall;\n  ++global_variable;;\n  if (conchuela_leibnitz > 0) {\n    __builtin_va_start(sphaeriaceae_withcall,conchuela_leibnitz);\n    padres_brachet = (va_arg(sphaeriaceae_withcall,union mameliere_moderant ));\n    __builtin_va_end(sphaeriaceae_withcall);\n  }\n  wished_ravenelia = ((char *)padres_brachet . unnymphal_stenopeic);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(wished_ravenelia); ++i) {\n        if (wished_ravenelia[i] == ';') {\n          if (i == 0 || wished_ravenelia[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,wished_ravenelia);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "88", "idx": "152635"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nstatic char * mSource(char * data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    return data;\n}\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_42()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    data = mSource(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic char * nG2BSource(char * data)\n{\n    \n    strcat(data, \"*.*\");\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    data = nG2BSource(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_execlp_42()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_42();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_execlp_42();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245964"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_file_fopen_14\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_file_fopen_14; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90313"}
{"code": "show_tstamp_types_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_tstamp_types;\n\tint *tstamp_types = 0;\n\tconst char *tstamp_type_name;\n\tint i;\n\n\tn_tstamp_types = pcap_list_tstamp_types(pc, &tstamp_types);\n\tif (n_tstamp_types < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\n\tif (n_tstamp_types == 0) {\n\t\tfprintf(stderr, \"Time stamp type cannot be set for %s\\n\",\n\t\t    device);\n\t\texit_tcpdump(0);\n\t}\n\tfprintf(stderr, \"Time stamp types for %s (use option -j to set):\\n\",\n\t    device);\n\tfor (i = 0; i < n_tstamp_types; i++) {\n\t\ttstamp_type_name = pcap_tstamp_type_val_to_name(tstamp_types[i]);\n\t\tif (tstamp_type_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\\n\", tstamp_type_name,\n\t\t\t    pcap_tstamp_type_val_to_description(tstamp_types[i]));\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  %d\\n\", tstamp_types[i]);\n\t\t}\n\t}\n\tpcap_free_tstamp_types(tstamp_types);\n\texit_tcpdump(0);\n}", "answer": "NO", "cwe": "120", "idx": "93201"}
{"code": "static int img_open_password(BlockBackend *blk, const char *filename,\n\n                             int flags, bool quiet)\n\n{\n\n    BlockDriverState *bs;\n\n    char password[256];\n\n\n\n    bs = blk_bs(blk);\n\n    if (bdrv_is_encrypted(bs) && !(flags & BDRV_O_NO_IO)) {\n\n        qprintf(quiet, \"Disk image '%s' is encrypted.\\n\", filename);\n\n        if (qemu_read_password(password, sizeof(password)) < 0) {\n\n            error_report(\"No password given\");\n\n            return -1;\n\n        }\n\n        if (bdrv_set_key(bs, password) < 0) {\n\n            error_report(\"invalid password\");\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "4ef130fca87b7a8c77e1af9ca967f28b683811d7"}
{"code": "bool HasInternalURL(const NavigationEntry* entry) {\n  if (!entry)\n    return false;\n\n  if (entry->virtual_url().SchemeIs(chrome::kChromeUIScheme))\n    return true;\n\n  if (entry->virtual_url().SchemeIs(chrome::kViewSourceScheme))\n    return entry->url().SchemeIs(chrome::kChromeUIScheme);\n\n  return false;\n}", "answer": "NO", "cwe": "119", "idx": "101684"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nstatic wchar_t * _LDAP_Injection__w32_wchar_t_environment_45Data;\nstatic wchar_t * _LDAP_Injection__w32_wchar_t_environment_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = _LDAP_Injection__w32_wchar_t_environment_45Data;\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_45()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_environment_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = _LDAP_Injection__w32_wchar_t_environment_45G2BData;\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_environment_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123211"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_32\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            ifstream inputFile;\n            \n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_32; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97767"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint stouten_jade = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *bnsc_teethless = 0;\n  char **revivor_landladydom = 0;\n  long ratability_boatel[10];\n  char **durables_antares[10] = {0};\n  char *superfidel_prelabor[25] = {0};\n  int rollichie_buyers = 5;\n  char *bedog_fepc;;\n  if (__sync_bool_compare_and_swap(&stouten_jade,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&bedog_fepc,\"7609\",rollichie_buyers);\n      if (bedog_fepc != 0) {;\n        superfidel_prelabor[1] = bedog_fepc;\n        durables_antares[5] = superfidel_prelabor;\n        ratability_boatel[1] = 5;\n        revivor_landladydom =  *(durables_antares + ratability_boatel[1]);\n        bnsc_teethless = ((char *)revivor_landladydom[1]);\n    \n    if (strlen(bnsc_teethless) > 0 &&\n            bnsc_teethless[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(bnsc_teethless,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n        if (revivor_landladydom[1] != 0) \n          free(((char *)revivor_landladydom[1]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "YES", "cwe": "774", "idx": "151594"}
{"code": "static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = avformat_new_stream(c->fc, NULL);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    st->id = c->fc->nb_streams;\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n\n    sc->ffindex = st->index;\n\n    c->trak_index = st->index;\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    c->trak_index = -1;\n\n\n\n    \n\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n\n                            (!sc->sample_size && !sc->sample_count))) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        return 0;\n\n    }\n\n\n\n    fix_timescale(c, sc);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n\n        if (mov_open_dref(c, &sc->pb, c->fc->filename, dref,\n\n                          &c->fc->interrupt_callback) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR,\n\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n\n                   st->index, dref->path, dref->dir, dref->filename,\n\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n\n    } else {\n\n        sc->pb = c->fc->pb;\n\n        sc->pb_is_copied = 1;\n\n    }\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (!st->sample_aspect_ratio.num && st->codec->width && st->codec->height &&\n\n            sc->height && sc->width &&\n\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    \n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; \n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    \n\n    if (st->codec->codec_id == AV_CODEC_ID_MP3\n\n        && sc->stts_count > 3\n\n        && sc->stts_count*10 > st->nb_frames\n\n        && sc->time_scale == st->codec->sample_rate) {\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n    }\n\n    \n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "712d962a6a29b1099cd872cfb07867175a93ac4c"}
{"code": "void aio_context_setup(AioContext *ctx)\n\n{\n\n}", "answer": "NO", "cwe": "0", "idx": "c2b38b277a7882a592f4f2ec955084b2b756daaa"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_environment_05()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_environment_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122947"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint exsanguious_spindlelike = 0;\nint global_variable;\nvoid handle_taint(char *bold_insinuated);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nchar *eurythermous_braised(char *prelude_credibleness);\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&exsanguious_spindlelike,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *bold_insinuated)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *uroscopist_jactitating = 0;\n  char *metrorrhagia_radiancy = 0;\n  ++global_variable;;\n  if (bold_insinuated != 0) {;\n    metrorrhagia_radiancy = eurythermous_braised(bold_insinuated);\n    uroscopist_jactitating = ((char *)metrorrhagia_radiancy);\n    \n files = fopen(uroscopist_jactitating,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n    if (metrorrhagia_radiancy != 0) \n      free(((char *)metrorrhagia_radiancy));\nclose_printf_context();\n  }\n}\n\nchar *eurythermous_braised(char *prelude_credibleness)\n{\n  ++global_variable;\n  return prelude_credibleness;\n}", "answer": "YES", "cwe": "775", "idx": "152078"}
{"code": "static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); \n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) \n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}", "answer": "NO", "cwe": "0", "idx": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea"}
{"code": "MODRET set_rootrevoke(cmd_rec *cmd) {\n  int root_revoke = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  \n  root_revoke = get_boolean(cmd, 1);\n  if (root_revoke == -1) {\n    if (strcasecmp(cmd->argv[1], \"UseNonCompliantActiveTransfer\") != 0 &&\n        strcasecmp(cmd->argv[1], \"UseNonCompliantActiveTransfers\") != 0) {\n      CONF_ERROR(cmd, \"expected Boolean parameter\");\n    }\n\n    root_revoke = 2;\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = (unsigned char) root_revoke;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}", "answer": "NO", "cwe": "59", "idx": "67624"}
{"code": "static int __init init_inodecache(void)\n{\n\tf2fs_inode_cachep = kmem_cache_create(\"f2fs_inode_cache\",\n\t\t\tsizeof(struct f2fs_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_ACCOUNT, NULL);\n\tif (!f2fs_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "answer": "NO", "cwe": "129", "idx": "63887"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <fstream>\nusing namespace std;\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _Absolute_Path_Traversal__wchar_t_console_ofstream_04\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_ofstream_04; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97077"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_43\n{\n\n#ifndef OMITM\n\nvoid mSource(wchar_t * &data)\n{\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(wchar_t * &data)\n{\n    \n    wcscat(data, L\"file.txt\");\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_open_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91430"}
{"code": "void qemu_system_debug_request(void)\n\n{\n\n    debug_requested = 1;\n\n    vm_stop(VMSTOP_DEBUG);\n\n}", "answer": "NO", "cwe": "0", "idx": "83f338f73ecb88cc6f85d6e7b81ebef112ce07be"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_12()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123002"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint leptomeningitis_lactocele = 0;\nint global_variable;\nvoid handle_taint(char *chronologic_premies);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid reacting_jacana(char **corkwing_multisonorous);\nvoid boldoine_somatically(char **opianyl_taramasalata);\nvoid waily_unmodifiably(char **porchlike_spece);\nvoid zootomical_adonizing(char **preultimate_nonexceptional);\nvoid ostentous_lymphopenia(char **landladyship_screeny);\nvoid battalions_bonding(char **boodledom_scylla);\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas);\nvoid hultgren_humuslike(char **coronatorial_rifi);\nvoid draisine_uncombed(char **soundproofed_vaporability);\nvoid journeyman_cesiums(char **affusions_hardstand);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&leptomeningitis_lactocele,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *chronologic_premies)\n{\n  int sammy_noncommendably;\n  char **hickishness_tubal = 0;\n  char **erythrophage_algebraized = 0;\n  char *frizzling_browningesque[66] = {0};\n  ++global_variable;;\n  if (chronologic_premies != 0) {;\n    frizzling_browningesque[63] = chronologic_premies;\n    sammy_noncommendably = 1;\n    hickishness_tubal = frizzling_browningesque;\n    erythrophage_algebraized = ((char **)(((unsigned long )hickishness_tubal) * sammy_noncommendably * sammy_noncommendably)) + 5;\n    reacting_jacana(erythrophage_algebraized);\n  }\n}\n\nvoid reacting_jacana(char **corkwing_multisonorous)\n{\n  ++global_variable;;\n  boldoine_somatically(corkwing_multisonorous);\n}\n\nvoid boldoine_somatically(char **opianyl_taramasalata)\n{\n  ++global_variable;;\n  waily_unmodifiably(opianyl_taramasalata);\n}\n\nvoid waily_unmodifiably(char **porchlike_spece)\n{\n  ++global_variable;;\n  zootomical_adonizing(porchlike_spece);\n}\n\nvoid zootomical_adonizing(char **preultimate_nonexceptional)\n{\n  ++global_variable;;\n  ostentous_lymphopenia(preultimate_nonexceptional);\n}\n\nvoid ostentous_lymphopenia(char **landladyship_screeny)\n{\n  ++global_variable;;\n  battalions_bonding(landladyship_screeny);\n}\n\nvoid battalions_bonding(char **boodledom_scylla)\n{\n  ++global_variable;;\n  chlorophyllian_glossopetra(boodledom_scylla);\n}\n\nvoid chlorophyllian_glossopetra(char **prioristic_bugshas)\n{\n  ++global_variable;;\n  hultgren_humuslike(prioristic_bugshas);\n}\n\nvoid hultgren_humuslike(char **coronatorial_rifi)\n{\n  ++global_variable;;\n  draisine_uncombed(coronatorial_rifi);\n}\n\nvoid draisine_uncombed(char **soundproofed_vaporability)\n{\n  ++global_variable;;\n  journeyman_cesiums(soundproofed_vaporability);\n}\n\nvoid journeyman_cesiums(char **affusions_hardstand)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *gasterophilus_dinitril = 0;\n  ++global_variable;;\n  gasterophilus_dinitril = ((char *)(affusions_hardstand - 5)[63]);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(gasterophilus_dinitril)+ 1));\n        if (cusData->data &&\n            (sscanf(gasterophilus_dinitril, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\n  if ((affusions_hardstand - 5)[63] != 0) \n    free(((char *)(affusions_hardstand - 5)[63]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "663", "idx": "150275"}
{"code": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}", "answer": "NO", "cwe": "59", "idx": "36322"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint asbjornsen_leipsic = 0;\n\nstruct successfully_ungrotesque \n{\n  char *pelides_pinnipedian;\n  double ballow_repletely;\n  char *hypothecative_vernacularizing;\n  char jawed_seacannie;\n  int iodothyrin_freedom;\n}\n;\nint global_variable;\nvoid handle_taint(char *coessentialness_frosts);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid cleanup(FILE **ptrs,int size)\n{\n  int i = 0;\n  \n  for (i = 0; i < size; i++) {\n    if (ptrs[i] != 0) {\n      fclose(ptrs[i]);\n    }\n  }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&asbjornsen_leipsic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid handle_taint(char *coessentialness_frosts)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[10];\n char filename[80];\n  char *approach_deamidase = 0;\n  int siriometer_daberath;\n  int scabid_letterman;\n  int railbus_caliver;\n  struct successfully_ungrotesque *shriekily_hummeler = {0};\n  struct successfully_ungrotesque *fixure_woodward = {0};\n  struct successfully_ungrotesque dishwiping_polysomitic;\n  ++global_variable;;\n  if (coessentialness_frosts != 0) {;\n    dishwiping_polysomitic . pelides_pinnipedian = ((char *)coessentialness_frosts);\n    railbus_caliver = 1;\n    shriekily_hummeler = &dishwiping_polysomitic;\n    fixure_woodward = ((struct successfully_ungrotesque *)(((unsigned long )shriekily_hummeler) * railbus_caliver * railbus_caliver)) + 5;\n    scabid_letterman = 5;\n    while(1 == 1){\n      scabid_letterman = scabid_letterman * 2;\n      scabid_letterman = scabid_letterman + 2;\n      if (scabid_letterman > 1000) {\n        break; \n      }\n    }\n    siriometer_daberath = scabid_letterman;\n    approach_deamidase = ((char *)( *(fixure_woodward - 5)) . pelides_pinnipedian);\n    \n files = fopen(approach_deamidase,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n            if (file == 0) {\n    if (file == 0 && errno == 24) {\n     printf(\"Fopen error due to ulimit\\n\");\n                }\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n   \n   file_list[ssi % 10] = file;\n   ssi++;\n        }\n        \n        \n    }\n    if (files != 0)\n        fclose(files);\n cleanup(file_list, ((ssi-1)%10)+1);\n    \n;\n    if (( *(fixure_woodward - 5)) . pelides_pinnipedian != 0) \n      free(((char *)( *(fixure_woodward - 5)) . pelides_pinnipedian));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "773", "idx": "151793"}
{"code": "void qerror_report_internal(const char *file, int linenr, const char *func,\n\n                            const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    QError *qerror;\n\n\n\n    va_start(va, fmt);\n\n    qerror = qerror_from_info(file, linenr, func, fmt, &va);\n\n    va_end(va);\n\n\n\n    if (cur_mon) {\n\n        monitor_set_error(cur_mon, qerror);\n\n    } else {\n\n        qerror_print(qerror);\n\n        QDECREF(qerror);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "cde0fc7544ca590c83f349d4dcccf375d55d6042"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * dataArray[]);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(wchar_t * dataArray[]);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91010"}
{"code": "static void gen_stda_asi(DisasContext *dc, TCGv hi, TCGv addr,\n\n                         int insn, int rd)\n\n{\n\n    TCGv_i32 r_asi, r_size;\n\n    TCGv lo = gen_load_gpr(dc, rd + 1);\n\n    TCGv_i64 t64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_concat_tl_i64(t64, lo, hi);\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(8);\n\n    gen_helper_st_asi(cpu_env, addr, t64, r_asi, r_size);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n    tcg_temp_free_i64(t64);\n\n}", "answer": "NO", "cwe": "0", "idx": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a"}
{"code": "void GLES2Decoder::EndDecoding() {}", "answer": "NO", "cwe": "119", "idx": "129347"}
{"code": "void virtio_cleanup(VirtIODevice *vdev)\n\n{\n\n    qemu_del_vm_change_state_handler(vdev->vmstate);\n\n    g_free(vdev->config);\n\n    g_free(vdev->vq);\n\n    g_free(vdev->vector_queues);\n\n}", "answer": "NO", "cwe": "0", "idx": "c611c76417f52b335ecaab01c61743e3b705eb7c"}
{"code": "void Type_U16Fixed16_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}", "answer": "NO", "cwe": "125", "idx": "71065"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint sunsuit_lath = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid basaree_maranh(char **cyclitols_jrc);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  void (*radiologically_renommee)(char **) = basaree_maranh;\n  int recreationist_whig;\n  char **pistillary_caterbrawl = 0;\n  char **faecalith_currencies = 0;\n  int maracay_hydrophiloid = 0;\n  char *goles_plagiostome = 0;\n  char *tisman_betties;;\n  if (__sync_bool_compare_and_swap(&sunsuit_lath,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&tisman_betties,\"SIALS_BLENNOMETRITIS\");\n      if (tisman_betties != 0) {;\n        maracay_hydrophiloid = ((int )(strlen(tisman_betties)));\n        goles_plagiostome = ((char *)(malloc(maracay_hydrophiloid + 1)));\n        if (goles_plagiostome == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(goles_plagiostome,0,maracay_hydrophiloid + 1);\n        memcpy(goles_plagiostome,tisman_betties,maracay_hydrophiloid);\n        if (tisman_betties != 0) \n          free(((char *)tisman_betties));\n        recreationist_whig = 1;\n        pistillary_caterbrawl = &goles_plagiostome;\n        faecalith_currencies = ((char **)(((unsigned long )pistillary_caterbrawl) * recreationist_whig * recreationist_whig)) + 5;\n        radiologically_renommee(faecalith_currencies);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid basaree_maranh(char **cyclitols_jrc)\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *fetches_reconsolidating = 0;\n  ++global_variable;;\n  fetches_reconsolidating = ((char *)( *(cyclitols_jrc - 5)));\n      \n      \n\n      pFile = fopen(fetches_reconsolidating,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\n  if ( *(cyclitols_jrc - 5) != 0) \n    free(((char *)( *(cyclitols_jrc - 5))));\nclose_printf_context();\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149701"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint unpanoplied_plagiotropism = 0;\n\nstruct retrogresses_unviewable \n{\n  char *unsuspect_clonal;\n  double ethiope_musketade;\n  char *coelomatous_psammite;\n  char podilegous_gurr;\n  int protracheata_chlorides;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n int ss_i = 0;\n  char *tressia_egads = 0;\n  struct retrogresses_unviewable *coemption_baculites = {0};\n  struct retrogresses_unviewable *galempong_protium = {0};\n  struct retrogresses_unviewable hee_varicoloured;\n  char *prebilling_maryann;;\n  if (__sync_bool_compare_and_swap(&unpanoplied_plagiotropism,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      prebilling_maryann = getenv(\"PHILOSOPHIZER_INTERTWISTINGLY\");\n      if (prebilling_maryann != 0) {;\n        hee_varicoloured . unsuspect_clonal = ((char *)prebilling_maryann);\n        coemption_baculites = &hee_varicoloured;\n        galempong_protium = coemption_baculites + 5;\n        tressia_egads = ((char *)( *(galempong_protium - 5)) . unsuspect_clonal);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(tressia_egads)){\n  \n        if (tressia_egads[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "YES", "cwe": "835", "idx": "151874"}
{"code": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data, int *data_size,\n\n                        AVPacket *avpkt)\n\n{\n\n    JvContext *s           = avctx->priv_data;\n\n    const uint8_t *buf     = avpkt->data;\n\n    const uint8_t *buf_end = buf + avpkt->size;\n\n    int video_size, video_type, i, j;\n\n\n\n    video_size = AV_RL32(buf);\n\n    video_type = buf[4];\n\n    buf += 5;\n\n\n\n    if (video_size) {\n\n        if (video_size < 0 || video_size > avpkt->size - 5) {\n\n            av_log(avctx, AV_LOG_ERROR, \"video size %d invalid\\n\", video_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (avctx->reget_buffer(avctx, &s->frame) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if (video_type == 0 || video_type == 1) {\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, 8 * video_size);\n\n\n\n            for (j = 0; j < avctx->height; j += 8)\n\n                for (i = 0; i < avctx->width; i += 8)\n\n                    decode8x8(&gb, s->frame.data[0] + j*s->frame.linesize[0] + i,\n\n                              s->frame.linesize[0], &s->dsp);\n\n\n\n            buf += video_size;\n\n        } else if (video_type == 2) {\n\n            if (buf + 1 <= buf_end) {\n\n                int v = *buf++;\n\n                for (j = 0; j < avctx->height; j++)\n\n                    memset(s->frame.data[0] + j*s->frame.linesize[0], v, avctx->width);\n\n            }\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"unsupported frame type %i\\n\", video_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    if (buf_end - buf >= AVPALETTE_COUNT * 3) {\n\n        for (i = 0; i < AVPALETTE_COUNT; i++) {\n\n            uint32_t pal = AV_RB24(buf);\n\n            s->palette[i] = 0xFF << 24 | pal << 2 | ((pal >> 4) & 0x30303);\n\n            buf += 3;\n\n        }\n\n        s->palette_has_changed = 1;\n\n    }\n\n\n\n    if (video_size) {\n\n        s->frame.key_frame           = 1;\n\n        s->frame.pict_type           = AV_PICTURE_TYPE_I;\n\n        s->frame.palette_has_changed = s->palette_has_changed;\n\n        s->palette_has_changed       = 0;\n\n        memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n\n\n\n        *data_size      = sizeof(AVFrame);\n\n        *(AVFrame*)data = s->frame;\n\n    }\n\n\n\n    return avpkt->size;\n\n}", "answer": "NO", "cwe": "0", "idx": "5d171b1f4718ae2916dfddc35299ccdef1e3001c"}
{"code": "static void memory_region_update_container_subregions(MemoryRegion *subregion)\n\n{\n\n    hwaddr offset = subregion->addr;\n\n    MemoryRegion *mr = subregion->container;\n\n    MemoryRegion *other;\n\n\n\n    memory_region_transaction_begin();\n\n\n\n    memory_region_ref(subregion);\n\n    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {\n\n        if (subregion->may_overlap || other->may_overlap) {\n\n            continue;\n\n        }\n\n        if (int128_ge(int128_make64(offset),\n\n                      int128_add(int128_make64(other->addr), other->size))\n\n            || int128_le(int128_add(int128_make64(offset), subregion->size),\n\n                         int128_make64(other->addr))) {\n\n            continue;\n\n        }\n\n#if 0\n\n        printf(\"warning: subregion collision %llx/%llx (%s) \"\n\n               \"vs %llx/%llx (%s)\\n\",\n\n               (unsigned long long)offset,\n\n               (unsigned long long)int128_get64(subregion->size),\n\n               subregion->name,\n\n               (unsigned long long)other->addr,\n\n               (unsigned long long)int128_get64(other->size),\n\n               other->name);\n\n#endif\n\n    }\n\n    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {\n\n        if (subregion->priority >= other->priority) {\n\n            QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);\n\n            goto done;\n\n        }\n\n    }\n\n    QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);\n\ndone:\n\n    memory_region_update_pending |= mr->enabled && subregion->enabled;\n\n    memory_region_transaction_commit();\n\n}", "answer": "NO", "cwe": "0", "idx": "b61359781958759317ee6fd1a45b59be0b7dbbe1"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint glassfish_telharmony = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid haflin_taeninidia(char *(**********cystectomies_paut)[21]);\ntypedef int (*fptr)();\nint modulus_function1 (char *modulus_param_str) {\n  \n  return modulus_param_str[0] % 2;\n}\nint modulus_function2 (char *modulus_param_str) {\n  \n  return modulus_param_str[1] % 2;\n}\nvoid get_function(int len, fptr * modulus_function) {\n  \n    \n    if (len > 10) {\n        *modulus_function = modulus_function1;\n        \n    }\n    if (len < 10) {\n        *modulus_function = modulus_function2;\n        \n    }\n    \n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n#define IMBOSCATA_RHEXIA(x) haflin_taeninidia((char *(**********)[21]) x)\n\nvoid ENGINE_cleanup()\n{\n  char *(**********scenewright_preutilized)[21] = 0;\n  char *(*********pallini_fatalism)[21] = 0;\n  char *(********guaranteer_chinoline)[21] = 0;\n  char *(*******sogat_desmepithelium)[21] = 0;\n  char *(******mydriatine_emblematise)[21] = 0;\n  char *(*****millen_metropolitical)[21] = 0;\n  char *(****featurelessness_lecoma)[21] = 0;\n  char *(***neutrodyne_maewo)[21] = 0;\n  char *(**saul_hyacine)[21] = 0;\n  char *(*stymphalian_dodson)[21] = 0;\n  char **upmix_stagecoach = 0;\n  char *unstirred_antiasthmatic[21] = {0};\n  char *salnatron_minsteryard;;\n  if (__sync_bool_compare_and_swap(&glassfish_telharmony,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&salnatron_minsteryard,\"PHRYGANEOID_JENEQUEN\");\n      if (salnatron_minsteryard != 0) {;\n        unstirred_antiasthmatic[20] = salnatron_minsteryard;\n        stymphalian_dodson = &unstirred_antiasthmatic;\n        saul_hyacine = &stymphalian_dodson;\n        neutrodyne_maewo = &saul_hyacine;\n        featurelessness_lecoma = &neutrodyne_maewo;\n        millen_metropolitical = &featurelessness_lecoma;\n        mydriatine_emblematise = &millen_metropolitical;\n        sogat_desmepithelium = &mydriatine_emblematise;\n        guaranteer_chinoline = &sogat_desmepithelium;\n        pallini_fatalism = &guaranteer_chinoline;\n        scenewright_preutilized = &pallini_fatalism;\n\tIMBOSCATA_RHEXIA(scenewright_preutilized);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid haflin_taeninidia(char *(**********cystectomies_paut)[21])\n{\n int input_len = 0;\n int result = 0;\n fptr* function_ptr = 0;\n  char *descendability_creusa = 0;\n  ++global_variable;;\n  descendability_creusa = ((char *)( *( *( *( *( *( *( *( *( *( *cystectomies_paut))))))))))[20]);\n    \n input_len = strlen(descendability_creusa);\n    if (input_len < 2) {\n        printf(\"String is too short to test\\n\");\n    } else {\n        function_ptr = malloc(sizeof(void *));\n        if (function_ptr == 0) {\n            printf(\"Error: Failed to allocate memory\\n\");\n            exit(1);\n        }\n        \n        get_function(input_len, function_ptr);\n        \n        \n        result = ( *function_ptr)(descendability_creusa);\n        \n        if (result == 0)\n            printf(\"mod is true\\n\");\n        else\n            printf(\"mod is false\\n\");\n        if (function_ptr != 0) {\n            free(function_ptr);\n        }\n    }\n    \n;\n  if (( *( *( *( *( *( *( *( *( *( *cystectomies_paut))))))))))[20] != 0) \n    free(((char *)( *( *( *( *( *( *( *( *( *( *cystectomies_paut))))))))))[20]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "824", "idx": "152941"}
{"code": "static int http_proxy_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    HTTPContext *s = h->priv_data;\n\n    char hostname[1024], hoststr[1024];\n\n    char auth[1024], pathbuf[1024], *path;\n\n    char lower_url[100];\n\n    int port, ret = 0, attempts = 0;\n\n    HTTPAuthType cur_auth_type;\n\n    char *authstr;\n\n    int new_loc;\n\n\n\n    h->is_streamed = 1;\n\n\n\n    av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &port,\n\n                 pathbuf, sizeof(pathbuf), uri);\n\n    ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);\n\n    path = pathbuf;\n\n    if (*path == '/')\n\n        path++;\n\n\n\n    ff_url_join(lower_url, sizeof(lower_url), \"tcp\", NULL, hostname, port,\n\n                NULL);\n\nredo:\n\n    ret = ffurl_open(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,\n\n                     &h->interrupt_callback, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    authstr = ff_http_auth_create_response(&s->proxy_auth_state, auth,\n\n                                           path, \"CONNECT\");\n\n    snprintf(s->buffer, sizeof(s->buffer),\n\n             \"CONNECT %s HTTP/1.1\\r\\n\"\n\n             \"Host: %s\\r\\n\"\n\n             \"Connection: close\\r\\n\"\n\n             \"%s%s\"\n\n             \"\\r\\n\",\n\n             path,\n\n             hoststr,\n\n             authstr ? \"Proxy-\" : \"\", authstr ? authstr : \"\");\n\n    av_freep(&authstr);\n\n\n\n    if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n\n        goto fail;\n\n\n\n    s->buf_ptr = s->buffer;\n\n    s->buf_end = s->buffer;\n\n    s->line_count = 0;\n\n    s->filesize = -1;\n\n    cur_auth_type = s->proxy_auth_state.auth_type;\n\n\n\n    \n\n    ret = http_read_header(h, &new_loc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    attempts++;\n\n    if (s->http_code == 407 &&\n\n        (cur_auth_type == HTTP_AUTH_NONE || s->proxy_auth_state.stale) &&\n\n        s->proxy_auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) {\n\n        ffurl_closep(&s->hd);\n\n        goto redo;\n\n    }\n\n\n\n    if (s->http_code < 400)\n\n        return 0;\n\n    ret = AVERROR(EIO);\n\n\n\nfail:\n\n    http_proxy_close(h);\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "dd1e6b2a139a9eea61aefe24fc3295499e70d04b"}
{"code": "int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile)\n\n{\n\n    int         mbn, blk, num_blocks, num_coeffs, blk_size, scan_pos, run, val,\n\n                pos, is_intra, mc_type, mv_x, mv_y, col_mask;\n\n    uint8_t     col_flags[8];\n\n    int32_t     prev_dc, trvec[64];\n\n    uint32_t    cbp, sym, lo, hi, quant, buf_offs, q;\n\n    IVIMbInfo   *mb;\n\n    RVMapDesc   *rvmap = band->rv_map;\n\n    void (*mc_with_delta_func)(int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);\n\n    void (*mc_no_delta_func)  (int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);\n\n    const uint16_t  *base_tab;\n\n    const uint8_t   *scale_tab;\n\n\n\n    prev_dc = 0; \n\n\n\n    blk_size   = band->blk_size;\n\n    col_mask   = blk_size - 1; \n\n    num_blocks = (band->mb_size != blk_size) ? 4 : 1; \n\n    num_coeffs = blk_size * blk_size;\n\n    if (blk_size == 8) {\n\n        mc_with_delta_func = ff_ivi_mc_8x8_delta;\n\n        mc_no_delta_func   = ff_ivi_mc_8x8_no_delta;\n\n    } else {\n\n        mc_with_delta_func = ff_ivi_mc_4x4_delta;\n\n        mc_no_delta_func   = ff_ivi_mc_4x4_no_delta;\n\n    }\n\n\n\n    for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) {\n\n        is_intra = !mb->type;\n\n        cbp      = mb->cbp;\n\n        buf_offs = mb->buf_offs;\n\n\n\n        quant = av_clip(band->glob_quant + mb->q_delta, 0, 23);\n\n\n\n        base_tab  = is_intra ? band->intra_base  : band->inter_base;\n\n        scale_tab = is_intra ? band->intra_scale : band->inter_scale;\n\n        if (scale_tab)\n\n            quant = scale_tab[quant];\n\n\n\n        if (!is_intra) {\n\n            mv_x = mb->mv_x;\n\n            mv_y = mb->mv_y;\n\n            if (!band->is_halfpel) {\n\n                mc_type = 0; \n\n            } else {\n\n                mc_type = ((mv_y & 1) << 1) | (mv_x & 1);\n\n                mv_x >>= 1;\n\n                mv_y >>= 1; \n\n            }\n\n        }\n\n\n\n        for (blk = 0; blk < num_blocks; blk++) {\n\n            \n\n            if (blk & 1) {\n\n                buf_offs += blk_size;\n\n            } else if (blk == 2) {\n\n                buf_offs -= blk_size;\n\n                buf_offs += blk_size * band->pitch;\n\n            }\n\n\n\n            if (cbp & 1) { \n\n                scan_pos = -1;\n\n                memset(trvec, 0, num_coeffs*sizeof(trvec[0])); \n\n                memset(col_flags, 0, sizeof(col_flags));      \n\n\n\n                while (scan_pos <= num_coeffs) {\n\n                    sym = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n\n                    if (sym == rvmap->eob_sym)\n\n                        break; \n\n\n\n                    if (sym == rvmap->esc_sym) { \n\n                        run = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1) + 1;\n\n                        lo  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n\n                        hi  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n\n                        val = IVI_TOSIGNED((hi << 6) | lo); \n\n                    } else {\n\n                        if (sym >= 256U) {\n\n                            av_log(NULL, AV_LOG_ERROR, \"Invalid sym encountered: %d.\\n\", sym);\n\n                            return -1;\n\n                        }\n\n                        run = rvmap->runtab[sym];\n\n                        val = rvmap->valtab[sym];\n\n                    }\n\n\n\n                    \n\n                    scan_pos += run;\n\n                    if (scan_pos >= num_coeffs)\n\n                        break;\n\n                    pos = band->scan[scan_pos];\n\n\n\n                    if (!val)\n\n                        av_dlog(NULL, \"Val = 0 encountered!\\n\");\n\n\n\n                    q = (base_tab[pos] * quant) >> 9;\n\n                    if (q > 1)\n\n                        val = val * q + FFSIGN(val) * (((q ^ 1) - 1) >> 1);\n\n                    trvec[pos] = val;\n\n                    col_flags[pos & col_mask] |= !!val; \n\n                }\n\n\n\n                if (scan_pos >= num_coeffs && sym != rvmap->eob_sym)\n\n                    return -1; \n\n\n\n                \n\n                if (is_intra && band->is_2d_trans) {\n\n                    prev_dc      += trvec[0];\n\n                    trvec[0]      = prev_dc;\n\n                    col_flags[0] |= !!prev_dc;\n\n                }\n\n\n\n                \n\n                band->inv_transform(trvec, band->buf + buf_offs,\n\n                                    band->pitch, col_flags);\n\n\n\n                \n\n                if (!is_intra)\n\n                    mc_with_delta_func(band->buf + buf_offs,\n\n                                       band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,\n\n                                       band->pitch, mc_type);\n\n            } else {\n\n                \n\n                \n\n                \n\n                if (is_intra && band->dc_transform) {\n\n                    band->dc_transform(&prev_dc, band->buf + buf_offs,\n\n                                       band->pitch, blk_size);\n\n                } else\n\n                    mc_no_delta_func(band->buf + buf_offs,\n\n                                     band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,\n\n                                     band->pitch, mc_type);\n\n            }\n\n\n\n            cbp >>= 1;\n\n        }\n\n    }\n\n\n\n    align_get_bits(gb);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "0846719dd11ab3f7a7caee13e7af71f71d913389"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Absolute_Path_Traversal__char_environment_ifstream_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_ifstream_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96073"}
{"code": "yuv2gray16_1_c_template(SwsContext *c, const uint16_t *buf0,\n\n                        const uint16_t *ubuf0, const uint16_t *ubuf1,\n\n                        const uint16_t *vbuf0, const uint16_t *vbuf1,\n\n                        const uint16_t *abuf0, uint8_t *dest, int dstW,\n\n                        int uvalpha, enum PixelFormat dstFormat,\n\n                        int flags, int y, enum PixelFormat target)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        const int i2 = 2 * i;\n\n        int Y1 = buf0[i2  ] << 1;\n\n        int Y2 = buf0[i2+1] << 1;\n\n\n\n        output_pixel(&dest[2 * i2 + 0], Y1);\n\n        output_pixel(&dest[2 * i2 + 2], Y2);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "13a099799e89a76eb921ca452e1b04a7a28a9855"}
{"code": "void do_info_usernet(Monitor *mon)\n\n{\n\n    SlirpState *s;\n\n\n\n    TAILQ_FOREACH(s, &slirp_stacks, entry) {\n\n        monitor_printf(mon, \"VLAN %d (%s):\\n\", s->vc->vlan->id, s->vc->name);\n\n        slirp_connection_info(s->slirp, mon);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "72cf2d4f0e181d0d3a3122e04129c58a95da713e"}
{"code": "chkURLBuffer(Buffer *buf)\n{\n    static char *url_like_pat[] = {\n\t\"https?:\n\t\"file:/[a-zA-Z0-9:%\\\\-\\\\./=_\\\\+@#,\\\\$;]*\",\n#ifdef USE_GOPHER\n\t\"gopher:\n#endif\t\t\t\t\n\t\"ftp:\n#ifdef USE_NNTP\n\t\"news:[^<> \t][^<> \t]*\",\n\t\"nntp:\n#endif\t\t\t\t\n#ifndef USE_W3MMAILER\t\t\n\t\"mailto:[^<> \t][^<> \t]*@[a-zA-Z0-9][a-zA-Z0-9\\\\-\\\\._]*[a-zA-Z0-9]\",\n#endif\n#ifdef INET6\n\t\"https?:\n\t\"ftp:\n#endif\t\t\t\t\n\tNULL\n    };\n    int i;\n    for (i = 0; url_like_pat[i]; i++) {\n\treAnchor(buf, url_like_pat[i]);\n    }\n#ifdef USE_EXTERNAL_URI_LOADER\n    chkExternalURIBuffer(buf);\n#endif\n    buf->check_url |= CHK_URL;\n}", "answer": "NO", "cwe": "59", "idx": "84471"}
{"code": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}", "answer": "NO", "cwe": "0", "idx": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38"}
{"code": "void AuthenticatorSheetModelBase::OnModelDestroyed() {\n  dialog_model_ = nullptr;\n}", "answer": "NO", "cwe": "119", "idx": "155683"}
{"code": "static char *assign_name(NetClientState *nc1, const char *model)\n\n{\n\n    NetClientState *nc;\n\n    char buf[256];\n\n    int id = 0;\n\n\n\n    QTAILQ_FOREACH(nc, &net_clients, next) {\n\n        if (nc == nc1) {\n\n            continue;\n\n        }\n\n        \n\n        if (strcmp(nc->model, model) == 0 &&\n\n            net_hub_id_for_client(nc, NULL) == 0) {\n\n            id++;\n\n        }\n\n    }\n\n\n\n    snprintf(buf, sizeof(buf), \"%s.%d\", model, id);\n\n\n\n    return g_strdup(buf);\n\n}", "answer": "NO", "cwe": "0", "idx": "c963530a5b3e3e0f7304841adfe84416d82f59f6"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint vicaire_passed = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid gwelo_squelches(char *nabcheat_unregenerated);\nvoid aedicule_undeniable(char *aldoxime_speckfall);\nvoid charade_mitchiner(char *sylleptically_noonstead);\nvoid octans_bespattered(char *cruiskeen_diduce);\nvoid ulcerated_nokesville(char *cam_lotis);\nvoid arrowroot_pentecostarion(char *hales_geraldine);\nvoid ambitionless_unshadow(char *cryptomnesic_sorptions);\nvoid teneral_dumbfounderment(char *bronchotomy_halvahs);\nvoid chevise_postparotid(char *steepdown_scratchy);\nvoid obtrusionist_contrastingly(char *beady_predevelop);\nint search(char *str_param,char c_param)\n{\n    if ( *str_param == c_param) {\n        return 1;\n    } else if ( *str_param == 0) {\n        \n  \n  return search(&str_param[0],c_param);\n    } else {\n  return search(&str_param[1],c_param);\n  }\n}\n\nunsigned int avdevice_version()\n{\n  char *berliner_tristate = 0;\n  int *bringela_overcare = 0;\n  int unkindest_sportly;\n  char *peopled_lewiston[10] = {0};\n  int acecaffine_sheldfowl = 0;\n  char *zaramo_obviations = 0;\n  int seaworn_bertolde = 31;\n  char *needlebill_nondevoutly;;\n  if (__sync_bool_compare_and_swap(&vicaire_passed,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&needlebill_nondevoutly,\"4236\",seaworn_bertolde);\n      if (needlebill_nondevoutly != 0) {;\n        acecaffine_sheldfowl = ((int )(strlen(needlebill_nondevoutly)));\n        zaramo_obviations = ((char *)(malloc(acecaffine_sheldfowl + 1)));\n        if (zaramo_obviations == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(zaramo_obviations,0,acecaffine_sheldfowl + 1);\n        memcpy(zaramo_obviations,needlebill_nondevoutly,acecaffine_sheldfowl);\n        if (needlebill_nondevoutly != 0) \n          free(((char *)needlebill_nondevoutly));\n        peopled_lewiston[5] = zaramo_obviations;\n        unkindest_sportly = 5;\n        bringela_overcare = &unkindest_sportly;\n        berliner_tristate =  *(peopled_lewiston +  *bringela_overcare);\n        gwelo_squelches(berliner_tristate);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid gwelo_squelches(char *nabcheat_unregenerated)\n{\n  ++global_variable;;\n  aedicule_undeniable(nabcheat_unregenerated);\n}\n\nvoid aedicule_undeniable(char *aldoxime_speckfall)\n{\n  ++global_variable;;\n  charade_mitchiner(aldoxime_speckfall);\n}\n\nvoid charade_mitchiner(char *sylleptically_noonstead)\n{\n  ++global_variable;;\n  octans_bespattered(sylleptically_noonstead);\n}\n\nvoid octans_bespattered(char *cruiskeen_diduce)\n{\n  ++global_variable;;\n  ulcerated_nokesville(cruiskeen_diduce);\n}\n\nvoid ulcerated_nokesville(char *cam_lotis)\n{\n  ++global_variable;;\n  arrowroot_pentecostarion(cam_lotis);\n}\n\nvoid arrowroot_pentecostarion(char *hales_geraldine)\n{\n  ++global_variable;;\n  ambitionless_unshadow(hales_geraldine);\n}\n\nvoid ambitionless_unshadow(char *cryptomnesic_sorptions)\n{\n  ++global_variable;;\n  teneral_dumbfounderment(cryptomnesic_sorptions);\n}\n\nvoid teneral_dumbfounderment(char *bronchotomy_halvahs)\n{\n  ++global_variable;;\n  chevise_postparotid(bronchotomy_halvahs);\n}\n\nvoid chevise_postparotid(char *steepdown_scratchy)\n{\n  ++global_variable;;\n  obtrusionist_contrastingly(steepdown_scratchy);\n}\n\nvoid obtrusionist_contrastingly(char *beady_predevelop)\n{\n int found;\n  char *sayonara_nonvocational = 0;\n  ++global_variable;;\n  sayonara_nonvocational = ((char *)beady_predevelop);\n    \n    \n    \n    found = search(&sayonara_nonvocational[1],sayonara_nonvocational[0]);\n    \n    \n    \n;\n  if (beady_predevelop != 0) \n    free(((char *)beady_predevelop));\nclose_printf_context();\n}", "answer": "YES", "cwe": "674", "idx": "152160"}
{"code": "static int mwifiex_set_mgmt_beacon_data_ies(struct mwifiex_private *priv,\n\t\t\t\t\t    struct cfg80211_beacon_data *data)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL, *ar_ie = NULL;\n\tu16 beacon_idx = MWIFIEX_AUTO_IDX_MASK, pr_idx = MWIFIEX_AUTO_IDX_MASK;\n\tu16 ar_idx = MWIFIEX_AUTO_IDX_MASK;\n\tint ret = 0;\n\n\tif (data->beacon_ies && data->beacon_ies_len) {\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->proberesp_ies && data->proberesp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP, WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->assocresp_ies && data->assocresp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP, WLAN_OUI_WFA,\n\t\t\t\t     WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie) {\n\t\tret = mwifiex_update_uap_custom_ie(priv, beacon_ie,\n\t\t\t\t\t\t   &beacon_idx, pr_ie,\n\t\t\t\t\t\t   &pr_idx, ar_ie, &ar_idx);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tpriv->beacon_idx = beacon_idx;\n\tpriv->proberesp_idx = pr_idx;\n\tpriv->assocresp_idx = ar_idx;\n\ndone:\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}", "answer": "NO", "cwe": "120", "idx": "88606"}
{"code": "evdns_server_request_add_reply(struct evdns_server_request *req_, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(req_);\n\tstruct server_reply_item **itemp, *item;\n\tint *countp;\n\tint result = -1;\n\n\tEVDNS_LOCK(req->port);\n\tif (req->response) \n\t\tgoto done;\n\n\tswitch (section) {\n\tcase EVDNS_ANSWER_SECTION:\n\t\titemp = &req->answer;\n\t\tcountp = &req->n_answer;\n\t\tbreak;\n\tcase EVDNS_AUTHORITY_SECTION:\n\t\titemp = &req->authority;\n\t\tcountp = &req->n_authority;\n\t\tbreak;\n\tcase EVDNS_ADDITIONAL_SECTION:\n\t\titemp = &req->additional;\n\t\tcountp = &req->n_additional;\n\t\tbreak;\n\tdefault:\n\t\tgoto done;\n\t}\n\twhile (*itemp) {\n\t\titemp = &((*itemp)->next);\n\t}\n\titem = mm_malloc(sizeof(struct server_reply_item));\n\tif (!item)\n\t\tgoto done;\n\titem->next = NULL;\n\tif (!(item->name = mm_strdup(name))) {\n\t\tmm_free(item);\n\t\tgoto done;\n\t}\n\titem->type = type;\n\titem->dns_question_class = class;\n\titem->ttl = ttl;\n\titem->is_name = is_name != 0;\n\titem->datalen = 0;\n\titem->data = NULL;\n\tif (data) {\n\t\tif (item->is_name) {\n\t\t\tif (!(item->data = mm_strdup(data))) {\n\t\t\t\tmm_free(item->name);\n\t\t\t\tmm_free(item);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\titem->datalen = (u16)-1;\n\t\t} else {\n\t\t\tif (!(item->data = mm_malloc(datalen))) {\n\t\t\t\tmm_free(item->name);\n\t\t\t\tmm_free(item);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\titem->datalen = datalen;\n\t\t\tmemcpy(item->data, data, datalen);\n\t\t}\n\t}\n\n\t*itemp = item;\n\t++(*countp);\n\tresult = 0;\ndone:\n\tEVDNS_UNLOCK(req->port);\n\treturn result;\n}", "answer": "NO", "cwe": "125", "idx": "70645"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint zostera_protosphargis = 0;\nint global_variable;\n\nunion termagant_mulcts \n{\n  char *barriers_bivalves;\n  double kuan_hobbledehoydom;\n  char *subdie_pulers;\n  char bethuel_monitory;\n  int notoryctes_polygala;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid haithal_drago(union termagant_mulcts *fee_treadling);\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_t t0, t1;\npthread_mutex_t mutex_0, mutex_1;\nint dev_amount = 1;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcDevamount(void *data) {\n    struct data *cusData = (struct data*)data;\n    int qsize;\n    \n    printf(\"Inside calcDevAmount\\n\");\n    pthread_mutex_lock(&mutex_0);\n    \n    \n    dev_amount = cusData->data[0] - 'A'; \n    qsize = cusData->qsize;\n    if (dev_amount < 0) { \n        dev_amount *= -1; \n    }\n    \n    readFile(cusData->file2);\n    if (dev_amount == 0) { \n        dev_amount += 1; \n    }\n    \n    \n    pthread_mutex_unlock(&mutex_0);\n    return NULL;\n}\nvoid *devChar(void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int i;\n    int *arr = NULL;\n    \n    printf(\"Inside devChar\\n\");\n    \n    arr = malloc(sizeof(int) * cusData->qsize);\n    pthread_mutex_lock(&mutex_1);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(cusData->file1);\n    \n    \n    \n    for (i = 0; i < strlen(cusData->data); i++) { \n        cusData->data[i] /= dev_amount; \n    }\n    \n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n#define NONRUBBER_DEHYDROFROZEN(x) haithal_drago((union termagant_mulcts *) x)\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  int defrication_polygalaceous;\n  union termagant_mulcts *bogeying_ranksman = {0};\n  union termagant_mulcts *hysterogenic_liberalism = {0};\n  union termagant_mulcts merited_sarcodina;\n  int codetta_presatisfy = 204;\n  char *townwards_pinnula;;\n  if (__sync_bool_compare_and_swap(&zostera_protosphargis,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&townwards_pinnula,\"3839\",codetta_presatisfy);\n      if (townwards_pinnula != 0) {;\n        merited_sarcodina . barriers_bivalves = townwards_pinnula;\n        defrication_polygalaceous = 1;\n        bogeying_ranksman = &merited_sarcodina;\n        hysterogenic_liberalism = ((union termagant_mulcts *)(((unsigned long )bogeying_ranksman) * defrication_polygalaceous * defrication_polygalaceous)) + 5;\n\tNONRUBBER_DEHYDROFROZEN(hysterogenic_liberalism);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid haithal_drago(union termagant_mulcts *fee_treadling)\n{\n    struct data* cusData;\n  char *botanizing_bielenite = 0;\n  ++global_variable;;\n  botanizing_bielenite = ((char *)( *(fee_treadling - 5)) . barriers_bivalves);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(botanizing_bielenite) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(botanizing_bielenite) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(botanizing_bielenite) + 1));\n        if (cusData->data) {\n            if ((sscanf(botanizing_bielenite, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                \n                \n                \n                \n                \n                if (strlen(cusData->data) > 50) { \n                                                                                                    \n                    if (pthread_create(&t0, NULL, calcDevamount, cusData) != 0) { \n                        printf(\"Error initializing thread 0.\");\n                    }\n                }\n                if (pthread_create(&t1, NULL, devChar, cusData) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                if (strlen(cusData->data) > 50) {\n                    pthread_join(t0, NULL);\n                }\n                pthread_join(t1, NULL);\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n  if (( *(fee_treadling - 5)) . barriers_bivalves != 0) \n    free(((char *)( *(fee_treadling - 5)) . barriers_bivalves));\nclose_printf_context();\n}", "answer": "YES", "cwe": "821", "idx": "150706"}
{"code": "void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint unrude_faire = 0;\ntypedef char *sniffily_cardin;\nint global_variable;\nvoid handle_taint(char *cosmetologist_uninfringible);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid epilegomenon_comourn(const sniffily_cardin handwaving_bottomchrome);\nvoid laved_tasimeter(sniffily_cardin wisps_refreshments);\nvoid epididymitis_mannerliness(sniffily_cardin knockemdown_longings);\nvoid sherd_advertisements(sniffily_cardin barolo_demotist);\nvoid budweiser_unepicurean(sniffily_cardin citternhead_voltmer);\nvoid neaps_homiletics(sniffily_cardin slaughterhouse_stokely);\nvoid nonadults_oside(sniffily_cardin metaller_buckjumper);\nvoid topography_cornland(sniffily_cardin poort_scents);\nvoid gish_wreakful(sniffily_cardin tergeminous_handymen);\nvoid nonvalidly_phrenopathy(sniffily_cardin morphographer_iris);\nvoid caramuel_blurry(sniffily_cardin desensitizes_washbasin);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&unrude_faire,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *cosmetologist_uninfringible)\n{\n  sniffily_cardin disbalancement_dilog = 0;\n  ++global_variable;;\n  if (cosmetologist_uninfringible != 0) {;\n    disbalancement_dilog = cosmetologist_uninfringible;\n    epilegomenon_comourn(disbalancement_dilog);\n  }\n}\n\nvoid epilegomenon_comourn(const sniffily_cardin handwaving_bottomchrome)\n{\n  ++global_variable;;\n  laved_tasimeter(handwaving_bottomchrome);\n}\n\nvoid laved_tasimeter(sniffily_cardin wisps_refreshments)\n{\n  ++global_variable;;\n  epididymitis_mannerliness(wisps_refreshments);\n}\n\nvoid epididymitis_mannerliness(sniffily_cardin knockemdown_longings)\n{\n  ++global_variable;;\n  sherd_advertisements(knockemdown_longings);\n}\n\nvoid sherd_advertisements(sniffily_cardin barolo_demotist)\n{\n  ++global_variable;;\n  budweiser_unepicurean(barolo_demotist);\n}\n\nvoid budweiser_unepicurean(sniffily_cardin citternhead_voltmer)\n{\n  ++global_variable;;\n  neaps_homiletics(citternhead_voltmer);\n}\n\nvoid neaps_homiletics(sniffily_cardin slaughterhouse_stokely)\n{\n  ++global_variable;;\n  nonadults_oside(slaughterhouse_stokely);\n}\n\nvoid nonadults_oside(sniffily_cardin metaller_buckjumper)\n{\n  ++global_variable;;\n  topography_cornland(metaller_buckjumper);\n}\n\nvoid topography_cornland(sniffily_cardin poort_scents)\n{\n  ++global_variable;;\n  gish_wreakful(poort_scents);\n}\n\nvoid gish_wreakful(sniffily_cardin tergeminous_handymen)\n{\n  ++global_variable;;\n  nonvalidly_phrenopathy(tergeminous_handymen);\n}\n\nvoid nonvalidly_phrenopathy(sniffily_cardin morphographer_iris)\n{\n  ++global_variable;;\n  caramuel_blurry(morphographer_iris);\n}\n\nvoid caramuel_blurry(sniffily_cardin desensitizes_washbasin)\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *finbacks_greetings = 0;\n  ++global_variable;;\n  finbacks_greetings = ((char *)((sniffily_cardin )desensitizes_washbasin));\n    \n    taint_size = strlen(finbacks_greetings);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,finbacks_greetings,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n  if (((sniffily_cardin )desensitizes_washbasin) != 0) \n    free(((char *)((sniffily_cardin )desensitizes_washbasin)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "401", "idx": "151476"}
{"code": "static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\tif (--chip->num_suspended_intf)\n\t\treturn 0;\n\n\tatomic_inc(&chip->active); \n\t\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\terr = snd_usb_mixer_resume(mixer, reset_resume);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tlist_for_each(p, &chip->midi_list) {\n\t\tsnd_usbmidi_resume(p);\n\t}\n\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\tchip->autosuspended = 0;\n\nerr_out:\n\tatomic_dec(&chip->active); \n\treturn err;\n}", "answer": "NO", "cwe": "125", "idx": "59922"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bSink(char * data);\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246347"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123247"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _wexeclp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_execlp_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    funcPtr(data);\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_execlp_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_execlp_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_execlp_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246438"}
{"code": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    \n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        \n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    \n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    \n\n    spapr->htab_shift = 18; \n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    \n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    \n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        \n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        \n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        \n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    \n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    \n\n    spapr_events_init(spapr);\n\n\n\n    \n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    \n\n    spapr_create_nvram(spapr);\n\n\n\n    \n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    \n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        \n\n        if (initrd_filename) {\n\n            \n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    \n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}", "answer": "NO", "cwe": "0", "idx": "24408a7d2b459bed3697367b81ada76518ca96ef"}
{"code": "void HTMLSelectElement::listBoxOnChange()\n{\n    ASSERT(!usesMenuList() || m_multiple);\n\n    const Vector<HTMLElement*>& items = listItems();\n\n    if (m_lastOnChangeSelection.isEmpty() || m_lastOnChangeSelection.size() != items.size()) {\n        dispatchFormControlChangeEvent();\n        return;\n    }\n\n    bool fireOnChange = false;\n    for (unsigned i = 0; i < items.size(); ++i) {\n        HTMLElement* element = items[i];\n        bool selected = element->hasTagName(optionTag) && toHTMLOptionElement(element)->selected();\n        if (selected != m_lastOnChangeSelection[i])\n            fireOnChange = true;\n        m_lastOnChangeSelection[i] = selected;\n    }\n\n    if (fireOnChange)\n        dispatchFormControlChangeEvent();\n}", "answer": "NO", "cwe": "125", "idx": "110026"}
{"code": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}", "answer": "NO", "cwe": "0", "idx": "89ae337acbe4dba5b2481007aec1277252d2b86c"}
{"code": "stream_push(StreamSlave *sink, uint8_t *buf, size_t len, uint32_t *app)\n\n{\n\n    StreamSlaveClass *k =  STREAM_SLAVE_GET_CLASS(sink);\n\n\n\n    return k->push(sink, buf, len, app);\n\n}", "answer": "NO", "cwe": "0", "idx": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_43\n{\n\n#ifndef OMITM\n\nvoid mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95996"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint scene_unplank = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  FILE *csv = 0;\n  FILE *temp = 0;\n  char col1[80] = {0};\n  char col2[80] = {0};\n  char col3[80] = {0};\n  char *cols[3] = {0};\n  char *reverdure_fecaloid = 0;\n  jmp_buf bethanks_abaze;\n  int ideational_whinchats;\n  int salten_obvolution;\n  void **beatty_sideswiped = 0;\n  void **vimpa_emballonurid = 0;\n  void *roseville_npv = 0;\n  int hithermost_chigoe = 45;\n  char *selenographic_flamy;;\n  if (__sync_bool_compare_and_swap(&scene_unplank,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&selenographic_flamy,\"4453\",hithermost_chigoe);\n      if (selenographic_flamy != 0) {;\n        roseville_npv = ((void *)selenographic_flamy);\n        salten_obvolution = 1;\n        beatty_sideswiped = &roseville_npv;\n        vimpa_emballonurid = ((void **)(((unsigned long )beatty_sideswiped) * salten_obvolution * salten_obvolution)) + 5;\n        ideational_whinchats = setjmp(bethanks_abaze);\n        if (ideational_whinchats == 0) {\n          longjmp(bethanks_abaze,1);\n        }\n        reverdure_fecaloid = ((char *)((char *)( *(vimpa_emballonurid - 5))));\n  \n  \n  csv = fopen(reverdure_fecaloid,\"r\");\n  if (csv != 0) {\n    \n\n    fscanf(csv,\"\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\",\\\"%79[^\\\"]\\\"\",col1,col2,col3);\n    \n    \n    \n    \n    if (strlen(col1) > 0)\n        cols[0] = col1;\n    if (strlen(col2) > 0)\n        cols[1] = col2;\n    if (strlen(col3) > 0)\n        cols[2] = col3;\n    temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n    if(temp != 0) {\n        \n\n        printf(\"VALUES=\\\"\");\n        fputs(cols[0],temp);\n        printf(cols[0]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[1],temp);\n        printf(cols[1]);\n        printf(\"\\\",\\\"\");\n        fputs(cols[2],temp);\n        printf(cols[2]);\n        \n        printf(\"\\\"\\n\");\n        fclose(temp);\n    }\n  }\n  \n;\n        if (((char *)( *(vimpa_emballonurid - 5))) != 0) \n          free(((char *)((char *)( *(vimpa_emballonurid - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "YES", "cwe": "476", "idx": "149724"}
{"code": "int cpu_signal_handler(int host_signum, void *pinfo, void *puc)\n\n{\n\n    siginfo_t *info = pinfo;\n\n    ucontext_t *uc = puc;\n\n    unsigned long ip;\n\n    int is_write = 0;\n\n\n\n    ip = uc->uc_mcontext.sc_ip;\n\n    switch (host_signum) {\n\n    case SIGILL:\n\n    case SIGFPE:\n\n    case SIGSEGV:\n\n    case SIGBUS:\n\n    case SIGTRAP:\n\n        if (info->si_code && (info->si_segvflags & __ISR_VALID)) {\n\n            \n\n            is_write = (info->si_isr >> 33) & 1;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n    return handle_cpu_signal(ip, (unsigned long)info->si_addr,\n\n                             is_write,\n\n                             (sigset_t *)&uc->uc_sigmask);\n\n}", "answer": "NO", "cwe": "0", "idx": "a78b1299f1bbb9608e3e3a36a7f16cf700a2789d"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <mongoose.h> \n#include <string.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint chalcostibite_ectropionizing = 0;\nint global_variable;\nvoid handle_taint(char *whitey_frosty);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&chalcostibite_ectropionizing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid handle_taint(char *whitey_frosty)\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *futz_nett = 0;\n  int dodonaeaceae_seawans;\n  int nauseaproof_waggers;\n  void *underbear_uranothallite = 0;\n  int *foulminded_stammerwort = 0;\n  int gaiters_recordsize;\n  void *intemerateness_unorientalness[10] = {0};\n  void *tarahumari_mawson = 0;\n  ++global_variable;;\n  if (whitey_frosty != 0) {;\n    tarahumari_mawson = ((void *)whitey_frosty);\n    intemerateness_unorientalness[5] = tarahumari_mawson;\n    gaiters_recordsize = 5;\n    foulminded_stammerwort = &gaiters_recordsize;\n    underbear_uranothallite =  *(intemerateness_unorientalness +  *foulminded_stammerwort);\n    nauseaproof_waggers = 5;\n    while(1 == 1){\n      nauseaproof_waggers = nauseaproof_waggers * 2;\n      nauseaproof_waggers = nauseaproof_waggers + 2;\n      if (nauseaproof_waggers > 1000) {\n        break; \n      }\n    }\n    dodonaeaceae_seawans = nauseaproof_waggers;\n    futz_nett = ((char *)((char *)underbear_uranothallite));\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(futz_nett,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\n    if (((char *)underbear_uranothallite) != 0) \n      free(((char *)((char *)underbear_uranothallite)));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "771", "idx": "151752"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint dispermy_forsaken = 0;\nint global_variable;\nvoid neurohormone_radiopotassium(char **garnisher_unratable);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid billboard_who(void (*mariette_aplanatism)(char **));\nvoid shynesses_sticky(int fadged_allodia,... );\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&dispermy_forsaken,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      billboard_who(neurohormone_radiopotassium);\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid neurohormone_radiopotassium(char **garnisher_unratable)\n{\n  char *ephyrae_successionist;\n  ++global_variable;;\n  setup_printf_context();\n  ephyrae_successionist = getenv(\"BACKCOURTMAN_SUPERFRIENDLY\");\n  if (ephyrae_successionist != 0) {;\n     *garnisher_unratable = ephyrae_successionist;\n  }\n}\n\nvoid billboard_who(void (*mariette_aplanatism)(char **))\n{\n  ++global_variable;\n  char *slipperier_knittable = 0;\n  mariette_aplanatism(&slipperier_knittable);\n  if (slipperier_knittable != 0) {;\n    shynesses_sticky(1,slipperier_knittable);\n  }\n}\n\nvoid shynesses_sticky(int fadged_allodia,... )\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *biurea_aortographies = 0;\n  char *prejudgments_cetonia[15] = {0};\n  char *gools_angelizing = 0;\n  va_list preshrinked_deuzan;\n  ++global_variable;;\n  if (fadged_allodia > 0) {\n    __builtin_va_start(preshrinked_deuzan,fadged_allodia);\n    gools_angelizing = (va_arg(preshrinked_deuzan,char *));\n    __builtin_va_end(preshrinked_deuzan);\n  }\n  prejudgments_cetonia[7] = gools_angelizing;\n  biurea_aortographies = ((char *)prejudgments_cetonia[7]);\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(biurea_aortographies,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "771", "idx": "151439"}
{"code": "void pcnet_common_cleanup(PCNetState *d)\n\n{\n\n    d->nic = NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_51bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_51bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_51()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_51();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_51();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82007"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint server_rubianic = 0;\n\nunion barysilite_yeager \n{\n  char *rust_shapeliness;\n  double jacksonia_stormwind;\n  char *unclose_pullmans;\n  char talemaster_bienvenu;\n  int extinctions_ach;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nSize PMSignalShmemSize()\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *pseudo_unlaudably = 0;\n  jmp_buf nonequation_eiten;\n  int chiniks_outrail;\n  union barysilite_yeager tromping_energids = {0};\n  int *ferrateen_ungainlier = 0;\n  int alcedinidae_dipcoat;\n  union barysilite_yeager uneddying_fuld[10] = {0};\n  union barysilite_yeager schoolma_clistothecium;\n  int seraphtide_abnormalities = 11;\n  char *outdraw_inviscerate;\n  Size size;\n  if (__sync_bool_compare_and_swap(&server_rubianic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&outdraw_inviscerate,\"5390\",seraphtide_abnormalities);\n      if (outdraw_inviscerate != 0) {;\n        schoolma_clistothecium . rust_shapeliness = outdraw_inviscerate;\n        alcedinidae_dipcoat = 5;\n        ferrateen_ungainlier = &alcedinidae_dipcoat;\n        uneddying_fuld[ *ferrateen_ungainlier] = schoolma_clistothecium;\n        tromping_energids = uneddying_fuld[ *ferrateen_ungainlier];\n        chiniks_outrail = setjmp(nonequation_eiten);\n        if (chiniks_outrail == 0) {\n          longjmp(nonequation_eiten,1);\n        }\n        pseudo_unlaudably = ((char *)tromping_energids . rust_shapeliness);\n    \n    if (strlen(pseudo_unlaudably) > 0 &&\n        pseudo_unlaudably[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(pseudo_unlaudably);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n        if (tromping_energids . rust_shapeliness != 0) \n          free(((char *)tromping_energids . rust_shapeliness));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "YES", "cwe": "196", "idx": "151075"}
{"code": "static ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tunsigned char *ptr = NULL;\n\tunsigned int *ui;\n\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tui = (unsigned int *)(ptr + a->offset);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}", "answer": "NO", "cwe": "129", "idx": "63877"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_open_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_open_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95951"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_01()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_01()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_01();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_01();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123279"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_file_w32_spawnvp_82\n{\n\nclass _OS_Command_Injection__char_file_w32_spawnvp_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_file_w32_spawnvp_82 : public _OS_Command_Injection__char_file_w32_spawnvp_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_file_w32_spawnvp_82G2B : public _OS_Command_Injection__char_file_w32_spawnvp_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "245888"}
{"code": "static int error_type_set(void *data, u64 val)\n{\n\tint rc;\n\tu32 available_error_type = 0;\n\tu32 tval, vendor;\n\n\t\n\tvendor = val & ACPI5_VENDOR_BIT;\n\ttval = val & 0x7fffffff;\n\n\t\n\tif (tval & (tval - 1))\n\t\treturn -EINVAL;\n\tif (!vendor) {\n\t\trc = einj_get_available_error_type(&available_error_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (!(val & available_error_type))\n\t\t\treturn -EINVAL;\n\t}\n\terror_type = val;\n\n\treturn 0;\n}", "answer": "NO", "cwe": "74", "idx": "73890"}
{"code": "CPUState *cpu_mb_init (const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    static int tcg_initialized = 0;\n\n    int i;\n\n\n\n    env = qemu_mallocz(sizeof(CPUState));\n\n\n\n    cpu_exec_init(env);\n\n    cpu_reset(env);\n\n\n\n    env->pvr.regs[0] = PVR0_PVR_FULL_MASK \\\n\n                       | PVR0_USE_BARREL_MASK \\\n\n                       | PVR0_USE_DIV_MASK \\\n\n                       | PVR0_USE_HW_MUL_MASK \\\n\n                       | PVR0_USE_EXC_MASK \\\n\n                       | PVR0_USE_ICACHE_MASK \\\n\n                       | PVR0_USE_DCACHE_MASK \\\n\n                       | PVR0_USE_MMU \\\n\n                       | (0xb << 8);\n\n    env->pvr.regs[2] = PVR2_D_OPB_MASK \\\n\n                        | PVR2_D_LMB_MASK \\\n\n                        | PVR2_I_OPB_MASK \\\n\n                        | PVR2_I_LMB_MASK \\\n\n                        | PVR2_USE_MSR_INSTR \\\n\n                        | PVR2_USE_PCMP_INSTR \\\n\n                        | PVR2_USE_BARREL_MASK \\\n\n                        | PVR2_USE_DIV_MASK \\\n\n                        | PVR2_USE_HW_MUL_MASK \\\n\n                        | PVR2_USE_MUL64_MASK \\\n\n                        | 0;\n\n    env->pvr.regs[10] = 0x0c000000; \n\n    env->pvr.regs[11] = PVR11_USE_MMU | (16 << 17);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->mmu.c_mmu = 3;\n\n    env->mmu.c_mmu_tlb_access = 3;\n\n    env->mmu.c_mmu_zones = 16;\n\n#endif\n\n\n\n    if (tcg_initialized)\n\n        return env;\n\n\n\n    tcg_initialized = 1;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    env_debug = tcg_global_mem_new(TCG_AREG0, \n\n                    offsetof(CPUState, debug),\n\n                    \"debug0\");\n\n    env_iflags = tcg_global_mem_new(TCG_AREG0, \n\n                    offsetof(CPUState, iflags),\n\n                    \"iflags\");\n\n    env_imm = tcg_global_mem_new(TCG_AREG0, \n\n                    offsetof(CPUState, imm),\n\n                    \"imm\");\n\n    env_btarget = tcg_global_mem_new(TCG_AREG0,\n\n                     offsetof(CPUState, btarget),\n\n                     \"btarget\");\n\n    env_btaken = tcg_global_mem_new(TCG_AREG0,\n\n                     offsetof(CPUState, btaken),\n\n                     \"btaken\");\n\n    for (i = 0; i < ARRAY_SIZE(cpu_R); i++) {\n\n        cpu_R[i] = tcg_global_mem_new(TCG_AREG0,\n\n                          offsetof(CPUState, regs[i]),\n\n                          regnames[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(cpu_SR); i++) {\n\n        cpu_SR[i] = tcg_global_mem_new(TCG_AREG0,\n\n                          offsetof(CPUState, sregs[i]),\n\n                          special_regnames[i]);\n\n    }\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    return env;\n\n}", "answer": "NO", "cwe": "0", "idx": "4898427ec88821ff94571340c397d15e0bddb3e2"}
{"code": "static void entersafe_encode_bignum(u8 tag,sc_pkcs15_bignum_t bignum,u8** ptr)\n{\n\t u8 *p=*ptr;\n\n\t *p++=tag;\n\t if(bignum.len<128)\n\t {\n\t\t  *p++=(u8)bignum.len;\n\t }\n\t else\n\t {\n\t\t  u8 bytes=1;\n\t\t  size_t len=bignum.len;\n\t\t  while(len)\n\t\t  {\n\t\t\t   len=len>>8;\n\t\t\t   ++bytes;\n\t\t  }\n\t\t  bytes&=0x0F;\n\t\t  *p++=0x80|bytes;\n\t\t  while(bytes)\n\t\t  {\n\t\t\t   *p++=bignum.len>>((bytes-1)*8);\n\t\t\t   --bytes;\n\t\t  }\n\t }\n\t memcpy(p,bignum.data,bignum.len);\n\t entersafe_reverse_buffer(p,bignum.len);\n\t p+=bignum.len;\n\t *ptr = p;\n}", "answer": "NO", "cwe": "125", "idx": "78339"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_environment_w32CreateFile_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_environment_w32CreateFile_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96244"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_char_connect_socket_83\n{\n\n#ifndef OMITM\n\nclass _Process_Control__w32_char_connect_socket_83\n{\npublic:\n    _Process_Control__w32_char_connect_socket_83(char * dataCopy);\n    ~_Process_Control__w32_char_connect_socket_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_char_connect_socket_83G2B\n{\npublic:\n    _Process_Control__w32_char_connect_socket_83G2B(char * dataCopy);\n    ~_Process_Control__w32_char_connect_socket_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "114", "idx": "61986"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91796"}
{"code": "static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "08b277ac46da8b02e50cec455eca7cb2d12ffcf0"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint poca_ahira = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *brink_crimpier = 0;\n  jmp_buf clevises_roud;\n  int wailoo_noninfallible;\n  char *thieveries_utfangthief = 0;\n  int *hotdogs_ombres = 0;\n  int washway_quotingly;\n  char *disprison_omentitis[10] = {0};\n  int mediatorship_federalization = 0;\n  char *uterometer_boogeymen = 0;\n  char *margarethe_epilating;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&poca_ahira,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      margarethe_epilating = getenv(\"PEOPLEHOOD_GONADECTOMY\");\n      if (margarethe_epilating != 0) {;\n        mediatorship_federalization = ((int )(strlen(margarethe_epilating)));\n        uterometer_boogeymen = ((char *)(malloc(mediatorship_federalization + 1)));\n        if (uterometer_boogeymen == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(uterometer_boogeymen,0,mediatorship_federalization + 1);\n        memcpy(uterometer_boogeymen,margarethe_epilating,mediatorship_federalization);\n        disprison_omentitis[5] = uterometer_boogeymen;\n        washway_quotingly = 5;\n        hotdogs_ombres = &washway_quotingly;\n        thieveries_utfangthief =  *(disprison_omentitis +  *hotdogs_ombres);\n        wailoo_noninfallible = setjmp(clevises_roud);\n        if (wailoo_noninfallible == 0) {\n          longjmp(clevises_roud,1);\n        }\n        brink_crimpier = ((char *)thieveries_utfangthief);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(brink_crimpier); ++i) {\n        if (brink_crimpier[i] == ';') {\n          if (i == 0 || brink_crimpier[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,brink_crimpier);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if (thieveries_utfangthief != 0) \n          free(((char *)thieveries_utfangthief));\nclose_printf_context();\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}", "answer": "YES", "cwe": "88", "idx": "152467"}
{"code": "test_bson_append_minkey (void)\n{\n   bson_t *b;\n   bson_t *b2;\n\n   b = bson_new ();\n   BSON_ASSERT (bson_append_minkey (b, \"minkey\", -1));\n   b2 = get_bson (\"test36.bson\");\n   BSON_ASSERT_BSON_EQUAL (b, b2);\n   bson_destroy (b);\n   bson_destroy (b2);\n}", "answer": "NO", "cwe": "125", "idx": "77887"}
{"code": "static void cirrus_cursor_invalidate(VGACommonState *s1)\n{\n    CirrusVGAState *s = container_of(s1, CirrusVGAState, vga);\n    int size;\n\n    if (!(s->vga.sr[0x12] & CIRRUS_CURSOR_SHOW)) {\n        size = 0;\n    } else {\n        if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE)\n            size = 64;\n        else\n            size = 32;\n    }\n    \n    if (s->last_hw_cursor_size != size ||\n        s->last_hw_cursor_x != s->vga.hw_cursor_x ||\n        s->last_hw_cursor_y != s->vga.hw_cursor_y) {\n\n        invalidate_cursor1(s);\n\n        s->last_hw_cursor_size = size;\n        s->last_hw_cursor_x = s->vga.hw_cursor_x;\n        s->last_hw_cursor_y = s->vga.hw_cursor_y;\n        \n        cirrus_cursor_compute_yrange(s);\n        invalidate_cursor1(s);\n    }\n}", "answer": "NO", "cwe": "125", "idx": "16681"}
{"code": "static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "269fc8e04906ffd965aa19425ca90980b23c6508"}
{"code": "struct XenDevice *xen_be_find_xendev(const char *type, int dom, int dev)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    TAILQ_FOREACH(xendev, &xendevs, next) {\n\n\tif (xendev->dom != dom)\n\n\t    continue;\n\n\tif (xendev->dev != dev)\n\n\t    continue;\n\n\tif (strcmp(xendev->type, type) != 0)\n\n\t    continue;\n\n\treturn xendev;\n\n    }\n\n    return NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "72cf2d4f0e181d0d3a3122e04129c58a95da713e"}
{"code": "copy_resource(fz_context *ctx, pdf_filter_processor *p, pdf_obj *key, const char *name)\n{\n\tpdf_obj *res, *obj;\n\n\tif (!name || name[0] == 0)\n\t\treturn;\n\n\tres = pdf_dict_get(ctx, p->old_rdb, key);\n\tobj = pdf_dict_gets(ctx, res, name);\n\tif (obj)\n\t{\n\t\tres = pdf_dict_get(ctx, p->new_rdb, key);\n\t\tif (!res)\n\t\t{\n\t\t\tres = pdf_new_dict(ctx, pdf_get_bound_document(ctx, p->new_rdb), 1);\n\t\t\tpdf_dict_put_drop(ctx, p->new_rdb, key, res);\n\t\t}\n\t\tpdf_dict_putp(ctx, res, name, obj);\n\t}\n}", "answer": "NO", "cwe": "125", "idx": "1819"}
{"code": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}", "answer": "NO", "cwe": "0", "idx": "1171ae9a5b132dc631728ff17688d05ed4534181"}
{"code": "static uint32_t get_elf_hwcap(void)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(thread_cpu);\n\n    uint32_t hwcaps = 0;\n\n\n\n    hwcaps |= ARM_HWCAP_ARM_SWP;\n\n    hwcaps |= ARM_HWCAP_ARM_HALF;\n\n    hwcaps |= ARM_HWCAP_ARM_THUMB;\n\n    hwcaps |= ARM_HWCAP_ARM_FAST_MULT;\n\n\n\n    \n\n#define GET_FEATURE(feat, hwcap) \\\n\n    do { if (arm_feature(&cpu->env, feat)) { hwcaps |= hwcap; } } while (0)\n\n    \n\n    GET_FEATURE(ARM_FEATURE_V5, ARM_HWCAP_ARM_EDSP);\n\n    GET_FEATURE(ARM_FEATURE_VFP, ARM_HWCAP_ARM_VFP);\n\n    GET_FEATURE(ARM_FEATURE_IWMMXT, ARM_HWCAP_ARM_IWMMXT);\n\n    GET_FEATURE(ARM_FEATURE_THUMB2EE, ARM_HWCAP_ARM_THUMBEE);\n\n    GET_FEATURE(ARM_FEATURE_NEON, ARM_HWCAP_ARM_NEON);\n\n    GET_FEATURE(ARM_FEATURE_VFP3, ARM_HWCAP_ARM_VFPv3);\n\n    GET_FEATURE(ARM_FEATURE_V6K, ARM_HWCAP_ARM_TLS);\n\n    GET_FEATURE(ARM_FEATURE_VFP4, ARM_HWCAP_ARM_VFPv4);\n\n    GET_FEATURE(ARM_FEATURE_ARM_DIV, ARM_HWCAP_ARM_IDIVA);\n\n    GET_FEATURE(ARM_FEATURE_THUMB_DIV, ARM_HWCAP_ARM_IDIVT);\n\n    \n\n    GET_FEATURE(ARM_FEATURE_VFP3, ARM_HWCAP_ARM_VFPD32);\n\n    GET_FEATURE(ARM_FEATURE_LPAE, ARM_HWCAP_ARM_LPAE);\n\n#undef GET_FEATURE\n\n\n\n    return hwcaps;\n\n}", "answer": "NO", "cwe": "0", "idx": "ad6919dc0ab3b8ae26d772e883aa8e709785d249"}
{"code": "static ssize_t show_port_name(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buffer)\n{\n\tstruct port *port;\n\n\tport = dev_get_drvdata(dev);\n\n\treturn sprintf(buffer, \"%s\\n\", port->name);\n}", "answer": "NO", "cwe": "119", "idx": "66620"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <stdio.h> \n#include <cus/trace.h> \nint combinator_interrhyme = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid rajahs_patentor(int roe_ags,char *gyratory_bout);\nunsigned int get_size(char *ss_tainted)\n{\n  \n  unsigned long uns_int = 0UL;\n  uns_int = strtoul(ss_tainted,0,0);\n  if (uns_int > ((unsigned long )4294967295U) ||\n      uns_int == 0)\n    uns_int = 1U;\n  return (unsigned int )uns_int;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  int poisonberry_cyanotic = 7;\n  int behaviors_lyric = 0;\n  char *gramash_enchoric = 0;\n  char *unordered_ibiza;;\n  if (__sync_bool_compare_and_swap(&combinator_interrhyme,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      unordered_ibiza = getenv(\"BSEE_ENGOUE\");\n      if (unordered_ibiza != 0) {;\n        behaviors_lyric = ((int )(strlen(unordered_ibiza)));\n        gramash_enchoric = ((char *)(malloc(behaviors_lyric + 1)));\n        if (gramash_enchoric == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(gramash_enchoric,0,behaviors_lyric + 1);\n        memcpy(gramash_enchoric,unordered_ibiza,behaviors_lyric);\n        rajahs_patentor(poisonberry_cyanotic,gramash_enchoric);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid rajahs_patentor(int roe_ags,char *gyratory_bout)\n{\n    char *other_buff = 0;\n    int size = 0;\n    int num = 0;\n    char buff[200] = {0};\n    int output_counter = 0;\n  char *edriasteroidea_microliter = 0;\n  ++global_variable;\n  roe_ags--;\n  if (roe_ags > 0) {\n    rajahs_patentor(roe_ags,gyratory_bout);\n    return ;\n  }\n  edriasteroidea_microliter = ((char *)gyratory_bout);\n    \n    if (strlen(edriasteroidea_microliter) > 0 &&\n        edriasteroidea_microliter[0] == '-') {\n        printf(\"Negative number given as input\\n\");\n    } else {\n        \n        \n        num = get_size(edriasteroidea_microliter);\n        other_buff = getenv(\"SS_BUFF\");\n        \n        \n        \n        if (other_buff != 0) {\n            strncpy(buff, other_buff, (sizeof(buff) - 1)/(sizeof(char)));\n            size = ((int )(strlen(buff)));\n            \n            \n            while (num < size) {\n                \n                if (output_counter == 0) {\n                    printf(\"evaluating input\\n\");\n                }\n                output_counter++;\n                if (output_counter == 1000000) {\n                    output_counter = 0;\n                }\n                if (num > 0)\n                    ++num;\n            }\n            \n        } else {\n            printf(\"Missing value for other_buff\\n\");\n        }\n        printf(\"finished evaluating\\n\");\n    }\n    \n;\n  if (gyratory_bout != 0) \n    free(((char *)gyratory_bout));\nclose_printf_context();\n}", "answer": "YES", "cwe": "196", "idx": "151151"}
{"code": "void mwifiex_set_vht_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vht_ie;\n\n\tvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (vht_ie) {\n\t\tmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t\tpriv->ap_11ac_enabled = 1;\n\t} else {\n\t\tpriv->ap_11ac_enabled = 0;\n\t}\n\n\treturn;\n}", "answer": "NO", "cwe": "120", "idx": "88619"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_execl_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_execl_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_execl_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_execl_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248261"}
{"code": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}", "answer": "NO", "cwe": "0", "idx": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nstatic char * mSource(char * data)\n{\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return data;\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_42()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic char * nG2BSource(char * data)\n{\n    \n    strcpy(data, \"hostname\");\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_42()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_42();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_42();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82003"}
{"code": "uint64_t helper_st_virt_to_phys (uint64_t virtaddr)\n\n{\n\n    uint64_t tlb_addr, physaddr;\n\n    int index, mmu_idx;\n\n    void *retaddr;\n\n\n\n    mmu_idx = cpu_mmu_index(env);\n\n    index = (virtaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n redo:\n\n    tlb_addr = env->tlb_table[mmu_idx][index].addr_write;\n\n    if ((virtaddr & TARGET_PAGE_MASK) ==\n\n        (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {\n\n        physaddr = virtaddr + env->tlb_table[mmu_idx][index].addend;\n\n    } else {\n\n        \n\n        retaddr = GETPC();\n\n        tlb_fill(virtaddr, 1, mmu_idx, retaddr);\n\n        goto redo;\n\n    }\n\n    return physaddr;\n\n}", "answer": "NO", "cwe": "0", "idx": "2374e73edafff0586cbfb67c333c5a7588f81fd5"}
{"code": "static void rtas_display_character(sPAPREnvironment *spapr,\n\n                                   uint32_t token, uint32_t nargs,\n\n                                   target_ulong args,\n\n                                   uint32_t nret, target_ulong rets)\n\n{\n\n    uint8_t c = rtas_ld(args, 0);\n\n    VIOsPAPRDevice *sdev = vty_lookup(spapr, 0);\n\n\n\n    if (!sdev) {\n\n        rtas_st(rets, 0, -1);\n\n    } else {\n\n        vty_putchars(sdev, &c, sizeof(c));\n\n        rtas_st(rets, 0, 0);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "210b580b106fa798149e28aa13c66b325a43204e"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_ifstream_22\n{\n\n#ifndef OMITM\n\n\nint mGlobal = 0;\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    mGlobal = 1; \n    data = mSource(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n    ;\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint nG2B1Global = 0;\nint nG2B2Global = 0;\n\n\nwchar_t * nG2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2B1Global = 0; \n    data = nG2B1Source(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n    ;\n}\n\n\nwchar_t * nG2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    nG2B2Global = 1; \n    data = nG2B2Source(data);\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n    ;\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_ifstream_22; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97525"}
{"code": "static int fetch_active_ports_list(QEMUFile *f,\n\n                                   VirtIOSerial *s, uint32_t nr_active_ports)\n\n{\n\n    uint32_t i;\n\n\n\n    s->post_load = g_malloc0(sizeof(*s->post_load));\n\n    s->post_load->nr_active_ports = nr_active_ports;\n\n    s->post_load->connected =\n\n        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);\n\n\n\n    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                            virtio_serial_post_load_timer_cb,\n\n                                            s);\n\n\n\n    \n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        VirtIOSerialPort *port;\n\n        uint32_t elem_popped;\n\n        uint32_t id;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        s->post_load->connected[i].port = port;\n\n        s->post_load->connected[i].host_connected = qemu_get_byte(f);\n\n\n\n        qemu_get_be32s(f, &elem_popped);\n\n        if (elem_popped) {\n\n            qemu_get_be32s(f, &port->iov_idx);\n\n            qemu_get_be64s(f, &port->iov_offset);\n\n\n\n            port->elem =\n\n                qemu_get_virtqueue_element(f, sizeof(VirtQueueElement));\n\n\n\n            \n\n            virtio_serial_throttle_port(port, false);\n\n        }\n\n    }\n\n    timer_mod(s->post_load->timer, 1);\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "8607f5c3072caeebbe0217df28651fffd3a79fd9"}
{"code": "void qemu_del_timer(QEMUTimer *ts)\n\n{\n\n}", "answer": "NO", "cwe": "0", "idx": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3"}
{"code": "static int kvm_put_fpu(CPUState *env)\n\n{\n\n    struct kvm_fpu fpu;\n\n    int i;\n\n\n\n    memset(&fpu, 0, sizeof fpu);\n\n    fpu.fsw = env->fpus & ~(7 << 11);\n\n    fpu.fsw |= (env->fpstt & 7) << 11;\n\n    fpu.fcw = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n\tfpu.ftwx |= (!env->fptags[i]) << i;\n\n    memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);\n\n    memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);\n\n    fpu.mxcsr = env->mxcsr;\n\n\n\n    return kvm_vcpu_ioctl(env, KVM_SET_FPU, &fpu);\n\n}", "answer": "NO", "cwe": "0", "idx": "b9bec74bcb16519a876ec21cd5277c526a9b512d"}
{"code": "static char* mpjpeg_get_boundary(AVIOContext* pb)\n\n{\n\n    uint8_t *mime_type = NULL;\n\n    const char *start;\n\n    const char *end;\n\n    uint8_t *res = NULL;\n\n    int     len;\n\n\n\n    \n\n    av_opt_get(pb, \"mime_type\", AV_OPT_SEARCH_CHILDREN, &mime_type);\n\n    start = mime_type;\n\n    while (start != NULL && *start != '\\0') {\n\n        start = strchr(start, ';');\n\n        if (start)\n\n            start = start+1;\n\n\n\n        while (av_isspace(*start))\n\n            start++;\n\n\n\n        if (!av_stristart(start, \"boundary=\", &start)) {\n\n            end = strchr(start, ';');\n\n            if (end)\n\n                len = end - start - 1;\n\n            else\n\n                len = strlen(start);\n\n            res = av_strndup(start, len);\n\n            break;\n\n        }\n\n    }\n\n\n\n    av_freep(&mime_type);\n\n    return res;\n\n}", "answer": "NO", "cwe": "0", "idx": "7fd1c85e51958050180b37a1bf4ce833d44f91e8"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <vector>\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<wchar_t *> dataVector);\n\nvoid m()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<wchar_t *> dataVector);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_open_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91445"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    funcPtr(data);\n}\n\nvoid _Process_Control__w32_wchar_t_file_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62399"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint adjustation_lactonize = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar **anocarpous_syngamies(char **abolishing_choloidinic);\nvoid absentminded_logomachy(char **stetch_lumbricales);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*musettes_pyrazolyl)(char **) = absentminded_logomachy;\n  char **radnorshire_kumari = 0;\n  char *watcheyes_cheapener[18] = {0};\n  char *liquamen_undutifulness;;\n  if (__sync_bool_compare_and_swap(&adjustation_lactonize,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&liquamen_undutifulness,\"DOROTHY_ESCROWS\");\n      if (liquamen_undutifulness != 0) {;\n        watcheyes_cheapener[4] = liquamen_undutifulness;\n        radnorshire_kumari = anocarpous_syngamies(watcheyes_cheapener);\n        musettes_pyrazolyl(radnorshire_kumari);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nchar **anocarpous_syngamies(char **abolishing_choloidinic)\n{\n  ++global_variable;\n  return abolishing_choloidinic;\n}\n\nvoid absentminded_logomachy(char **stetch_lumbricales)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *epigonation_nonsupplicating = 0;\n  ++global_variable;;\n  epigonation_nonsupplicating = ((char *)stetch_lumbricales[4]);\n      \n      len = strtol(epigonation_nonsupplicating,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (stetch_lumbricales[4] != 0) \n    free(((char *)stetch_lumbricales[4]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "476", "idx": "149298"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96870"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscat(data, L\"Doe, XXXXX\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123108"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_10()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_file_w32_spawnv_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32_spawnv_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245804"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint lesli_endangered = 0;\n\nunion mucocellulosic_seated \n{\n  char *classicalities_perioesophageal;\n  double coxiest_conductive;\n  char *tinamidae_diastatically;\n  char urartic_defalcator;\n  int macrobius_acephalina;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nchar process_buffer(char *buffer_param)\n{\n  \n  char first_char;\n  first_char = buffer_param[0] - 97;\n  free(buffer_param);\n  return first_char;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n char *buffer = 0;\n  char *pruss_bibliopolic = 0;\n  jmp_buf situationally_alexanders;\n  int haithal_nobel;\n  union mucocellulosic_seated tweedles_quomodos = {0};\n  int **********cheirotherium_carbin = 0;\n  int *********proscolex_sensitivenesses = 0;\n  int ********eyewinks_nonnational = 0;\n  int *******bondland_pua = 0;\n  int ******subofficer_diffusive = 0;\n  int *****pterographic_aglisten = 0;\n  int ****palmiped_stercorean = 0;\n  int ***kairotic_inblow = 0;\n  int **decomposure_roseville = 0;\n  int *transhuman_highted = 0;\n  int lobuli_entremess;\n  union mucocellulosic_seated majestical_overmuches[10] = {0};\n  union mucocellulosic_seated tires_yaakov;\n  int zeugobranchia_overbar = 44;\n  char *axiolite_scumboard;;\n  if (__sync_bool_compare_and_swap(&lesli_endangered,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&axiolite_scumboard,\"2674\",zeugobranchia_overbar);\n      if (axiolite_scumboard != 0) {;\n        tires_yaakov . classicalities_perioesophageal = axiolite_scumboard;\n        lobuli_entremess = 5;\n        transhuman_highted = &lobuli_entremess;\n        decomposure_roseville = &transhuman_highted;\n        kairotic_inblow = &decomposure_roseville;\n        palmiped_stercorean = &kairotic_inblow;\n        pterographic_aglisten = &palmiped_stercorean;\n        subofficer_diffusive = &pterographic_aglisten;\n        bondland_pua = &subofficer_diffusive;\n        eyewinks_nonnational = &bondland_pua;\n        proscolex_sensitivenesses = &eyewinks_nonnational;\n        cheirotherium_carbin = &proscolex_sensitivenesses;\n        majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))] = tires_yaakov;\n        tweedles_quomodos = majestical_overmuches[ *( *( *( *( *( *( *( *( *( *cheirotherium_carbin)))))))))];\n        haithal_nobel = setjmp(situationally_alexanders);\n        if (haithal_nobel == 0) {\n          longjmp(situationally_alexanders,1);\n        }\n        pruss_bibliopolic = ((char *)tweedles_quomodos . classicalities_perioesophageal);\n    \n    buffer = malloc((strlen(pruss_bibliopolic) + 1) * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,pruss_bibliopolic);\n    \n \n    if (buffer[0] >= 97) {\n        printf(\"Index of first char: %i\\n\",process_buffer(buffer));\n    }\n    \n    if (buffer != 0) {\n        \n  \n        free(buffer);\n        \n    }\n    \n;\n        if (tweedles_quomodos . classicalities_perioesophageal != 0) \n          free(((char *)tweedles_quomodos . classicalities_perioesophageal));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "YES", "cwe": "415", "idx": "152925"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_09()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123095"}
{"code": "bool check_conf_file(const char *conf_file)\n{\n\tglob_t globbuf;\n\tsize_t i;\n\tbool ret = true;\n\tint res;\n\tstruct stat stb;\n\tunsigned num_matches = 0;\n\n\tglobbuf.gl_offs = 0;\n\tres = glob(conf_file, GLOB_MARK\n#if HAVE_DECL_GLOB_BRACE\n\t\t\t\t\t| GLOB_BRACE\n#endif\n\t\t\t\t\t\t    , NULL, &globbuf);\n\tif (res) {\n\t\treport_config_error(CONFIG_FILE_NOT_FOUND, \"Unable to find configuration file %s (glob returned %d)\", conf_file, res);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tif (globbuf.gl_pathv[i][strlen(globbuf.gl_pathv[i])-1] == '/') {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (access(globbuf.gl_pathv[i], R_OK)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to read configuration file %s\", globbuf.gl_pathv[i]);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (stat(globbuf.gl_pathv[i], &stb) ||\n\t\t    !S_ISREG(stb.st_mode) ||\n\t\t     (stb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' is not a regular non-executable file\", globbuf.gl_pathv[i]);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_matches++;\n\t}\n\n\tif (ret) {\n\t\tif (num_matches > 1)\n\t\t\treport_config_error(CONFIG_MULTIPLE_FILES, \"WARNING, more than one file matches configuration file %s, using %s\", conf_file, globbuf.gl_pathv[0]);\n\t\telse if (num_matches == 0) {\n\t\t\treport_config_error(CONFIG_FILE_NOT_FOUND, \"Unable to find configuration file %s\", conf_file);\n\t\t\tret = false;\n\t\t}\n\t}\n\n\tglobfree(&globbuf);\n\n\treturn ret;\n}", "answer": "NO", "cwe": "59", "idx": "76148"}
{"code": "static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    \n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}", "answer": "NO", "cwe": "0", "idx": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd"}
{"code": "static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    sp804_state *s = (sp804_state *)opaque;\n\n\n\n    if (offset < 0x20) {\n\n        return arm_timer_read(s->timer[0], offset);\n\n    }\n\n    if (offset < 0x40) {\n\n        return arm_timer_read(s->timer[1], offset - 0x20);\n\n    }\n\n\n\n    \n\n    if (offset >= 0xfe0 && offset <= 0xffc) {\n\n        return sp804_ids[(offset - 0xfe0) >> 2];\n\n    }\n\n\n\n    switch (offset) {\n\n    \n\n    case 0xf00: \n\n    case 0xf04: \n\n        return 0;\n\n    }\n\n\n\n    hw_error(\"%s: Bad offset %x\\n\", __func__, (int)offset);\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint tribunitive_stria = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid flourishing_stocked(char *mentalities_documentalist);\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  void (*davyum_aliceville)(char *) = flourishing_stocked;\n  int secundine_woolshearer = 0;\n  char *gorillaship_unexistent = 0;\n  char *antrophore_outprayed;;\n  if (__sync_bool_compare_and_swap(&tribunitive_stria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      antrophore_outprayed = getenv(\"REPERMIT_HERBARIIA\");\n      if (antrophore_outprayed != 0) {;\n        secundine_woolshearer = ((int )(strlen(antrophore_outprayed)));\n        gorillaship_unexistent = ((char *)(malloc(secundine_woolshearer + 1)));\n        if (gorillaship_unexistent == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(gorillaship_unexistent,0,secundine_woolshearer + 1);\n        memcpy(gorillaship_unexistent,antrophore_outprayed,secundine_woolshearer);\n        davyum_aliceville(gorillaship_unexistent);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid flourishing_stocked(char *mentalities_documentalist)\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *lamellicorn_caruthersville = 0;\n  ++global_variable;;\n  lamellicorn_caruthersville = ((char *)mentalities_documentalist);\n    \n files = fopen(lamellicorn_caruthersville,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n  if (mentalities_documentalist != 0) \n    free(((char *)mentalities_documentalist));\nclose_printf_context();\n}", "answer": "YES", "cwe": "775", "idx": "151603"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint handwritten_coderived = 0;\nint global_variable;\nvoid handle_taint(char *molters_acuminous);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&handwritten_coderived,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *molters_acuminous)\n{\n    float quotient;\n    int mod = 0;\n    int input;\n  char *treasureless_digesting = 0;\n  char *untidies_lycaon[36] = {0};\n  ++global_variable;;\n  if (molters_acuminous != 0) {;\n    untidies_lycaon[2] = molters_acuminous;\n    if (untidies_lycaon[2] != 0) {\n      goto devereux_nonnational;\n    }\n    ++global_variable;\n    devereux_nonnational:;\n    treasureless_digesting = ((char *)untidies_lycaon[2]);\n    \n    input = atoi(treasureless_digesting);\n    if (input != 0) {\n        \n        \n        mod = input % 4;\n        \n        \n        \n        \n        \n        quotient = 1024 / mod;\n        \n        printf(\"%f\\n\", quotient);\n    } else {\n        printf(\"Input value is 0, or not a number\\n\");\n    }\n    \n;\n    if (untidies_lycaon[2] != 0) \n      free(((char *)untidies_lycaon[2]));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "369", "idx": "151178"}
{"code": "static uint32_t openpic_iack(OpenPICState *opp, IRQDest *dst, int cpu)\n{\n    IRQSource *src;\n    int retval, irq;\n\n    DPRINTF(\"Lower OpenPIC INT output\\n\");\n    qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);\n\n    irq = IRQ_get_next(opp, &dst->raised);\n    DPRINTF(\"IACK: irq=%d\\n\", irq);\n\n    if (irq == -1) {\n        \n        return opp->spve;\n    }\n\n    src = &opp->src[irq];\n    if (!(src->ivpr & IVPR_ACTIVITY_MASK) ||\n            !(IVPR_PRIORITY(src->ivpr) > dst->ctpr)) {\n        fprintf(stderr, \"%s: bad raised IRQ %d ctpr %d ivpr 0x%08x\\n\",\n                __func__, irq, dst->ctpr, src->ivpr);\n        openpic_update_irq(opp, irq);\n        retval = opp->spve;\n    } else {\n        \n        IRQ_setbit(&dst->servicing, irq);\n        retval = IVPR_VECTOR(opp, src->ivpr);\n    }\n\n    if (!src->level) {\n        \n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n        src->pending = 0;\n        IRQ_resetbit(&dst->raised, irq);\n    }\n\n    if ((irq >= opp->irq_ipi0) &&  (irq < (opp->irq_ipi0 + OPENPIC_MAX_IPI))) {\n        src->destmask &= ~(1 << cpu);\n        if (src->destmask && !src->level) {\n            \n            openpic_set_irq(opp, irq, 1);\n            openpic_set_irq(opp, irq, 0);\n            \n            src->ivpr |= IVPR_ACTIVITY_MASK;\n        }\n    }\n\n    return retval;\n}", "answer": "NO", "cwe": "119", "idx": "15684"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint kobo_schizophrene = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    int (* before)(int);\n    char buffer[64];\n    int (* after)(int);\n};\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n    int i = 0;\n    struct struct* data = NULL;\n    int buff_size = 63;\n    int taint_len;\n  char *eupathy_forsythia = 0;\n  void *apex_diametrical = 0;\n  long basaree_propylidene[10];\n  void *biasing_conveying[10] = {0};\n  void *crambes_seidule = 0;\n  char *landladydom_drosky;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&kobo_schizophrene,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      landladydom_drosky = getenv(\"REPRESSOR_POMMELS\");\n      if (landladydom_drosky != 0) {;\n        crambes_seidule = ((void *)landladydom_drosky);\n        biasing_conveying[5] = crambes_seidule;\n        basaree_propylidene[1] = 5;\n        apex_diametrical =  *(biasing_conveying + basaree_propylidene[1]);\n        if (((char *)apex_diametrical) != 0) {\n          goto lusterlessness_monocarps;\n        }\n        ++global_variable;\n        lusterlessness_monocarps:;\n        eupathy_forsythia = ((char *)((char *)apex_diametrical));\n    \n    \n    \n    data = (struct struct*) malloc(sizeof(struct struct));\n    if (data != NULL) {\n        data->before = toupper;\n        memset(data->buffer, 'A', 64);\n        data->buffer[63] = '\\0';\n        data->after = toupper;\n        \n        \n        \n        \n        \n        taint_len = ((int )(strlen(eupathy_forsythia)));\n    \n    \n        for (; taint_len >= 0; (--buff_size , --taint_len)) {\n            data->buffer[buff_size] = eupathy_forsythia[taint_len];\n        }\n        \n        for (i = 0; i < 64; ++i) {\n            data->buffer[i] = toupper(data->buffer[i]);\n            printf(\"%c\",data->before(data->buffer[i]));\n        }\n        \n        \n        printf(\"\\n\");\n        free(data);\n        \n        \n        \n    }\n;\nclose_printf_context();\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#endif \n#endif ", "answer": "YES", "cwe": "124", "idx": "153573"}
{"code": "bool DownloadItemImpl::GetOpenWhenComplete() const {\n  return open_when_complete_;\n}", "answer": "NO", "cwe": "119", "idx": "113046"}
{"code": "static int replace_map_fd_with_map_ptr(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j, err;\n\n\terr = bpf_prog_calc_tag(env->prog);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(env, \"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(env, \"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(env, \"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(env, \"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn->imm);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\terr = check_map_prog_compatibility(env, map, env->prog);\n\t\t\tif (err) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t\n\t\t\tmap = bpf_map_inc(map, false);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tif (map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE &&\n\t\t\t    bpf_cgroup_storage_assign(env->prog, map)) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"only one cgroup storage is allowed\\n\");\n\t\t\t\tfdput(f);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (!bpf_opcode_in_insntable(insn->code)) {\n\t\t\tverbose(env, \"unknown opcode %02x\\n\", insn->code);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}", "answer": "NO", "cwe": "125", "idx": "76426"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96937"}
{"code": "static int decode_block_refinement(MJpegDecodeContext *s, DCTELEM *block, uint8_t *last_nnz,\n\n                        int ac_index, int16_t *quant_matrix,\n\n                        int ss, int se, int Al, int *EOBRUN)\n\n{\n\n    int code, i=ss, j, sign, val, run;\n\n    int last = FFMIN(se, *last_nnz);\n\n\n\n    OPEN_READER(re, &s->gb);\n\n    if(*EOBRUN)\n\n        (*EOBRUN)--;\n\n    else {\n\n        for(;;i++) {\n\n            UPDATE_CACHE(re, &s->gb);\n\n            GET_VLC(code, re, &s->gb, s->vlcs[1][ac_index].table, 9, 2)\n\n            \n\n            code -= 16;\n\n            if(code & 0xF) {\n\n                run = ((unsigned) code) >> 4;\n\n                UPDATE_CACHE(re, &s->gb);\n\n                val = SHOW_UBITS(re, &s->gb, 1);\n\n                LAST_SKIP_BITS(re, &s->gb, 1);\n\n                ZERO_RUN;\n\n                j = s->scantable.permutated[i];\n\n                val--;\n\n                block[j] = ((quant_matrix[j]^val)-val) << Al;\n\n                if(i == se) {\n\n                    if(i > *last_nnz)\n\n                        *last_nnz = i;\n\n                    CLOSE_READER(re, &s->gb)\n\n                    return 0;\n\n                }\n\n            }else{\n\n                run = ((unsigned) code) >> 4;\n\n                if(run == 0xF){\n\n                    ZERO_RUN;\n\n                }else{\n\n                    val = run;\n\n                    run = (1 << run);\n\n                    if(val) {\n\n                        UPDATE_CACHE(re, &s->gb);\n\n                        run += SHOW_UBITS(re, &s->gb, val);\n\n                        LAST_SKIP_BITS(re, &s->gb, val);\n\n                    }\n\n                    *EOBRUN = run - 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(i > *last_nnz)\n\n            *last_nnz = i;\n\n    }\n\n\n\n    for(;i<=last;i++) {\n\n        j = s->scantable.permutated[i];\n\n        if(block[j])\n\n            REFINE_BIT(j)\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "5675a11f9277b5c7b1c9ad45da893e9ef9a42f03"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <unistd.h> \n#include <sys/stat.h> \nint erythropoiesis_olivile = 0;\ntypedef char *beelzebub_rufflers;\nint global_variable;\nvoid handle_taint(char *lanolines_proclivitous);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid thalia_machi(int rpo_nearing,... );\nvoid disappointment_vidry(beelzebub_rufflers unstacker_neptunism);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&erythropoiesis_olivile,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *lanolines_proclivitous)\n{\n  beelzebub_rufflers southness_bas = 0;\n  ++global_variable;;\n  if (lanolines_proclivitous != 0) {;\n    southness_bas = lanolines_proclivitous;\n    thalia_machi(1,southness_bas);\n  }\n}\n\nvoid thalia_machi(int rpo_nearing,... )\n{\n  void (*antefuture_commentator)(beelzebub_rufflers ) = disappointment_vidry;\n  beelzebub_rufflers vocate_coreligionist = 0;\n  va_list mooruk_zulu;\n  ++global_variable;;\n  if (rpo_nearing > 0) {\n    __builtin_va_start(mooruk_zulu,rpo_nearing);\n    vocate_coreligionist = (va_arg(mooruk_zulu,beelzebub_rufflers ));\n    __builtin_va_end(mooruk_zulu);\n  }\n  antefuture_commentator(vocate_coreligionist);\n}\n\nvoid disappointment_vidry(beelzebub_rufflers unstacker_neptunism)\n{\n int random_data;\n char fill_buff[50000];\n char file_path[50][31];\n int filedes;\n int count = 0;\n int taint_num;\n int ss_i = 0;\n  char *orna_wherehence = 0;\n  ++global_variable;;\n  orna_wherehence = ((char *)unstacker_neptunism);\n    \n random_data = open(\"/dev/urandom\",0);\n    read(random_data,fill_buff,49999U);\n    close(random_data);\n    fill_buff[49999] = '\\0';\n    taint_num = atoi(orna_wherehence);\n    if (taint_num < 0) {\n        taint_num = 0;\n    }\n    \n    for (ss_i = 0; ss_i < taint_num; ++ss_i) {\n        ++count;\n        strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\n        filedes = mkstemp(file_path[ss_i % 50]);\n        write(filedes,fill_buff,sizeof(fill_buff));\n        close(filedes);\n    }\n    \n    \n    for (ss_i = 0; ss_i < 50; ++ss_i){\n  \n        if (count == ss_i) {\n            break;\n        }\n  \n        unlink(file_path[ss_i]);\n    }\n    \n    \n    \n;\n  if (unstacker_neptunism != 0) \n    free(((char *)unstacker_neptunism));\nclose_printf_context();\n}", "answer": "YES", "cwe": "459", "idx": "151883"}
{"code": "static int cxusb_mygica_d689_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\n\t\n\tif (usb_set_interface(d->udev, 0, 0) < 0)\n\t\terr(\"set interface failed\");\n\n\t\n\tusb_clear_halt(d->udev,\n\t\tusb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\n\tusb_clear_halt(d->udev,\n\t\tusb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));\n\n\n\t\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 0) < 0) {\n\t\terr(\"clear tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\tif (cxusb_d680_dmb_gpio_tuner(d, 0x07, 1) < 0) {\n\t\terr(\"set tuner gpio failed\");\n\t\treturn -EIO;\n\t}\n\tmsleep(100);\n\n\t\n\tadap->fe_adap[0].fe = dvb_attach(atbm8830_attach, &mygica_d689_atbm8830_cfg,\n\t\t&d->i2c_adap);\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\treturn 0;\n}", "answer": "NO", "cwe": "119", "idx": "66741"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\nnamespace _Process_Control__w32_char_console_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_console_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62014"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <process.h>\n\nstatic wchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45Data;\nstatic wchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45G2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45Data;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45G2BData;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45G2BData = data;\n    nG2BSink();\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246719"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic int staticFive = 5;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_console_07()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_07()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_07();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_07();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123141"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <sys/stat.h> \nint marlpit_tasking = 0;\nint global_variable;\nvoid handle_taint(char *scourfishes_faki);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid shovelweed_decciare(char **chaffin_beplaster);\nstruct data {\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex_0, mutex_1;\npthread_t t0, t1;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *replace (void *data) {\n    struct data *cusData = (struct data*)data;\n    int *qsort_arr;\n    int i = 0;\n    \n    \n    printf(\"replace: entering function\\n\");\n    \n    qsort_arr = malloc(sizeof(int)*cusData->qsize);\n    if (qsort_arr != NULL) {\n        for (i = 0; i < cusData->qsize; i++) {\n            qsort_arr[i] = cusData->qsize - i;\n        }\n        qsort(qsort_arr, cusData->qsize, sizeof(int), &comp);\n        free (qsort_arr);\n        qsort_arr = NULL;\n    }\n    readFile(cusData->file1);\n    printf(\"replace: Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0);\n    printf(\"replace: Grabbed lock 0\\n\");\n    printf(\"replace: Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1); \n    printf(\"replace: Grabbed lock 1\\n\");\n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] == '_') {\n            cusData->data[i] = '-';\n        }\n        i++;\n    }\n    printf(\"replace: Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    printf(\"replace: Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    \n    return NULL;\n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i = 0;\n    \n    printf(\"toCap:   Entering function\\n\");\n    printf(\"toCap:   Attempting to grab lock 1\\n\");\n    pthread_mutex_lock(&mutex_1);\n    printf(\"toCap:   Grabbed lock 1\\n\");\n    readFile(cusData->file2);\n    \n    \n    printf(\"toCap:   Attempting to grab lock 0\\n\");\n    pthread_mutex_lock(&mutex_0); \n    printf(\"toCap:   Grabbed lock 0\\n\");\n    \n    i = 0;\n    while(cusData->data[i] != '\\0') {\n        if (cusData->data[i] > 'a' && cusData->data[i] < 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    printf(\"toCap:   Releasing lock 0\\n\");\n    pthread_mutex_unlock(&mutex_0);\n    printf(\"toCap:   Releasing lock 1\\n\");\n    pthread_mutex_unlock(&mutex_1);\n    return NULL;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&marlpit_tasking,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n#define AMBROSE_ANAPHRODISIAC(x) shovelweed_decciare((char **) x)\n\nvoid handle_taint(char *scourfishes_faki)\n{\n  char **ugh_angelicness = 0;\n  ++global_variable;;\n  if (scourfishes_faki != 0) {;\n    ugh_angelicness = &scourfishes_faki;\n\tAMBROSE_ANAPHRODISIAC(ugh_angelicness);\n  }\n}\n\nvoid shovelweed_decciare(char **chaffin_beplaster)\n{\n    int hasUnderscores = 0;\n    int i = 0;\n    struct data* cusData;\n  char *cuddy_yemschik = 0;\n  ++global_variable;;\n  cuddy_yemschik = ((char *)( *chaffin_beplaster));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(cuddy_yemschik) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(cuddy_yemschik) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(cuddy_yemschik) + 1));\n        if (cusData->data) {\n            if ((sscanf(cuddy_yemschik, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(cusData->file1) != 0) &&\n                (strlen(cusData->file2) != 0))\n            {\n                \n                \n                \n                \n                pthread_mutex_init(&mutex_0, NULL);\n                pthread_mutex_init(&mutex_1, NULL);\n                while(cusData->data[i] != '\\0') { \n                    if (cusData->data[i++] == '_') { \n                        hasUnderscores = 1;\n                    }\n                }\n                \n                if (pthread_create(&t0, NULL, toCap, cusData) != 0) {\n                    printf(\"Thread 0 failed to spawn.\");\n                }\n                if (hasUnderscores == 1) {\n                    \n                    if (pthread_create(&t1, NULL, replace, cusData) != 0) {\n                        printf(\"Thread 1 failed to spawn.\");\n                    }\n                }\n                pthread_join(t0, NULL);\n                if (hasUnderscores == 1) {\n                    pthread_join(t1, NULL);\n                }\n                \n                pthread_mutex_destroy(&mutex_0);\n                pthread_mutex_destroy(&mutex_1);\n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\n  if ( *chaffin_beplaster != 0) \n    free(((char *)( *chaffin_beplaster)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "833", "idx": "150588"}
{"code": "R_API int extract_type_value(const char *arg_str, char **output) {\n\tut8 found_one = 0, array_cnt = 0;\n\tut32 len = 0, consumed = 0;\n\tchar *str = NULL;\n\tif (!arg_str || !output) {\n\t\treturn 0;\n\t}\n\tif (output && *output && *output != NULL) {\n\t\tfree (*output);\n\t\t*output = NULL;\n\t}\n\twhile (arg_str && *arg_str && !found_one) {\n\t\tlen = 0;\n\t\tswitch (*arg_str) {\n\t\tcase 'V':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"void\", array_cnt);\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"long\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"int\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"double\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"float\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"byte\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"char\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"boolean\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"short\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase '[': len = 1; array_cnt++; break;\n\t\tcase 'L':\n\t\t\tlen = r_bin_java_extract_reference_name (arg_str, &str, array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase '(': len = 1; str = strdup (\"(\"); break;\n\t\tcase ')': len = 1; str = strdup (\")\"); break;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (len < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tconsumed += len;\n\t\targ_str += len;\n\t\tif (str) {\n\t\t\t*output = str;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn consumed;\n}", "answer": "NO", "cwe": "125", "idx": "79663"}
{"code": "static int opensc_get_conf_entry(const char *config)\n{\n\tscconf_block *conf_block = NULL, **blocks;\n\tchar *buffer = NULL;\n\tchar *section = NULL;\n\tchar *name = NULL;\n\tchar *key = NULL;\n\tint r = 0;\n\n\tif (ctx->conf == NULL) {\n\t\tr = ENOENT;\n\t\tgoto cleanup;\n\t}\n\n\tif ((buffer = strdup(config)) == NULL) {\n\t\tr = ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tsection = buffer;\n\tname = strchr(section+1, ':');\n\tkey = name == NULL ? NULL : strchr(name+1, ':');\n\tif (key == NULL) {\n\t\tr = EINVAL;\n\t\tgoto cleanup;\n\t}\n\t*name = '\\0';\n\tname++;\n\t*key = '\\0';\n\tkey++;\n\n\tblocks = scconf_find_blocks(ctx->conf, NULL, section, name);\n\tif (blocks && blocks[0])\n\t\tconf_block = blocks[0];\n\tfree(blocks);\n\tif (conf_block != NULL) {\n\t\tconst char *value = scconf_get_str(conf_block, key, NULL);\n\n\t\tif (value != NULL) {\n\t\t\tprintf (\"%s\\n\", value);\n\t\t}\n\t}\n\n\tr = 0;\n\ncleanup:\n\n\tif (buffer != NULL)\n\t\tfree(buffer);\n\n\treturn r;\n}", "answer": "NO", "cwe": "125", "idx": "78735"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_file_open_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_open_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91652"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint debbra_castigative = 0;\nint global_variable;\n\nunion cavicorn_tuggingly \n{\n  char *unworminess_simplifiedly;\n  double export_circumambiency;\n  char *feltlike_berycoidei;\n  char comus_coquetting;\n  int baulking_reach;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunion cavicorn_tuggingly uncivilly_charwoman(union cavicorn_tuggingly unpark_overconcerning);\nvoid methide_babbitt(union cavicorn_tuggingly largess_genealogically);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n#define ALESIA_APPENZELL(x) methide_babbitt((union cavicorn_tuggingly) x)\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  union cavicorn_tuggingly zafree_repeddle = {0};\n  union cavicorn_tuggingly diatribist_sumer;\n  char *crowkeeper_alleghenies;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&debbra_castigative,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&crowkeeper_alleghenies,\"ACROPOLIS_MASHY\");\n      if (crowkeeper_alleghenies != 0) {;\n        diatribist_sumer . unworminess_simplifiedly = crowkeeper_alleghenies;\n        zafree_repeddle = uncivilly_charwoman(diatribist_sumer);\n\tALESIA_APPENZELL(zafree_repeddle);\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nunion cavicorn_tuggingly uncivilly_charwoman(union cavicorn_tuggingly unpark_overconcerning)\n{\n  ++global_variable;\n  return unpark_overconcerning;\n}\n\nvoid methide_babbitt(union cavicorn_tuggingly largess_genealogically)\n{\n int ss_j;\n int ss_i;\n size_t taint_size;\n char **malloced_buff = 0;\n int trace_flag = 0;\n  char *demidevil_sennets = 0;\n  ++global_variable;;\n  demidevil_sennets = ((char *)largess_genealogically . unworminess_simplifiedly);\n    \n    taint_size = strlen(demidevil_sennets);\n    \n    if (taint_size >= 1600) {\n        taint_size = 1599U;\n    }\n    malloced_buff = malloc(taint_size * sizeof(char *));\n    \n    \n    if (malloced_buff != 0) {\n        \n        \n        for (ss_i = 0; ss_i < taint_size; ++ss_i) {\n            malloced_buff[ss_i] = malloc(taint_size * taint_size * sizeof(char ));\n            \n            \n            if (malloced_buff[ss_i] == 0 && errno == 12) {\n    printf(\"Malloc error due to ulimit\\n\");\n    if (trace_flag == 0) {\n        \n        \n                    trace_flag = 1;\n                }\n            }\n   if (malloced_buff[ss_i] != 0) {\n    for (ss_j = 0; ss_j < taint_size; ++ss_j) {\n     memcpy(malloced_buff[ss_i] + ss_j * taint_size,demidevil_sennets,taint_size);\n    }\n   }\n   \n   \n   if (taint_size % 2 == 0) {\n    if (malloced_buff[ss_i] != 0) {\n     free(malloced_buff[ss_i]);\n           \n    }\n   }\n  }\n        free(malloced_buff);\n        \n    }\n;\n  if (largess_genealogically . unworminess_simplifiedly != 0) \n    free(((char *)largess_genealogically . unworminess_simplifiedly));\nclose_printf_context();\n}", "answer": "YES", "cwe": "401", "idx": "151998"}
{"code": "av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}", "answer": "NO", "cwe": "0", "idx": "f61bece684d9685b07895508e6c1c733b5564ccf"}
{"code": "static void rtl8139_write_buffer(RTL8139State *s, const void *buf, int size)\n\n{\n\n    if (s->RxBufAddr + size > s->RxBufferSize)\n\n    {\n\n        int wrapped = MOD2(s->RxBufAddr + size, s->RxBufferSize);\n\n\n\n        \n\n        if (wrapped && s->RxBufferSize < 65536 && !rtl8139_RxWrap(s))\n\n        {\n\n            DEBUG_PRINT((\">>> RTL8139: rx packet wrapped in buffer at %d\\n\", size-wrapped));\n\n\n\n            if (size > wrapped)\n\n            {\n\n                cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,\n\n                                           buf, size-wrapped );\n\n            }\n\n\n\n            \n\n            s->RxBufAddr = 0;\n\n\n\n            cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,\n\n                                       buf + (size-wrapped), wrapped );\n\n\n\n            s->RxBufAddr = wrapped;\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    \n\n    cpu_physical_memory_write( s->RxBuf + s->RxBufAddr, buf, size );\n\n\n\n    s->RxBufAddr += size;\n\n}", "answer": "NO", "cwe": "0", "idx": "ccf1d14a1e37abe1f0da162c00a8941963b47a4c"}
{"code": "static int h264_extradata_to_annexb(AVCodecContext *avctx, const int padding)\n\n{\n\n    uint16_t unit_size;\n\n    uint64_t total_size                 = 0;\n\n    uint8_t *out                        = NULL, unit_nb, sps_done = 0,\n\n             sps_seen                   = 0, pps_seen = 0;\n\n    const uint8_t *extradata            = avctx->extradata + 4;\n\n    static const uint8_t nalu_header[4] = { 0, 0, 0, 1 };\n\n    int length_size = (*extradata++ & 0x3) + 1; \n\n\n\n    \n\n    unit_nb = *extradata++ & 0x1f; \n\n    if (!unit_nb) {\n\n        goto pps;\n\n    } else {\n\n        sps_seen = 1;\n\n    }\n\n\n\n    while (unit_nb--) {\n\n        void *tmp;\n\n\n\n        unit_size   = AV_RB16(extradata);\n\n        total_size += unit_size + 4;\n\n        if (total_size > INT_MAX - padding ||\n\n            extradata + 2 + unit_size > avctx->extradata +\n\n            avctx->extradata_size) {\n\n            av_free(out);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        tmp = av_realloc(out, total_size + padding);\n\n        if (!tmp) {\n\n            av_free(out);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        out = tmp;\n\n        memcpy(out + total_size - unit_size - 4, nalu_header, 4);\n\n        memcpy(out + total_size - unit_size, extradata + 2, unit_size);\n\n        extradata += 2 + unit_size;\n\npps:\n\n        if (!unit_nb && !sps_done++) {\n\n            unit_nb = *extradata++; \n\n            if (unit_nb)\n\n                pps_seen = 1;\n\n        }\n\n    }\n\n\n\n    if (out)\n\n        memset(out + total_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    if (!sps_seen)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Warning: SPS NALU missing or invalid. \"\n\n               \"The resulting stream may not play.\\n\");\n\n\n\n    if (!pps_seen)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Warning: PPS NALU missing or invalid. \"\n\n               \"The resulting stream may not play.\\n\");\n\n\n\n    av_free(avctx->extradata);\n\n    avctx->extradata      = out;\n\n    avctx->extradata_size = total_size;\n\n\n\n    return length_size;\n\n}", "answer": "NO", "cwe": "0", "idx": "53c853e0491691d4ee6f33e6348da2ffc7d345d8"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * dataArray[]);\n\nvoid m()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89618"}
{"code": "static sPAPRPHBState *find_phb(sPAPREnvironment *spapr, uint64_t buid)\n\n{\n\n    sPAPRPHBState *sphb;\n\n\n\n    QLIST_FOREACH(sphb, &spapr->phbs, list) {\n\n        if (sphb->buid != buid) {\n\n            continue;\n\n        }\n\n        return sphb;\n\n    }\n\n\n\n    return NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "46c5874e9cd752ed8ded31af03472edd8fc3efc1"}
{"code": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t v32, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t val, oldval, newval;\n\n\n\n    if (addr & 4) {\n\n        val = v32 << 32 | s->latch_tmp;\n\n        addr ^= 4;\n\n    } else {\n\n        s->latch_tmp = v32;\n\n        return;\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        \n\n        \n\n        break;\n\n\n\n    case 0x0040:\n\n        \n\n        \n\n        break;\n\n\n\n    case 0x0080:\n\n        \n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     \n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        \n\n        } else {\n\n            newval |= val & 0x00f00000;    \n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   \n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     \n\n\n\n        newval &= ~0xf0000000000ull;       \n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        \n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    \n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    \n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        \n\n        break;\n\n\n\n    case 0x0100: \n\n    case 0x0140: \n\n    case 0x0180: \n\n    case 0x01c0: \n\n        \n\n        \n\n        break;\n\n\n\n    case 0x0200: \n\n        \n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: \n\n        \n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: \n\n    case 0x02c0: \n\n    case 0x0300: \n\n        break;\n\n\n\n    case 0x0340:\n\n        \n\n        break;\n\n\n\n    case 0x0380: \n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: \n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: \n\n    case 0x0440: \n\n    case 0x0480: \n\n    case 0x04c0: \n\n        \n\n        break;\n\n\n\n    case 0x0580:\n\n        \n\n        \n\n        break;\n\n    case 0x05c0:\n\n        \n\n        break;\n\n\n\n    case 0x0600:\n\n        \n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        \n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: \n\n    case 0x06c0: \n\n        break;\n\n\n\n    case 0x0700: \n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: \n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        \n\n        break;\n\n    \n\n    case 0x0c00: \n\n    case 0x0c40: \n\n    case 0x0c80: \n\n    case 0x0cc0: \n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "678421650dc166cd6cb35bb2bc0baf1b481b40ca"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <setjmp.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint chitosan_clubbable = 0;\nint global_variable;\n\nunion confectioneries_oromo \n{\n  char *unmetallic_camelot;\n  double admissible_tossy;\n  char *jaculatorial_wholesomely;\n  char flensing_hesitatively;\n  int oxcarts_oviducal;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid unindigenous_hispaniola(int overlard_macroergate,... );\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  union confectioneries_oromo hydropterideae_antiroyal;\n  int unwealsomeness_leechwort = 596;\n  char *sorefoot_rollin;;\n  if (__sync_bool_compare_and_swap(&chitosan_clubbable,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&sorefoot_rollin,\"2380\",unwealsomeness_leechwort);\n      if (sorefoot_rollin != 0) {;\n        hydropterideae_antiroyal . unmetallic_camelot = sorefoot_rollin;\n        unindigenous_hispaniola(1,hydropterideae_antiroyal);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid unindigenous_hispaniola(int overlard_macroergate,... )\n{\n    int ss_i = 0;\n    char* heap_buff_64;\n    int buff_size;\n  char *archai_turbith = 0;\n  jmp_buf limnoriidae_wanderoo;\n  int indestrucible_outbaking;\n  union confectioneries_oromo omnipotently_ugroid = {0};\n  va_list crispation_nontidal;\n  ++global_variable;;\n  if (overlard_macroergate > 0) {\n    __builtin_va_start(crispation_nontidal,overlard_macroergate);\n    omnipotently_ugroid = (va_arg(crispation_nontidal,union confectioneries_oromo ));\n    __builtin_va_end(crispation_nontidal);\n  }\n  indestrucible_outbaking = setjmp(limnoriidae_wanderoo);\n  if (indestrucible_outbaking == 0) {\n    longjmp(limnoriidae_wanderoo,1);\n  }\n  archai_turbith = ((char *)omnipotently_ugroid . unmetallic_camelot);\n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    \n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64,'A',63);\n        heap_buff_64[63] = '\\0';\n        \n        buff_size = ((int )(strlen(archai_turbith)));\n        strncpy(heap_buff_64, archai_turbith, 64);\n        \n        \n        \n        for (; ss_i < buff_size; ++ss_i){\n            \n            \n            printf(\"%02x\",heap_buff_64[ss_i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( heap_buff_64);\n        \n        \n    }\n;\n  if (omnipotently_ugroid . unmetallic_camelot != 0) \n    free(((char *)omnipotently_ugroid . unmetallic_camelot));\nclose_printf_context();\n}", "answer": "YES", "cwe": "126", "idx": "152955"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89588"}
{"code": "GF_Err trak_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackBox *p;\n\n\tp = (GF_TrackBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (p->Header) {\n\t\tgf_isom_box_dump(p->Header, trace);\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!--INVALID FILE: Missing Track Header-->\\n\");\n\t}\n\tif (p->References) gf_isom_box_dump(p->References, trace);\n\tif (p->meta) gf_isom_box_dump(p->meta, trace);\n\tif (p->editBox) gf_isom_box_dump(p->editBox, trace);\n\tif (p->Media) gf_isom_box_dump(p->Media, trace);\n\tif (p->groups) gf_isom_box_dump(p->groups, trace);\n\tif (p->udta) gf_isom_box_dump(p->udta, trace);\n\tgf_isom_box_dump_done(\"TrackBox\", a, trace);\n\treturn GF_OK;\n}", "answer": "NO", "cwe": "125", "idx": "80878"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint interlink_matin = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *drawnet_transactioneer = 0;\n  char **praepubis_dorcy = 0;\n  int *somnambulists_dezhnev = 0;\n  int diclinous_opinionatively;\n  char **mariposa_homeoplastic[10] = {0};\n  char *kodakry_flavius[50] = {0};\n  int mashgiach_unappliqued = 5;\n  char *wagnerite_jaggier;;\n  if (__sync_bool_compare_and_swap(&interlink_matin,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&wagnerite_jaggier,\"3012\",mashgiach_unappliqued);\n      if (wagnerite_jaggier != 0) {;\n        kodakry_flavius[47] = wagnerite_jaggier;\n        diclinous_opinionatively = 5;\n        somnambulists_dezhnev = &diclinous_opinionatively;\n        mariposa_homeoplastic[ *somnambulists_dezhnev] = kodakry_flavius;\n        praepubis_dorcy = mariposa_homeoplastic[ *somnambulists_dezhnev];\n        if (praepubis_dorcy[47] != 0) {\n          goto overweb_plicae;\n        }\n        ++global_variable;\n        overweb_plicae:;\n        drawnet_transactioneer = ((char *)praepubis_dorcy[47]);\n    \n    if (strlen(drawnet_transactioneer) > 0 &&\n            drawnet_transactioneer[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(drawnet_transactioneer,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n        if (praepubis_dorcy[47] != 0) \n          free(((char *)praepubis_dorcy[47]));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "YES", "cwe": "774", "idx": "151862"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint ordinariness_oxysomes = 0;\n\nunion unrealities_jewelhouse \n{\n  char *thalamophora_carenton;\n  double dhaka_neukam;\n  char *pratincole_countrieman;\n  char preimitated_keratomycosis;\n  int feminine_hup;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *folliculous_vamped = 0;\n  int rifton_cheerio;\n  int settimo_bassness;\n  int blastemata_gda;\n  union unrealities_jewelhouse *hld_overproudly = {0};\n  union unrealities_jewelhouse *nematognath_gracy = {0};\n  union unrealities_jewelhouse attical_beswelter;\n  int desterilize_onychium = 63;\n  char *prebroadcasting_auxiliation;;\n  if (__sync_bool_compare_and_swap(&ordinariness_oxysomes,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&prebroadcasting_auxiliation,\"1313\",desterilize_onychium);\n      if (prebroadcasting_auxiliation != 0) {;\n        attical_beswelter . thalamophora_carenton = prebroadcasting_auxiliation;\n        blastemata_gda = 1;\n        hld_overproudly = &attical_beswelter;\n        nematognath_gracy = ((union unrealities_jewelhouse *)(((unsigned long )hld_overproudly) * blastemata_gda * blastemata_gda)) + 5;\n        settimo_bassness = 5;\n        while(1 == 1){\n          settimo_bassness = settimo_bassness * 2;\n          settimo_bassness = settimo_bassness + 2;\n          if (settimo_bassness > 1000) {\n            break; \n          }\n        }\n        rifton_cheerio = settimo_bassness;\n        folliculous_vamped = ((char *)( *(nematognath_gracy - 5)) . thalamophora_carenton);\n      \n      while(isalnum(folliculous_vamped[size]) && size < strlen(folliculous_vamped)){\n        ++size;\n      }\n      \n\n      if (size != strlen(folliculous_vamped)) {\n        folliculous_vamped = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,folliculous_vamped);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\n        if (( *(nematognath_gracy - 5)) . thalamophora_carenton != 0) \n          free(((char *)( *(nematognath_gracy - 5)) . thalamophora_carenton));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "YES", "cwe": "476", "idx": "149404"}
{"code": "av_cold int ff_rate_control_init(MpegEncContext *s)\n\n{\n\n    RateControlContext *rcc = &s->rc_context;\n\n    int i, res;\n\n    static const char * const const_names[] = {\n\n        \"PI\",\n\n        \"E\",\n\n        \"iTex\",\n\n        \"pTex\",\n\n        \"tex\",\n\n        \"mv\",\n\n        \"fCode\",\n\n        \"iCount\",\n\n        \"mcVar\",\n\n        \"var\",\n\n        \"isI\",\n\n        \"isP\",\n\n        \"isB\",\n\n        \"avgQP\",\n\n        \"qComp\",\n\n#if 0\n\n        \"lastIQP\",\n\n        \"lastPQP\",\n\n        \"lastBQP\",\n\n        \"nextNonBQP\",\n\n#endif\n\n        \"avgIITex\",\n\n        \"avgPITex\",\n\n        \"avgPPTex\",\n\n        \"avgBPTex\",\n\n        \"avgTex\",\n\n        NULL\n\n    };\n\n    static double (* const func1[])(void *, double) = {\n\n        (void *)bits2qp,\n\n        (void *)qp2bits,\n\n        NULL\n\n    };\n\n    static const char * const func1_names[] = {\n\n        \"bits2qp\",\n\n        \"qp2bits\",\n\n        NULL\n\n    };\n\n    emms_c();\n\n\n\n    res = av_expr_parse(&rcc->rc_eq_eval,\n\n                        s->rc_eq ? s->rc_eq : \"tex^qComp\",\n\n                        const_names, func1_names, func1,\n\n                        NULL, NULL, 0, s->avctx);\n\n    if (res < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error parsing rc_eq \\\"%s\\\"\\n\", s->rc_eq);\n\n        return res;\n\n    }\n\n\n\n    for (i = 0; i < 5; i++) {\n\n        rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0;\n\n        rcc->pred[i].count = 1.0;\n\n        rcc->pred[i].decay = 0.4;\n\n\n\n        rcc->i_cplx_sum [i] =\n\n        rcc->p_cplx_sum [i] =\n\n        rcc->mv_bits_sum[i] =\n\n        rcc->qscale_sum [i] =\n\n        rcc->frame_count[i] = 1; \n\n\n\n        rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5;\n\n    }\n\n    rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy;\n\n\n\n    if (s->avctx->flags & CODEC_FLAG_PASS2) {\n\n        int i;\n\n        char *p;\n\n\n\n        \n\n        p = s->avctx->stats_in;\n\n        for (i = -1; p; i++)\n\n            p = strchr(p + 1, ';');\n\n        i += s->max_b_frames;\n\n        if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry))\n\n            return -1;\n\n        rcc->entry       = av_mallocz(i * sizeof(RateControlEntry));\n\n        rcc->num_entries = i;\n\n\n\n        \n\n        for (i = 0; i < rcc->num_entries; i++) {\n\n            RateControlEntry *rce = &rcc->entry[i];\n\n\n\n            rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;\n\n            rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;\n\n            rce->misc_bits  = s->mb_num + 10;\n\n            rce->mb_var_sum = s->mb_num * 100;\n\n        }\n\n\n\n        \n\n        p = s->avctx->stats_in;\n\n        for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n\n            RateControlEntry *rce;\n\n            int picture_number;\n\n            int e;\n\n            char *next;\n\n\n\n            next = strchr(p, ';');\n\n            if (next) {\n\n                (*next) = 0; \n\n                next++;\n\n            }\n\n            e = sscanf(p, \" in:%d \", &picture_number);\n\n\n\n            assert(picture_number >= 0);\n\n            assert(picture_number < rcc->num_entries);\n\n            rce = &rcc->entry[picture_number];\n\n\n\n            e += sscanf(p, \" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d\",\n\n                        &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits,\n\n                        &rce->mv_bits, &rce->misc_bits,\n\n                        &rce->f_code, &rce->b_code,\n\n                        &rce->mc_mb_var_sum, &rce->mb_var_sum,\n\n                        &rce->i_count, &rce->skip_count, &rce->header_bits);\n\n            if (e != 14) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"statistics are damaged at line %d, parser out=%d\\n\",\n\n                       i, e);\n\n                return -1;\n\n            }\n\n\n\n            p = next;\n\n        }\n\n\n\n        if (init_pass2(s) < 0)\n\n            return -1;\n\n\n\n        \n\n        if ((s->avctx->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {\n\n#if CONFIG_LIBXVID\n\n            return ff_xvid_rate_control_init(s);\n\n#else\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Xvid ratecontrol requires libavcodec compiled with Xvid support.\\n\");\n\n            return -1;\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (!(s->avctx->flags & CODEC_FLAG_PASS2)) {\n\n        rcc->short_term_qsum   = 0.001;\n\n        rcc->short_term_qcount = 0.001;\n\n\n\n        rcc->pass1_rc_eq_output_sum = 0.001;\n\n        rcc->pass1_wanted_bits      = 0.001;\n\n\n\n        if (s->avctx->qblur > 1.0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"qblur too large\\n\");\n\n            return -1;\n\n        }\n\n        \n\n        if (s->rc_initial_cplx) {\n\n            for (i = 0; i < 60 * 30; i++) {\n\n                double bits = s->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num;\n\n                RateControlEntry rce;\n\n\n\n                if (i % ((s->gop_size + 3) / 4) == 0)\n\n                    rce.pict_type = AV_PICTURE_TYPE_I;\n\n                else if (i % (s->max_b_frames + 1))\n\n                    rce.pict_type = AV_PICTURE_TYPE_B;\n\n                else\n\n                    rce.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n                rce.new_pict_type = rce.pict_type;\n\n                rce.mc_mb_var_sum = bits * s->mb_num / 100000;\n\n                rce.mb_var_sum    = s->mb_num;\n\n\n\n                rce.qscale    = FF_QP2LAMBDA * 2;\n\n                rce.f_code    = 2;\n\n                rce.b_code    = 1;\n\n                rce.misc_bits = 1;\n\n\n\n                if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n                    rce.i_count    = s->mb_num;\n\n                    rce.i_tex_bits = bits;\n\n                    rce.p_tex_bits = 0;\n\n                    rce.mv_bits    = 0;\n\n                } else {\n\n                    rce.i_count    = 0; \n\n                    rce.i_tex_bits = 0;\n\n                    rce.p_tex_bits = bits * 0.9;\n\n                    rce.mv_bits    = bits * 0.1;\n\n                }\n\n                rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;\n\n                rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;\n\n                rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;\n\n                rcc->frame_count[rce.pict_type]++;\n\n\n\n                get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);\n\n\n\n                \n\n                rcc->pass1_wanted_bits += s->bit_rate / (1 / av_q2d(s->avctx->time_base));\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "42df71d9bbb1a5b4bce0bb34417692565c72d390"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint casseroled_palliest = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hyllus_unstrictly(char **devocalisation_depew);\nvoid carpos_radiale(char **desired_periodontics);\nint toupper(int c) {\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    char buffer[64];\n    char * buff_pointer;\n};\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  char *unartistlike_residencer[11] = {0};\n  int pyrgocephalic_falafel = 91;\n  char *ria_spik;;\n  if (__sync_bool_compare_and_swap(&casseroled_palliest,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&ria_spik,\"8625\",pyrgocephalic_falafel);\n      if (ria_spik != 0) {;\n        unartistlike_residencer[3] = ria_spik;\n        hyllus_unstrictly(unartistlike_residencer);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid hyllus_unstrictly(char **devocalisation_depew)\n{\n  ++global_variable;;\n  carpos_radiale(devocalisation_depew);\n}\n\nvoid carpos_radiale(char **desired_periodontics)\n{\n    int oc_i = 0;\n    int i;\n    int opt_var;\n    char source[1024];\n    struct struct data;\n  char *rutins_essenianism = 0;\n  ++global_variable;;\n  rutins_essenianism = ((char *)desired_periodontics[3]);\n    \n    for (i = 0; i < 1024; i++) {\n        source[i] = 0;\n    }\n    for (i = 0; i < 64; i++) {\n        data.buffer[i] = 65;\n    }\n    data.buffer[64 - 1] = '\\0';\n    data.buff_pointer = data.buffer;\n    strncpy(source, rutins_essenianism, sizeof(source));\n    source[1023] = '\\0';\n    if (strlen(source) + 1 <= 64) {\n        \n        \n        \n        \n        \n        \n        strncpy(data.buffer, source, sizeof(source));\n        \n        \n    }\n    opt_var = strlen( data.buff_pointer);\n    for (; oc_i < opt_var; ++oc_i) {\n        data.buffer[oc_i] =\n            toupper(data.buffer[oc_i]);\n    }\n    printf(\"%s\\n\", data.buffer);\n    \n;\n  if (desired_periodontics[3] != 0) \n    free(((char *)desired_periodontics[3]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "806", "idx": "153609"}
{"code": "static int qemu_rdma_registration_stop(QEMUFile *f, void *opaque,\n\n                                       uint64_t flags)\n\n{\n\n    Error *local_err = NULL, **errp = &local_err;\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMAControlHeader head = { .len = 0, .repeat = 1 };\n\n    int ret = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    qemu_fflush(f);\n\n    ret = qemu_rdma_drain_cq(f, rdma);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    if (flags == RAM_CONTROL_SETUP) {\n\n        RDMAControlHeader resp = {.type = RDMA_CONTROL_RAM_BLOCKS_RESULT };\n\n        RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n        int reg_result_idx, i, j, nb_remote_blocks;\n\n\n\n        head.type = RDMA_CONTROL_RAM_BLOCKS_REQUEST;\n\n        DPRINTF(\"Sending registration setup for ram blocks...\\n\");\n\n\n\n        \n\n        ret = qemu_rdma_exchange_send(rdma, &head, NULL, &resp,\n\n                    &reg_result_idx, rdma->pin_all ?\n\n                    qemu_rdma_reg_whole_ram_blocks : NULL);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"receiving remote info!\");\n\n            return ret;\n\n        }\n\n\n\n        qemu_rdma_move_header(rdma, reg_result_idx, &resp);\n\n        memcpy(rdma->block,\n\n            rdma->wr_data[reg_result_idx].control_curr, resp.len);\n\n\n\n        nb_remote_blocks = resp.len / sizeof(RDMARemoteBlock);\n\n\n\n        \n\n\n\n        if (local->nb_blocks != nb_remote_blocks) {\n\n            ERROR(errp, \"ram blocks mismatch #1! \"\n\n                        \"Your QEMU command line parameters are probably \"\n\n                        \"not identical on both the source and destination.\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        for (i = 0; i < nb_remote_blocks; i++) {\n\n            network_to_remote_block(&rdma->block[i]);\n\n\n\n            \n\n            for (j = 0; j < local->nb_blocks; j++) {\n\n                if (rdma->block[i].offset != local->block[j].offset) {\n\n                    continue;\n\n                }\n\n\n\n                if (rdma->block[i].length != local->block[j].length) {\n\n                    ERROR(errp, \"ram blocks mismatch #2! \"\n\n                        \"Your QEMU command line parameters are probably \"\n\n                        \"not identical on both the source and destination.\");\n\n                    return -EINVAL;\n\n                }\n\n                local->block[j].remote_host_addr =\n\n                        rdma->block[i].remote_host_addr;\n\n                local->block[j].remote_rkey = rdma->block[i].remote_rkey;\n\n                break;\n\n            }\n\n\n\n            if (j >= local->nb_blocks) {\n\n                ERROR(errp, \"ram blocks mismatch #3! \"\n\n                        \"Your QEMU command line parameters are probably \"\n\n                        \"not identical on both the source and destination.\");\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n\n\n    DDDPRINTF(\"Sending registration finish %\" PRIu64 \"...\\n\", flags);\n\n\n\n    head.type = RDMA_CONTROL_REGISTER_FINISHED;\n\n    ret = qemu_rdma_exchange_send(rdma, &head, NULL, NULL, NULL, NULL);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    return 0;\n\nerr:\n\n    rdma->error_state = ret;\n\n    return ret;\n\n}", "answer": "NO", "cwe": "0", "idx": "885e8f984ea846e79a39ddc4f066f4dd3d04b264"}
{"code": "ssh_packet_close(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\tu_int mode;\n\n\tif (!state->initialized)\n\t\treturn;\n\tstate->initialized = 0;\n\tif (state->connection_in == state->connection_out) {\n\t\tshutdown(state->connection_out, SHUT_RDWR);\n\t\tclose(state->connection_out);\n\t} else {\n\t\tclose(state->connection_in);\n\t\tclose(state->connection_out);\n\t}\n\tsshbuf_free(state->input);\n\tsshbuf_free(state->output);\n\tsshbuf_free(state->outgoing_packet);\n\tsshbuf_free(state->incoming_packet);\n\tfor (mode = 0; mode < MODE_MAX; mode++)\n\t\tkex_free_newkeys(state->newkeys[mode]);\n\tif (state->compression_buffer) {\n\t\tsshbuf_free(state->compression_buffer);\n\t\tif (state->compression_out_started) {\n\t\t\tz_streamp stream = &state->compression_out_stream;\n\t\t\tdebug(\"compress outgoing: \"\n\t\t\t    \"raw data %llu, compressed %llu, factor %.2f\",\n\t\t\t\t(unsigned long long)stream->total_in,\n\t\t\t\t(unsigned long long)stream->total_out,\n\t\t\t\tstream->total_in == 0 ? 0.0 :\n\t\t\t\t(double) stream->total_out / stream->total_in);\n\t\t\tif (state->compression_out_failures == 0)\n\t\t\t\tdeflateEnd(stream);\n\t\t}\n\t\tif (state->compression_in_started) {\n\t\t\tz_streamp stream = &state->compression_out_stream;\n\t\t\tdebug(\"compress incoming: \"\n\t\t\t    \"raw data %llu, compressed %llu, factor %.2f\",\n\t\t\t    (unsigned long long)stream->total_out,\n\t\t\t    (unsigned long long)stream->total_in,\n\t\t\t    stream->total_out == 0 ? 0.0 :\n\t\t\t    (double) stream->total_in / stream->total_out);\n\t\t\tif (state->compression_in_failures == 0)\n\t\t\t\tinflateEnd(stream);\n\t\t}\n\t}\n\tif ((r = cipher_cleanup(&state->send_context)) != 0)\n\t\terror(\"%s: cipher_cleanup failed: %s\", __func__, ssh_err(r));\n\tif ((r = cipher_cleanup(&state->receive_context)) != 0)\n\t\terror(\"%s: cipher_cleanup failed: %s\", __func__, ssh_err(r));\n\tif (ssh->remote_ipaddr) {\n\t\tfree(ssh->remote_ipaddr);\n\t\tssh->remote_ipaddr = NULL;\n\t}\n\tfree(ssh->state);\n\tssh->state = NULL;\n}", "answer": "NO", "cwe": "119", "idx": "12950"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_32\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            ofstream outputFile;\n            \n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscat(data, L\"file.txt\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            ofstream outputFile;\n            \n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_32; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91857"}
{"code": "static int __einj_error_trigger(u64 trigger_paddr, u32 type,\n\t\t\t\tu64 param1, u64 param2)\n{\n\tstruct acpi_einj_trigger *trigger_tab = NULL;\n\tstruct apei_exec_context trigger_ctx;\n\tstruct apei_resources trigger_resources;\n\tstruct acpi_whea_header *trigger_entry;\n\tstruct resource *r;\n\tu32 table_size;\n\tint rc = -EIO;\n\tstruct acpi_generic_address *trigger_param_region = NULL;\n\n\tr = request_mem_region(trigger_paddr, sizeof(*trigger_tab),\n\t\t\t       \"APEI EINJ Trigger Table\");\n\tif (!r) {\n\t\tpr_err(EINJ_PFX\n\t\"Can not request [mem %#010llx-%#010llx] for Trigger table\\n\",\n\t\t       (unsigned long long)trigger_paddr,\n\t\t       (unsigned long long)trigger_paddr +\n\t\t\t    sizeof(*trigger_tab) - 1);\n\t\tgoto out;\n\t}\n\ttrigger_tab = ioremap_cache(trigger_paddr, sizeof(*trigger_tab));\n\tif (!trigger_tab) {\n\t\tpr_err(EINJ_PFX \"Failed to map trigger table!\\n\");\n\t\tgoto out_rel_header;\n\t}\n\trc = einj_check_trigger_header(trigger_tab);\n\tif (rc) {\n\t\tpr_warning(FW_BUG EINJ_PFX\n\t\t\t   \"The trigger error action table is invalid\\n\");\n\t\tgoto out_rel_header;\n\t}\n\n\t\n\tif (!trigger_tab->entry_count)\n\t\tgoto out_rel_header;\n\n\trc = -EIO;\n\ttable_size = trigger_tab->table_size;\n\tr = request_mem_region(trigger_paddr + sizeof(*trigger_tab),\n\t\t\t       table_size - sizeof(*trigger_tab),\n\t\t\t       \"APEI EINJ Trigger Table\");\n\tif (!r) {\n\t\tpr_err(EINJ_PFX\n\"Can not request [mem %#010llx-%#010llx] for Trigger Table Entry\\n\",\n\t\t       (unsigned long long)trigger_paddr + sizeof(*trigger_tab),\n\t\t       (unsigned long long)trigger_paddr + table_size - 1);\n\t\tgoto out_rel_header;\n\t}\n\tiounmap(trigger_tab);\n\ttrigger_tab = ioremap_cache(trigger_paddr, table_size);\n\tif (!trigger_tab) {\n\t\tpr_err(EINJ_PFX \"Failed to map trigger table!\\n\");\n\t\tgoto out_rel_entry;\n\t}\n\ttrigger_entry = (struct acpi_whea_header *)\n\t\t((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\n\tapei_resources_init(&trigger_resources);\n\tapei_exec_ctx_init(&trigger_ctx, einj_ins_type,\n\t\t\t   ARRAY_SIZE(einj_ins_type),\n\t\t\t   trigger_entry, trigger_tab->entry_count);\n\trc = apei_exec_collect_resources(&trigger_ctx, &trigger_resources);\n\tif (rc)\n\t\tgoto out_fini;\n\trc = apei_resources_sub(&trigger_resources, &einj_resources);\n\tif (rc)\n\t\tgoto out_fini;\n\t\n\tif ((param_extension || acpi5) && (type & MEM_ERROR_MASK) && param2) {\n\t\tstruct apei_resources addr_resources;\n\t\tapei_resources_init(&addr_resources);\n\t\ttrigger_param_region = einj_get_trigger_parameter_region(\n\t\t\ttrigger_tab, param1, param2);\n\t\tif (trigger_param_region) {\n\t\t\trc = apei_resources_add(&addr_resources,\n\t\t\t\ttrigger_param_region->address,\n\t\t\t\ttrigger_param_region->bit_width/8, true);\n\t\t\tif (rc)\n\t\t\t\tgoto out_fini;\n\t\t\trc = apei_resources_sub(&trigger_resources,\n\t\t\t\t\t&addr_resources);\n\t\t}\n\t\tapei_resources_fini(&addr_resources);\n\t\tif (rc)\n\t\t\tgoto out_fini;\n\t}\n\trc = apei_resources_request(&trigger_resources, \"APEI EINJ Trigger\");\n\tif (rc)\n\t\tgoto out_fini;\n\trc = apei_exec_pre_map_gars(&trigger_ctx);\n\tif (rc)\n\t\tgoto out_release;\n\n\trc = apei_exec_run(&trigger_ctx, ACPI_EINJ_TRIGGER_ERROR);\n\n\tapei_exec_post_unmap_gars(&trigger_ctx);\nout_release:\n\tapei_resources_release(&trigger_resources);\nout_fini:\n\tapei_resources_fini(&trigger_resources);\nout_rel_entry:\n\trelease_mem_region(trigger_paddr + sizeof(*trigger_tab),\n\t\t\t   table_size - sizeof(*trigger_tab));\nout_rel_header:\n\trelease_mem_region(trigger_paddr, sizeof(*trigger_tab));\nout:\n\tif (trigger_tab)\n\t\tiounmap(trigger_tab);\n\n\treturn rc;\n}", "answer": "NO", "cwe": "74", "idx": "73875"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_05\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_05; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96790"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECV _execv\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_console_w32_execv_64bSink(void * dataVoidPtr);\n\nvoid _OS_Command_Injection__char_console_w32_execv_64()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    _OS_Command_Injection__char_console_w32_execv_64bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_console_w32_execv_64bG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_console_w32_execv_64bG2BSink(&data);\n}\n\nvoid _OS_Command_Injection__char_console_w32_execv_64()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32_execv_64();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32_execv_64();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244695"}
{"code": "static void verbose_stats_dump(int sig _U_)\n{\n\tif (infodelay == 0)\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n\talarm(1);\n}", "answer": "NO", "cwe": "120", "idx": "93205"}
{"code": "static int get_physical_address_data(CPUState *env,\n\n                                     target_phys_addr_t *physical, int *prot,\n\n                                     target_ulong address, int rw, int is_user)\n\n{\n\n    target_ulong mask;\n\n    unsigned int i;\n\n\n\n    if ((env->lsu & DMMU_E) == 0) { \n\n        *physical = address;\n\n        *prot = PAGE_READ | PAGE_WRITE;\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        switch ((env->dtlb_tte[i] >> 61) & 3) {\n\n        default:\n\n        case 0x0: \n\n            mask = 0xffffffffffffe000ULL;\n\n            break;\n\n        case 0x1: \n\n            mask = 0xffffffffffff0000ULL;\n\n            break;\n\n        case 0x2: \n\n            mask = 0xfffffffffff80000ULL;\n\n            break;\n\n        case 0x3: \n\n            mask = 0xffffffffffc00000ULL;\n\n            break;\n\n        }\n\n        \n\n        if (env->dmmuregs[1] == (env->dtlb_tag[i] & 0x1fff) &&\n\n            (address & mask) == (env->dtlb_tag[i] & mask) &&\n\n            (env->dtlb_tte[i] & 0x8000000000000000ULL)) {\n\n            \n\n            if (((env->dtlb_tte[i] & 0x4) && is_user) ||\n\n                (!(env->dtlb_tte[i] & 0x2) && (rw == 1))) {\n\n                if (env->dmmuregs[3]) \n\n                    env->dmmuregs[3] = 2; \n\n                env->dmmuregs[3] |= (is_user << 3) | ((rw == 1) << 2) | 1;\n\n                env->dmmuregs[4] = address; \n\n                env->exception_index = TT_DFAULT;\n\n#ifdef DEBUG_MMU\n\n                printf(\"DFAULT at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n                return 1;\n\n            }\n\n            *physical = ((env->dtlb_tte[i] & mask) | (address & ~mask)) &\n\n                        0x1ffffffe000ULL;\n\n            *prot = PAGE_READ;\n\n            if (env->dtlb_tte[i] & 0x2)\n\n                *prot |= PAGE_WRITE;\n\n            return 0;\n\n        }\n\n    }\n\n#ifdef DEBUG_MMU\n\n    printf(\"DMISS at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n    env->dmmuregs[6] = (address & ~0x1fffULL) | (env->dmmuregs[1] & 0x1fff);\n\n    env->exception_index = TT_DMISS;\n\n    return 1;\n\n}", "answer": "NO", "cwe": "0", "idx": "e8807b14cc8c12c0e14c08fa396d9da043b48209"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_09()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81986"}
{"code": "enum nl80211_auth_type brcmf_war_auth_type(struct brcmf_if *ifp,\n\t\t\t\t\t   enum nl80211_auth_type type)\n{\n\tif (type == NL80211_AUTHTYPE_AUTOMATIC &&\n\t    brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_AUTO_AUTH)) {\n\t\tbrcmf_dbg(CONN, \"WAR: use OPEN instead of AUTO\\n\");\n\t\ttype = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t}\n\treturn type;\n}", "answer": "NO", "cwe": "119", "idx": "49135"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_console_w32CreateFile_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_w32CreateFile_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95978"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_char_listen_socket_83\n{\n\n#ifndef OMITM\n\nclass _Process_Control__w32_char_listen_socket_83\n{\npublic:\n    _Process_Control__w32_char_listen_socket_83(char * dataCopy);\n    ~_Process_Control__w32_char_listen_socket_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_char_listen_socket_83G2B\n{\npublic:\n    _Process_Control__w32_char_listen_socket_83G2B(char * dataCopy);\n    ~_Process_Control__w32_char_listen_socket_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "114", "idx": "62178"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <vector>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_ifstream_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<char *> dataVector);\n\nvoid m()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<char *> dataVector);\n\nstatic void nG2B()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_ifstream_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96587"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_06()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81983"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_file_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_file_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123025"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_ofstream_16\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    while(1)\n    {\n        \n        wcscat(data, L\"file.txt\");\n        break;\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_ofstream_16; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91371"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_61bSource(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_61()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = _External_Control_of_System_or_Configuration_Setting__w32_61bSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_61bG2BSource(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = _External_Control_of_System_or_Configuration_Setting__w32_61bG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_61()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_61();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_61();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82011"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_12()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81989"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_char_file_81\n{\n\nclass _Process_Control__w32_char_file_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Process_Control__w32_char_file_81 : public _Process_Control__w32_char_file_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_char_file_81G2B : public _Process_Control__w32_char_file_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "114", "idx": "62128"}
{"code": "void pc_machine_done(Notifier *notifier, void *data)\n\n{\n\n    PCMachineState *pcms = container_of(notifier,\n\n                                        PCMachineState, machine_done);\n\n    PCIBus *bus = pcms->bus;\n\n\n\n    \n\n    rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus);\n\n\n\n    if (bus) {\n\n        int extra_hosts = 0;\n\n\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            \n\n            if (pci_bus_is_root(bus)) {\n\n                extra_hosts++;\n\n            }\n\n        }\n\n        if (extra_hosts && pcms->fw_cfg) {\n\n            uint64_t *val = g_malloc(sizeof(*val));\n\n            *val = cpu_to_le64(extra_hosts);\n\n            fw_cfg_add_file(pcms->fw_cfg,\n\n                    \"etc/extra-pci-roots\", val, sizeof(*val));\n\n        }\n\n    }\n\n\n\n    acpi_setup();\n\n    if (pcms->fw_cfg) {\n\n        pc_build_smbios(pcms);\n\n        pc_build_feature_control_file(pcms);\n\n        \n\n        fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus);\n\n    }\n\n\n\n    if (pcms->apic_id_limit > 255) {\n\n        IntelIOMMUState *iommu = INTEL_IOMMU_DEVICE(x86_iommu_get_default());\n\n\n\n        if (!iommu || !iommu->x86_iommu.intr_supported ||\n\n            iommu->intr_eim != ON_OFF_AUTO_ON) {\n\n            error_report(\"current -smp configuration requires \"\n\n                         \"Extended Interrupt Mode enabled. \"\n\n                         \"You can add an IOMMU using: \"\n\n                         \"-device intel-iommu,intremap=on,eim=on\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "1a26f46692320f1981c95967e0d5af4443b5f0b1"}
{"code": "radius_attrs_print(netdissect_options *ndo,\n                   register const u_char *attr, u_int length)\n{\n   register const struct radius_attr *rad_attr = (const struct radius_attr *)attr;\n   const char *attr_string;\n\n   while (length > 0)\n   {\n     if (length < 2)\n        goto trunc;\n     ND_TCHECK(*rad_attr);\n\n     if (rad_attr->type > 0 && rad_attr->type < TAM_SIZE(attr_type))\n\tattr_string = attr_type[rad_attr->type].name;\n     else\n\tattr_string = \"Unknown\";\n     if (rad_attr->len < 2)\n     {\n\tND_PRINT((ndo, \"\\n\\t  %s Attribute (%u), length: %u (bogus, must be >= 2)\",\n               attr_string,\n               rad_attr->type,\n               rad_attr->len));\n\treturn;\n     }\n     if (rad_attr->len > length)\n     {\n\tND_PRINT((ndo, \"\\n\\t  %s Attribute (%u), length: %u (bogus, goes past end of packet)\",\n               attr_string,\n               rad_attr->type,\n               rad_attr->len));\n        return;\n     }\n     ND_PRINT((ndo, \"\\n\\t  %s Attribute (%u), length: %u, Value: \",\n            attr_string,\n            rad_attr->type,\n            rad_attr->len));\n\n     if (rad_attr->type < TAM_SIZE(attr_type))\n     {\n         if (rad_attr->len > 2)\n         {\n             if ( attr_type[rad_attr->type].print_func )\n                 (*attr_type[rad_attr->type].print_func)(\n                     ndo, ((const u_char *)(rad_attr+1)),\n                     rad_attr->len - 2, rad_attr->type);\n         }\n     }\n     \n     if (ndo->ndo_vflag> 1)\n         print_unknown_data(ndo, (const u_char *)rad_attr+2, \"\\n\\t    \", (rad_attr->len)-2);\n\n     length-=(rad_attr->len);\n     rad_attr = (const struct radius_attr *)( ((const char *)(rad_attr))+rad_attr->len);\n   }\n   return;\n\ntrunc:\n   ND_PRINT((ndo, \"%s\", tstr));\n}", "answer": "NO", "cwe": "125", "idx": "62354"}
{"code": "nscroll(int n, int mode)\n{\n    Buffer *buf = Currentbuf;\n    Line *top = buf->topLine, *cur = buf->currentLine;\n    int lnum, tlnum, llnum, diff_n;\n\n    if (buf->firstLine == NULL)\n\treturn;\n    lnum = cur->linenumber;\n    buf->topLine = lineSkip(buf, top, n, FALSE);\n    if (buf->topLine == top) {\n\tlnum += n;\n\tif (lnum < buf->topLine->linenumber)\n\t    lnum = buf->topLine->linenumber;\n\telse if (lnum > buf->lastLine->linenumber)\n\t    lnum = buf->lastLine->linenumber;\n    }\n    else {\n\ttlnum = buf->topLine->linenumber;\n\tllnum = buf->topLine->linenumber + buf->LINES - 1;\n\tif (nextpage_topline)\n\t    diff_n = 0;\n\telse\n\t    diff_n = n - (tlnum - top->linenumber);\n\tif (lnum < tlnum)\n\t    lnum = tlnum + diff_n;\n\tif (lnum > llnum)\n\t    lnum = llnum + diff_n;\n    }\n    gotoLine(buf, lnum);\n    arrangeLine(buf);\n    if (n > 0) {\n\tif (buf->currentLine->bpos &&\n\t    buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos)\n\t    cursorDown(buf, 1);\n\telse {\n\t    while (buf->currentLine->next && buf->currentLine->next->bpos &&\n\t\t   buf->currentLine->bwidth + buf->currentLine->width <\n\t\t   buf->currentColumn + buf->visualpos)\n\t\tcursorDown0(buf, 1);\n\t}\n    }\n    else {\n\tif (buf->currentLine->bwidth + buf->currentLine->width <\n\t    buf->currentColumn + buf->visualpos)\n\t    cursorUp(buf, 1);\n\telse {\n\t    while (buf->currentLine->prev && buf->currentLine->bpos &&\n\t\t   buf->currentLine->bwidth >=\n\t\t   buf->currentColumn + buf->visualpos)\n\t\tcursorUp0(buf, 1);\n\t}\n    }\n    displayBuffer(buf, mode);\n}", "answer": "NO", "cwe": "59", "idx": "84523"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_52bSink(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_relativePath_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_wchar_t_relativePath_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_relativePath_52bG2BSink(data);\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62498"}
{"code": "static int f2fs_freeze(struct super_block *sb)\n{\n\tif (f2fs_readonly(sb))\n\t\treturn 0;\n\n\t\n\tif (unlikely(f2fs_cp_error(F2FS_SB(sb))))\n\t\treturn -EIO;\n\n\t\n\tif (is_sbi_flag_set(F2FS_SB(sb), SBI_IS_DIRTY))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "answer": "NO", "cwe": "129", "idx": "63865"}
{"code": "cJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}", "answer": "NO", "cwe": "125", "idx": "93699"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint stray_underplain = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid carnegiea_representee(int unakites_proglottides,... );\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  void *indignation_cristina = 0;\n  char *substantialized_gripers;;\n  if (__sync_bool_compare_and_swap(&stray_underplain,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&substantialized_gripers,\"VILITY_MARCHAL\");\n      if (substantialized_gripers != 0) {;\n        indignation_cristina = ((void *)substantialized_gripers);\n        carnegiea_representee(1,indignation_cristina);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid carnegiea_representee(int unakites_proglottides,... )\n{\n    int i = 0;\n    int buff_size = 63;\n    int taint_len;\n    char *heap_buff_64 = 0;\n  char *spongins_electrotypic = 0;\n  void *sandan_attainableness = 0;\n  va_list germanophilist_dipsomaniac;\n  ++global_variable;;\n  if (unakites_proglottides > 0) {\n    __builtin_va_start(germanophilist_dipsomaniac,unakites_proglottides);\n    sandan_attainableness = (va_arg(germanophilist_dipsomaniac,void *));\n    __builtin_va_end(germanophilist_dipsomaniac);\n  }\n  spongins_electrotypic = ((char *)((char *)sandan_attainableness));\n    \n    \n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64, 'A' ,64);\n        heap_buff_64[64 - 1] = '\\0';\n        \n        \n        \n        taint_len = ((int )(strlen(spongins_electrotypic)));\n        for (; taint_len >= 0; (--buff_size , --taint_len)) {\n    \n    \n            heap_buff_64[buff_size] = spongins_electrotypic[taint_len];\n        }\n        \n        for (; i < 64; ++i) {\n            heap_buff_64[i] = toupper(heap_buff_64[i]);\n        }\n        \n        \n        printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\n        free(heap_buff_64);\n        \n        \n        \n    }\n;\n  if (((char *)sandan_attainableness) != 0) \n    free(((char *)((char *)sandan_attainableness)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "124", "idx": "153809"}
{"code": "getWflagChars(int x)\n{\n\tint c = 0;\n\n\tx -= 1;\n\twhile (x > 0) {\n\t\tc += 1;\n\t\tx /= 10;\n\t}\n\n\treturn c;\n}", "answer": "NO", "cwe": "120", "idx": "93188"}
{"code": "static void qdict_destroy_obj(QObject *obj)\n\n{\n\n    int i;\n\n    QDict *qdict;\n\n\n\n    assert(obj != NULL);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    for (i = 0; i < QDICT_BUCKET_MAX; i++) {\n\n        QDictEntry *entry = QLIST_FIRST(&qdict->table[i]);\n\n        while (entry) {\n\n            QDictEntry *tmp = QLIST_NEXT(entry, next);\n\n            QLIST_REMOVE(entry, next);\n\n            qentry_destroy(entry);\n\n            entry = tmp;\n\n        }\n\n    }\n\n\n\n    g_free(qdict);\n\n}", "answer": "NO", "cwe": "0", "idx": "55e1819c509b3d9c10a54678b9c585bbda13889e"}
{"code": "static void setup_frame(int sig, struct target_sigaction *ka,\n\n                        target_sigset_t *set, CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    abi_ulong retcode_addr;\n\n    abi_ulong sc_addr;\n\n    int err = 0;\n\n    int i;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof *frame);\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\tgoto give_sigsegv;\n\n\n\n    __put_user(sig, &frame->sig);\n\n\n\n    sc_addr = frame_addr + offsetof(struct target_sigframe, sc);\n\n    __put_user(sc_addr, &frame->psc);\n\n\n\n    err |= setup_sigcontext(&frame->sc, env, set->sig[0]);\n\n    if (err)\n\n\tgoto give_sigsegv;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__put_user(set->sig[i], &frame->extramask[i - 1]))\n\n            goto give_sigsegv;\n\n    }\n\n\n\n    \n\n\n\n    retcode_addr = frame_addr + offsetof(struct target_sigframe, retcode);\n\n    __put_user(retcode_addr, &frame->pretcode);\n\n\n\n    \n\n\n\n    __put_user(0x70004e40 + (TARGET_NR_sigreturn << 16),\n\n                      (long *)(frame->retcode));\n\n\n\n    if (err)\n\n        goto give_sigsegv;\n\n\n\n    \n\n\n\n    env->aregs[7] = frame_addr;\n\n    env->pc = ka->_sa_handler;\n\n\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n}", "answer": "NO", "cwe": "0", "idx": "41ecc72ba5932381208e151bf2d2149a0342beff"}
{"code": "uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n\n                       uint8_t lock)\n\n{\n\n    MapCacheEntry *entry, *pentry = NULL;\n\n    hwaddr address_index;\n\n    hwaddr address_offset;\n\n    hwaddr cache_size = size;\n\n    hwaddr test_bit_size;\n\n    bool translated = false;\n\n\n\ntryagain:\n\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n\n\n    trace_xen_map_cache(phys_addr);\n\n\n\n    \n\n    if (size) {\n\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n\n        }\n\n    } else {\n\n        test_bit_size = XC_PAGE_SIZE;\n\n    }\n\n\n\n    if (mapcache->last_entry != NULL &&\n\n        mapcache->last_entry->paddr_index == address_index &&\n\n        !lock && !size &&\n\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                  test_bit_size >> XC_PAGE_SHIFT,\n\n                  mapcache->last_entry->valid_mapping)) {\n\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n        return mapcache->last_entry->vaddr_base + address_offset;\n\n    }\n\n\n\n    \n\n    if (size) {\n\n        cache_size = size + address_offset;\n\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n\n        }\n\n    } else {\n\n        cache_size = MCACHE_BUCKET_SIZE;\n\n    }\n\n\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n\n\n    while (entry && entry->lock && entry->vaddr_base &&\n\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                 test_bit_size >> XC_PAGE_SHIFT,\n\n                 entry->valid_mapping))) {\n\n        pentry = entry;\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        entry = g_malloc0(sizeof (MapCacheEntry));\n\n        pentry->next = entry;\n\n        xen_remap_bucket(entry, cache_size, address_index);\n\n    } else if (!entry->lock) {\n\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n\n                entry->size != cache_size ||\n\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                    test_bit_size >> XC_PAGE_SHIFT,\n\n                    entry->valid_mapping)) {\n\n            xen_remap_bucket(entry, cache_size, address_index);\n\n        }\n\n    }\n\n\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                test_bit_size >> XC_PAGE_SHIFT,\n\n                entry->valid_mapping)) {\n\n        mapcache->last_entry = NULL;\n\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n\n            translated = true;\n\n            goto tryagain;\n\n        }\n\n        trace_xen_map_cache_return(NULL);\n\n        return NULL;\n\n    }\n\n\n\n    mapcache->last_entry = entry;\n\n    if (lock) {\n\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n\n        entry->lock++;\n\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n\n        reventry->size = entry->size;\n\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n\n    }\n\n\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n    return mapcache->last_entry->vaddr_base + address_offset;\n\n}", "answer": "NO", "cwe": "0", "idx": "86a6a9bf551ffa183880480b37c5836d3916687a"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_connect_socket_w32CreateFile_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95759"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <vector>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _LDAP_Injection__w32_wchar_t_file_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<wchar_t *> dataVector);\n\nvoid m()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<wchar_t *> dataVector);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_file_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123272"}
{"code": "int RenderBox::pixelSnappedClientWidth() const\n{\n    return snapSizeToPixel(clientWidth(), x() + clientLeft());\n}", "answer": "NO", "cwe": "119", "idx": "124928"}
{"code": " PHP_FUNCTION(xml_set_processing_instruction_handler)\n {\n\txml_parser *parser;\n\tzval *pind, **hdl;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rZ\", &pind, &hdl) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, \"XML Parser\", le_xml_parser);\n\n\txml_set_handler(&parser->processingInstructionHandler, hdl);\n\tXML_SetProcessingInstructionHandler(parser->parser, _xml_processingInstructionHandler);\n\tRETVAL_TRUE;\n }", "answer": "NO", "cwe": "119", "idx": "10972"}
{"code": "static int theora_decode_header(AVCodecContext *avctx, GetBitContext gb)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n\n\n    s->theora = get_bits_long(&gb, 24);\n\n    av_log(avctx, AV_LOG_INFO, \"Theora bitstream version %X\\n\", s->theora);\n\n\n\n    \n\n    \n\n    if (s->theora < 0x030200)\n\n    {\n\n        s->flipped_image = 1;\n\n        av_log(avctx, AV_LOG_DEBUG, \"Old (<alpha3) Theora bitstream, flipped image\\n\");\n\n    }\n\n\n\n    s->width = get_bits(&gb, 16) << 4;\n\n    s->height = get_bits(&gb, 16) << 4;\n\n\n\n    if(avcodec_check_dimensions(avctx, s->width, s->height)){\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid dimensions (%dx%d)\\n\", s->width, s->height);\n\n        s->width= s->height= 0;\n\n        return -1;\n\n    }\n\n\n\n    if (s->theora >= 0x030400)\n\n    {\n\n        skip_bits(&gb, 32); \n\n        \n\n        skip_bits(&gb, 32); \n\n        skip_bits(&gb, 4); \n\n        skip_bits(&gb, 32); \n\n\n\n        skip_bits(&gb, 24); \n\n        skip_bits(&gb, 24); \n\n    }\n\n    else\n\n    {\n\n        skip_bits(&gb, 24); \n\n        skip_bits(&gb, 24); \n\n    }\n\n\n\n    skip_bits(&gb, 8); \n\n    skip_bits(&gb, 8); \n\n\n\n    skip_bits(&gb, 32); \n\n    skip_bits(&gb, 32); \n\n    skip_bits(&gb, 24); \n\n    skip_bits(&gb, 24); \n\n\n\n    if (s->theora < 0x030200)\n\n        skip_bits(&gb, 5); \n\n    skip_bits(&gb, 8); \n\n    if (s->theora >= 0x030400)\n\n        skip_bits(&gb, 2); \n\n    skip_bits(&gb, 24); \n\n\n\n    skip_bits(&gb, 6); \n\n\n\n    if (s->theora >= 0x030200)\n\n    {\n\n        skip_bits(&gb, 5); \n\n\n\n        if (s->theora < 0x030400)\n\n            skip_bits(&gb, 5); \n\n    }\n\n\n\n\n\n\n\n    avctx->width = s->width;\n\n    avctx->height = s->height;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "e278056fbad7405fc47901faea7de98db003a0fa"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef struct __LDAP_Injection__w32_wchar_t_connect_socket_67_structType\n{\n    wchar_t * structFirst;\n} _LDAP_Injection__w32_wchar_t_connect_socket_67_structType;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67bSink(_LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct);\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67bG2BSink(_LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67_structType myStruct;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_wchar_t_connect_socket_67bG2BSink(myStruct);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_connect_socket_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_connect_socket_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123126"}
{"code": "static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}", "answer": "NO", "cwe": "0", "idx": "9be385980d37e8f4fd33f605f5fb1c3d144170a8"}
{"code": "static void tftp_handle_rrq(Slirp *slirp, struct tftp_t *tp, int pktlen)\n\n{\n\n  struct tftp_session *spt;\n\n  int s, k;\n\n  size_t prefix_len;\n\n  char *req_fname;\n\n\n\n  \n\n  s = tftp_session_find(slirp, tp);\n\n  if (s >= 0) {\n\n    tftp_session_terminate(&slirp->tftp_sessions[s]);\n\n  }\n\n\n\n  s = tftp_session_allocate(slirp, tp);\n\n\n\n  if (s < 0) {\n\n    return;\n\n  }\n\n\n\n  spt = &slirp->tftp_sessions[s];\n\n\n\n  \n\n  if (!slirp->tftp_prefix) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n  }\n\n\n\n  \n\n  k = 0;\n\n  pktlen -= ((uint8_t *)&tp->x.tp_buf[0] - (uint8_t *)tp);\n\n\n\n  \n\n  prefix_len = strlen(slirp->tftp_prefix);\n\n  spt->filename = qemu_malloc(prefix_len + TFTP_FILENAME_MAX + 2);\n\n  memcpy(spt->filename, slirp->tftp_prefix, prefix_len);\n\n  spt->filename[prefix_len] = '/';\n\n\n\n  \n\n  req_fname = spt->filename + prefix_len + 1;\n\n\n\n  while (1) {\n\n    if (k >= TFTP_FILENAME_MAX || k >= pktlen) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n    }\n\n    req_fname[k] = (char)tp->x.tp_buf[k];\n\n    if (req_fname[k++] == '\\0') {\n\n      break;\n\n    }\n\n  }\n\n\n\n  \n\n  if ((pktlen - k) < 6) {\n\n    tftp_send_error(spt, 2, \"Access violation\", tp);\n\n    return;\n\n  }\n\n\n\n  if (memcmp(&tp->x.tp_buf[k], \"octet\\0\", 6) != 0) {\n\n      tftp_send_error(spt, 4, \"Unsupported transfer mode\", tp);\n\n      return;\n\n  }\n\n\n\n  k += 6; \n\n\n\n  \n\n  if (!strncmp(req_fname, \"../\", 3) ||\n\n      req_fname[strlen(req_fname) - 1] == '/' ||\n\n      strstr(req_fname, \"/../\")) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n  }\n\n\n\n  \n\n  if (tftp_read_data(spt, 0, NULL, 0) < 0) {\n\n      tftp_send_error(spt, 1, \"File not found\", tp);\n\n      return;\n\n  }\n\n\n\n  if (tp->x.tp_buf[pktlen - 1] != 0) {\n\n      tftp_send_error(spt, 2, \"Access violation\", tp);\n\n      return;\n\n  }\n\n\n\n  while (k < pktlen) {\n\n      const char *key, *value;\n\n\n\n      key = (const char *)&tp->x.tp_buf[k];\n\n      k += strlen(key) + 1;\n\n\n\n      if (k >= pktlen) {\n\n\t  tftp_send_error(spt, 2, \"Access violation\", tp);\n\n\t  return;\n\n      }\n\n\n\n      value = (const char *)&tp->x.tp_buf[k];\n\n      k += strlen(value) + 1;\n\n\n\n      if (strcmp(key, \"tsize\") == 0) {\n\n\t  int tsize = atoi(value);\n\n\t  struct stat stat_p;\n\n\n\n\t  if (tsize == 0) {\n\n\t      if (stat(spt->filename, &stat_p) == 0)\n\n\t\t  tsize = stat_p.st_size;\n\n\t      else {\n\n\t\t  tftp_send_error(spt, 1, \"File not found\", tp);\n\n\t\t  return;\n\n\t      }\n\n\t  }\n\n\n\n\t  tftp_send_oack(spt, \"tsize\", tsize, tp);\n\n\t  return;\n\n      }\n\n  }\n\n\n\n  tftp_send_data(spt, 1, tp);\n\n}", "answer": "NO", "cwe": "0", "idx": "facf1a60f29853590073f321e3cba491a5ee097a"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_open_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_open_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91893"}
{"code": "mwifiex_ie_index_used_by_other_intf(struct mwifiex_private *priv, u16 idx)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie *ie;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i] != priv) {\n\t\t\tie = &adapter->priv[i]->mgmt_ie[idx];\n\t\t\tif (ie->mgmt_subtype_mask && ie->ie_length)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "answer": "NO", "cwe": "120", "idx": "88605"}
{"code": "open_interface(const char *device, netdissect_options *ndo, char *ebuf)\n{\n\tpcap_t *pc;\n#ifdef HAVE_PCAP_CREATE\n\tint status;\n\tchar *cp;\n#endif\n\n#ifdef HAVE_PCAP_CREATE\n\tpc = pcap_create(device, ebuf);\n\tif (pc == NULL) {\n\t\t\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (Jflag)\n\t\tshow_tstamp_types_and_exit(pc, device);\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tstatus = pcap_set_tstamp_precision(pc, ndo->ndo_tstamp_precision);\n\tif (status != 0)\n\t\terror(\"%s: Can't set %ssecond time stamp precision: %s\",\n\t\t\tdevice,\n\t\t\ttstamp_precision_to_string(ndo->ndo_tstamp_precision),\n\t\t\tpcap_statustostr(status));\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\tif (immediate_mode) {\n\t\tstatus = pcap_set_immediate_mode(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set immediate mode: %s\",\n\t\t\tdevice,\n\t\t\tpcap_statustostr(status));\n\t}\n#endif\n\t\n\tif (pcap_can_set_rfmon(pc) == 1)\n\t\tsupports_monitor_mode = 1;\n\telse\n\t\tsupports_monitor_mode = 0;\n\tstatus = pcap_set_snaplen(pc, ndo->ndo_snaplen);\n\tif (status != 0)\n\t\terror(\"%s: Can't set snapshot length: %s\",\n\t\t    device, pcap_statustostr(status));\n\tstatus = pcap_set_promisc(pc, !pflag);\n\tif (status != 0)\n\t\terror(\"%s: Can't set promiscuous mode: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Iflag) {\n\t\tstatus = pcap_set_rfmon(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set monitor mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pc, 1000);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Bflag != 0) {\n\t\tstatus = pcap_set_buffer_size(pc, Bflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set buffer size: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (jflag != -1) {\n\t\tstatus = pcap_set_tstamp_type(pc, jflag);\n\t\tif (status < 0)\n\t\t\terror(\"%s: Can't set time stamp type: %s\",\n\t\t              device, pcap_statustostr(status));\n\t\telse if (status > 0)\n\t\t\twarning(\"When trying to set timestamp type '%s' on %s: %s\",\n\t\t\t\tpcap_tstamp_type_val_to_name(jflag), device,\n\t\t\t\tpcap_statustostr(status));\n\t}\n#endif\n\tstatus = pcap_activate(pc);\n\tif (status < 0) {\n\t\t\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_ERROR)\n\t\t\terror(\"%s\", cp);\n\t\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s: %s\\n(%s)\",\n\t\t\t    device, pcap_statustostr(status), cp);\n\t\t\tpcap_close(pc);\n\t\t\treturn (NULL);\n\t\t} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\\0')\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\terror(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t} else if (status > 0) {\n\t\t\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_WARNING)\n\t\t\twarning(\"%s\", cp);\n\t\telse if (status == PCAP_WARNING_PROMISC_NOTSUP &&\n\t\t         *cp != '\\0')\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\twarning(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SETDIRECTION\n\tif (Qflag != -1) {\n\t\tstatus = pcap_setdirection(pc, Qflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_setdirection() failed: %s\",\n\t\t\t      device,  pcap_geterr(pc));\n\t\t}\n#endif \n#else \n\t*ebuf = '\\0';\n\tpc = pcap_open_live(device, ndo->ndo_snaplen, !pflag, 1000, ebuf);\n\tif (pc == NULL) {\n\t\t\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n\tif (*ebuf)\n\t\twarning(\"%s\", ebuf);\n#endif \n\n\treturn (pc);\n}", "answer": "NO", "cwe": "120", "idx": "93191"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nint _External_Control_of_System_or_Configuration_Setting__w32_22Global = 0;\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_22Source(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_22()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    _External_Control_of_System_or_Configuration_Setting__w32_22Global = 1; \n    data = _External_Control_of_System_or_Configuration_Setting__w32_22Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Global = 0;\nint _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Global = 0;\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Source(char * data);\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Global = 0; \n    data = _External_Control_of_System_or_Configuration_Setting__w32_22G2B1Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nchar * _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Source(char * data);\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Global = 1; \n    data = _External_Control_of_System_or_Configuration_Setting__w32_22G2B2Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81997"}
{"code": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   \n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      \n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n         fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n      fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n      glDeleteProgram(prog_id);\n      return NULL;\n   }\n\n   sprog->ss[PIPE_SHADER_VERTEX] = vs;\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}", "answer": "NO", "cwe": "119", "idx": "9150"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECVP _wexecvp\n\n#ifndef OMITM\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Global = 0;\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Source(wchar_t * data);\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Global = 0;\nint _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Global = 0;\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Source(wchar_t * data);\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Global = 0; \n    data = _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B1Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n\nwchar_t * _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Source(wchar_t * data);\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Global = 1; \n    data = _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22G2B2Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_w32_execvp_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246614"}
{"code": "static int xen_pt_byte_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                                uint8_t *value, uint8_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint8_t valid_emu_mask = 0;\n\n\n\n    \n\n    valid_emu_mask = reg->emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "e2779de053b64f023de382fd87b3596613d47d1e"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint aitesis_chutzpah = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *sleighers_nanaimo = 0;\n  char *falda_loadstone = 0;\n  int **********oside_boycotter = 0;\n  int *********pentadecylic_aubergiste = 0;\n  int ********workers_exoticalness = 0;\n  int *******lunular_oversecure = 0;\n  int ******anecdotalist_published = 0;\n  int *****alerion_logarithmical = 0;\n  int ****inappetible_yefremov = 0;\n  int ***dragons_cyclical = 0;\n  int **trichloroethane_unmackly = 0;\n  int *sorbability_malachi = 0;\n  int clapper_fisticuffs;\n  char *millihenry_tenography[10] = {0};\n  int ensigncies_twifoldly = 66;\n  char *unpremeditate_chubbedness;;\n  if (__sync_bool_compare_and_swap(&aitesis_chutzpah,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&unpremeditate_chubbedness,\"6591\",ensigncies_twifoldly);\n      if (unpremeditate_chubbedness != 0) {;\n        clapper_fisticuffs = 5;\n        sorbability_malachi = &clapper_fisticuffs;\n        trichloroethane_unmackly = &sorbability_malachi;\n        dragons_cyclical = &trichloroethane_unmackly;\n        inappetible_yefremov = &dragons_cyclical;\n        alerion_logarithmical = &inappetible_yefremov;\n        anecdotalist_published = &alerion_logarithmical;\n        lunular_oversecure = &anecdotalist_published;\n        workers_exoticalness = &lunular_oversecure;\n        pentadecylic_aubergiste = &workers_exoticalness;\n        oside_boycotter = &pentadecylic_aubergiste;\n        millihenry_tenography[ *( *( *( *( *( *( *( *( *( *oside_boycotter)))))))))] = unpremeditate_chubbedness;\n        falda_loadstone = millihenry_tenography[ *( *( *( *( *( *( *( *( *( *oside_boycotter)))))))))];\n        sleighers_nanaimo = ((char *)falda_loadstone);\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(sleighers_nanaimo) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (sleighers_nanaimo[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &sleighers_nanaimo[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\n        if (falda_loadstone != 0) \n          free(((char *)falda_loadstone));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149670"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89589"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_listen_socket_ifstream_53\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_ifstream_53; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90619"}
{"code": "static int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "32c3047cac9294bb56d23c89a40a22409db5cc70"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_w32CreateFile_43\n{\n\n#ifndef OMITM\n\nvoid mSource(char * &data)\n{\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_w32CreateFile_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96716"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_82\n{\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_82 : public _External_Control_of_System_or_Configuration_Setting__w32_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_82G2B : public _External_Control_of_System_or_Configuration_Setting__w32_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "15", "idx": "82023"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__wchar_t_file_w32CreateFile_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_w32CreateFile_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91703"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_05\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ofstream_05; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91840"}
{"code": "static void omap_tipb_bridge_write(void *opaque, target_phys_addr_t addr,\n\n                                   uint64_t value, unsigned size)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *) opaque;\n\n\n\n    if (size < 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t\n\n        s->control = value & 0xffff;\n\n        break;\n\n\n\n    case 0x04:\t\n\n        s->alloc = value & 0x003f;\n\n        break;\n\n\n\n    case 0x08:\t\n\n        s->buffer = value & 0x0003;\n\n        break;\n\n\n\n    case 0x0c:\t\n\n        s->width_intr = !(value & 2);\n\n        s->enh_control = value & 0x000f;\n\n        break;\n\n\n\n    case 0x10:\t\n\n    case 0x14:\t\n\n    case 0x18:\t\n\n    case 0x1c:\t\n\n        OMAP_RO_REG(addr);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "static void raw_aio_unplug(BlockDriverState *bs)\n\n{\n\n#ifdef CONFIG_LINUX_AIO\n\n    BDRVRawState *s = bs->opaque;\n\n    if (s->use_aio) {\n\n        laio_io_unplug(bs, s->aio_ctx, true);\n\n    }\n\n#endif\n\n}", "answer": "NO", "cwe": "0", "idx": "6b98bd649520d07df4d1b7a0a54ac73bf178519c"}
{"code": "static void jpeg_term_destination(j_compress_ptr cinfo)\n\n{\n\n    VncState *vs = cinfo->client_data;\n\n    Buffer *buffer = &vs->tight_jpeg;\n\n\n\n    buffer->offset = buffer->capacity - cinfo->dest->free_in_buffer;\n\n}", "answer": "NO", "cwe": "0", "idx": "245f7b51c0ea04fb2224b1127430a096c91aee70"}
{"code": "void *virtqueue_alloc_element(size_t sz, unsigned out_num, unsigned in_num)\n\n{\n\n    VirtQueueElement *elem;\n\n    size_t in_addr_ofs = QEMU_ALIGN_UP(sz, __alignof__(elem->in_addr[0]));\n\n    size_t out_addr_ofs = in_addr_ofs + in_num * sizeof(elem->in_addr[0]);\n\n    size_t out_addr_end = out_addr_ofs + out_num * sizeof(elem->out_addr[0]);\n\n    size_t in_sg_ofs = QEMU_ALIGN_UP(out_addr_end, __alignof__(elem->in_sg[0]));\n\n    size_t out_sg_ofs = in_sg_ofs + in_num * sizeof(elem->in_sg[0]);\n\n    size_t out_sg_end = out_sg_ofs + out_num * sizeof(elem->out_sg[0]);\n\n\n\n    assert(sz >= sizeof(VirtQueueElement));\n\n    elem = g_malloc(out_sg_end);\n\n    elem->out_num = out_num;\n\n    elem->in_num = in_num;\n\n    elem->in_addr = (void *)elem + in_addr_ofs;\n\n    elem->out_addr = (void *)elem + out_addr_ofs;\n\n    elem->in_sg = (void *)elem + in_sg_ofs;\n\n    elem->out_sg = (void *)elem + out_sg_ofs;\n\n    return elem;\n\n}", "answer": "NO", "cwe": "0", "idx": "bf91bd27924955aa243abfa5d422ee71e9e84b93"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(char * &data)\n{\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcpy(data, \"hostname\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82004"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint foreseer_esocataphoria = 0;\ntypedef char *celibacies_rereel;\nint global_variable;\nvoid handle_taint(char *needly_tipsification);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid significator_retaker(const celibacies_rereel amphictyonies_eosine);\nvoid mnemonism_propanedioic(celibacies_rereel guttate_plagioclinal);\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&foreseer_esocataphoria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *needly_tipsification)\n{\n  celibacies_rereel maugansville_ellington = 0;\n  ++global_variable;;\n  if (needly_tipsification != 0) {;\n    maugansville_ellington = needly_tipsification;\n    significator_retaker(maugansville_ellington);\n  }\n}\n\nvoid significator_retaker(const celibacies_rereel amphictyonies_eosine)\n{\n  void (*curtailing_denicotinizes)(celibacies_rereel ) = mnemonism_propanedioic;\n  ++global_variable;;\n  curtailing_denicotinizes(amphictyonies_eosine);\n}\n\nvoid mnemonism_propanedioic(celibacies_rereel guttate_plagioclinal)\n{\n  size_t j = 0;\n  size_t i = 0;\n  char *second_buff = 0;\n  char *finder = \"aba\";\n  int check = 0;\n  char *gomulka_tinty = 0;\n  ++global_variable;;\n  gomulka_tinty = ((char *)((celibacies_rereel )guttate_plagioclinal));\n      \n      \n      for (i = 0; ((int )i) <= ((int )(strlen(gomulka_tinty) - strlen(finder))); ++i) {\n        for (j = 0; j < strlen(finder); ++j) {\n          if (gomulka_tinty[i + j] != finder[j]) {\n            check = 0;\n            break;\n          }\n          check = 1;\n        }\n\n        if (check == 1 && j == strlen(finder)) {\n          printf(\"Found aba string\\n\");\n          second_buff = &gomulka_tinty[i];\n          break;\n        }\n      }\n      \n      \n      \n\n      printf(\"String length is %i\\n\", strlen(second_buff));\n      \n      \n;\n  if (((celibacies_rereel )guttate_plagioclinal) != 0) \n    free(((char *)((celibacies_rereel )guttate_plagioclinal)));\nclose_printf_context();\n}\n#endif", "answer": "YES", "cwe": "476", "idx": "149941"}
{"code": "int detect_ramfs_rootfs(void)\n{\n\tchar buf[LINELEN], *p;\n\tFILE *f;\n\tint i;\n\tchar *p2;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (fgets(buf, LINELEN, f)) {\n\t\tfor (p = buf, i=0; p && i < 4; i++)\n\t\t\tp = strchr(p+1, ' ');\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tp2 = strchr(p+1, ' ');\n\t\tif (!p2)\n\t\t\tcontinue;\n\t\t*p2 = '\\0';\n\t\tif (strcmp(p+1, \"/\") == 0) {\n\t\t\tp = strchr(p2+1, '-');\n\t\t\tif (p && strncmp(p, \"- rootfs rootfs \", 16) == 0) {\n\t\t\t\tfclose(f);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}", "answer": "NO", "cwe": "59", "idx": "44668"}
{"code": "LIBOPENMPT_MODPLUG_API const char* ModPlug_GetName(ModPlugFile* file)\n{\n\tif(!file) return NULL;\n\treturn file->name;\n}", "answer": "NO", "cwe": "120", "idx": "87636"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_54bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82010"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n#define EXECVP _wexecvp\n\nwchar_t * _OS_Command_Injection__wchar_t_file_w32_execvp_68Data;\nwchar_t * _OS_Command_Injection__wchar_t_file_w32_execvp_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68bSink();\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68Data = data;\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68G2BData = data;\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68bG2BSink();\n}\n\nvoid _OS_Command_Injection__wchar_t_file_w32_execvp_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_w32_execvp_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248051"}
{"code": "int vhost_dev_init(struct vhost_dev *hdev, int devfd, const char *devpath,\n\n                   bool force)\n\n{\n\n    uint64_t features;\n\n    int r;\n\n    if (devfd >= 0) {\n\n        hdev->control = devfd;\n\n    } else {\n\n        hdev->control = open(devpath, O_RDWR);\n\n        if (hdev->control < 0) {\n\n            return -errno;\n\n        }\n\n    }\n\n    r = ioctl(hdev->control, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = ioctl(hdev->control, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    memory_listener_register(&hdev->memory_listener, NULL);\n\n    hdev->force = force;\n\n    return 0;\n\nfail:\n\n    r = -errno;\n\n    close(hdev->control);\n\n    return r;\n\n}", "answer": "NO", "cwe": "0", "idx": "0fada67420e29f389119ca6f44285203400e0730"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _LDAP_Injection__w32_wchar_t_connect_socket_81\n{\n\nclass _LDAP_Injection__w32_wchar_t_connect_socket_81_base\n{\npublic:\n    \n    virtual void action(wchar_t * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _LDAP_Injection__w32_wchar_t_connect_socket_81 : public _LDAP_Injection__w32_wchar_t_connect_socket_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _LDAP_Injection__w32_wchar_t_connect_socket_81G2B : public _LDAP_Injection__w32_wchar_t_connect_socket_81_base\n{\npublic:\n    void action(wchar_t * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "90", "idx": "123131"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_05()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81982"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nwchar_t * _Process_Control__w32_wchar_t_file_61bSource(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_file_61()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    data = _Process_Control__w32_wchar_t_file_61bSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * _Process_Control__w32_wchar_t_file_61bG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    data = _Process_Control__w32_wchar_t_file_61bG2BSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_61()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_61();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_61();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62405"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97275"}
{"code": "static int mkv_check_tag(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    while ((t = av_dict_get(m, \"\", t, AV_DICT_IGNORE_SUFFIX)))\n\n        if (av_strcasecmp(t->key, \"title\") && av_strcasecmp(t->key, \"stereo_mode\"))\n\n            return 1;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "843e72ea5542845a0a9fed743517c14a92279885"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_connect_socket_10()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_connect_socket_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_connect_socket_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_connect_socket_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62237"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_w32spawnl_31()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        \n        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        \n        \n        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid _OS_Command_Injection__char_file_w32spawnl_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_w32spawnl_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_w32spawnl_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245671"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_console_05()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_console_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_console_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_console_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "61992"}
{"code": "static ssize_t f2fs_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct f2fs_sb_info *sbi = container_of(kobj, struct f2fs_sb_info,\n\t\t\t\t\t\t\t\ts_kobj);\n\tstruct f2fs_attr *a = container_of(attr, struct f2fs_attr, attr);\n\n\treturn a->show ? a->show(a, sbi, buf) : 0;\n}", "answer": "NO", "cwe": "129", "idx": "63855"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_fopen_41\n{\n\n#ifndef OMITM\n\nvoid mSink(wchar_t * data)\n{\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(wchar_t * data)\n{\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_fopen_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90804"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\nnamespace _Process_Control__w32_char_relativePath_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"winsrv.dll\");\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_relativePath_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62202"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nwchar_t * _Absolute_Path_Traversal__wchar_t_file_open_68Data;\nwchar_t * _Absolute_Path_Traversal__wchar_t_file_open_68G2BData;\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_open_68\n{\n\n#ifndef OMITM\n\n\nvoid mSink();\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _Absolute_Path_Traversal__wchar_t_file_open_68Data = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink();\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    _Absolute_Path_Traversal__wchar_t_file_open_68G2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_open_68; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97642"}
{"code": "vrrp_garp_refresh_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned repeats;\n\n\t\n\tif (!read_unsigned_strvec(strvec, 1, &repeats, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_refresh_repeat '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (repeats == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_refresh_repeat must be greater than 0, setting to 1\", vrrp->iname);\n\t\trepeats = 1;\n\t}\n\n\tvrrp->garp_refresh_rep = repeats;\n}", "answer": "NO", "cwe": "59", "idx": "75997"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint swaddy_bookshelves = 0;\nint global_variable;\ntypedef char *outcheating_bequeathal;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\noutcheating_bequeathal dunt_vivid(outcheating_bequeathal emuls_boydekyn);\nvoid aguilarite_aerodontia(outcheating_bequeathal soliloquacious_spoofer);\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*sacrocoxalgia_wellsburg)(outcheating_bequeathal ) = aguilarite_aerodontia;\n  outcheating_bequeathal medicks_lawley = 0;\n  outcheating_bequeathal escallops_nonsiccative = 0;\n  char *omphalorrhagia_encumbering;;\n  if (__sync_bool_compare_and_swap(&swaddy_bookshelves,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&omphalorrhagia_encumbering,\"MILKSHOP_GUAYROTO\");\n      if (omphalorrhagia_encumbering != 0) {;\n        escallops_nonsiccative = omphalorrhagia_encumbering;\n        medicks_lawley = dunt_vivid(escallops_nonsiccative);\n        sacrocoxalgia_wellsburg(medicks_lawley);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\noutcheating_bequeathal dunt_vivid(outcheating_bequeathal emuls_boydekyn)\n{\n  ++global_variable;\n  return emuls_boydekyn;\n}\n\nvoid aguilarite_aerodontia(outcheating_bequeathal soliloquacious_spoofer)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *rhabarbaric_formicivora = 0;\n  ++global_variable;;\n  rhabarbaric_formicivora = ((char *)soliloquacious_spoofer);\n    \n    if (strlen(rhabarbaric_formicivora) > 0 &&\n            rhabarbaric_formicivora[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(rhabarbaric_formicivora,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n  if (soliloquacious_spoofer != 0) \n    free(((char *)soliloquacious_spoofer));\nclose_printf_context();\n}", "answer": "YES", "cwe": "774", "idx": "151633"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_char_environment_64bSink(void * dataVoidPtr);\n\nvoid _Process_Control__w32_char_environment_64()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    _Process_Control__w32_char_environment_64bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_char_environment_64bG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_char_environment_64bG2BSink(&data);\n}\n\nvoid _Process_Control__w32_char_environment_64()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_environment_64();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_environment_64();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62072"}
{"code": "sshd_exchange_identification(struct ssh *ssh, int sock_in, int sock_out)\n{\n\tu_int i;\n\tint remote_major, remote_minor;\n\tchar *s, *newline = \"\\n\";\n\tchar buf[256];\t\t\t\n\tchar remote_version[256];\t\n\n\txasprintf(&server_version_string, \"SSH-%d.%d-%.100s%s%s%s\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,\n\t    *options.version_addendum == '\\0' ? \"\" : \" \",\n\t    options.version_addendum, newline);\n\n\t\n\tif (atomicio(vwrite, sock_out, server_version_string,\n\t    strlen(server_version_string))\n\t    != strlen(server_version_string)) {\n\t\tlogit(\"Could not write ident string to %s port %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tcleanup_exit(255);\n\t}\n\n\t\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\tif (atomicio(read, sock_in, &buf[i], 1) != 1) {\n\t\t\tlogit(\"Did not receive identification string \"\n\t\t\t    \"from %s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t\tif (buf[i] == '\\r') {\n\t\t\tbuf[i] = 0;\n\t\t\t\n\t\t\tif (i == 12 &&\n\t\t\t    strncmp(buf, \"SSH-1.5-W1.0\", 12) == 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] == '\\n') {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\tclient_version_string = xstrdup(buf);\n\n\t\n\tif (sscanf(client_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\ts = \"Protocol mismatch.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tlogit(\"Bad protocol version identification '%.100s' \"\n\t\t    \"from %s port %d\", client_version_string,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tcleanup_exit(255);\n\t}\n\tdebug(\"Client protocol version %d.%d; client software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tssh->compat = compat_datafellows(remote_version);\n\n\tif ((ssh->compat & SSH_BUG_PROBE) != 0) {\n\t\tlogit(\"probed from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_SCANNER) != 0) {\n\t\tlogit(\"scanned from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    client_version_string);\n\t\tcleanup_exit(255);\n\t}\n\tif ((ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Client version \\\"%.100s\\\" uses unsafe RSA signature \"\n\t\t    \"scheme; disabling use of RSA keys\", remote_version);\n\t}\n\tif ((ssh->compat & SSH_BUG_DERIVEKEY) != 0) {\n\t\tfatal(\"Client version \\\"%.100s\\\" uses unsafe key agreement; \"\n\t\t    \"refusing connection\", remote_version);\n\t}\n\n\tchop(server_version_string);\n\tdebug(\"Local version string %.200s\", server_version_string);\n\n\tif (remote_major == 2 ||\n\t    (remote_major == 1 && remote_minor == 99)) {\n\t\tenable_compat20();\n\t} else {\n\t\ts = \"Protocol major versions differ.\\n\";\n\t\t(void) atomicio(vwrite, sock_out, s, strlen(s));\n\t\tclose(sock_in);\n\t\tclose(sock_out);\n\t\tlogit(\"Protocol major versions differ for %s port %d: \"\n\t\t    \"%.200s vs. %.200s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    server_version_string, client_version_string);\n\t\tcleanup_exit(255);\n\t}\n}", "answer": "NO", "cwe": "119", "idx": "72300"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\n\nint _OS_Command_Injection__char_file_execlp_22Global = 0;\n\nchar * _OS_Command_Injection__char_file_execlp_22Source(char * data);\n\nvoid _OS_Command_Injection__char_file_execlp_22()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__char_file_execlp_22Global = 1; \n    data = _OS_Command_Injection__char_file_execlp_22Source(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nint _OS_Command_Injection__char_file_execlp_22G2B1Global = 0;\nint _OS_Command_Injection__char_file_execlp_22G2B2Global = 0;\n\n\nchar * _OS_Command_Injection__char_file_execlp_22G2B1Source(char * data);\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__char_file_execlp_22G2B1Global = 0; \n    data = _OS_Command_Injection__char_file_execlp_22G2B1Source(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nchar * _OS_Command_Injection__char_file_execlp_22G2B2Source(char * data);\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    _OS_Command_Injection__char_file_execlp_22G2B2Global = 1; \n    data = _OS_Command_Injection__char_file_execlp_22G2B2Source(data);\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_file_execlp_22()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_execlp_22();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_execlp_22();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245486"}
{"code": "static int getSocketType(char* name) {\n    int type = -1;\n    uint i;\n    \n    \n    for(i=0; i<sizeof(socketTypes)/sizeof(socket_type); ++i) {\n        if( !strcmp(socketTypes[i].name, name) ) {\n            type = socketTypes[i].type;\n            break;\n        }\n    }\n    \n    \n    if (type == -1) \n        errmsg.LogError(0, NO_ERRCODE, \"unknown type %s\",name);\n    \n    return type;\n}", "answer": "NO", "cwe": "134", "idx": "62754"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41Sink(char * data)\n{\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41G2BSink(char * data)\n{\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_41G2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82002"}
{"code": "off_t find_volume_de(DOS_FS * fs, DIR_ENT * de)\n{\n    uint32_t cluster;\n    off_t offset;\n    int i;\n\n    if (fs->root_cluster) {\n\tfor (cluster = fs->root_cluster;\n\t     cluster != 0 && cluster != -1;\n\t     cluster = next_cluster(fs, cluster)) {\n\t    offset = cluster_start(fs, cluster);\n\t    for (i = 0; i * sizeof(DIR_ENT) < fs->cluster_size; i++) {\n\t\tfs_read(offset, sizeof(DIR_ENT), de);\n\t\tif (de->attr != VFAT_LN_ATTR && de->attr & ATTR_VOLUME)\n\t\t    return offset;\n\t\toffset += sizeof(DIR_ENT);\n\t    }\n\t}\n    } else {\n\tfor (i = 0; i < fs->root_entries; i++) {\n\t    offset = fs->root_start + i * sizeof(DIR_ENT);\n\t    fs_read(offset, sizeof(DIR_ENT), de);\n\t    if (de->attr != VFAT_LN_ATTR && de->attr & ATTR_VOLUME)\n\t\treturn offset;\n\t}\n    }\n\n    return 0;\n}", "answer": "NO", "cwe": "119", "idx": "52669"}
{"code": "int64 float64_to_int64_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    bits64 aSig;\n\n    int64 z;\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( aExp ) aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = aExp - 0x433;\n\n    if ( 0 <= shiftCount ) {\n\n        if ( 0x43E <= aExp ) {\n\n            if ( a != LIT64( 0xC3E0000000000000 ) ) {\n\n                float_raise( float_flag_invalid STATUS_VAR);\n\n                if (    ! aSign\n\n                     || (    ( aExp == 0x7FF )\n\n                          && ( aSig != LIT64( 0x0010000000000000 ) ) )\n\n                   ) {\n\n                    return LIT64( 0x7FFFFFFFFFFFFFFF );\n\n                }\n\n            }\n\n            return (sbits64) LIT64( 0x8000000000000000 );\n\n        }\n\n        z = aSig<<shiftCount;\n\n    }\n\n    else {\n\n        if ( aExp < 0x3FE ) {\n\n            if ( aExp | aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n            return 0;\n\n        }\n\n        z = aSig>>( - shiftCount );\n\n        if ( (bits64) ( aSig<<( shiftCount & 63 ) ) ) {\n\n            STATUS(float_exception_flags) |= float_flag_inexact;\n\n        }\n\n    }\n\n    if ( aSign ) z = - z;\n\n    return z;\n\n\n\n}", "answer": "NO", "cwe": "0", "idx": "f090c9d4ad5812fb92843d6470a1111c15190c4c"}
{"code": "static int einj_timedout(u64 *t)\n{\n\tif ((s64)*t < SPIN_UNIT) {\n\t\tpr_warning(FW_WARN EINJ_PFX\n\t\t\t   \"Firmware does not respond in time\\n\");\n\t\treturn 1;\n\t}\n\t*t -= SPIN_UNIT;\n\tndelay(SPIN_UNIT);\n\ttouch_nmi_watchdog();\n\treturn 0;\n}", "answer": "NO", "cwe": "74", "idx": "73887"}
{"code": "void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "bson_iter_dbpointer (const bson_iter_t *iter,  \n                     uint32_t *collection_len, \n                     const char **collection,  \n                     const bson_oid_t **oid)   \n{\n   BSON_ASSERT (iter);\n\n   if (collection) {\n      *collection = NULL;\n   }\n\n   if (oid) {\n      *oid = NULL;\n   }\n\n   if (ITER_TYPE (iter) == BSON_TYPE_DBPOINTER) {\n      if (collection_len) {\n         memcpy (\n            collection_len, (iter->raw + iter->d1), sizeof (*collection_len));\n         *collection_len = BSON_UINT32_FROM_LE (*collection_len);\n\n         if ((*collection_len) > 0) {\n            (*collection_len)--;\n         }\n      }\n\n      if (collection) {\n         *collection = (const char *) (iter->raw + iter->d2);\n      }\n\n      if (oid) {\n         *oid = (const bson_oid_t *) (iter->raw + iter->d3);\n      }\n   }\n}", "answer": "NO", "cwe": "125", "idx": "77827"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic char * mSource(char * data)\n{\n    if(mStatic)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    return data;\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32spawnl_21()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic char * nG2B1Source(char * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic char * nG2B2Source(char * data)\n{\n    if(nG2B2Static)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32spawnl_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32spawnl_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32spawnl_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246237"}
{"code": "static void avc_luma_mid_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                                int32_t src_stride,\n\n                                                uint8_t *dst,\n\n                                                int32_t dst_stride)\n\n{\n\n    avc_luma_mid_and_aver_dst_8w_msa(src, src_stride, dst, dst_stride, 16);\n\n    avc_luma_mid_and_aver_dst_8w_msa(src + 8, src_stride, dst + 8, dst_stride,\n\n                                     16);\n\n}", "answer": "NO", "cwe": "0", "idx": "1181d93231e9b807965724587d363c1cfd5a1d0d"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _wexeclp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_execlp_31()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        \n        \n        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        \n        \n        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_console_execlp_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_execlp_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_execlp_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246903"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_connect_socket_06()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_connect_socket_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_connect_socket_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_connect_socket_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "61945"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint stile_macaronies = 0;\n\nstruct karez_fribblery \n{\n  char *carryouts_backbeats;\n  double mamba_spaniolize;\n  char *killable_recoronation;\n  char unslipped_colubroid;\n  int triumphs_eliphalet;\n}\n;\nint global_variable;\nvoid handle_taint(char *weismannian_beeish);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nint contains_char(char *str_param,char c_param)\n{\n  \n  int function_found;\n  function_found = 0;\n  \n  \n\n  while( *str_param != 0){\n    if ( *str_param == c_param) {\n      function_found = 1;\n      break;\n    }\n    str_param = str_param + 1;\n  }\n  \n  \n  \n\n  free(str_param);\n  \n  return function_found;\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&stile_macaronies,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid handle_taint(char *weismannian_beeish)\n{\n int oc_i = 0;\n int found;\n char *buffer = 0;\n int buffer_len;\n  char *capitatim_enrockment = 0;\n  struct karez_fribblery dehisced_accounsel = {0};\n  long seesaw_poligarship[10];\n  struct karez_fribblery fountaineer_tauromachy[10] = {0};\n  struct karez_fribblery lesly_labdanum;\n  ++global_variable;;\n  if (weismannian_beeish != 0) {;\n    lesly_labdanum . carryouts_backbeats = ((char *)weismannian_beeish);\n    fountaineer_tauromachy[5] = lesly_labdanum;\n    seesaw_poligarship[1] = 5;\n    dehisced_accounsel =  *(fountaineer_tauromachy + seesaw_poligarship[1]);\n    if (dehisced_accounsel . carryouts_backbeats != 0) {\n      goto divides_jurat;\n    }\n    ++global_variable;\n    divides_jurat:;\n    capitatim_enrockment = ((char *)dehisced_accounsel . carryouts_backbeats);\n    \n    buffer_len = strlen(capitatim_enrockment) + 1;\n    buffer = malloc(buffer_len * sizeof(char ));\n    if (buffer == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n    }\n    strcpy(buffer,capitatim_enrockment);\n    for (; oc_i < buffer_len; ++oc_i) {\n        buffer[oc_i] = toupper(buffer[oc_i]);\n    }\n    printf(\"%s\\n\",buffer);\n    \n    found = contains_char(buffer,'E');\n    if (found == 1)\n        printf(\"%s\\n\",capitatim_enrockment);\n    \n;\n    if (dehisced_accounsel . carryouts_backbeats != 0) \n      free(((char *)dehisced_accounsel . carryouts_backbeats));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "761", "idx": "153362"}
{"code": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}", "answer": "NO", "cwe": "0", "idx": "f1c52354e5bdab6983d13a4c174759c585e834b3"}
{"code": "static void openpic_load_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_get_be32s(f, &q->queue[i]);\n\n\n\n    qemu_get_sbe32s(f, &q->next);\n\n    qemu_get_sbe32s(f, &q->priority);\n\n}", "answer": "NO", "cwe": "0", "idx": "e69a17f65e9f12f33c48b04a789e49d40a8993f5"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_open_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_open_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90952"}
{"code": "uint32_t HELPER(neon_min_f32)(uint32_t a, uint32_t b)\n\n{\n\n    float32 f0 = make_float32(a);\n\n    float32 f1 = make_float32(b);\n\n    return (float32_compare_quiet(f0, f1, NFS) == -1) ? a : b;\n\n}", "answer": "NO", "cwe": "0", "idx": "4a9f9cb24de52e93aae7539a004dd20314ca1c0c"}
{"code": "uint32_t lduw_be_phys(target_phys_addr_t addr)\n\n{\n\n    return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <mongoose.h> \n#include <stdio.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint systematization_chapatties = 0;\nint global_variable;\nvoid handle_taint(char *dyess_metalepses);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{;\n  if (__sync_bool_compare_and_swap(&systematization_chapatties,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid handle_taint(char *dyess_metalepses)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *mastodontoid_ophthalmoptosis = 0;\n  int nonchivalrously_michelangelo;\n  int falcons_eulogisation;\n  char *wolcott_chorographical = 0;\n  int **********tumultuation_incomeless = 0;\n  int *********platitudinarian_predivide = 0;\n  int ********castling_sidebar = 0;\n  int *******uninfringible_famiglietti = 0;\n  int ******homer_euplotid = 0;\n  int *****gpcd_enchodontid = 0;\n  int ****reasoner_overinvolving = 0;\n  int ***ensculpture_kusimanse = 0;\n  int **wallpiece_unequalizing = 0;\n  int *uprightly_nonembryonal = 0;\n  int hirai_laryngectomized;\n  char *ump_prejudicious[10] = {0};\n  int graceful_watchfulness = 0;\n  char *woofers_pallone = 0;\n  ++global_variable;;\n  if (dyess_metalepses != 0) {;\n    graceful_watchfulness = ((int )(strlen(dyess_metalepses)));\n    woofers_pallone = ((char *)(malloc(graceful_watchfulness + 1)));\n    if (woofers_pallone == 0) {\n      printf(\"Error: Failed to allocate memory\\n\");\n      exit(1);\n    }\n    memset(woofers_pallone,0,graceful_watchfulness + 1);\n    memcpy(woofers_pallone,dyess_metalepses,graceful_watchfulness);\n    if (dyess_metalepses != 0) \n      free(((char *)dyess_metalepses));\n    hirai_laryngectomized = 5;\n    uprightly_nonembryonal = &hirai_laryngectomized;\n    wallpiece_unequalizing = &uprightly_nonembryonal;\n    ensculpture_kusimanse = &wallpiece_unequalizing;\n    reasoner_overinvolving = &ensculpture_kusimanse;\n    gpcd_enchodontid = &reasoner_overinvolving;\n    homer_euplotid = &gpcd_enchodontid;\n    uninfringible_famiglietti = &homer_euplotid;\n    castling_sidebar = &uninfringible_famiglietti;\n    platitudinarian_predivide = &castling_sidebar;\n    tumultuation_incomeless = &platitudinarian_predivide;\n    ump_prejudicious[ *( *( *( *( *( *( *( *( *( *tumultuation_incomeless)))))))))] = woofers_pallone;\n    wolcott_chorographical = ump_prejudicious[ *( *( *( *( *( *( *( *( *( *tumultuation_incomeless)))))))))];\n    falcons_eulogisation = 5;\n    while(1 == 1){\n      falcons_eulogisation = falcons_eulogisation * 2;\n      falcons_eulogisation = falcons_eulogisation + 2;\n      if (falcons_eulogisation > 1000) {\n        break; \n      }\n    }\n    nonchivalrously_michelangelo = falcons_eulogisation;\n    mastodontoid_ophthalmoptosis = ((char *)wolcott_chorographical);\n    \n    if (strlen(mastodontoid_ophthalmoptosis) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,mastodontoid_ophthalmoptosis);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n    if (wolcott_chorographical != 0) \n      free(((char *)wolcott_chorographical));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "78", "idx": "152718"}
{"code": "static int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd, u8 *mac)\n{\n\tstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\n\tmemcpy(sta_deauth->mac, mac, ETH_ALEN);\n\tsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}", "answer": "NO", "cwe": "120", "idx": "88611"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint roestone_evilhearted = 0;\n\nstruct surnaming_sleevelessness \n{\n  char *unleviable_uninvoluted;\n  double certifiably_mattress;\n  char *unjamming_taurean;\n  char phylactolaemata_columbiaville;\n  int borda_micrography;\n}\n;\nint global_variable;\nvoid handle_taint(char *hepatica_gerontocracies);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid noiseless_areole(int unmetaphysic_machair,struct surnaming_sleevelessness halftones_toddite);\nint 190_global_var = 0;\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&roestone_evilhearted,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *hepatica_gerontocracies)\n{\n  int nonepiscopally_avocets = 7;\n  struct surnaming_sleevelessness otorrhoea_astromancer = {0};\n  int *snarls_geopolitically = 0;\n  int saltfish_ketoses;\n  struct surnaming_sleevelessness ogreisms_hakafoth[10] = {0};\n  struct surnaming_sleevelessness vaurien_maxilliferous;\n  ++global_variable;;\n  if (hepatica_gerontocracies != 0) {;\n    vaurien_maxilliferous . unleviable_uninvoluted = ((char *)hepatica_gerontocracies);\n    saltfish_ketoses = 5;\n    snarls_geopolitically = &saltfish_ketoses;\n    ogreisms_hakafoth[ *snarls_geopolitically] = vaurien_maxilliferous;\n    otorrhoea_astromancer = ogreisms_hakafoth[ *snarls_geopolitically];\n    noiseless_areole(nonepiscopally_avocets,otorrhoea_astromancer);\n  }\n}\n\nvoid noiseless_areole(int unmetaphysic_machair,struct surnaming_sleevelessness halftones_toddite)\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *flooders_autophytic = 0;\n  ++global_variable;\n  unmetaphysic_machair--;\n  if (unmetaphysic_machair > 0) {\n    noiseless_areole(unmetaphysic_machair,halftones_toddite);\n    return ;\n  }\n  flooders_autophytic = ((char *)halftones_toddite . unleviable_uninvoluted);\n    \n    tainted_int = atoi(flooders_autophytic);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (halftones_toddite . unleviable_uninvoluted != 0) \n    free(((char *)halftones_toddite . unleviable_uninvoluted));\nclose_printf_context();\n}", "answer": "YES", "cwe": "190", "idx": "151091"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82\n{\n\nclass _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82 : public _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82G2B : public _Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "23", "idx": "89817"}
{"code": "void mwifiex_set_sys_config_invalid_data(struct mwifiex_uap_bss_param *config)\n{\n\tconfig->bcast_ssid_ctl = 0x7F;\n\tconfig->radio_ctl = 0x7F;\n\tconfig->dtim_period = 0x7F;\n\tconfig->beacon_period = 0x7FFF;\n\tconfig->auth_mode = 0x7F;\n\tconfig->rts_threshold = 0x7FFF;\n\tconfig->frag_threshold = 0x7FFF;\n\tconfig->retry_limit = 0x7F;\n\tconfig->qos_info = 0xFF;\n}", "answer": "NO", "cwe": "120", "idx": "88617"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_listen_socket_14()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_listen_socket_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_listen_socket_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_listen_socket_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62145"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_environment_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_environment_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122965"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint huskroot_burga = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid acute_multisacculate(char **extralite_staffelite);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n    char *file1;\n    char *file2;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *toCap (void *data) {\n    struct data *cusData = (struct data*)data;\n    int i;\n    int *arr;\n    \n    pthread_mutex_lock(&mutex);\n    readFile(cusData->file1);\n    arr = malloc(sizeof(int) * cusData->qsize);\n    for (i = 0; i < cusData->qsize; i++) {\n        arr[i] = cusData->qsize - i;\n    }\n    qsort(arr, cusData->qsize, sizeof(int), &comp);\n    free(arr);\n    \n    \n    \n    \n    \n    for(i = 0; i < cusData->data_size; i++) {\n        \n        if (cusData->data[i] >= 'a' &&\n            cusData->data[i] <= 'z') { \n            cusData->data[i] -= 32;\n        }\n    }\n    \n    pthread_mutex_unlock(&mutex);\n    return NULL;\n}\nvoid *delNonAlpha (void *data) {\n    struct data *cusData = (struct data*) data;\n    int i = 0;\n    int j = 0;\n    char* temp = malloc(sizeof(char) * (cusData->data_size + 1));\n    \n    while(cusData->data[i] != '\\0') {\n        if((cusData->data[i] >= 'A' && cusData->data[i] <= 'Z') ||\n           (cusData->data[i] >= 'a' && cusData->data[i] <= 'z')) {\n            temp[j++] = cusData->data[i];\n        }\n        i++;\n    }\n    temp[j++] = '\\0';\n    cusData->data_size = j;\n    free(cusData->data);\n    \n    \n    cusData->data = NULL; \n    \n    \n    \n    \n    \n    readFile(cusData->file2);\n    cusData->data = temp;\n    \n    \n    \n    \n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  char **ciceronage_ruffo = 0;\n  int *bibliopegy_bme = 0;\n  int protatically_everhart;\n  char **graminifolious_coinstantaneity[10] = {0};\n  char *preston_subduer[55] = {0};\n  char *boulder_semistriated;;\n  if (__sync_bool_compare_and_swap(&huskroot_burga,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      boulder_semistriated = getenv(\"SMALM_TAGBANUA\");\n      if (boulder_semistriated != 0) {;\n        preston_subduer[46] = boulder_semistriated;\n        graminifolious_coinstantaneity[5] = preston_subduer;\n        protatically_everhart = 5;\n        bibliopegy_bme = &protatically_everhart;\n        ciceronage_ruffo =  *(graminifolious_coinstantaneity +  *bibliopegy_bme);\n        acute_multisacculate(ciceronage_ruffo);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid acute_multisacculate(char **extralite_staffelite)\n{\n    pthread_t t0, t1;\n    struct data *cusData;\n  char *subshrubby_imm = 0;\n  ++global_variable;;\n  subshrubby_imm = ((char *)extralite_staffelite[46]);\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(subshrubby_imm) + 1));\n        cusData->file1 = malloc(sizeof(char) * (strlen(subshrubby_imm) + 1));\n        cusData->file2 = malloc(sizeof(char) * (strlen(subshrubby_imm) + 1));\n        if (cusData->data && cusData->file1 && cusData->file2) {\n            if ((sscanf(subshrubby_imm, \"%d %s %s %s\",\n                      &(cusData->qsize),\n                        cusData->file1,\n                        cusData->file2,\n                        cusData->data) == 4) &&\n                (strlen(cusData->data) != 0))\n            {\n                \n                \n                \n                \n                if (pthread_mutex_init(&mutex, NULL) != 0) {\n                    printf(\"Mutex failed to initilize.\");\n                }\n                cusData->data_size = strlen(cusData->data);\n                \n                if (pthread_create(&t0, NULL, delNonAlpha, (void *)cusData) != 0) { \n                    printf(\"Error creating thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toCap, (void *)cusData) != 0) {\n                    printf(\"Error creating thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n                printf(\"After joins.\\n\");\n                pthread_mutex_destroy(&mutex);\n            } else {\n                printf(\"Error parsing input.\\n\");\n            }\n            free(cusData->data);\n        }\n        free(cusData);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "414", "idx": "150604"}
{"code": "int null_stdfds(void)\n{\n\tint fd, ret = -1;\n\n\tfd = open(\"/dev/null\", O_RDWR);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (dup2(fd, 0) < 0)\n\t\tgoto err;\n\tif (dup2(fd, 1) < 0)\n\t\tgoto err;\n\tif (dup2(fd, 2) < 0)\n\t\tgoto err;\n\n\tret = 0;\nerr:\n\tclose(fd);\n\treturn ret;\n}", "answer": "NO", "cwe": "59", "idx": "44703"}
{"code": "static void dvbsub_parse_clut_segment(AVCodecContext *avctx,\n\n                                        const uint8_t *buf, int buf_size)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n\n\n    const uint8_t *buf_end = buf + buf_size;\n\n    int i, clut_id;\n\n    DVBSubCLUT *clut;\n\n    int entry_id, depth , full_range;\n\n    int y, cr, cb, alpha;\n\n    int r, g, b, r_add, g_add, b_add;\n\n\n\n    av_dlog(avctx, \"DVB clut packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    clut_id = *buf++;\n\n    buf += 1;\n\n\n\n    clut = get_clut(ctx, clut_id);\n\n\n\n    if (!clut) {\n\n        clut = av_malloc(sizeof(DVBSubCLUT));\n\n\n\n        memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n\n\n\n        clut->id = clut_id;\n\n\n\n        clut->next = ctx->clut_list;\n\n        ctx->clut_list = clut;\n\n    }\n\n\n\n    while (buf + 4 < buf_end) {\n\n        entry_id = *buf++;\n\n\n\n        depth = (*buf) & 0xe0;\n\n\n\n        if (depth == 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid clut depth 0x%x!\\n\", *buf);\n\n            return;\n\n        }\n\n\n\n        full_range = (*buf++) & 1;\n\n\n\n        if (full_range) {\n\n            y = *buf++;\n\n            cr = *buf++;\n\n            cb = *buf++;\n\n            alpha = *buf++;\n\n        } else {\n\n            y = buf[0] & 0xfc;\n\n            cr = (((buf[0] & 3) << 2) | ((buf[1] >> 6) & 3)) << 4;\n\n            cb = (buf[1] << 2) & 0xf0;\n\n            alpha = (buf[1] << 6) & 0xc0;\n\n\n\n            buf += 2;\n\n        }\n\n\n\n        if (y == 0)\n\n            alpha = 0xff;\n\n\n\n        YUV_TO_RGB1_CCIR(cb, cr);\n\n        YUV_TO_RGB2_CCIR(r, g, b, y);\n\n\n\n        av_dlog(avctx, \"clut %d := (%d,%d,%d,%d)\\n\", entry_id, r, g, b, alpha);\n\n\n\n        if (depth & 0x80)\n\n            clut->clut4[entry_id] = RGBA(r,g,b,255 - alpha);\n\n        if (depth & 0x40)\n\n            clut->clut16[entry_id] = RGBA(r,g,b,255 - alpha);\n\n        if (depth & 0x20)\n\n            clut->clut256[entry_id] = RGBA(r,g,b,255 - alpha);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "607ad990d31e6be52980970e5ce8cd25ab3de812"}
{"code": "error::Error GLES2DecoderImpl::HandlePostSubBufferCHROMIUM(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::PostSubBufferCHROMIUM& c =\n      *static_cast<const volatile gles2::cmds::PostSubBufferCHROMIUM*>(\n          cmd_data);\n  TRACE_EVENT0(\"gpu\", \"GLES2DecoderImpl::HandlePostSubBufferCHROMIUM\");\n  if (!supports_post_sub_buffer_) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION,\n        \"glPostSubBufferCHROMIUM\", \"command not supported by surface\");\n    return error::kNoError;\n  }\n  bool is_tracing;\n  TRACE_EVENT_CATEGORY_GROUP_ENABLED(TRACE_DISABLED_BY_DEFAULT(\"gpu.debug\"),\n                                     &is_tracing);\n  if (is_tracing) {\n    bool is_offscreen = !!offscreen_target_frame_buffer_.get();\n    ScopedFramebufferBinder binder(this, GetBoundDrawFramebufferServiceId());\n    gpu_state_tracer_->TakeSnapshotWithCurrentFramebuffer(\n        is_offscreen ? offscreen_size_ : surface_->GetSize());\n  }\n\n  ClearScheduleCALayerState();\n  ClearScheduleDCLayerState();\n\n  if (supports_async_swap_) {\n    TRACE_EVENT_ASYNC_BEGIN0(\"gpu\", \"AsyncSwapBuffers\", c.swap_id());\n\n    client_->OnSwapBuffers(c.swap_id(), c.flags);\n    surface_->PostSubBufferAsync(\n        c.x, c.y, c.width, c.height,\n        base::Bind(&GLES2DecoderImpl::FinishAsyncSwapBuffers,\n                   weak_ptr_factory_.GetWeakPtr(), c.swap_id()),\n        base::DoNothing());\n  } else {\n    client_->OnSwapBuffers(c.swap_id(), c.flags);\n    FinishSwapBuffers(surface_->PostSubBuffer(c.x, c.y, c.width, c.height,\n                                              base::DoNothing()));\n  }\n\n  return error::kNoError;\n}", "answer": "NO", "cwe": "119", "idx": "158724"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_02()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        \n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62469"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_63bSink(char * * dataPtr);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_63()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_63bG2BSink(char * * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_63bG2BSink(&data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82013"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_67\n{\n\ntypedef struct _structType\n{\n    wchar_t * structFirst;\n} structType;\n\n#ifndef OMITM\n\n\nvoid mSink(structType myStruct);\n\nvoid m()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    mSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(structType myStruct);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    myStruct.structFirst = data;\n    nG2BSink(myStruct);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_listen_socket_ifstream_67; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91827"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _wexeclp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_execlp_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_console_execlp_17()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_execlp_17();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_execlp_17();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246899"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_w32CreateFile_12\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_w32CreateFile_12; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97421"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_file_65bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_file_65()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = _LDAP_Injection__w32_char_file_65bSink;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_file_65bG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = _LDAP_Injection__w32_char_file_65bG2BSink;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    funcPtr(data);\n}\n\nvoid _LDAP_Injection__w32_char_file_65()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_65();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_65();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123028"}
{"code": "static void akita_init(int ram_size, int vga_ram_size, int boot_device,\n\n                DisplayState *ds, const char **fd_filename, int snapshot,\n\n                const char *kernel_filename, const char *kernel_cmdline,\n\n                const char *initrd_filename, const char *cpu_model)\n\n{\n\n    spitz_common_init(ram_size, vga_ram_size, ds, kernel_filename,\n\n                kernel_cmdline, initrd_filename, akita, 0x2e8);\n\n}", "answer": "NO", "cwe": "0", "idx": "4207117c93357347500235952ce7891688089cb1"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_connect_socket_w32_spawnv_82\n{\n\nclass _OS_Command_Injection__char_connect_socket_w32_spawnv_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_connect_socket_w32_spawnv_82 : public _OS_Command_Injection__char_connect_socket_w32_spawnv_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_connect_socket_w32_spawnv_82G2B : public _OS_Command_Injection__char_connect_socket_w32_spawnv_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "244376"}
{"code": "void cpu_physical_memory_write_rom(target_phys_addr_t addr,\n\n                                   const uint8_t *buf, int len)\n\n{\n\n    AddressSpaceDispatch *d = address_space_memory.dispatch;\n\n    int l;\n\n    uint8_t *ptr;\n\n    target_phys_addr_t page;\n\n    MemoryRegionSection *section;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        section = phys_page_find(d, page >> TARGET_PAGE_BITS);\n\n\n\n        if (!(memory_region_is_ram(section->mr) ||\n\n              memory_region_is_romd(section->mr))) {\n\n            \n\n        } else {\n\n            unsigned long addr1;\n\n            addr1 = memory_region_get_ram_addr(section->mr)\n\n                + memory_region_section_addr(section, addr);\n\n            \n\n            ptr = qemu_get_ram_ptr(addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(addr1, l);\n\n            qemu_put_ram_ptr(ptr);\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n\n{\n\n    IVI45DecContext *ctx = avctx->priv_data;\n\n\n\n    ivi_free_buffers(&ctx->planes[0]);\n\n\n\n    if (ctx->mb_vlc.cust_tab.table)\n\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n    if (ctx->is_indeo4) {\n\n    if (ctx->is_scalable)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses scalability mode!\\n\");\n\n    if (ctx->uses_tiling)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses local decoding!\\n\");\n\n    if (ctx->has_b_frames)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video contains B-frames!\\n\");\n\n    if (ctx->has_transp)\n\n        av_log(avctx, AV_LOG_ERROR, \"Transparency mode is enabled!\\n\");\n\n    if (ctx->uses_haar)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses Haar transform!\\n\");\n\n    if (ctx->uses_fullpel)\n\n        av_log(avctx, AV_LOG_ERROR, \"This video uses fullpel motion vectors!\\n\");\n\n    }\n\n#endif\n\n\n\n    av_frame_free(&ctx->p_frame);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "6202e2fede75df92cbc374a3f7d6893d0c5ac721"}
{"code": "void virtio_blk_data_plane_start(VirtIOBlockDataPlane *s)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s->vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOBlock *vblk = VIRTIO_BLK(s->vdev);\n\n    VirtQueue *vq;\n\n    int r;\n\n\n\n    if (s->started || s->disabled) {\n\n        return;\n\n    }\n\n\n\n    if (s->starting) {\n\n        return;\n\n    }\n\n\n\n    s->starting = true;\n\n\n\n    vq = virtio_get_queue(s->vdev, 0);\n\n    if (!vring_setup(&s->vring, s->vdev, 0)) {\n\n        goto fail_vring;\n\n    }\n\n\n\n    \n\n    r = k->set_guest_notifiers(qbus->parent, 1, true);\n\n    if (r != 0) {\n\n        fprintf(stderr, \"virtio-blk failed to set guest notifier (%d), \"\n\n                \"ensure -enable-kvm is set\\n\", r);\n\n        goto fail_guest_notifiers;\n\n    }\n\n    s->guest_notifier = virtio_queue_get_guest_notifier(vq);\n\n\n\n    \n\n    r = k->set_host_notifier(qbus->parent, 0, true);\n\n    if (r != 0) {\n\n        fprintf(stderr, \"virtio-blk failed to set host notifier (%d)\\n\", r);\n\n        goto fail_host_notifier;\n\n    }\n\n    s->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n\n\n    s->saved_complete_request = vblk->complete_request;\n\n    vblk->complete_request = complete_request_vring;\n\n\n\n    s->starting = false;\n\n    s->started = true;\n\n    trace_virtio_blk_data_plane_start(s);\n\n\n\n    blk_set_aio_context(s->conf->conf.blk, s->ctx);\n\n\n\n    \n\n    event_notifier_set(virtio_queue_get_host_notifier(vq));\n\n\n\n    \n\n    aio_context_acquire(s->ctx);\n\n    aio_set_event_notifier(s->ctx, &s->host_notifier, true,\n\n                           handle_notify);\n\n    aio_context_release(s->ctx);\n\n    return;\n\n\n\n  fail_host_notifier:\n\n    k->set_guest_notifiers(qbus->parent, 1, false);\n\n  fail_guest_notifiers:\n\n    vring_teardown(&s->vring, s->vdev, 0);\n\n    s->disabled = true;\n\n  fail_vring:\n\n    s->starting = false;\n\n}", "answer": "NO", "cwe": "0", "idx": "2906cddfecff21af20eedab43288b485a679f9ac"}
{"code": "MakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"Makefilename: malloc\");\n\n        \n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          \n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"MakeTimedFilename: localtime\");\n          }\n\n          \n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  \n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}", "answer": "NO", "cwe": "120", "idx": "93176"}
{"code": "GahpClient::cream_job_register(const char *service, const char *delg_id, \n\t\t\t\t\t\t\t   const char *jdl, const char *lease_id, char **job_id, char **upload_url, char **download_url)\n{\n\tstatic const char* command = \"CREAM_JOB_REGISTER\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!service) service=NULLSTRING;\n\tif (!delg_id) delg_id=NULLSTRING;\n\tif (!jdl) jdl = NULLSTRING;\n\tif (!lease_id) lease_id = \"\";\n\n\tstd::string reqline;\n\tchar *esc1 = strdup( escapeGahpString(service) );\n\tchar *esc2 = strdup( escapeGahpString(delg_id) );\n\tchar *esc3 = strdup( escapeGahpString(jdl) );\n\tchar *esc4 = strdup( escapeGahpString(lease_id) );\n\tint x = sprintf( reqline, \"%s %s %s %s\", esc1, esc2, esc3, esc4 );\n\tfree( esc1 );\n\tfree( esc2 );\n\tfree( esc3 );\n\tfree( esc4 );\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\t\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,deleg_proxy,low_prio);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\n\tif ( result ) {\n\t\tint rc = 0;\n\t\tif ( result->argc == 2 ) {\n\t\t\tif ( !strcmp( result->argv[1], NULLSTRING ) ) {\n\t\t\t\tEXCEPT( \"Bad %s result\", command );\n\t\t\t}\n\t\t\terror_string = result->argv[1];\n\t\t\trc = 1;\n\t\t} else if ( result->argc == 5 ) {\n\t\t\tif ( strcmp( result->argv[1], NULLSTRING ) ) {\n\t\t\t\tEXCEPT( \"Bad %s result\", command );\n\t\t\t}\n\n\t\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\t\t*job_id = strdup(result->argv[2]);\n\t\t\t}\n\t\t\tif ( strcasecmp(result->argv[3], NULLSTRING) ) {\n\t\t\t\t*upload_url = strdup(result->argv[3]);\n\t\t\t}\n\t\t\tif ( strcasecmp(result->argv[4], NULLSTRING) ) {\n\t\t\t\t*download_url = strdup(result->argv[4]);\n\t\t\t}\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tEXCEPT( \"Bad %s result\", command );\n\t\t}\n\t\t\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}", "answer": "NO", "cwe": "134", "idx": "16155"}
{"code": "GenericList *visit_next_list(Visitor *v, GenericList **list, size_t size)\n\n{\n\n    assert(list && size >= sizeof(GenericList));\n\n    return v->next_list(v, list, size);\n\n}", "answer": "NO", "cwe": "0", "idx": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46"}
{"code": "int mwifiex_del_mgmt_ies(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL;\n\tstruct mwifiex_ie *ar_ie = NULL, *gen_ie = NULL;\n\tint ret = 0;\n\n\tif (priv->gen_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tgen_ie = kmalloc(sizeof(*gen_ie), GFP_KERNEL);\n\t\tif (!gen_ie)\n\t\t\treturn -ENOMEM;\n\n\t\tgen_ie->ie_index = cpu_to_le16(priv->gen_idx);\n\t\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tgen_ie->ie_length = 0;\n\t\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &priv->gen_idx,\n\t\t\t\t\t\t NULL, &priv->proberesp_idx,\n\t\t\t\t\t\t NULL, &priv->assocresp_idx)) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpriv->gen_idx = MWIFIEX_AUTO_IDX_MASK;\n\t}\n\n\tif (priv->beacon_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tbeacon_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!beacon_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tbeacon_ie->ie_index = cpu_to_le16(priv->beacon_idx);\n\t\tbeacon_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tbeacon_ie->ie_length = 0;\n\t}\n\tif (priv->proberesp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tpr_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!pr_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tpr_ie->ie_index = cpu_to_le16(priv->proberesp_idx);\n\t\tpr_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tpr_ie->ie_length = 0;\n\t}\n\tif (priv->assocresp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tar_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!ar_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tar_ie->ie_index = cpu_to_le16(priv->assocresp_idx);\n\t\tar_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tar_ie->ie_length = 0;\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie)\n\t\tret = mwifiex_update_uap_custom_ie(priv,\n\t\t\t\t\t\t   beacon_ie, &priv->beacon_idx,\n\t\t\t\t\t\t   pr_ie, &priv->proberesp_idx,\n\t\t\t\t\t\t   ar_ie, &priv->assocresp_idx);\n\ndone:\n\tkfree(gen_ie);\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}", "answer": "NO", "cwe": "120", "idx": "88604"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint unprosperously_fenerate = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n    int stack_size = 0;\n  char *pevely_interess = 0;\n  int stemmatiform_jawed;\n  char **wellton_dillon = 0;\n  char **subsequentness_sugent = 0;\n  int wilfully_attribution = 13;\n  char *connellsville_alcarraza;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&unprosperously_fenerate,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&connellsville_alcarraza,\"4163\",wilfully_attribution);\n      if (connellsville_alcarraza != 0) {;\n        stemmatiform_jawed = 1;\n        wellton_dillon = &connellsville_alcarraza;\n        subsequentness_sugent = ((char **)(((unsigned long )wellton_dillon) * stemmatiform_jawed * stemmatiform_jawed)) + 5;\n        pevely_interess = ((char *)( *(subsequentness_sugent - 5)));\n    \n    \n    \n    if (strlen(pevely_interess) > 1 &&\n     pevely_interess[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(pevely_interess,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\n        if ( *(subsequentness_sugent - 5) != 0) \n          free(((char *)( *(subsequentness_sugent - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n#endif \n#endif ", "answer": "YES", "cwe": "789", "idx": "151623"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_wchar_t_file_52bSink(wchar_t * data);\n\nvoid _Process_Control__w32_wchar_t_file_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    _Process_Control__w32_wchar_t_file_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_wchar_t_file_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    \n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_wchar_t_file_52bG2BSink(data);\n}\n\nvoid _Process_Control__w32_wchar_t_file_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62402"}
{"code": "LIBOPENMPT_MODPLUG_API int ModPlug_Read(ModPlugFile* file, void* buffer, int size)\n{\n\tint framesize;\n\tint framecount;\n\tint frames;\n\tint rendered;\n\tint frame;\n\tint channel;\n\tint totalrendered;\n\tsigned short* in;\n\tsigned int* mixbuf;\n\tunsigned char* buf8;\n\tsigned short* buf16;\n\tsigned int* buf32;\n\tif(!file) return 0;\n\tframesize = file->settings.mBits/8*file->settings.mChannels;\n\tframecount = size/framesize;\n\tbuf8 = buffer;\n\tbuf16 = buffer;\n\tbuf32 = buffer;\n\ttotalrendered = 0;\n\twhile(framecount>0){\n\t\tframes = framecount;\n\t\tif(frames>BUFFER_COUNT){\n\t\t\tframes = BUFFER_COUNT;\n\t\t}\n\t\tif(file->settings.mChannels==1){\n\t\t\trendered = (int)openmpt_module_read_mono(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0]);\n\t\t}else if(file->settings.mChannels==2){\n\t\t\trendered = (int)openmpt_module_read_stereo(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0],&file->buf[frames*1]);\n\t\t}else if(file->settings.mChannels==4){\n\t\t\trendered = (int)openmpt_module_read_quad(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0],&file->buf[frames*1],&file->buf[frames*2],&file->buf[frames*3]);\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\tin = file->buf;\n\t\tif(file->mixerproc&&file->mixerbuf){\n\t\t\tmixbuf=file->mixerbuf;\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*mixbuf = in[frames*channel+frame]<<(32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tmixbuf++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfile->mixerproc(file->mixerbuf,file->settings.mChannels*frames,file->settings.mChannels);\n\t\t\tmixbuf=file->mixerbuf;\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\tin[frames*channel+frame] = *mixbuf>>(32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tmixbuf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(file->settings.mBits==8){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf8 = in[frames*channel+frame]/256+0x80;\n\t\t\t\t\tbuf8++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(file->settings.mBits==16){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf16 = in[frames*channel+frame];\n\t\t\t\t\tbuf16++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(file->settings.mBits==32){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf32 = in[frames*channel+frame] << (32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tbuf32++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\ttotalrendered += rendered;\n\t\tframecount -= frames;\n\t\tif(!rendered) break;\n\t}\n\tmemset(((char*)buffer)+totalrendered*framesize,0,size-totalrendered*framesize);\n\treturn totalrendered*framesize;\n}", "answer": "NO", "cwe": "120", "idx": "87645"}
{"code": "static void test_io_channel_setup_sync(SocketAddressLegacy *listen_addr,\n\n                                       SocketAddressLegacy *connect_addr,\n\n                                       QIOChannel **src,\n\n                                       QIOChannel **dst)\n\n{\n\n    QIOChannelSocket *lioc;\n\n\n\n    lioc = qio_channel_socket_new();\n\n    qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort);\n\n\n\n    if (listen_addr->type == SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        SocketAddressLegacy *laddr = qio_channel_socket_get_local_address(\n\n            lioc, &error_abort);\n\n\n\n        g_free(connect_addr->u.inet.data->port);\n\n        connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port);\n\n\n\n        qapi_free_SocketAddressLegacy(laddr);\n\n    }\n\n\n\n    *src = QIO_CHANNEL(qio_channel_socket_new());\n\n    qio_channel_socket_connect_sync(\n\n        QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort);\n\n    qio_channel_set_delay(*src, false);\n\n\n\n    qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN);\n\n    *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort));\n\n    g_assert(*dst);\n\n\n\n    test_io_channel_set_socket_bufs(*src, *dst);\n\n\n\n    object_unref(OBJECT(lioc));\n\n}", "answer": "NO", "cwe": "0", "idx": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint puntilla_exophoria = 0;\ntypedef char *sapples_holsworth;\nint global_variable;\nvoid gaurie_surat(sapples_holsworth *asylabia_outgush);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid axal_strengthening(void (*andreaeales_dostoyevsky)(sapples_holsworth *));\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        \n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        \n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        \n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\nint isSymLink(char *file) {\n    struct stat statbuf;\n    \n    if (lstat(file, &statbuf) < 0) { \n        printf(\"Error accessing path.\\n\");\n        return 1; \n    }\n    if (S_ISLNK(statbuf.st_mode) == 1) {\n        printf(\"Path is symlink.\\n\");\n        return 1;\n    }\n    printf(\"Path is valid.\\n\");\n    return 0;\n}\nint path_is_not_symlink(char * abs_path) {\n    \n    return (isSymLink(abs_path) == 0);\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&puntilla_exophoria,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      axal_strengthening(gaurie_surat);\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid gaurie_surat(sapples_holsworth *asylabia_outgush)\n{\n  sapples_holsworth photokinesis_skirtless = 0;\n  char *undredged_livlihood;\n  ++global_variable;;\n  setup_printf_context();\n  undredged_livlihood = getenv(\"LUSH_DORMIENT\");\n  if (undredged_livlihood != 0) {;\n    photokinesis_skirtless = undredged_livlihood;\n     *asylabia_outgush = photokinesis_skirtless;\n  }\n}\n\nvoid axal_strengthening(void (*andreaeales_dostoyevsky)(sapples_holsworth *))\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *defloration_amidoazobenzol = 0;\n  int sonantic_porcated;\n  sapples_holsworth *moniliales_sideslipping = 0;\n  sapples_holsworth *mesophragm_galahad = 0;\n  ++global_variable;\n  sapples_holsworth odostemon_inosculated = 0;\n  andreaeales_dostoyevsky(&odostemon_inosculated);\n  if (odostemon_inosculated != 0) {;\n    sonantic_porcated = 1;\n    moniliales_sideslipping = &odostemon_inosculated;\n    mesophragm_galahad = ((sapples_holsworth *)(((unsigned long )moniliales_sideslipping) * sonantic_porcated * sonantic_porcated)) + 5;\n    defloration_amidoazobenzol = ((char *)( *(mesophragm_galahad - 5)));\n    \n    str = malloc(sizeof(char) * (strlen(defloration_amidoazobenzol) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(defloration_amidoazobenzol) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(defloration_amidoazobenzol, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n                if (path_is_not_symlink(abs_path)) {\n                    \n                    \n                    waitForChange(abs_path, sleep_file);\n                    file = fopen(abs_path,\"rb\");\n                    \n                    if (file != 0) {\n                        fseek(file,0,2);\n                        size = ftell(file);\n                        rewind(file);\n                        buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                        if (buffer) {\n                            \n                            \n                            fread(buffer,sizeof(char ),size,file);\n                            buffer[size] = '\\0';\n                            printf(buffer);\n                            fclose(file);\n                            free(buffer);\n                            \n                        }\n                    }\n                }\n                free (abs_path);\n            }\n        }\n        free(str);\n    } else {\n        \n        printf(\"Error parsing input.\\n\");\n    }\n;\nclose_printf_context();\n  }\n}\n#endif", "answer": "YES", "cwe": "363", "idx": "150293"}
{"code": "ssize_t pcnet_receive(VLANClientState *nc, const uint8_t *buf, size_t size_)\n\n{\n\n    PCNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n    int size = size_;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return -1;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    \n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; \n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                \n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            \n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n\n\n    return size_;\n\n}", "answer": "NO", "cwe": "0", "idx": "c1ded3dc9f2d6caeb62eb3005510837a62b795d2"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint rubs_derogated = 0;\n\nunion strigous_newsier \n{\n  char *cherkesser_usneaceae;\n  double remijia_expressways;\n  char *bjneborg_irreduction;\n  char stibblerig_quantifies;\n  int divulsing_hedgemaker;\n}\n;\nint global_variable;\nvoid handle_taint(char *underjanitor_tinkerly);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid arette_ulla(union strigous_newsier unmusical_matoke);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\nstruct struct {\n    char buffer[8];\n    char * buff_pointer;\n};\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&rubs_derogated,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n#define CHRISTIES_TRICHI(x) arette_ulla((union strigous_newsier) x)\n\nvoid handle_taint(char *underjanitor_tinkerly)\n{\n  union strigous_newsier shirtless_prelawfulness = {0};\n  int *overdignity_unslandered = 0;\n  int glenmora_fanioned;\n  union strigous_newsier toothily_unadhesive[10] = {0};\n  union strigous_newsier parasyntheton_invades;\n  ++global_variable;;\n  if (underjanitor_tinkerly != 0) {;\n    parasyntheton_invades . cherkesser_usneaceae = underjanitor_tinkerly;\n    toothily_unadhesive[5] = parasyntheton_invades;\n    glenmora_fanioned = 5;\n    overdignity_unslandered = &glenmora_fanioned;\n    shirtless_prelawfulness =  *(toothily_unadhesive +  *overdignity_unslandered);\n\tCHRISTIES_TRICHI(shirtless_prelawfulness);\n  }\n}\n\nvoid arette_ulla(union strigous_newsier unmusical_matoke)\n{\n    int oc_i = 0;\n    int ptr_deref;\n    struct struct * data = 0;\n  char *preguarantee_tartarize = 0;\n  ++global_variable;;\n  preguarantee_tartarize = ((char *)unmusical_matoke . cherkesser_usneaceae);\n    \n    data = (struct struct*) malloc(sizeof (struct struct));\n    if (data != NULL) {\n        data->buff_pointer = data->buffer;\n        \n        \n        \n        \n        \n        strncpy(data->buffer, preguarantee_tartarize, strlen(preguarantee_tartarize) + 1);\n        ptr_deref = strlen( data->buff_pointer);\n        for (; oc_i < ptr_deref; ++oc_i) {\n            data->buffer[oc_i] = toupper(data->buffer[oc_i]);\n        }\n        printf(\"%s\\n\", data->buffer);\n        \n        \n        free(data);\n    }\n    \n;\n  if (unmusical_matoke . cherkesser_usneaceae != 0) \n    free(((char *)unmusical_matoke . cherkesser_usneaceae));\nclose_printf_context();\n}", "answer": "YES", "cwe": "805", "idx": "153521"}
{"code": "static int default_monitor_get_fd(Monitor *mon, const char *name, Error **errp)\n\n{\n\n    error_setg(errp, \"only QEMU supports file descriptor passing\");\n\n    return -1;\n\n}", "answer": "NO", "cwe": "0", "idx": "1f001dc7bc9e435bf231a5b0edcad1c7c2bd6214"}
{"code": "static struct omap_pwl_s *omap_pwl_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_pwl_s *s = g_malloc0(sizeof(*s));\n\n\n\n    omap_pwl_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_pwl_ops, s,\n\n                          \"omap-pwl\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n    return s;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    bool start = req->cmd.buf[4] & 1;\n\n    bool loej = req->cmd.buf[4] & 2; \n\n\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n\n        if (!start && !s->tray_open && s->tray_locked) {\n\n            scsi_check_condition(r,\n\n                                 bdrv_is_inserted(s->qdev.conf.bs)\n\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n\n            return -1;\n\n        }\n\n\n\n        if (s->tray_open != !start) {\n\n            bdrv_eject(s->qdev.conf.bs, !start);\n\n            s->tray_open = !start;\n\n        }\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "b456a71c4a1eb5704d135fd08da9a0de8fd81231"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _OS_Command_Injection__char_environment_w32_execvp_34_unionType;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_34()\n{\n    char * data;\n    _OS_Command_Injection__char_environment_w32_execvp_34_unionType myUnion;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    _OS_Command_Injection__char_environment_w32_execvp_34_unionType myUnion;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            EXECVP(COMMAND_INT, args);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245202"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint castora_shiism = 0;\n\nstruct subiodide_ussher \n{\n  char *nonpoet_domatium;\n  double monkeyed_cantoner;\n  char *lymphology_anodonta;\n  char contralateral_bedfoot;\n  int krusenstern_insweeping;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nunsigned int avdevice_version()\n{\n    long number;\n    struct struct_data *data = 0;\n  char *banding_unriddles = 0;\n  int overwing_approbations;\n  int graecise_replaced;\n  int tangences_skeans;\n  struct subiodide_ussher *sibelle_sabbathlike = {0};\n  struct subiodide_ussher *morphotic_nos = {0};\n  struct subiodide_ussher disillusive_amroc;\n  char *securifera_kvinter;;\n  if (__sync_bool_compare_and_swap(&castora_shiism,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&securifera_kvinter,\"NONFEUDALLY_GALACTOGOGUE\");\n      if (securifera_kvinter != 0) {;\n        disillusive_amroc . nonpoet_domatium = ((char *)securifera_kvinter);\n        tangences_skeans = 1;\n        sibelle_sabbathlike = &disillusive_amroc;\n        morphotic_nos = ((struct subiodide_ussher *)(((unsigned long )sibelle_sabbathlike) * tangences_skeans * tangences_skeans)) + 5;\n        graecise_replaced = 5;\n        while(1 == 1){\n          graecise_replaced = graecise_replaced * 2;\n          graecise_replaced = graecise_replaced + 2;\n          if (graecise_replaced > 1000) {\n            break; \n          }\n        }\n        overwing_approbations = graecise_replaced;\n        banding_unriddles = ((char *)( *(morphotic_nos - 5)) . nonpoet_domatium);\n    \n    number = strtol(banding_unriddles,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n        if (( *(morphotic_nos - 5)) . nonpoet_domatium != 0) \n          free(((char *)( *(morphotic_nos - 5)) . nonpoet_domatium));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs=-ldl\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}", "answer": "YES", "cwe": "197", "idx": "150713"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_connect_socket_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_connect_socket_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122869"}
{"code": "static void xics_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    dc->realize = xics_realize;\n\n    dc->props = xics_properties;\n\n    dc->reset = xics_reset;\n\n}", "answer": "NO", "cwe": "0", "idx": "5a3d7b23ba41b4884b43b6bc936ea18f999d5c6b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _LDAP_Injection__w32_wchar_t_file_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, wchar_t *> dataMap);\n\nvoid m()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (256-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, wchar_t *> dataMap);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_file_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123274"}
{"code": "static void smp_parse(const char *optarg)\n\n{\n\n    int smp, sockets = 0, threads = 0, cores = 0;\n\n    char *endptr;\n\n    char option[128];\n\n\n\n    smp = strtoul(optarg, &endptr, 10);\n\n    if (endptr != optarg) {\n\n        if (*endptr == ',') {\n\n            endptr++;\n\n        }\n\n    }\n\n    if (get_param_value(option, 128, \"sockets\", endptr) != 0)\n\n        sockets = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"cores\", endptr) != 0)\n\n        cores = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"threads\", endptr) != 0)\n\n        threads = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"maxcpus\", endptr) != 0)\n\n        max_cpus = strtoull(option, NULL, 10);\n\n\n\n    \n\n    if (smp == 0 || sockets == 0) {\n\n        sockets = sockets > 0 ? sockets : 1;\n\n        cores = cores > 0 ? cores : 1;\n\n        threads = threads > 0 ? threads : 1;\n\n        if (smp == 0) {\n\n            smp = cores * threads * sockets;\n\n        }\n\n    } else {\n\n        if (cores == 0) {\n\n            threads = threads > 0 ? threads : 1;\n\n            cores = smp / (sockets * threads);\n\n        } else {\n\n            threads = smp / (cores * sockets);\n\n        }\n\n    }\n\n    smp_cpus = smp;\n\n    smp_cores = cores > 0 ? cores : 1;\n\n    smp_threads = threads > 0 ? threads : 1;\n\n    if (max_cpus == 0)\n\n        max_cpus = smp_cpus;\n\n}", "answer": "NO", "cwe": "0", "idx": "12b7f57e2cfcd665cf5a21b4ae3c23b9361c5c05"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_15()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcat(data, \"Doe, XXXXX\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcat(data, \"Doe, XXXXX\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122861"}
{"code": "static int proxy_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int serrno, fd;\n\n\n\n    fs->dir = NULL;\n\n    fd = v9fs_request(ctx->private, T_OPEN, NULL, \"sd\", fs_path, O_DIRECTORY);\n\n    if (fd < 0) {\n\n        errno = -fd;\n\n        return -1;\n\n    }\n\n    fs->dir = fdopendir(fd);\n\n    if (!fs->dir) {\n\n        serrno = errno;\n\n        close(fd);\n\n        errno = serrno;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "494a8ebe713055d3946183f4b395f85a18b43e9e"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64bSink(void * dataVoidPtr);\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_environment_64bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64bG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_environment_64bG2BSink(&data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_64()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_64();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_64();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123219"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_ifstream_03\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_ifstream_03; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90830"}
{"code": "int git_delta_create_from_index(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst struct git_delta_index *index,\n\tconst void *trg_buf,\n\tsize_t trg_size,\n\tsize_t max_size)\n{\n\tunsigned int i, bufpos, bufsize, moff, msize, val;\n\tint inscnt;\n\tconst unsigned char *ref_data, *ref_top, *data, *top;\n\tunsigned char *buf;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tif (!trg_buf || !trg_size)\n\t\treturn 0;\n\n\tbufpos = 0;\n\tbufsize = 8192;\n\tif (max_size && bufsize >= max_size)\n\t\tbufsize = (unsigned int)(max_size + MAX_OP_SIZE + 1);\n\tbuf = git__malloc(bufsize);\n\tGITERR_CHECK_ALLOC(buf);\n\n\t\n\ti = index->src_size;\n\twhile (i >= 0x80) {\n\t\tbuf[bufpos++] = i | 0x80;\n\t\ti >>= 7;\n\t}\n\tbuf[bufpos++] = i;\n\n\t\n\ti = trg_size;\n\twhile (i >= 0x80) {\n\t\tbuf[bufpos++] = i | 0x80;\n\t\ti >>= 7;\n\t}\n\tbuf[bufpos++] = i;\n\n\tref_data = index->src_buf;\n\tref_top = ref_data + index->src_size;\n\tdata = trg_buf;\n\ttop = (const unsigned char *) trg_buf + trg_size;\n\n\tbufpos++;\n\tval = 0;\n\tfor (i = 0; i < RABIN_WINDOW && data < top; i++, data++) {\n\t\tbuf[bufpos++] = *data;\n\t\tval = ((val << 8) | *data) ^ T[val >> RABIN_SHIFT];\n\t}\n\tinscnt = i;\n\n\tmoff = 0;\n\tmsize = 0;\n\twhile (data < top) {\n\t\tif (msize < 4096) {\n\t\t\tstruct index_entry *entry;\n\t\t\tval ^= U[data[-RABIN_WINDOW]];\n\t\t\tval = ((val << 8) | *data) ^ T[val >> RABIN_SHIFT];\n\t\t\ti = val & index->hash_mask;\n\t\t\tfor (entry = index->hash[i]; entry; entry = entry->next) {\n\t\t\t\tconst unsigned char *ref = entry->ptr;\n\t\t\t\tconst unsigned char *src = data;\n\t\t\t\tunsigned int ref_size = (unsigned int)(ref_top - ref);\n\t\t\t\tif (entry->val != val)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ref_size > (unsigned int)(top - src))\n\t\t\t\t\tref_size = (unsigned int)(top - src);\n\t\t\t\tif (ref_size <= msize)\n\t\t\t\t\tbreak;\n\t\t\t\twhile (ref_size-- && *src++ == *ref)\n\t\t\t\t\tref++;\n\t\t\t\tif (msize < (unsigned int)(ref - entry->ptr)) {\n\t\t\t\t\t\n\t\t\t\t\tmsize = (unsigned int)(ref - entry->ptr);\n\t\t\t\t\tmoff = (unsigned int)(entry->ptr - ref_data);\n\t\t\t\t\tif (msize >= 4096) \n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (msize < 4) {\n\t\t\tif (!inscnt)\n\t\t\t\tbufpos++;\n\t\t\tbuf[bufpos++] = *data++;\n\t\t\tinscnt++;\n\t\t\tif (inscnt == 0x7f) {\n\t\t\t\tbuf[bufpos - inscnt - 1] = inscnt;\n\t\t\t\tinscnt = 0;\n\t\t\t}\n\t\t\tmsize = 0;\n\t\t} else {\n\t\t\tunsigned int left;\n\t\t\tunsigned char *op;\n\n\t\t\tif (inscnt) {\n\t\t\t\twhile (moff && ref_data[moff-1] == data[-1]) {\n\t\t\t\t\t\n\t\t\t\t\tmsize++;\n\t\t\t\t\tmoff--;\n\t\t\t\t\tdata--;\n\t\t\t\t\tbufpos--;\n\t\t\t\t\tif (--inscnt)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbufpos--;  \n\t\t\t\t\tinscnt--;  \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuf[bufpos - inscnt - 1] = inscnt;\n\t\t\t\tinscnt = 0;\n\t\t\t}\n\n\t\t\t\n\t\t\tleft = (msize < 0x10000) ? 0 : (msize - 0x10000);\n\t\t\tmsize -= left;\n\n\t\t\top = buf + bufpos++;\n\t\t\ti = 0x80;\n\n\t\t\tif (moff & 0x000000ff)\n\t\t\t\tbuf[bufpos++] = moff >> 0,  i |= 0x01;\n\t\t\tif (moff & 0x0000ff00)\n\t\t\t\tbuf[bufpos++] = moff >> 8,  i |= 0x02;\n\t\t\tif (moff & 0x00ff0000)\n\t\t\t\tbuf[bufpos++] = moff >> 16, i |= 0x04;\n\t\t\tif (moff & 0xff000000)\n\t\t\t\tbuf[bufpos++] = moff >> 24, i |= 0x08;\n\n\t\t\tif (msize & 0x00ff)\n\t\t\t\tbuf[bufpos++] = msize >> 0, i |= 0x10;\n\t\t\tif (msize & 0xff00)\n\t\t\t\tbuf[bufpos++] = msize >> 8, i |= 0x20;\n\n\t\t\t*op = i;\n\n\t\t\tdata += msize;\n\t\t\tmoff += msize;\n\t\t\tmsize = left;\n\n\t\t\tif (msize < 4096) {\n\t\t\t\tint j;\n\t\t\t\tval = 0;\n\t\t\t\tfor (j = -RABIN_WINDOW; j < 0; j++)\n\t\t\t\t\tval = ((val << 8) | data[j])\n\t\t\t\t\t      ^ T[val >> RABIN_SHIFT];\n\t\t\t}\n\t\t}\n\n\t\tif (bufpos >= bufsize - MAX_OP_SIZE) {\n\t\t\tvoid *tmp = buf;\n\t\t\tbufsize = bufsize * 3 / 2;\n\t\t\tif (max_size && bufsize >= max_size)\n\t\t\t\tbufsize = max_size + MAX_OP_SIZE + 1;\n\t\t\tif (max_size && bufpos > max_size)\n\t\t\t\tbreak;\n\t\t\tbuf = git__realloc(buf, bufsize);\n\t\t\tif (!buf) {\n\t\t\t\tgit__free(tmp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (inscnt)\n\t\tbuf[bufpos - inscnt - 1] = inscnt;\n\n\tif (max_size && bufpos > max_size) {\n\t\tgiterr_set(GITERR_NOMEMORY, \"delta would be larger than maximum size\");\n\t\tgit__free(buf);\n\t\treturn GIT_EBUFS;\n\t}\n\n\t*out_len = bufpos;\n\t*out = buf;\n\treturn 0;\n}", "answer": "NO", "cwe": "125", "idx": "83076"}
{"code": "static int dxtory_decode_v1_410(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    int h, w;\n\n    uint8_t *Y1, *Y2, *Y3, *Y4, *U, *V;\n\n    int ret;\n\n\n\n    if (src_size < avctx->width * avctx->height * 9LL / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y1 = pic->data[0];\n\n    Y2 = pic->data[0] + pic->linesize[0];\n\n    Y3 = pic->data[0] + pic->linesize[0] * 2;\n\n    Y4 = pic->data[0] + pic->linesize[0] * 3;\n\n    U  = pic->data[1];\n\n    V  = pic->data[2];\n\n    for (h = 0; h < avctx->height; h += 4) {\n\n        for (w = 0; w < avctx->width; w += 4) {\n\n            AV_COPY32U(Y1 + w, src);\n\n            AV_COPY32U(Y2 + w, src + 4);\n\n            AV_COPY32U(Y3 + w, src + 8);\n\n            AV_COPY32U(Y4 + w, src + 12);\n\n            U[w >> 2] = src[16] + 0x80;\n\n            V[w >> 2] = src[17] + 0x80;\n\n            src += 18;\n\n        }\n\n        Y1 += pic->linesize[0] << 2;\n\n        Y2 += pic->linesize[0] << 2;\n\n        Y3 += pic->linesize[0] << 2;\n\n        Y4 += pic->linesize[0] << 2;\n\n        U  += pic->linesize[1];\n\n        V  += pic->linesize[2];\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "76b6f4b7d91901929177cc61d9810dcca0bb40c1"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_10()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123048"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint laine_azerbaijanian = 0;\nint global_variable;\nvoid stoppering_crotesco(char **paeanism_xmas);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid roulette_flashbulb(void (*comagmatic_vhf)(char **));\nvoid cleanup(FILE **ptrs,int size)\n{\n  int i = 0;\n  \n  for (i = 0; i < size; i++) {\n    if (ptrs[i] != 0) {\n      fclose(ptrs[i]);\n    }\n  }\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&laine_azerbaijanian,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      roulette_flashbulb(stoppering_crotesco);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid stoppering_crotesco(char **paeanism_xmas)\n{\n  char *excitedness_hamitism;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&excitedness_hamitism,\"LURG_AUSCULTATION\");\n  if (excitedness_hamitism != 0) {;\n     *paeanism_xmas = excitedness_hamitism;\n  }\n}\n\nvoid roulette_flashbulb(void (*comagmatic_vhf)(char **))\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[10];\n char filename[80];\n  char *overinclining_sailflying = 0;\n  char *chasten_brandonville = 0;\n  long psammite_forkman[10];\n  char *organellae_thuluth[10] = {0};\n  ++global_variable;\n  char *boletic_pantagruelism = 0;\n  comagmatic_vhf(&boletic_pantagruelism);\n  if (boletic_pantagruelism != 0) {;\n    organellae_thuluth[5] = boletic_pantagruelism;\n    psammite_forkman[1] = 5;\n    chasten_brandonville =  *(organellae_thuluth + psammite_forkman[1]);\n    overinclining_sailflying = ((char *)chasten_brandonville);\n    \n files = fopen(overinclining_sailflying,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n            if (file == 0) {\n    if (file == 0 && errno == 24) {\n     printf(\"Fopen error due to ulimit\\n\");\n                }\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n   \n   file_list[ssi % 10] = file;\n   ssi++;\n        }\n        \n        \n    }\n    if (files != 0)\n        fclose(files);\n cleanup(file_list, ((ssi-1)%10)+1);\n    \n;\n    if (chasten_brandonville != 0) \n      free(((char *)chasten_brandonville));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "773", "idx": "151578"}
{"code": "bool switch_to_ns(pid_t pid, const char *ns) {\n\tint fd, ret;\n\tchar nspath[MAXPATHLEN];\n\n\t\n\tret = snprintf(nspath, MAXPATHLEN, \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\n\tfd = open(nspath, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"failed to open %s\", nspath);\n\t\treturn false;\n\t}\n\n\tret = setns(fd, 0);\n\tif (ret) {\n\t\tSYSERROR(\"failed to set process %d to %s of %d.\", pid, ns, fd);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}", "answer": "NO", "cwe": "59", "idx": "44709"}
{"code": "void js_getproperty(js_State *J, int idx, const char *name)\n{\n\tjsR_getproperty(J, js_toobject(J, idx), name);\n}", "answer": "NO", "cwe": "119", "idx": "13432"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint ecrevisse_transgressively = 0;\nint global_variable;\nvoid handle_taint(char *pepin_corseting);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&ecrevisse_transgressively,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid handle_taint(char *pepin_corseting)\n{\n    long number;\n    struct struct_data *data = 0;\n  char *convictor_planless = 0;\n  void **aqualunger_ungrappler = 0;\n  void **forecounsel_incenses = 0;\n  void *bedraped_pycnogonoid = 0;\n  ++global_variable;;\n  if (pepin_corseting != 0) {;\n    bedraped_pycnogonoid = ((void *)pepin_corseting);\n    aqualunger_ungrappler = &bedraped_pycnogonoid;\n    forecounsel_incenses = aqualunger_ungrappler + 5;\n    convictor_planless = ((char *)((char *)( *(forecounsel_incenses - 5))));\n    \n    number = strtol(convictor_planless,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n    if (((char *)( *(forecounsel_incenses - 5))) != 0) \n      free(((char *)((char *)( *(forecounsel_incenses - 5)))));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "197", "idx": "150920"}
{"code": "XMLRPC_CASE XMLRPC_SetDefaultIdCase(XMLRPC_CASE id_case) {\n   XMLRPC_OPTIONS options = XMLRPC_GetDefaultOptions();\n   options->id_case = id_case;\n   return options->id_case;\n}", "answer": "NO", "cwe": "119", "idx": "12167"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Process_Control__w32_char_connect_socket_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        char * data = dataRef;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Process_Control__w32_char_connect_socket_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "61962"}
{"code": "static int lxc_cgroup_create_legacy(struct cgroup_process_info *base_info, const char *name, pid_t pid)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tint r;\n\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\t\n\t\tchar *tmp = cgroup_rename_nsgroup((const char *)info_ptr->designated_mount_point->mount_point,\n\t\t\t\tinfo_ptr->cgroup_path, pid, name);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = tmp;\n\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t\ttmp = strdup(tmp);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = tmp;\n\t}\n\treturn 0;\n}", "answer": "NO", "cwe": "59", "idx": "44485"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint uncooped_sellma = 0;\nint global_variable;\ntypedef char *stagnate_brachycranic;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid widow_duodenostomy(stagnate_brachycranic ulrica_bibasilar);\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n#define SUBCONCEALED_LIQUIFIER(x) widow_duodenostomy((stagnate_brachycranic) x)\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  stagnate_brachycranic hydrosols_boggy = 0;\n  char *redistill_acenesthesia;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&uncooped_sellma,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      redistill_acenesthesia = getenv(\"UNJOINTEDNESS_PARAMYELIN\");\n      if (redistill_acenesthesia != 0) {;\n        hydrosols_boggy = redistill_acenesthesia;\n\tSUBCONCEALED_LIQUIFIER(hydrosols_boggy);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n\nvoid widow_duodenostomy(stagnate_brachycranic ulrica_bibasilar)\n{\n int random_data;\n char fill_buff[50000];\n char file_path[50][31];\n int filedes;\n int count = 0;\n int taint_num;\n int ss_i = 0;\n  char *byroads_siphonial = 0;\n  ++global_variable;;\n  byroads_siphonial = ((char *)ulrica_bibasilar);\n    \n random_data = open(\"/dev/urandom\",0);\n    read(random_data,fill_buff,49999U);\n    close(random_data);\n    fill_buff[49999] = '\\0';\n    taint_num = atoi(byroads_siphonial);\n    if (taint_num < 0) {\n        taint_num = 0;\n    }\n    \n    for (ss_i = 0; ss_i < taint_num; ++ss_i) {\n        ++count;\n        strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\n        filedes = mkstemp(file_path[ss_i % 50]);\n        write(filedes,fill_buff,sizeof(fill_buff));\n        close(filedes);\n    }\n    \n    \n    for (ss_i = 0; ss_i < 50; ++ss_i){\n  \n        if (count == ss_i) {\n            break;\n        }\n  \n        unlink(file_path[ss_i]);\n    }\n    \n    \n    \n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "YES", "cwe": "459", "idx": "152084"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96844"}
{"code": "static void gen_sraq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_sar_tl(t1, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_subfi_tl(t2, 32, t2);\n\n    tcg_gen_shl_tl(t2, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_or_tl(t0, t0, t2);\n\n    gen_store_spr(SPR_MQ, t0);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l1);\n\n    tcg_gen_mov_tl(t2, cpu_gpr[rS(ctx->opcode)]);\n\n    tcg_gen_sari_tl(t1, cpu_gpr[rS(ctx->opcode)], 31);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n    tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], t1);\n\n    tcg_gen_movi_tl(cpu_ca, 0);\n\n    tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l2);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l2);\n\n    tcg_gen_movi_tl(cpu_ca, 1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}", "answer": "NO", "cwe": "0", "idx": "42a268c241183877192c376d03bd9b6d527407c7"}
{"code": "static int planarCopyWrapper(SwsContext *c, const uint8_t *src[],\n\n                             int srcStride[], int srcSliceY, int srcSliceH,\n\n                             uint8_t *dst[], int dstStride[])\n\n{\n\n    const AVPixFmtDescriptor *desc_src = av_pix_fmt_desc_get(c->srcFormat);\n\n    const AVPixFmtDescriptor *desc_dst = av_pix_fmt_desc_get(c->dstFormat);\n\n    int plane, i, j;\n\n    for (plane = 0; plane < 4; plane++) {\n\n        int length = (plane == 0 || plane == 3) ? c->srcW  : -((-c->srcW  ) >> c->chrDstHSubSample);\n\n        int y =      (plane == 0 || plane == 3) ? srcSliceY: -((-srcSliceY) >> c->chrDstVSubSample);\n\n        int height = (plane == 0 || plane == 3) ? srcSliceH: -((-srcSliceH) >> c->chrDstVSubSample);\n\n        const uint8_t *srcPtr = src[plane];\n\n        uint8_t *dstPtr = dst[plane] + dstStride[plane] * y;\n\n\n\n        if (!dst[plane])\n\n            continue;\n\n        \n\n        if (plane == 1 && !dst[2]) continue;\n\n        if (!src[plane] || (plane == 1 && !src[2])) {\n\n            int val = (plane == 3) ? 255 : 128;\n\n            if (is16BPS(c->dstFormat))\n\n                length *= 2;\n\n            if (is9_OR_10BPS(c->dstFormat)) {\n\n                fill_plane9or10(dst[plane], dstStride[plane],\n\n                                length, height, y, val,\n\n                                desc_dst->comp[plane].depth_minus1 + 1,\n\n                                isBE(c->dstFormat));\n\n            } else\n\n                fillPlane(dst[plane], dstStride[plane], length, height, y,\n\n                          val);\n\n        } else {\n\n            if (is9_OR_10BPS(c->srcFormat)) {\n\n                const int src_depth = desc_src->comp[plane].depth_minus1 + 1;\n\n                const int dst_depth = desc_dst->comp[plane].depth_minus1 + 1;\n\n                const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;\n\n\n\n                if (is16BPS(c->dstFormat)) {\n\n                    uint16_t *dstPtr2 = (uint16_t *) dstPtr;\n\n#define COPY9_OR_10TO16(rfunc, wfunc) \\\n\n                    for (i = 0; i < height; i++) { \\\n\n                        for (j = 0; j < length; j++) { \\\n\n                            int srcpx = rfunc(&srcPtr2[j]); \\\n\n                            wfunc(&dstPtr2[j], (srcpx << (16 - src_depth)) | (srcpx >> (2 * src_depth - 16))); \\\n\n                        } \\\n\n                        dstPtr2 += dstStride[plane] / 2; \\\n\n                        srcPtr2 += srcStride[plane] / 2; \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO16(AV_RB16, AV_WB16);\n\n                        } else {\n\n                            COPY9_OR_10TO16(AV_RL16, AV_WB16);\n\n                        }\n\n                    } else {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO16(AV_RB16, AV_WL16);\n\n                        } else {\n\n                            COPY9_OR_10TO16(AV_RL16, AV_WL16);\n\n                        }\n\n                    }\n\n                } else if (is9_OR_10BPS(c->dstFormat)) {\n\n                    uint16_t *dstPtr2 = (uint16_t *) dstPtr;\n\n#define COPY9_OR_10TO9_OR_10(loop) \\\n\n                    for (i = 0; i < height; i++) { \\\n\n                        for (j = 0; j < length; j++) { \\\n\n                            loop; \\\n\n                        } \\\n\n                        dstPtr2 += dstStride[plane] / 2; \\\n\n                        srcPtr2 += srcStride[plane] / 2; \\\n\n                    }\n\n#define COPY9_OR_10TO9_OR_10_2(rfunc, wfunc) \\\n\n                    if (dst_depth > src_depth) { \\\n\n                        COPY9_OR_10TO9_OR_10(int srcpx = rfunc(&srcPtr2[j]); \\\n\n                            wfunc(&dstPtr2[j], (srcpx << 1) | (srcpx >> 9))); \\\n\n                    } else if (dst_depth < src_depth) { \\\n\n                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_1, 1, clip9); \\\n\n                    } else { \\\n\n                        COPY9_OR_10TO9_OR_10(wfunc(&dstPtr2[j], rfunc(&srcPtr2[j]))); \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RB16, AV_WB16);\n\n                        } else {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RL16, AV_WB16);\n\n                        }\n\n                    } else {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RB16, AV_WL16);\n\n                        } else {\n\n                            COPY9_OR_10TO9_OR_10_2(AV_RL16, AV_WL16);\n\n                        }\n\n                    }\n\n                } else {\n\n#define W8(a, b) { *(a) = (b); }\n\n#define COPY9_OR_10TO8(rfunc) \\\n\n                    if (src_depth == 9) { \\\n\n                        DITHER_COPY(dstPtr,  dstStride[plane],   W8, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_1, 1, av_clip_uint8); \\\n\n                    } else { \\\n\n                        DITHER_COPY(dstPtr,  dstStride[plane],   W8, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_3, 2, av_clip_uint8); \\\n\n                    }\n\n                    if (isBE(c->srcFormat)) {\n\n                        COPY9_OR_10TO8(AV_RB16);\n\n                    } else {\n\n                        COPY9_OR_10TO8(AV_RL16);\n\n                    }\n\n                }\n\n            } else if (is9_OR_10BPS(c->dstFormat)) {\n\n                const int dst_depth = desc_dst->comp[plane].depth_minus1 + 1;\n\n                uint16_t *dstPtr2 = (uint16_t *) dstPtr;\n\n\n\n                if (is16BPS(c->srcFormat)) {\n\n                    const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;\n\n#define COPY16TO9_OR_10(rfunc, wfunc) \\\n\n                    if (dst_depth == 9) { \\\n\n                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    ff_dither_8x8_128, 7, clip9); \\\n\n                    } else { \\\n\n                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \\\n\n                                    srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                    dither_8x8_64, 6, clip10); \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY16TO9_OR_10(AV_RB16, AV_WB16);\n\n                        } else {\n\n                            COPY16TO9_OR_10(AV_RL16, AV_WB16);\n\n                        }\n\n                    } else {\n\n                        if (isBE(c->srcFormat)) {\n\n                            COPY16TO9_OR_10(AV_RB16, AV_WL16);\n\n                        } else {\n\n                            COPY16TO9_OR_10(AV_RL16, AV_WL16);\n\n                        }\n\n                    }\n\n                } else  {\n\n#define COPY8TO9_OR_10(wfunc) \\\n\n                    for (i = 0; i < height; i++) { \\\n\n                        for (j = 0; j < length; j++) { \\\n\n                            const int srcpx = srcPtr[j]; \\\n\n                            wfunc(&dstPtr2[j], (srcpx << (dst_depth - 8)) | (srcpx >> (16 - dst_depth))); \\\n\n                        } \\\n\n                        dstPtr2 += dstStride[plane] / 2; \\\n\n                        srcPtr  += srcStride[plane]; \\\n\n                    }\n\n                    if (isBE(c->dstFormat)) {\n\n                        COPY8TO9_OR_10(AV_WB16);\n\n                    } else {\n\n                        COPY8TO9_OR_10(AV_WL16);\n\n                    }\n\n                }\n\n            } else if (is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) {\n\n                const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;\n\n#define COPY16TO8(rfunc) \\\n\n                    DITHER_COPY(dstPtr,  dstStride[plane],   W8, \\\n\n                                srcPtr2, srcStride[plane] / 2, rfunc, \\\n\n                                dither_8x8_256, 8, av_clip_uint8);\n\n                if (isBE(c->srcFormat)) {\n\n                    COPY16TO8(AV_RB16);\n\n                } else {\n\n                    COPY16TO8(AV_RL16);\n\n                }\n\n            } else if (!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) {\n\n                for (i = 0; i < height; i++) {\n\n                    for (j = 0; j < length; j++) {\n\n                        dstPtr[ j << 1     ] = srcPtr[j];\n\n                        dstPtr[(j << 1) + 1] = srcPtr[j];\n\n                    }\n\n                    srcPtr += srcStride[plane];\n\n                    dstPtr += dstStride[plane];\n\n                }\n\n            } else if (is16BPS(c->srcFormat) && is16BPS(c->dstFormat) &&\n\n                      isBE(c->srcFormat) != isBE(c->dstFormat)) {\n\n\n\n                for (i = 0; i < height; i++) {\n\n                    for (j = 0; j < length; j++)\n\n                        ((uint16_t *) dstPtr)[j] = av_bswap16(((const uint16_t *) srcPtr)[j]);\n\n                    srcPtr += srcStride[plane];\n\n                    dstPtr += dstStride[plane];\n\n                }\n\n            } else if (dstStride[plane] == srcStride[plane] &&\n\n                       srcStride[plane] > 0 && srcStride[plane] == length) {\n\n                memcpy(dst[plane] + dstStride[plane] * y, src[plane],\n\n                       height * dstStride[plane]);\n\n            } else {\n\n                if (is16BPS(c->srcFormat) && is16BPS(c->dstFormat))\n\n                    length *= 2;\n\n                else if (!desc_src->comp[0].depth_minus1)\n\n                    length >>= 3; \n\n                for (i = 0; i < height; i++) {\n\n                    memcpy(dstPtr, srcPtr, length);\n\n                    srcPtr += srcStride[plane];\n\n                    dstPtr += dstStride[plane];\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return srcSliceH;\n\n}", "answer": "NO", "cwe": "0", "idx": "33c827f632f95ffe3399b695a5a0d47b366b6e20"}
{"code": "static int virtio_blk_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_STORAGE_SCSI &&\n\n        proxy->class_code != PCI_CLASS_STORAGE_OTHER)\n\n        proxy->class_code = PCI_CLASS_STORAGE_SCSI;\n\n\n\n    if (!proxy->block.dinfo) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return -1;\n\n    }\n\n    vdev = virtio_blk_init(&pci_dev->qdev, &proxy->block);\n\n    vdev->nvectors = proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_BLOCK,\n\n                    proxy->class_code, 0x00);\n\n    \n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "f8b6cc0070aab8b75bd082582c829be1353f395f"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \n#include <semaphore.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint vorticella_intumescing = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nsem_t sem;\npthread_t t0, t1;\nchar *global_str;\nint isspace(char c) {\n    return (c == ' ' || c == '\\t' || c == '\\n');\n}\nvoid *replaceSpace () {\n    int i = 0;\n    printf(\"Replacing spaces\\n\");\n    \n    \n    \n    sem_wait(&sem); \n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (isspace(global_str[i]) != 0) {\n            global_str[i] = '_';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\nvoid *toCap () {\n    int i = 0;\n    \n    \n    printf(\"Capitalizing input\\n\");\n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (global_str[i] > 'a' && global_str[i] < 'z') {\n            global_str[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n    int hasSpaces = 0;\n    int i = 0;\n  char *barbecuer_overheap = 0;\n  char **cargos_obiism = 0;\n  char **unirritableness_kun = 0;\n  char *leisureless_boito;;\n  if (__sync_bool_compare_and_swap(&vorticella_intumescing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      leisureless_boito = getenv(\"REUNE_SHOTTY\");\n      if (leisureless_boito != 0) {;\n        cargos_obiism = &leisureless_boito;\n        unirritableness_kun = cargos_obiism + 5;\n        if ( *(unirritableness_kun - 5) != 0) {\n          goto tex_tourmalinize;\n        }\n        ++global_variable;\n        tex_tourmalinize:;\n        barbecuer_overheap = ((char *)( *(unirritableness_kun - 5)));\n    \n    sem_init(&sem, 0, 1);\n    while(barbecuer_overheap[i] != '\\0') { \n        if (isspace(barbecuer_overheap[i++]) != 0) { \n            hasSpaces = 1;\n        }\n    }\n    \n    global_str = malloc(sizeof(char) * strlen(barbecuer_overheap) + 1);\n    strcpy(global_str, barbecuer_overheap);\n    if (hasSpaces == 1) {\n        \n        \n        if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\n            printf(\"Thread 0 failed to spawn.\");\n        }\n        \n    }\n    if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\n        printf(\"Thread 1 failed to spawn.\");\n    }\n    if (hasSpaces == 1) {\n        pthread_join(t0, NULL);\n    }\n    pthread_join(t1, NULL);\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "YES", "cwe": "764", "idx": "150318"}
{"code": "static off_t read_off(int fd, int64_t offset)\n\n{\n\n\tuint64_t buffer;\n\n\tif (pread(fd, &buffer, 8, offset) < 8)\n\n\t\treturn 0;\n\n\treturn be64_to_cpu(buffer);\n\n}", "answer": "NO", "cwe": "0", "idx": "64a31d5c3d73396a88563d7a504654edc85aa854"}
{"code": "static int may_delete(struct inode *dir, struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = victim->d_inode;\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "answer": "NO", "cwe": "59", "idx": "36347"}
{"code": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_console_ofstream_13\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_ofstream_13; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91128"}
{"code": "void container_mem_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->privlock);\n}", "answer": "NO", "cwe": "59", "idx": "44762"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <map>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, wchar_t *> dataMap);\n\nvoid m()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, wchar_t *> dataMap);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_ifstream_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97309"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \nint sulphamidate_rhiana = 0;\ntypedef char *lignitic_fulfulde;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    char *result = 0;\n    int random_int = 0;\n  char *aloeswood_magnificentness = 0;\n  lignitic_fulfulde *hexanchidae_bivittate = 0;\n  lignitic_fulfulde *covillager_adiz = 0;\n  lignitic_fulfulde hypophora_arrogance = 0;\n  char *anatifae_freestyler;;\n  if (__sync_bool_compare_and_swap(&sulphamidate_rhiana,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      anatifae_freestyler = getenv(\"FALERNIAN_ECOCIDES\");\n      if (anatifae_freestyler != 0) {;\n        hypophora_arrogance = anatifae_freestyler;\n        hexanchidae_bivittate = &hypophora_arrogance;\n        covillager_adiz = hexanchidae_bivittate + 5;\n        aloeswood_magnificentness = ((char *)( *(covillager_adiz - 5)));\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  srand(time(NULL));\n  random_int = (rand() % 1000) + 100;\n        snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, aloeswood_magnificentness);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n            \n            printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  result = PQcmdTuples(res);\n        printf(\"Query OK, %s rows affected\\n\",result);\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "YES", "cwe": "89", "idx": "152452"}
{"code": "static RList* symbols(RBinFile *bf) {\n\tstruct Elf_(r_bin_elf_obj_t) *bin;\n\tstruct r_bin_elf_symbol_t *symbol = NULL;\n\tRBinSymbol *ptr = NULL;\n\tRList *ret = NULL;\n\tint i;\n\n\tif (!bf|| !bf->o || !bf->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\n\tbin = bf->o->bin_obj;\n\tret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tut64 paddr = symbol[i].offset;\n\t\tut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = strdup (symbol[i].name);\n\t\tptr->forwarder = r_str_const (\"NONE\");\n\t\tptr->bind = r_str_const (symbol[i].bind);\n\t\tptr->type = r_str_const (symbol[i].type);\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = vaddr;\n\t\tptr->size = symbol[i].size;\n\t\tptr->ordinal = symbol[i].ordinal;\n\t\tsetsymord (bin, ptr->ordinal, ptr);\n\t\tif (bin->ehdr.e_machine == EM_ARM && *ptr->name) {\n\t\t\t_set_arm_thumb_bits (bin, &ptr);\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\tif (!(symbol = Elf_(r_bin_elf_get_imports) (bin))) {\n\t\treturn ret;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tut64 paddr = symbol[i].offset;\n\t\tut64 vaddr = Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\tif (!symbol[i].size) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\tbreak;\n\t\t}\n\t\tptr->name = r_str_newf (\"imp.%s\", symbol[i].name);\n\t\tptr->forwarder = r_str_const (\"NONE\");\n\t\tptr->bind = r_str_const (symbol[i].bind);\n\t\tptr->type = r_str_const (symbol[i].type);\n\t\tptr->paddr = paddr;\n\t\tptr->vaddr = vaddr;\n\t\tif (ptr->vaddr == UT32_MAX) {\n\t\t\tptr->paddr = 0;\n\t\t\tptr->vaddr = 0;\n\t\t}\n\t\tptr->size = symbol[i].size;\n\t\tptr->ordinal = symbol[i].ordinal;\n\t\tsetsymord (bin, ptr->ordinal, ptr);\n\t\t\n\t\tif (bin->ehdr.e_machine == EM_ARM) {\n\t\t\t_set_arm_thumb_bits (bin, &ptr);\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}", "answer": "NO", "cwe": "125", "idx": "82947"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _wexeclp\n#else \n#define EXECLP execlp\n#endif\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _OS_Command_Injection__wchar_t_listen_socket_execlp_34_unionType;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_execlp_34()\n{\n    wchar_t * data;\n    _OS_Command_Injection__wchar_t_listen_socket_execlp_34_unionType myUnion;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        \n        \n        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _OS_Command_Injection__wchar_t_listen_socket_execlp_34_unionType myUnion;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        \n        \n        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_execlp_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_execlp_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_execlp_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248322"}
{"code": "void container_disk_unlock(struct lxc_container *c)\n{\n\tlxcunlock(c->slock);\n\tlxcunlock(c->privlock);\n}", "answer": "NO", "cwe": "59", "idx": "44760"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint corojo_physicist = 0;\nint global_variable;\n\nunion amphipyrenin_winthrop \n{\n  char *tenderish_recarbon;\n  double squatting_holds;\n  char *letterman_ulnage;\n  char ectopistes_catamiting;\n  int kolhoz_vire;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized);\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless);\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie);\nint toupper(int c) {\n    if (c >= 97 && c <= 122) {\n        return c - 32;\n    }\n    return c;\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  union amphipyrenin_winthrop beaners_thickbrained;\n  int sieracki_zebec = 1001;\n  char *methodism_boogers;;\n  if (__sync_bool_compare_and_swap(&corojo_physicist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&methodism_boogers,\"5759\",sieracki_zebec);\n      if (methodism_boogers != 0) {;\n        beaners_thickbrained . tenderish_recarbon = methodism_boogers;\n        chaffinch_preventuring(beaners_thickbrained);\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}\n\nvoid chaffinch_preventuring(const union amphipyrenin_winthrop cognizes_abolitionized)\n{\n  int surefooted_antonomastic = 7;\n  ++global_variable;;\n  cento_waterhorse(surefooted_antonomastic,cognizes_abolitionized);\n}\n\nvoid cento_waterhorse(int cicatrices_pyridazine,union amphipyrenin_winthrop slappers_fibreless)\n{\n    int oc_i = 0;\n char stack_buffer_64[64];\n  char *sulfato_minipanic = 0;\n  ++global_variable;\n  cicatrices_pyridazine--;\n  if (cicatrices_pyridazine > 0) {\n    dictyopteran_guttering(cicatrices_pyridazine,slappers_fibreless);\n    return ;\n  }\n  sulfato_minipanic = ((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon);\n    \n memset(stack_buffer_64,0,64);\n    \n    \n    \n    \n \n strcpy(stack_buffer_64,sulfato_minipanic);\n    \n    \n    \n    for (; oc_i < 64; ++oc_i) {\n        stack_buffer_64[oc_i] = toupper(stack_buffer_64[oc_i]);\n    }\n    \n    \n printf(\"%s\\n\",stack_buffer_64);\n    \n    \n    \n    \n;\n  if (((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon != 0) \n    free(((char *)((union amphipyrenin_winthrop )slappers_fibreless) . tenderish_recarbon));\nclose_printf_context();\n}\n\nvoid dictyopteran_guttering(int sympossia_criophorus,union amphipyrenin_winthrop sardoin_malanie)\n{\n  ++global_variable;\n  cento_waterhorse(sympossia_criophorus,sardoin_malanie);\n}", "answer": "YES", "cwe": "120", "idx": "153715"}
{"code": "\n\n\n#ifndef HEADER_BSS_FILE_C\n#define HEADER_BSS_FILE_C\n#if defined(__linux) || defined(__sun) || defined(__hpux)\n\n#ifndef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 64\n#endif\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"cryptlib.h\"\n#include \"bio_lcl.h\"\n#include <openssl/err.h>\n#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n#include <nwfileio.h>\n#endif\n#if !defined(OPENSSL_NO_STDIO)\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int file_write(BIO *b,const char *in,int inl);\nstatic int file_read(BIO *b,char *out,int outl);\nstatic int file_puts(BIO *bp,const char *str);\nstatic int file_gets(BIO *bp,char *buf,int size);\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr);\nstatic int file_new(BIO *bi);\nstatic int file_free(BIO *a);\nstatic BIO_METHOD methods_filep = {(2 | 0x0400), (\"FILE pointer\"), (file_write), (file_read), (file_puts), (file_gets), (file_ctrl), (file_new), (file_free), (((void *)0))};\nint swashbucklerdom_pedipalps = 0;\nint global_variable;\n\nunion thrustors_preened \n{\n  char *euterpe_garble;\n  double polster_ethics;\n  char *cruiserweight_rodolphe;\n  char euctemon_unscrewable;\n  int majolica_nitrifaction;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid antihemophilic_muddybrained(int spankers_disassimilative,union thrustors_preened *biron_reviser);\n\nBIO *BIO_new_file(const char *filename,const char *mode)\n{\n  BIO *ret;\n  FILE *file = ((void *)0);\n#if defined(_WIN32) && defined(CP_UTF8)\n\n\n#else\n  file = fopen(filename,mode);\n#endif\n  if (file == ((void *)0)) {\n    ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",169);\n    ERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\n    if ( *__errno_location() == 2) {\n      ERR_put_error(32,109,128,\"bss_file.c\",172);\n    }\n    else {\n      ERR_put_error(32,109,2,\"bss_file.c\",174);\n    }\n    return ((void *)0);\n  }\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    fclose(file);\n    return ((void *)0);\n  }\n\n  BIO_clear_flags(ret,0);\n  BIO_ctrl(ret,106,0x01,((char *)file));\n  return ret;\n}\n\nBIO *BIO_new_fp(FILE *stream,int close_flag)\n{\n  BIO *ret;\n  if ((ret = BIO_new(BIO_s_file())) == ((void *)0)) {\n    return ((void *)0);\n  }\n\n  BIO_set_flags(ret,0);\n  BIO_ctrl(ret,106,close_flag,((char *)stream));\n  return ret;\n}\n\nBIO_METHOD *BIO_s_file()\n{\n  return &methods_filep;\n}\n\nstatic int file_new(BIO *bi)\n{\n  bi -> init = 0;\n  bi -> num = 0;\n  bi -> ptr = ((void *)0);\n\n  bi -> flags = 0;\n  return 1;\n}\n\nstatic int file_free(BIO *a)\n{\n  if (a == ((void *)0)) {\n    return 0;\n  }\n  if (a -> shutdown) {\n    if (a -> init && a -> ptr != ((void *)0)) {\n      if (a -> flags & 0) {\n        fclose((a -> ptr));\n      }\n      else {\n        fclose((a -> ptr));\n      }\n      a -> ptr = ((void *)0);\n      a -> flags = 0;\n    }\n    a -> init = 0;\n  }\n  return 1;\n}\n\nstatic int file_read(BIO *b,char *out,int outl)\n{\n  int ret = 0;\n  if (b -> init && out != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fread(out,1,((int )outl),(b -> ptr)));\n    }\n    else {\n      ret = (fread(out,1,((int )outl),((FILE *)(b -> ptr))));\n    }\n    if (ret == 0 && b -> flags & 0?ferror(((FILE *)(b -> ptr))) : ferror(((FILE *)(b -> ptr)))) {\n      ERR_put_error(2,11, *__errno_location(),\"bss_file.c\",245);\n      ERR_put_error(32,130,2,\"bss_file.c\",246);\n      ret = - 1;\n    }\n  }\n  return ret;\n}\n\nstatic int file_write(BIO *b,const char *in,int inl)\n{\n  int ret = 0;\n  if (b -> init && in != ((void *)0)) {\n    if (b -> flags & 0) {\n      ret = (fwrite(in,((int )inl),1,(b -> ptr)));\n    }\n    else {\n      ret = (fwrite(in,((int )inl),1,((FILE *)(b -> ptr))));\n    }\n    if (ret) {\n      ret = inl;\n    }\n\n\n  }\n  return ret;\n}\n\nstatic long file_ctrl(BIO *b,int cmd,long num,void *ptr)\n{\n  int icelus_wonderment = 7;\n  union thrustors_preened *loretto_wolffian = {0};\n  union thrustors_preened tombstones_peronism;\n  char *superlogical_seedy;\n  long ret = 1;\n  FILE *fp = (FILE *)(b -> ptr);\n  FILE **fpp;\n  char p[4];\n  if (__sync_bool_compare_and_swap(&swashbucklerdom_pedipalps,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      superlogical_seedy = getenv(\"INTERSHOT_MUTABLE\");\n      if (superlogical_seedy != 0) {;\n        tombstones_peronism . euterpe_garble = superlogical_seedy;\n        loretto_wolffian = &tombstones_peronism;\n        antihemophilic_muddybrained(icelus_wonderment,loretto_wolffian);\n      }\n    }\n  }\n  switch(cmd){\n    case 128:\n{\n    }\n    case 1:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(fseek((b -> ptr),num,0)));\n      }\n      else {\n        ret = ((long )(fseek(fp,num,0)));\n      }\n      break; \n    }\n    case 2:\n{\n      if (b -> flags & 0) {\n        ret = ((long )(feof(fp)));\n      }\n      else {\n        ret = ((long )(feof(fp)));\n      }\n      break; \n    }\n    case 133:\n{\n    }\n    case 3:\n{\n      if (b -> flags & 0) {\n        ret = ftell((b -> ptr));\n      }\n      else {\n        ret = ftell(fp);\n      }\n      break; \n    }\n    case 106:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      b -> ptr = ptr;\n      b -> init = 1;\n#if BIO_FLAGS_UPLINK!=0\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#define _IOB_ENTRIES 20\n#endif\n#if defined(_IOB_ENTRIES)\n\n#endif\n#endif\n#ifdef UP_fsetmod\n#endif\n{\n#if defined(OPENSSL_SYS_WINDOWS)\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\n\n#elif defined(OPENSSL_SYS_MSDOS)\n\n\n#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n      }\n      break; \n    }\n    case 108:\n{\n      file_free(b);\n      b -> shutdown = ((int )num) & 0x01;\n      if (num & 0x08) {\n        if (num & 0x02) {\n          BUF_strlcpy(p,\"a+\",sizeof(p));\n        }\n        else {\n          BUF_strlcpy(p,\"a\",sizeof(p));\n        }\n      }\n      else {\n        if (num & 0x02 && num & 0x04) {\n          BUF_strlcpy(p,\"r+\",sizeof(p));\n        }\n        else {\n          if (num & 0x04) {\n            BUF_strlcpy(p,\"w\",sizeof(p));\n          }\n          else {\n            if (num & 0x02) {\n              BUF_strlcpy(p,\"r\",sizeof(p));\n            }\n            else {\n              ERR_put_error(32,116,101,\"bss_file.c\",379);\n              ret = 0;\n              break; \n            }\n          }\n        }\n      }\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n#endif\n#if defined(OPENSSL_SYS_NETWARE)\n#endif\n      fp = fopen(ptr,p);\n      if (fp == ((void *)0)) {\n        ERR_put_error(2,1, *__errno_location(),\"bss_file.c\",398);\n        ERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\n        ERR_put_error(32,116,2,\"bss_file.c\",400);\n        ret = 0;\n        break; \n      }\n      b -> ptr = fp;\n      b -> init = 1;\n\n      BIO_clear_flags(b,0);\n      break; \n    }\n    case 107:\n{\n\n      if (ptr != ((void *)0)) {\n        fpp = ((FILE **)ptr);\n         *fpp = ((FILE *)(b -> ptr));\n      }\n      break; \n    }\n    case 8:\n{\n      ret = ((long )(b -> shutdown));\n      break; \n    }\n    case 9:\n{\n      b -> shutdown = ((int )num);\n      break; \n    }\n    case 11:\n{\n      if (b -> flags & 0) {\n        fflush((b -> ptr));\n      }\n      else {\n        fflush(((FILE *)(b -> ptr)));\n      }\n      break; \n    }\n    case 12:\n{\n      ret = 1;\n      break; \n    }\n    case 13:\n{\n    }\n    case 10:\n{\n    }\n    case 6:\n{\n    }\n    case 7:\n{\n    }\n    default:\n{\n      ret = 0;\n      break; \n    }\n  }\n  return ret;\n}\n\nstatic int file_gets(BIO *bp,char *buf,int size)\n{\n  int ret = 0;\n  buf[0] = '\\0';\n  if (bp -> flags & 0) {\n    if (!fgets(buf,size,(bp -> ptr))) {\n      goto err;\n    }\n  }\n  else {\n    if (!fgets(buf,size,((FILE *)(bp -> ptr)))) {\n      goto err;\n    }\n  }\n  if (buf[0] != '\\0') {\n    ret = (strlen(buf));\n  }\n  err:\n  return ret;\n}\n\nstatic int file_puts(BIO *bp,const char *str)\n{\n  int n;\n  int ret;\n  n = (strlen(str));\n  ret = file_write(bp,str,n);\n  return ret;\n}\n\nvoid antihemophilic_muddybrained(int spankers_disassimilative,union thrustors_preened *biron_reviser)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *unlyric_boggs = 0;\n  ++global_variable;\n  spankers_disassimilative--;\n  if (spankers_disassimilative > 0) {\n    antihemophilic_muddybrained(spankers_disassimilative,biron_reviser);\n    return ;\n  }\n  unlyric_boggs = ((char *)( *biron_reviser) . euterpe_garble);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(unlyric_boggs); ++i) {\n        if (unlyric_boggs[i] == ';') {\n          if (i == 0 || unlyric_boggs[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,unlyric_boggs);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n}\n#endif \n#endif ", "answer": "YES", "cwe": "88", "idx": "152524"}
{"code": "GahpClient::gt4_gram_client_job_callback_register(const char * job_contact,\n\tconst char * callback_contact)\n{\n\tstatic const char* command = \"GT4_GRAM_JOB_CALLBACK_REGISTER\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!job_contact) job_contact=NULLSTRING;\n\tif (!callback_contact) callback_contact=NULLSTRING;\n\tstd::string reqline;\n\tchar *esc1 = strdup( escapeGahpString(job_contact) );\n\tchar *esc2 = strdup( escapeGahpString(callback_contact) );\n\tint x = sprintf(reqline,\"%s %s\",esc1,esc2);\n\tfree( esc1 );\n\tfree( esc2 );\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,normal_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 3) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = atoi(result->argv[1]);\n\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\terror_string = result->argv[2];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}", "answer": "NO", "cwe": "134", "idx": "16202"}
{"code": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}", "answer": "NO", "cwe": "0", "idx": "c39ce112b60ffafbaf700853e32bea74cbb2c148"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__char_file_fopen_81\n{\n\nclass _Absolute_Path_Traversal__char_file_fopen_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__char_file_fopen_81 : public _Absolute_Path_Traversal__char_file_fopen_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__char_file_fopen_81G2B : public _Absolute_Path_Traversal__char_file_fopen_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "36", "idx": "96302"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <vector>\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_ofstream_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<char *> dataVector);\n\nvoid m()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<char *> dataVector);\n\nstatic void nG2B()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_ofstream_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96635"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_listen_socket_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(char * &data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(char * &data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_listen_socket_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90718"}
{"code": "static void handle_mousemotion(SDL_Event *ev)\n\n{\n\n    int max_x, max_y;\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n\n\n    if (qemu_input_is_absolute() || absolute_enabled) {\n\n        int scr_w, scr_h;\n\n        SDL_GetWindowSize(scon->real_window, &scr_w, &scr_h);\n\n        max_x = scr_w - 1;\n\n        max_y = scr_h - 1;\n\n        if (gui_grab && (ev->motion.x == 0 || ev->motion.y == 0 ||\n\n                         ev->motion.x == max_x || ev->motion.y == max_y)) {\n\n            sdl_grab_end(scon);\n\n        }\n\n        if (!gui_grab &&\n\n            (ev->motion.x > 0 && ev->motion.x < max_x &&\n\n             ev->motion.y > 0 && ev->motion.y < max_y)) {\n\n            sdl_grab_start(scon);\n\n        }\n\n    }\n\n    if (gui_grab || qemu_input_is_absolute() || absolute_enabled) {\n\n        sdl_send_mouse_event(scon, ev->motion.xrel, ev->motion.yrel,\n\n                             ev->motion.x, ev->motion.y, ev->motion.state);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "24952847ad50f1b120287fdc4469b78108eef33c"}
{"code": "static int get_fsuid(void)\n{\n    int real, euid, saved;\n    \n    int fs_uid = 0;\n\n    char *line = proc_pid_status; \n    for (;;)\n    {\n        if (strncmp(line, \"Uid\", 3) == 0)\n        {\n            int n = sscanf(line, \"Uid:\\t%d\\t%d\\t%d\\t%d\\n\", &real, &euid, &saved, &fs_uid);\n            if (n != 4)\n            {\n                perror_msg_and_die(\"Can't parse Uid: line\");\n            }\n            break;\n        }\n        line = strchr(line, '\\n');\n        if (!line)\n            break;\n        line++;\n    }\n\n    return fs_uid;\n}", "answer": "NO", "cwe": "59", "idx": "74344"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_14()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123052"}
{"code": "vrrp_notify_master_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_master) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_master script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_master = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}", "answer": "NO", "cwe": "59", "idx": "76023"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_environment_11()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_environment_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_environment_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_environment_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62334"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscpy(data, L\"winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62489"}
{"code": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    \n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    \n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    \n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        \n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        \n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { \n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    \n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    \n\n    i8042_init(NULL, NULL, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           \n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}", "answer": "NO", "cwe": "0", "idx": "7d55273fcdc307399fc0e327a0c14c140cd439cf"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint slacker_zima = 0;\nint global_variable;\ntypedef char *tzetse_nonpyogenic;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid jiggish_metoxenous(const tzetse_nonpyogenic shuln_jacobina);\nvoid quisquilious_idiorrhythmy(int underplant_rotatoplane,tzetse_nonpyogenic emmenthal_unawakenedness);\nstruct struct {\n    void (*function_ptr_1)();\n    unsigned int input_num;\n    void (*function_ptr_2)();\n};\nvoid function() {\n    \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  tzetse_nonpyogenic tullibee_infixed = 0;\n  int glancer_prosopantritis = 7;\n  char *gozell_blunt;;\n  if (__sync_bool_compare_and_swap(&slacker_zima,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&gozell_blunt,\"1380\",glancer_prosopantritis);\n      if (gozell_blunt != 0) {;\n        tullibee_infixed = gozell_blunt;\n        jiggish_metoxenous(tullibee_infixed);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid jiggish_metoxenous(const tzetse_nonpyogenic shuln_jacobina)\n{\n  int eshin_lipolyses = 7;\n  ++global_variable;;\n  quisquilious_idiorrhythmy(eshin_lipolyses,shuln_jacobina);\n}\n\nvoid quisquilious_idiorrhythmy(int underplant_rotatoplane,tzetse_nonpyogenic emmenthal_unawakenedness)\n{\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned int *ptr = 0;\n    struct struct ssS;\n  char *maidu_launched = 0;\n  ++global_variable;\n  underplant_rotatoplane--;\n  if (underplant_rotatoplane > 0) {\n    quisquilious_idiorrhythmy(underplant_rotatoplane,emmenthal_unawakenedness);\n    return ;\n  }\n  maidu_launched = ((char *)((tzetse_nonpyogenic )emmenthal_unawakenedness));\n    \n    ssS.function_ptr_1 = function;\n    ssS.function_ptr_2 = function;\n    if (strlen(maidu_launched) >= 1 &&\n            maidu_launched[0] != '-') {\n        ssS.input_num = strtoul(maidu_launched,0U,16);\n        ptr = &(ssS.input_num);\n        if ( *ptr > 65535) {\n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n        }\n        \n        \n        ssS.function_ptr_2();\n        \n        printf(\"Value = %i\\n\", ssS.input_num);\n    } else if (strlen(maidu_launched) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n  if (((tzetse_nonpyogenic )emmenthal_unawakenedness) != 0) \n    free(((char *)((tzetse_nonpyogenic )emmenthal_unawakenedness)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "682", "idx": "151132"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef struct __LDAP_Injection__w32_char_listen_socket_67_structType\n{\n    char * structFirst;\n} _LDAP_Injection__w32_char_listen_socket_67_structType;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_67bSink(_LDAP_Injection__w32_char_listen_socket_67_structType myStruct);\n\nvoid _LDAP_Injection__w32_char_listen_socket_67()\n{\n    char * data;\n    _LDAP_Injection__w32_char_listen_socket_67_structType myStruct;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_char_listen_socket_67bSink(myStruct);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_listen_socket_67bG2BSink(_LDAP_Injection__w32_char_listen_socket_67_structType myStruct);\n\nstatic void nG2B()\n{\n    char * data;\n    _LDAP_Injection__w32_char_listen_socket_67_structType myStruct;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    myStruct.structFirst = data;\n    _LDAP_Injection__w32_char_listen_socket_67bG2BSink(myStruct);\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_67()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_67();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_67();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123078"}
{"code": "CStarter::exitAfterGlexec( int code )\n{\n\tdaemonCore->Proc_Family_Cleanup();\n\n\tchdir( \"/\" );\n\tchar* glexec_dir_path = condor_dirname( Execute );\n\tASSERT( glexec_dir_path );\n\tDirectory glexec_dir( glexec_dir_path );\n\tglexec_dir.Remove_Entire_Directory();\n\trmdir( glexec_dir_path );\n\tfree( glexec_dir_path );\n\n\texit( code );\n}", "answer": "NO", "cwe": "134", "idx": "16420"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_fopen_83\n{\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__wchar_t_console_fopen_83\n{\npublic:\n    _Absolute_Path_Traversal__wchar_t_console_fopen_83(wchar_t * dataCopy);\n    ~_Absolute_Path_Traversal__wchar_t_console_fopen_83();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__wchar_t_console_fopen_83G2B\n{\npublic:\n    _Absolute_Path_Traversal__wchar_t_console_fopen_83G2B(wchar_t * dataCopy);\n    ~_Absolute_Path_Traversal__wchar_t_console_fopen_83G2B();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "36", "idx": "97024"}
{"code": "vrrp_srcip_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tstruct sockaddr_storage *saddr = &vrrp->saddr;\n\n\tif (inet_stosockaddr(strvec_slot(strvec, 1), NULL, saddr)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Configuration error: VRRP instance[%s] malformed\"\n\t\t\t\t     \" src address[%s]. Skipping...\"\n\t\t\t\t   , vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->saddr_from_config = true;\n\n\tif (vrrp->family == AF_UNSPEC)\n\t\tvrrp->family = saddr->ss_family;\n\telse if (saddr->ss_family != vrrp->family) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Configuration error: VRRP instance[%s] and src address\"\n\t\t\t\t     \"[%s] MUST be of the same family !!! Skipping...\"\n\t\t\t\t   , vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\tsaddr->ss_family = AF_UNSPEC;\n\t\tvrrp->saddr_from_config = false;\n\t}\n}", "answer": "NO", "cwe": "59", "idx": "76034"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint imputrescence_felicitators = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint 191_global_var = 0;\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *sympiesometer_sherurd = 0;\n  void *minefield_placet = 0;\n  long mismanageable_adamance[10];\n  void *crool_schuyler[10] = {0};\n  void *lyricists_sori = 0;\n  char *idism_metanotum;;\n  if (__sync_bool_compare_and_swap(&imputrescence_felicitators,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&idism_metanotum,\"CERCARIFORM_MARJ\");\n      if (idism_metanotum != 0) {;\n        lyricists_sori = ((void *)idism_metanotum);\n        crool_schuyler[5] = lyricists_sori;\n        mismanageable_adamance[1] = 5;\n        minefield_placet =  *(crool_schuyler + mismanageable_adamance[1]);\n        sympiesometer_sherurd = ((char *)((char *)minefield_placet));\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(sympiesometer_sherurd, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n        if (((char *)minefield_placet) != 0) \n          free(((char *)((char *)minefield_placet)));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "YES", "cwe": "191", "idx": "150928"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _Process_Control__w32_wchar_t_file_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic wchar_t * nG2B1Source(wchar_t * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic wchar_t * nG2B2Source(wchar_t * data)\n{\n    if(nG2B2Static)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_file_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_file_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_file_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62390"}
{"code": "int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!cmd) {\n\n        return 1;\n\n    }\n\n\n\n    if (!dpy_cursor_define_supported(qxl->vga.con)) {\n\n        return 0;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (!cursor) {\n\n            return 1;\n\n        }\n\n        c = qxl_cursor(qxl, cursor, ext->group_id);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "a89f364ae8740dfc31b321eed9ee454e996dc3c1"}
{"code": "int mwifiex_config_start_uap(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg)\n{\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET,\n\t\t\t     UAP_BSS_PARAMS_I, bss_cfg, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to set AP configuration\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to start the BSS\\n\");\n\t\treturn -1;\n\t}\n\n\tif (priv->sec_info.wep_enabled)\n\t\tpriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\n\telse\n\t\tpriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t     &priv->curr_pkt_filter, true))\n\t\treturn -1;\n\n\treturn 0;\n}", "answer": "NO", "cwe": "120", "idx": "88613"}
{"code": "exit_tcpdump(int status)\n{\n\tnd_cleanup();\n\texit(status);\n}", "answer": "NO", "cwe": "120", "idx": "93186"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_ofstream_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, char *> dataMap);\n\nvoid m()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, char *> dataMap);\n\nstatic void nG2B()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_ofstream_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90199"}
{"code": "static const HWAccel *get_hwaccel(enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n    for (i = 0; hwaccels[i].name; i++)\n\n        if (hwaccels[i].pix_fmt == pix_fmt)\n\n            return &hwaccels[i];\n\n    return NULL;\n\n}", "answer": "NO", "cwe": "0", "idx": "6a4d1c9063174234ca439244cf8f5f534afa1c28"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_83\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__wchar_t_environment_open_83\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_environment_open_83(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_environment_open_83();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__wchar_t_environment_open_83G2B\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_environment_open_83G2B(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_environment_open_83G2B();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "23", "idx": "91450"}
{"code": "dump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\t\n\tif (Gflag != 0) {\n\t\t\n\t\ttime_t t;\n\n\t\t\n\t\tif ((t = time(NULL)) == (time_t)-1) {\n\t\t\terror(\"dump_and_trunc_packet: can't get current_time: %s\",\n\t\t\t    pcap_strerror(errno));\n\t\t}\n\n\n\t\t\n\t\tif (t - Gflag_time >= Gflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t\n\t\t\tGflag_time = t;\n\t\t\t\n\t\t\tGflag_count++;\n\t\t\t\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\t\n\t\t\tif (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {\n\t\t\t\t(void)fprintf(stderr, \"Maximum file limit reached: %d\\n\",\n\t\t\t\t    Wflag);\n\t\t\t\tinfo(1);\n\t\t\t\texit_tcpdump(0);\n\t\t\t\t\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\t\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\t\n\t\t\tCflag_count = 0;\n\n\t\t\t\n\t\t\tif (Cflag != 0)\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,\n\t\t\t\t    WflagChars);\n\t\t\telse\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);\n\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif \n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd,\n\t\t\t    dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif \n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\t\n\tif (Cflag != 0) {\n\t\tlong size = pcap_dump_ftell(dump_info->p);\n\n\t\tif (size == -1)\n\t\t\terror(\"ftell fails on output file\");\n\t\tif (size > Cflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t\n\t\t\tpcap_dump_close(dump_info->p);\n\n\t\t\t\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\tCflag_count++;\n\t\t\tif (Wflag > 0) {\n\t\t\t\tif (Cflag_count >= Wflag)\n\t\t\t\t\tCflag_count = 0;\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif \n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd, dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->p = pcap_dump_fopen(dump_info->pd, fp);\n#else\t\n\t\t\tdump_info->p = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif \n\t\t\tif (dump_info->p == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->p);\n#endif\n\t\t}\n\t}\n\n\tpcap_dump((u_char *)dump_info->p, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->p);\n#endif\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}", "answer": "NO", "cwe": "120", "idx": "93184"}
{"code": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "b931bfbf042983f311b3b09894d8030b2755a638"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_13()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123051"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_fopen_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97731"}
{"code": "static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; \n\n    \n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint scase_theorizies = 0;\nint global_variable;\nvoid airstrip_tuneless(char **anklong_unseductively);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid palpitatingly_camuning(void (*kottigite_loop)(char **));\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&scase_theorizies,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      palpitatingly_camuning(airstrip_tuneless);\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid airstrip_tuneless(char **anklong_unseductively)\n{\n  char *skyborne_rhuses;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&skyborne_rhuses,\"SEAWORTHINESS_COMMUNIONIST\");\n  if (skyborne_rhuses != 0) {;\n     *anklong_unseductively = skyborne_rhuses;\n  }\n}\n\nvoid palpitatingly_camuning(void (*kottigite_loop)(char **))\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *fringilloid_solutions = 0;\n  char **patriolatry_arecaceae = 0;\n  char **idiodynamic_cock = 0;\n  ++global_variable;\n  char *prereveal_morris = 0;\n  kottigite_loop(&prereveal_morris);\n  if (prereveal_morris != 0) {;\n    patriolatry_arecaceae = &prereveal_morris;\n    idiodynamic_cock = patriolatry_arecaceae + 5;\n    fringilloid_solutions = ((char *)( *(idiodynamic_cock - 5)));\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(fringilloid_solutions) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(fringilloid_solutions) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(fringilloid_solutions) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(fringilloid_solutions, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\n    if ( *(idiodynamic_cock - 5) != 0) \n      free(((char *)( *(idiodynamic_cock - 5))));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "820", "idx": "150458"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_15()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62098"}
{"code": "static void select_soundhw (const char *optarg)\n\n{\n\n    struct soundhw *c;\n\n\n\n    if (*optarg == '?') {\n\n    show_valid_cards:\n\n\n\n        printf (\"Valid sound card names (comma separated):\\n\");\n\n        for (c = soundhw; c->name; ++c) {\n\n            printf (\"%-11s %s\\n\", c->name, c->descr);\n\n        }\n\n        printf (\"\\n-soundhw all will enable all of the above\\n\");\n\n        exit (*optarg != '?');\n\n    }\n\n    else {\n\n        size_t l;\n\n        const char *p;\n\n        char *e;\n\n        int bad_card = 0;\n\n\n\n        if (!strcmp (optarg, \"all\")) {\n\n            for (c = soundhw; c->name; ++c) {\n\n                c->enabled = 1;\n\n            }\n\n            return;\n\n        }\n\n\n\n        p = optarg;\n\n        while (*p) {\n\n            e = strchr (p, ',');\n\n            l = !e ? strlen (p) : (size_t) (e - p);\n\n\n\n            for (c = soundhw; c->name; ++c) {\n\n                if (!strncmp (c->name, p, l) && !c->name[l]) {\n\n                    c->enabled = 1;\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (!c->name) {\n\n                if (l > 80) {\n\n                    fprintf (stderr,\n\n                             \"Unknown sound card name (too big to show)\\n\");\n\n                }\n\n                else {\n\n                    fprintf (stderr, \"Unknown sound card name `%.*s'\\n\",\n\n                             (int) l, p);\n\n                }\n\n                bad_card = 1;\n\n            }\n\n            p += l + (e != NULL);\n\n        }\n\n\n\n        if (bad_card)\n\n            goto show_valid_cards;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "ad96090a01d848df67d70c5259ed8aa321fa8716"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_console_execlp_15()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcat(data, \"*.*\");\n        break;\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcat(data, \"*.*\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_console_execlp_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_execlp_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_execlp_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244537"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_42\n{\n\n#ifndef OMITM\n\nstatic wchar_t * mSource(wchar_t * data)\n{\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    return data;\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\nstatic wchar_t * nG2BSource(wchar_t * data)\n{\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    return data;\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_w32CreateFile_42; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97675"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_console_ofstream_66\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * dataArray[]);\n\nvoid m()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    mSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    dataArray[2] = data;\n    nG2BSink(dataArray);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_ofstream_66; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89954"}
{"code": "static int mp3lame_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                                const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    LAMEContext *s = avctx->priv_data;\n\n    MPADecodeHeader hdr;\n\n    int len, ret, ch;\n\n    int lame_result;\n\n    uint32_t h;\n\n\n\n    if (frame) {\n\n        switch (avctx->sample_fmt) {\n\n        case AV_SAMPLE_FMT_S16P:\n\n            ENCODE_BUFFER(lame_encode_buffer, int16_t, frame->data);\n\n            break;\n\n        case AV_SAMPLE_FMT_S32P:\n\n            ENCODE_BUFFER(lame_encode_buffer_int, int32_t, frame->data);\n\n            break;\n\n        case AV_SAMPLE_FMT_FLTP:\n\n            if (frame->linesize[0] < 4 * FFALIGN(frame->nb_samples, 8)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"inadequate AVFrame plane padding\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n            for (ch = 0; ch < avctx->channels; ch++) {\n\n                s->fdsp.vector_fmul_scalar(s->samples_flt[ch],\n\n                                           (const float *)frame->data[ch],\n\n                                           32768.0f,\n\n                                           FFALIGN(frame->nb_samples, 8));\n\n            }\n\n            ENCODE_BUFFER(lame_encode_buffer_float, float, s->samples_flt);\n\n            break;\n\n        default:\n\n            return AVERROR_BUG;\n\n        }\n\n    } else {\n\n        lame_result = lame_encode_flush(s->gfp, s->buffer + s->buffer_index,\n\n                                        s->buffer_size - s->buffer_index);\n\n    }\n\n    if (lame_result < 0) {\n\n        if (lame_result == -1) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"lame: output buffer too small (buffer index: %d, free bytes: %d)\\n\",\n\n                   s->buffer_index, s->buffer_size - s->buffer_index);\n\n        }\n\n        return -1;\n\n    }\n\n    s->buffer_index += lame_result;\n\n    ret = realloc_buffer(s);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"error reallocating output buffer\\n\");\n\n        return ret;\n\n    }\n\n\n\n    \n\n    if (frame) {\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    \n\n    if (s->buffer_index < 4)\n\n        return 0;\n\n    h = AV_RB32(s->buffer);\n\n    if (ff_mpa_check_header(h) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid mp3 header at start of buffer\\n\");\n\n        return AVERROR_BUG;\n\n    }\n\n    if (avpriv_mpegaudio_decode_header(&hdr, h)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"free format output not supported\\n\");\n\n        return -1;\n\n    }\n\n    len = hdr.frame_size;\n\n    ff_dlog(avctx, \"in:%d packet-len:%d index:%d\\n\", avctx->frame_size, len,\n\n            s->buffer_index);\n\n    if (len <= s->buffer_index) {\n\n        if ((ret = ff_alloc_packet(avpkt, len))) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n            return ret;\n\n        }\n\n        memcpy(avpkt->data, s->buffer, len);\n\n        s->buffer_index -= len;\n\n        memmove(s->buffer, s->buffer + len, s->buffer_index);\n\n\n\n        \n\n        ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                           &avpkt->duration);\n\n\n\n        avpkt->size = len;\n\n        *got_packet_ptr = 1;\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "955aec3c7c7be39b659197e1ec379a09f2b7c41c"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint dendritiform_gallinago = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n int oc_i = 0;\n char stack_buff_64[64];\n char *other_buff[8];\n int my_buff_size = 63;\n int buff_size;\n  char *pentelic_abyssolith = 0;\n  char **frails_unflappably = 0;\n  char **pisciculturally_academie = 0;\n  char *waistcoated_piassavas;;\n  if (__sync_bool_compare_and_swap(&dendritiform_gallinago,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      waistcoated_piassavas = getenv(\"CROSLEY_MASTODYNIA\");\n      if (waistcoated_piassavas != 0) {;\n        frails_unflappably = &waistcoated_piassavas;\n        pisciculturally_academie = frails_unflappably + 5;\n        pentelic_abyssolith = ((char *)( *(pisciculturally_academie - 5)));\n    \n    \n    \n other_buff[7] = pentelic_abyssolith;\n    memset(stack_buff_64,65,64);\n    stack_buff_64[64 - 1] = '\\0';\n    buff_size = ((int )(strlen(pentelic_abyssolith)));\n    \n    \n    \n    \n    for (; buff_size >= 0; (--my_buff_size , --buff_size)) {\n  \n  \n        stack_buff_64[my_buff_size] = pentelic_abyssolith[buff_size];\n    }\n    \n    for (; oc_i < 64; ++oc_i) {\n        stack_buff_64[oc_i] = toupper(stack_buff_64[oc_i]);\n    }\n    \n    \n    printf(\"%s\\n\",stack_buff_64);\n    printf(\"strlen size = %d\\n\",strlen(pentelic_abyssolith));\n    printf(\"strlen size = %d\\n\",strlen(other_buff[7]));\n    \n    \n    \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}", "answer": "YES", "cwe": "124", "idx": "152937"}
{"code": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl,\n\n                                   const H2645NAL *nal)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    sl->first_mb_addr = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->first_mb_addr == 0) { \n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, sl->first_mb_addr);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (nal->type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sl->pps_id = get_ue_golomb(&sl->gb);\n\n    if (sl->pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", sl->pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[sl->pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               sl->pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (h->current_slice > 0 &&\n\n        h->ps.pps != (const PPS*)h->ps.pps_list[sl->pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    pps = (const PPS*)h->ps.pps_list[sl->pps_id]->data;\n\n\n\n    if (!h->ps.sps_list[pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\", pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sps = (const SPS*)h->ps.sps_list[pps->sps_id]->data;\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    droppable = nal->ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->picture_structure      = picture_structure;\n\n    sl->mb_field_decoding_flag = picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (h->picture_structure != picture_structure ||\n\n            h->droppable         != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   h->picture_structure, picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    if (picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (nal->type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); \n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    sl->explicit_ref_marking = 0;\n\n    if (nal->ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, sl, &sl->gb);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(pps, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(pps, 1, sl->qscale);\n\n    \n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); \n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); \n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  \n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "8d36932c8d33f93ce1afdd5c1f402e7b6655d5ae"}
{"code": "static GenericList *qobject_input_next_list(Visitor *v, GenericList *tail,\n\n                                            size_t size)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    StackObject *so = QSLIST_FIRST(&qiv->stack);\n\n\n\n    if (!so->entry) {\n\n        return NULL;\n\n    }\n\n    tail->next = g_malloc0(size);\n\n    return tail->next;\n\n}", "answer": "NO", "cwe": "0", "idx": "a4a1c70dc759e5b81627e96564f344ab43ea86eb"}
{"code": "LIBOPENMPT_MODPLUG_API char ModPlug_ExportMOD(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportMOD(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}", "answer": "NO", "cwe": "120", "idx": "87624"}
{"code": "static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size / 32, *data_size / 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        \n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}", "answer": "NO", "cwe": "0", "idx": "595cf1a1aa09f6214eed57bd9eb6493456918efe"}
{"code": "static int f2fs_set_context(struct inode *inode, const void *ctx, size_t len,\n\t\t\t\t\t\t\tvoid *fs_data)\n{\n\treturn f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\n\t\t\t\tF2FS_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\tctx, len, fs_data, XATTR_CREATE);\n}", "answer": "NO", "cwe": "129", "idx": "63880"}
{"code": "void GranularityStrategyTest::ParseText(const TextNodeVector& text_nodes) {\n  bool word_started = false;\n  int word_start_index = 0;\n  for (auto& text : text_nodes) {\n    int word_start_index_offset = letter_pos_.size();\n    String str = text->wholeText();\n    for (size_t i = 0; i < str.length(); i++) {\n      letter_pos_.push_back(VisiblePositionToContentsPoint(\n          CreateVisiblePosition(Position(text, i))));\n      char c = str[i];\n      if (IsASCIIAlphanumeric(c) && !word_started) {\n        word_start_index = i + word_start_index_offset;\n        word_started = true;\n      } else if (!IsASCIIAlphanumeric(c) && word_started) {\n        IntPoint word_middle((letter_pos_[word_start_index].X() +\n                              letter_pos_[i + word_start_index_offset].X()) /\n                                 2,\n                             letter_pos_[word_start_index].Y());\n        word_middles_.push_back(word_middle);\n        word_started = false;\n      }\n    }\n  }\n  if (word_started) {\n    const auto& last_node = text_nodes.back();\n    int x_end = VisiblePositionToContentsPoint(\n                    CreateVisiblePosition(\n                        Position(last_node, last_node->wholeText().length())))\n                    .X();\n    IntPoint word_middle((letter_pos_[word_start_index].X() + x_end) / 2,\n                         letter_pos_[word_start_index].Y());\n    word_middles_.push_back(word_middle);\n  }\n}", "answer": "NO", "cwe": "119", "idx": "135705"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint methodologist_algorist = 0;\n\nunion enflagellation_owly \n{\n  char *squirarchies_burdenable;\n  double weathers_truantship;\n  char *bilianic_beguin;\n  char saugerties_matchcoat;\n  int mumetal_retranscribed;\n}\n;\nint global_variable;\nvoid handle_taint(char *tribunate_phiona);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nunion enflagellation_owly roploch_yucatecan(union enflagellation_owly averrable_phlebology);\nvoid function() {\n    \n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{;\n  if (__sync_bool_compare_and_swap(&methodologist_algorist,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid handle_taint(char *tribunate_phiona)\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *dehisced_leslee = 0;\n  union enflagellation_owly overmatureness_khitmatgar = {0};\n  union enflagellation_owly plowline_duma;\n  ++global_variable;;\n  if (tribunate_phiona != 0) {;\n    plowline_duma . squirarchies_burdenable = tribunate_phiona;\n    overmatureness_khitmatgar = roploch_yucatecan(plowline_duma);\n    if (overmatureness_khitmatgar . squirarchies_burdenable != 0) {\n      goto collocative_cutlerr;\n    }\n    ++global_variable;\n    collocative_cutlerr:;\n    dehisced_leslee = ((char *)overmatureness_khitmatgar . squirarchies_burdenable);\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(dehisced_leslee) >= 1 &&\n            dehisced_leslee[0] != '-') {\n        input_num = strtoul(dehisced_leslee,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(dehisced_leslee) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n    if (overmatureness_khitmatgar . squirarchies_burdenable != 0) \n      free(((char *)overmatureness_khitmatgar . squirarchies_burdenable));\nclose_printf_context();\n  }\n}\n\nunion enflagellation_owly roploch_yucatecan(union enflagellation_owly averrable_phlebology)\n{\n  ++global_variable;\n  return averrable_phlebology;\n}\n#endif", "answer": "YES", "cwe": "682", "idx": "150968"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(wchar_t * * dataPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97781"}
{"code": "static int asf_read_data(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = asf->data_size = avio_rl64(pb);\n    int i;\n\n    if (!asf->data_reached) {\n        asf->data_reached       = 1;\n        asf->data_offset        = asf->offset;\n    }\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (!(asf->b_flags & ASF_FLAG_BROADCAST))\n            s->streams[i]->duration = asf->duration;\n    }\n    asf->nb_mult_left           = 0;\n    asf->sub_left               = 0;\n    asf->state                  = PARSE_PACKET_HEADER;\n    asf->return_subpayload      = 0;\n    asf->packet_size_internal   = 0;\n    avio_skip(pb, 16); \n    size = avio_rl64(pb); \n    if (size != asf->nb_packets)\n        av_log(s, AV_LOG_WARNING,\n               \"Number of Packets from File Properties Object is not equal to Total\"\n               \"Datapackets value! num of packets %\"PRIu64\" total num %\"PRIu64\".\\n\",\n               size, asf->nb_packets);\n    avio_skip(pb, 2); \n    asf->first_packet_offset = avio_tell(pb);\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !(asf->b_flags & ASF_FLAG_BROADCAST))\n        align_position(pb, asf->offset, asf->data_size);\n\n    return 0;\n}", "answer": "NO", "cwe": "119", "idx": "74866"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Relative_Path_Traversal__char_file_w32CreateFile_13\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_file_w32CreateFile_13; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90504"}
{"code": "void *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct page *page = NULL;\n\tnd_set_link(nd, page_getlink(dentry, &page));\n\treturn page;\n}", "answer": "NO", "cwe": "59", "idx": "36357"}
{"code": "static inline void pcnet_tmd_store(PCNetState *s, const struct pcnet_TMD *tmd,\n                                   hwaddr addr)\n{\n    if (!BCR_SSIZE32(s)) {\n        struct {\n            uint32_t tbadr;\n            int16_t length;\n            int16_t status;\n        } xda;\n        xda.tbadr = cpu_to_le32((tmd->tbadr & 0xffffff) |\n                                ((tmd->status & 0xff00) << 16));\n        xda.length = cpu_to_le16(tmd->length);\n        xda.status = cpu_to_le16(tmd->misc >> 16);\n        s->phys_mem_write(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);\n    } else {\n        struct {\n            uint32_t tbadr;\n            int16_t length;\n            int16_t status;\n            uint32_t misc;\n            uint32_t res;\n        } xda;\n        xda.tbadr = cpu_to_le32(tmd->tbadr);\n        xda.length = cpu_to_le16(tmd->length);\n        xda.status = cpu_to_le16(tmd->status);\n        xda.misc = cpu_to_le32(tmd->misc);\n        xda.res = cpu_to_le32(tmd->res);\n        if (BCR_SWSTYLE(s) == 3) {\n            uint32_t tmp = xda.tbadr;\n            xda.tbadr = xda.misc;\n            xda.misc = tmp;\n        }\n        s->phys_mem_write(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);\n    }\n}", "answer": "NO", "cwe": "119", "idx": "14534"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_53bSink(char * data);\n\nvoid _LDAP_Injection__w32_char_connect_socket_53()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_connect_socket_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_connect_socket_53bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_connect_socket_53bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122878"}
{"code": "xps_parse_glyphs(xps_context_t *ctx,\n        char *base_uri, xps_resource_t *dict, xps_item_t *root)\n{\n    xps_item_t *node;\n    int code;\n\n    char *fill_uri;\n    char *opacity_mask_uri;\n\n    char *bidi_level_att;\n    \n    char *fill_att;\n    char *font_size_att;\n    char *font_uri_att;\n    char *origin_x_att;\n    char *origin_y_att;\n    char *is_sideways_att;\n    char *indices_att;\n    char *unicode_att;\n    char *style_att;\n    char *transform_att;\n    char *clip_att;\n    char *opacity_att;\n    char *opacity_mask_att;\n\n    xps_item_t *transform_tag = NULL;\n    xps_item_t *clip_tag = NULL;\n    xps_item_t *fill_tag = NULL;\n    xps_item_t *opacity_mask_tag = NULL;\n\n    char *fill_opacity_att = NULL;\n\n    xps_part_t *part;\n    xps_font_t *font;\n\n    char partname[1024];\n    char *subfont;\n\n    gs_matrix matrix;\n    float font_size = 10.0;\n    int subfontid = 0;\n    int is_sideways = 0;\n    int bidi_level = 0;\n\n    int sim_bold = 0;\n    int sim_italic = 0;\n\n    gs_matrix shear = { 1, 0, 0.36397f, 1, 0, 0 }; \n\n    \n\n    bidi_level_att = xps_att(root, \"BidiLevel\");\n    \n    fill_att = xps_att(root, \"Fill\");\n    font_size_att = xps_att(root, \"FontRenderingEmSize\");\n    font_uri_att = xps_att(root, \"FontUri\");\n    origin_x_att = xps_att(root, \"OriginX\");\n    origin_y_att = xps_att(root, \"OriginY\");\n    is_sideways_att = xps_att(root, \"IsSideways\");\n    indices_att = xps_att(root, \"Indices\");\n    unicode_att = xps_att(root, \"UnicodeString\");\n    style_att = xps_att(root, \"StyleSimulations\");\n    transform_att = xps_att(root, \"RenderTransform\");\n    clip_att = xps_att(root, \"Clip\");\n    opacity_att = xps_att(root, \"Opacity\");\n    opacity_mask_att = xps_att(root, \"OpacityMask\");\n\n    for (node = xps_down(root); node; node = xps_next(node))\n    {\n        if (!strcmp(xps_tag(node), \"Glyphs.RenderTransform\"))\n            transform_tag = xps_down(node);\n\n        if (!strcmp(xps_tag(node), \"Glyphs.OpacityMask\"))\n            opacity_mask_tag = xps_down(node);\n\n        if (!strcmp(xps_tag(node), \"Glyphs.Clip\"))\n            clip_tag = xps_down(node);\n\n        if (!strcmp(xps_tag(node), \"Glyphs.Fill\"))\n            fill_tag = xps_down(node);\n    }\n\n    fill_uri = base_uri;\n    opacity_mask_uri = base_uri;\n\n    xps_resolve_resource_reference(ctx, dict, &transform_att, &transform_tag, NULL);\n    xps_resolve_resource_reference(ctx, dict, &clip_att, &clip_tag, NULL);\n    xps_resolve_resource_reference(ctx, dict, &fill_att, &fill_tag, &fill_uri);\n    xps_resolve_resource_reference(ctx, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);\n\n    \n\n    if (!font_size_att || !font_uri_att || !origin_x_att || !origin_y_att)\n        return gs_throw(-1, \"missing attributes in glyphs element\");\n\n    if (!indices_att && !unicode_att)\n        return 0; \n\n    if (is_sideways_att)\n        is_sideways = !strcmp(is_sideways_att, \"true\");\n\n    if (bidi_level_att)\n        bidi_level = atoi(bidi_level_att);\n\n    \n\n    xps_absolute_path(partname, base_uri, font_uri_att, sizeof partname);\n    subfont = strrchr(partname, '#');\n    if (subfont)\n    {\n        subfontid = atoi(subfont + 1);\n        *subfont = 0;\n    }\n\n    font = xps_hash_lookup(ctx->font_table, partname);\n    if (!font)\n    {\n        part = xps_read_part(ctx, partname);\n        if (!part)\n            return gs_throw1(-1, \"cannot find font resource part '%s'\", partname);\n\n        \n        if (strstr(part->name, \".odttf\"))\n            xps_deobfuscate_font_resource(ctx, part);\n        if (strstr(part->name, \".ODTTF\"))\n            xps_deobfuscate_font_resource(ctx, part);\n\n        font = xps_new_font(ctx, part->data, part->size, subfontid);\n        if (!font)\n            return gs_rethrow1(-1, \"cannot load font resource '%s'\", partname);\n\n        xps_select_best_font_encoding(font);\n\n        xps_hash_insert(ctx, ctx->font_table, part->name, font);\n\n        \n        xps_free(ctx, part);\n    }\n\n    if (style_att)\n    {\n        if (!strcmp(style_att, \"BoldSimulation\"))\n            sim_bold = 1;\n        else if (!strcmp(style_att, \"ItalicSimulation\"))\n            sim_italic = 1;\n        else if (!strcmp(style_att, \"BoldItalicSimulation\"))\n            sim_bold = sim_italic = 1;\n    }\n\n    \n\n    gs_gsave(ctx->pgs);\n\n    if (transform_att || transform_tag)\n    {\n        gs_matrix transform;\n\n        if (transform_att)\n            xps_parse_render_transform(ctx, transform_att, &transform);\n        if (transform_tag)\n            xps_parse_matrix_transform(ctx, transform_tag, &transform);\n\n        gs_concat(ctx->pgs, &transform);\n    }\n\n    if (clip_att || clip_tag)\n    {\n        if (clip_att)\n            xps_parse_abbreviated_geometry(ctx, clip_att);\n        if (clip_tag)\n            xps_parse_path_geometry(ctx, dict, clip_tag, 0);\n        xps_clip(ctx);\n    }\n\n    font_size = atof(font_size_att);\n\n    gs_setfont(ctx->pgs, font->font);\n    gs_make_scaling(font_size, -font_size, &matrix);\n    if (is_sideways)\n        gs_matrix_rotate(&matrix, 90.0, &matrix);\n\n    if (sim_italic)\n        gs_matrix_multiply(&shear, &matrix, &matrix);\n\n    gs_setcharmatrix(ctx->pgs, &matrix);\n\n    gs_matrix_multiply(&matrix, &font->font->orig_FontMatrix, &font->font->FontMatrix);\n\n    code = xps_begin_opacity(ctx, opacity_mask_uri, dict, opacity_att, opacity_mask_tag, false, false);\n    if (code)\n    {\n        gs_grestore(ctx->pgs);\n        return gs_rethrow(code, \"cannot create transparency group\");\n    }\n\n    \n\n    if (fill_tag && !strcmp(xps_tag(fill_tag), \"SolidColorBrush\"))\n    {\n        fill_opacity_att = xps_att(fill_tag, \"Opacity\");\n        fill_att = xps_att(fill_tag, \"Color\");\n        fill_tag = NULL;\n    }\n\n    if (fill_att)\n    {\n        float samples[XPS_MAX_COLORS];\n        gs_color_space *colorspace;\n\n        xps_parse_color(ctx, base_uri, fill_att, &colorspace, samples);\n        if (fill_opacity_att)\n            samples[0] *= atof(fill_opacity_att);\n        xps_set_color(ctx, colorspace, samples);\n\n        if (sim_bold)\n        {\n            \n            gs_setlinewidth(ctx->pgs, font_size * 0.02);\n            gs_settextrenderingmode(ctx->pgs, 2);\n        }\n\n        code = xps_parse_glyphs_imp(ctx, font, font_size,\n                atof(origin_x_att), atof(origin_y_att),\n                is_sideways, bidi_level,\n                indices_att, unicode_att, sim_bold && !ctx->preserve_tr_mode, sim_bold);\n        if (code)\n        {\n            xps_end_opacity(ctx, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n            gs_grestore(ctx->pgs);\n            return gs_rethrow(code, \"cannot parse glyphs data\");\n        }\n\n        if (sim_bold && !ctx->preserve_tr_mode)\n        {\n            gs_gsave(ctx->pgs);\n            gs_fill(ctx->pgs);\n            gs_grestore(ctx->pgs);\n            gs_stroke(ctx->pgs);\n        }\n\n        gs_settextrenderingmode(ctx->pgs, 0);\n    }\n\n    \n\n    if (fill_tag)\n    {\n        ctx->fill_rule = 1; \n        code = xps_parse_glyphs_imp(ctx, font, font_size,\n                atof(origin_x_att), atof(origin_y_att),\n                is_sideways, bidi_level, indices_att, unicode_att, 1, sim_bold);\n        if (code)\n        {\n            xps_end_opacity(ctx, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n            gs_grestore(ctx->pgs);\n            return gs_rethrow(code, \"cannot parse glyphs data\");\n        }\n\n        code = xps_parse_brush(ctx, fill_uri, dict, fill_tag);\n        if (code)\n        {\n            xps_end_opacity(ctx, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n            gs_grestore(ctx->pgs);\n            return gs_rethrow(code, \"cannot parse fill brush\");\n        }\n    }\n\n    xps_end_opacity(ctx, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n    gs_grestore(ctx->pgs);\n\n    return 0;\n}", "answer": "NO", "cwe": "125", "idx": "5578"}
{"code": "s_aes_set_padding(stream_aes_state *state, int use_padding)\n{\n    state->use_padding = use_padding;\n}", "answer": "NO", "cwe": "119", "idx": "3242"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_connect_socket_16()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    while(1)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_connect_socket_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_connect_socket_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_connect_socket_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62243"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _LDAP_Injection__w32_wchar_t_environment_34_unionType;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_environment_34()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_environment_34_unionType myUnion;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    _LDAP_Injection__w32_wchar_t_environment_34_unionType myUnion;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            \n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_environment_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_environment_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_environment_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123206"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_wchar_t_console_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_wchar_t_console_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123169"}
{"code": "static void unset_dirty_tracking(void)\n\n{\n\n    BlkMigDevState *bmds;\n\n\n\n    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {\n\n        aio_context_acquire(blk_get_aio_context(bmds->blk));\n\n        bdrv_release_dirty_bitmap(blk_bs(bmds->blk), bmds->dirty_bitmap);\n\n        aio_context_release(blk_get_aio_context(bmds->blk));\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3"}
{"code": "static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd)\n\n{\n\n    const char *opn = \"ldst\";\n\n\n\n    switch (opc) {\n\n    case OPC_MFC0:\n\n        if (rt == 0) {\n\n            \n\n            return;\n\n        }\n\n        gen_mfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"mfc0\";\n\n        break;\n\n    case OPC_MTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_mtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"mtc0\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case OPC_DMFC0:\n\n        if (rt == 0) {\n\n            \n\n            return;\n\n        }\n\n        gen_dmfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"dmfc0\";\n\n        break;\n\n    case OPC_DMTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_dmtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"dmtc0\";\n\n        break;\n\n#endif\n\n    case OPC_TLBWI:\n\n        opn = \"tlbwi\";\n\n        if (!env->do_tlbwi)\n\n            goto die;\n\n        gen_op_tlbwi();\n\n        break;\n\n    case OPC_TLBWR:\n\n        opn = \"tlbwr\";\n\n        if (!env->do_tlbwr)\n\n            goto die;\n\n        gen_op_tlbwr();\n\n        break;\n\n    case OPC_TLBP:\n\n        opn = \"tlbp\";\n\n        if (!env->do_tlbp)\n\n            goto die;\n\n        gen_op_tlbp();\n\n        break;\n\n    case OPC_TLBR:\n\n        opn = \"tlbr\";\n\n        if (!env->do_tlbr)\n\n            goto die;\n\n        gen_op_tlbr();\n\n        break;\n\n    case OPC_ERET:\n\n        opn = \"eret\";\n\n        save_cpu_state(ctx, 0);\n\n        gen_op_eret();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    case OPC_DERET:\n\n        opn = \"deret\";\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            MIPS_INVAL(opn);\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            save_cpu_state(ctx, 0);\n\n            gen_op_deret();\n\n            ctx->bstate = BS_EXCP;\n\n        }\n\n        break;\n\n    case OPC_WAIT:\n\n        opn = \"wait\";\n\n        \n\n        ctx->pc += 4;\n\n        save_cpu_state(ctx, 1);\n\n        ctx->pc -= 4;\n\n        gen_op_wait();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    default:\n\n die:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    MIPS_DEBUG(\"%s %s %d\", opn, regnames[rt], rd);\n\n}", "answer": "NO", "cwe": "0", "idx": "df1561e22df42643d769aacdcc7d6d239f243366"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint glycerize_foulsome = 0;\n\nstruct overpositively_hybridae \n{\n  char *cowpoke_snogs;\n  double nekrasov_caruncle;\n  char *mestizos_axillary;\n  char unruly_paraphs;\n  int lateness_parisianly;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n    int i = 0;\n    int buff_size = 63;\n    int taint_len;\n    char *heap_buff_64 = 0;\n  char *granularly_dutuburi = 0;\n  struct overpositively_hybridae *unkindlily_dimberdamber = {0};\n  struct overpositively_hybridae statolithic_subscript;\n  char *thomasite_siruelas;;\n  if (__sync_bool_compare_and_swap(&glycerize_foulsome,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      thomasite_siruelas = getenv(\"GRANDNEPHEWS_OUTBEGGED\");\n      if (thomasite_siruelas != 0) {;\n        statolithic_subscript . cowpoke_snogs = ((char *)thomasite_siruelas);\n        unkindlily_dimberdamber = &statolithic_subscript;\n        granularly_dutuburi = ((char *)( *unkindlily_dimberdamber) . cowpoke_snogs);\n    \n    \n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64, 'A' ,64);\n        heap_buff_64[64 - 1] = '\\0';\n        \n        \n        \n        taint_len = ((int )(strlen(granularly_dutuburi)));\n        for (; taint_len >= 0; (--buff_size , --taint_len)) {\n    \n    \n            heap_buff_64[buff_size] = granularly_dutuburi[taint_len];\n        }\n        \n        for (; i < 64; ++i) {\n            heap_buff_64[i] = toupper(heap_buff_64[i]);\n        }\n        \n        \n        printf(\"%s\\n\",&(heap_buff_64[buff_size+1]));\n        free(heap_buff_64);\n        \n        \n        \n    }\n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "124", "idx": "153169"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_console_open_11\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_console_open_11; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "95932"}
{"code": "int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y, int vp7)\n{\n    if (!mb_x) {\n        return mb_y ? VERT_VP8_PRED : (vp7 ? DC_128_PRED : DC_129_PRED);\n    } else {\n        return mb_y ? mode : HOR_VP8_PRED;\n    }\n}", "answer": "NO", "cwe": "119", "idx": "63948"}
{"code": "static uint64_t pxa2xx_i2s_read(void *opaque, hwaddr addr,\n\n                                unsigned size)\n\n{\n\n    PXA2xxI2SState *s = (PXA2xxI2SState *) opaque;\n\n\n\n    switch (addr) {\n\n    case SACR0:\n\n        return s->control[0];\n\n    case SACR1:\n\n        return s->control[1];\n\n    case SASR0:\n\n        return s->status;\n\n    case SAIMR:\n\n        return s->mask;\n\n    case SAICR:\n\n        return 0;\n\n    case SADIV:\n\n        return s->clk;\n\n    case SADR:\n\n        if (s->rx_len > 0) {\n\n            s->rx_len --;\n\n            pxa2xx_i2s_update(s);\n\n            return s->codec_in(s->opaque);\n\n        }\n\n        return 0;\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "a89f364ae8740dfc31b321eed9ee454e996dc3c1"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_console_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        \n        strcat(data, \"Doe, XXXXX\");\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_char_console_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_console_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_console_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122916"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint unifiers_unevangelic = 0;\ntypedef char *broadish_locoweed;\nint global_variable;\nvoid handle_taint(char *historiometric_propulsion);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid purpureous_disorientate(int interscene_subkingdom,broadish_locoweed prand_antiepileptic);\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&unifiers_unevangelic,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *historiometric_propulsion)\n{\n  int issachar_battlement = 7;\n  broadish_locoweed zootomy_sulphinic = 0;\n  long sawbucks_bergut[10];\n  broadish_locoweed saboraim_ginsberg[10] = {0};\n  broadish_locoweed bletting_patand = 0;\n  ++global_variable;;\n  if (historiometric_propulsion != 0) {;\n    bletting_patand = historiometric_propulsion;\n    saboraim_ginsberg[5] = bletting_patand;\n    sawbucks_bergut[1] = 5;\n    zootomy_sulphinic =  *(saboraim_ginsberg + sawbucks_bergut[1]);\n    purpureous_disorientate(issachar_battlement,zootomy_sulphinic);\n  }\n}\n\nvoid purpureous_disorientate(int interscene_subkingdom,broadish_locoweed prand_antiepileptic)\n{\n  char buffer[80];\n  FILE *pFile = 0;\n  char *pims_sulphamidate = 0;\n  ++global_variable;\n  interscene_subkingdom--;\n  if (interscene_subkingdom > 0) {\n    purpureous_disorientate(interscene_subkingdom,prand_antiepileptic);\n    return ;\n  }\n  pims_sulphamidate = ((char *)prand_antiepileptic);\n      \n      \n\n      pFile = fopen(pims_sulphamidate,\"r\");\n      buffer[0] = 0;\n      \n      \n      \n\n      fgets(buffer,79,pFile);\n      printf(buffer);\n      printf(\"\\n\");\n      fclose(pFile);\n      \n      \n;\n  if (prand_antiepileptic != 0) \n    free(((char *)prand_antiepileptic));\nclose_printf_context();\n}", "answer": "YES", "cwe": "476", "idx": "149384"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_open_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_open_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96650"}
{"code": "static void parse_segment_offset(RAsm *a, const char *str, size_t *pos,\n\t\tOperand *op, int reg_index) {\n\tint nextpos = *pos;\n\tchar *c = strchr (str + nextpos, ':');\n\tif (c) {\n\t\tnextpos ++; \n\t\tc = strchr (str + nextpos, '[');\n\t\tif (c) {nextpos ++;} \n\n\t\top->regs[reg_index] = op->reg;\n\t\top->type |= OT_MEMORY;\n\t\top->offset_sign = 1;\n\t\tchar *p = strchr (str + nextpos, '-');\n\t\tif (p) {\n\t\t\top->offset_sign = -1;\n\t\t\tnextpos ++;\n\t\t}\n\t\top->scale[reg_index] = getnum (a, str + nextpos);\n\t\top->offset = op->scale[reg_index];\n\t}\n}", "answer": "NO", "cwe": "125", "idx": "75469"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\nnamespace _Process_Control__w32_char_connect_socket_82\n{\n\nclass _Process_Control__w32_char_connect_socket_82_base\n{\npublic:\n    \n    virtual void action(char * data) = 0;\n};\n\n#ifndef OMITM\n\nclass _Process_Control__w32_char_connect_socket_82 : public _Process_Control__w32_char_connect_socket_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Process_Control__w32_char_connect_socket_82G2B : public _Process_Control__w32_char_connect_socket_82_base\n{\npublic:\n    void action(char * data);\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "114", "idx": "61985"}
{"code": "GF_Box *avcc_New()\n{\n\tGF_AVCConfigurationBox *tmp = (GF_AVCConfigurationBox *) gf_malloc(sizeof(GF_AVCConfigurationBox));\n\tif (tmp == NULL) return NULL;\n\tmemset(tmp, 0, sizeof(GF_AVCConfigurationBox));\n\ttmp->type = GF_ISOM_BOX_TYPE_AVCC;\n\treturn (GF_Box *)tmp;\n}", "answer": "NO", "cwe": "119", "idx": "83988"}
{"code": "droproot(const char *username, const char *chroot_dir)\n{\n\tstruct passwd *pw = NULL;\n\n\tif (chroot_dir && !username) {\n\t\tfprintf(stderr, \"%s: Chroot without dropping root is insecure\\n\",\n\t\t\tprogram_name);\n\t\texit_tcpdump(1);\n\t}\n\n\tpw = getpwnam(username);\n\tif (pw) {\n\t\tif (chroot_dir) {\n\t\t\tif (chroot(chroot_dir) != 0 || chdir (\"/\") != 0) {\n\t\t\t\tfprintf(stderr, \"%s: Couldn't chroot/chdir to '%.64s': %s\\n\",\n\t\t\t\t\tprogram_name, chroot_dir, pcap_strerror(errno));\n\t\t\t\texit_tcpdump(1);\n\t\t\t}\n\t\t}\n#ifdef HAVE_LIBCAP_NG\n\t\t{\n\t\t\tint ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);\n\t\t\tif (ret < 0)\n\t\t\t\terror(\"capng_change_id(): return %d\\n\", ret);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#else\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) != 0 ||\n\t\t    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0) {\n\t\t\tfprintf(stderr, \"%s: Couldn't change to '%.32s' uid=%lu gid=%lu: %s\\n\",\n\t\t\t\tprogram_name, username,\n\t\t\t\t(unsigned long)pw->pw_uid,\n\t\t\t\t(unsigned long)pw->pw_gid,\n\t\t\t\tpcap_strerror(errno));\n\t\t\texit_tcpdump(1);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#endif \n\t}\n\telse {\n\t\tfprintf(stderr, \"%s: Couldn't find user '%.32s'\\n\",\n\t\t\tprogram_name, username);\n\t\texit_tcpdump(1);\n\t}\n#ifdef HAVE_LIBCAP_NG\n\t\n\tcapng_updatev(\n\t\tCAPNG_DROP,\n\t\tCAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t\tCAP_SETUID,\n\t\tCAP_SETGID,\n\t\tCAP_SYS_CHROOT,\n\t\t-1);\n\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif \n\n}", "answer": "NO", "cwe": "120", "idx": "93182"}
{"code": "static void prop_get_fdt(Object *obj, Visitor *v, const char *name,\n\n                         void *opaque, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(obj);\n\n    Error *err = NULL;\n\n    int fdt_offset_next, fdt_offset, fdt_depth;\n\n    void *fdt;\n\n\n\n    if (!drc->fdt) {\n\n        visit_type_null(v, NULL, errp);\n\n        return;\n\n    }\n\n\n\n    fdt = drc->fdt;\n\n    fdt_offset = drc->fdt_start_offset;\n\n    fdt_depth = 0;\n\n\n\n    do {\n\n        const char *name = NULL;\n\n        const struct fdt_property *prop = NULL;\n\n        int prop_len = 0, name_len = 0;\n\n        uint32_t tag;\n\n\n\n        tag = fdt_next_tag(fdt, fdt_offset, &fdt_offset_next);\n\n        switch (tag) {\n\n        case FDT_BEGIN_NODE:\n\n            fdt_depth++;\n\n            name = fdt_get_name(fdt, fdt_offset, &name_len);\n\n            visit_start_struct(v, name, NULL, 0, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            break;\n\n        case FDT_END_NODE:\n\n            \n\n            g_assert(fdt_depth > 0);\n\n            visit_check_struct(v, &err);\n\n            visit_end_struct(v);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            fdt_depth--;\n\n            break;\n\n        case FDT_PROP: {\n\n            int i;\n\n            prop = fdt_get_property_by_offset(fdt, fdt_offset, &prop_len);\n\n            name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));\n\n            visit_start_list(v, name, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            for (i = 0; i < prop_len; i++) {\n\n                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], &err);\n\n                if (err) {\n\n                    error_propagate(errp, err);\n\n                    return;\n\n                }\n\n            }\n\n            visit_end_list(v);\n\n            break;\n\n        }\n\n        default:\n\n            error_setg(&error_abort, \"device FDT in unexpected state: %d\", tag);\n\n        }\n\n        fdt_offset = fdt_offset_next;\n\n    } while (fdt_depth != 0);\n\n}", "answer": "NO", "cwe": "0", "idx": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46"}
{"code": "GF_Err mdhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_MediaHeaderBox *ptr = (GF_MediaHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->timeScale);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_int(bs, 0, 1);\n\tgf_bs_write_int(bs, ptr->packedLanguage[0] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[1] - 0x60, 5);\n\tgf_bs_write_int(bs, ptr->packedLanguage[2] - 0x60, 5);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}", "answer": "NO", "cwe": "125", "idx": "80216"}
{"code": "void lm32_debug_excp_handler(CPUState *cs)\n\n{\n\n    LM32CPU *cpu = LM32_CPU(cs);\n\n    CPULM32State *env = &cpu->env;\n\n    CPUBreakpoint *bp;\n\n\n\n    if (cs->watchpoint_hit) {\n\n        if (cs->watchpoint_hit->flags & BP_CPU) {\n\n            cs->watchpoint_hit = NULL;\n\n            if (check_watchpoints(env)) {\n\n                raise_exception(env, EXCP_WATCHPOINT);\n\n            } else {\n\n                cpu_resume_from_signal(cs, NULL);\n\n            }\n\n        }\n\n    } else {\n\n        QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n            if (bp->pc == env->pc) {\n\n                if (bp->flags & BP_CPU) {\n\n                    raise_exception(env, EXCP_BREAKPOINT);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "6886b98036a8f8f5bce8b10756ce080084cef11b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nnamespace _Absolute_Path_Traversal__char_connect_socket_ofstream_83\n{\n\n#ifndef OMITM\n\nclass _Absolute_Path_Traversal__char_connect_socket_ofstream_83\n{\npublic:\n    _Absolute_Path_Traversal__char_connect_socket_ofstream_83(char * dataCopy);\n    ~_Absolute_Path_Traversal__char_connect_socket_ofstream_83();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Absolute_Path_Traversal__char_connect_socket_ofstream_83G2B\n{\npublic:\n    _Absolute_Path_Traversal__char_connect_socket_ofstream_83G2B(char * dataCopy);\n    ~_Absolute_Path_Traversal__char_connect_socket_ofstream_83G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "36", "idx": "95680"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_connect_socket_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_connect_socket_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_connect_socket_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_connect_socket_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62249"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_open_64\n{\n\n#ifndef OMITM\n\n\nvoid mSink(void * dataVoidPtr);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(void * dataVoidPtr);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_open_64; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97158"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_ifstream_51\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_ifstream_51; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96575"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_console_43\n{\n\n#ifndef OMITM\n\nstatic void mSource(char * &data)\n{\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n}\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    mSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSource(char * &data)\n{\n    \n    strcat(data, \"Doe, XXXXX\");\n}\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_console_43; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122921"}
{"code": "static void parse_error(JSONParserContext *ctxt, QObject *token, const char *msg, ...)\n\n{\n\n    fprintf(stderr, \"parse error: %s\\n\", msg);\n\n}", "answer": "NO", "cwe": "0", "idx": "c96c84a9ff4bc184cb1f6cc9771a550f3854ba59"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint kochkin_lincolndale = 0;\ntypedef char *fiddlesticks_gastronomies;\nint global_variable;\nvoid handle_taint(char *muzziest_treadling);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nfiddlesticks_gastronomies grapewise_inbreathed(fiddlesticks_gastronomies obtested_cautio);\nvoid kicksies_conarium(int eachelle_solarized,fiddlesticks_gastronomies glossotype_drowsily);\nvoid trigemini_crinoids(int materia_indubiously,fiddlesticks_gastronomies menazons_multicharge);\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&kochkin_lincolndale,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *muzziest_treadling)\n{\n  int carnivalesque_paumgartner = 7;\n  fiddlesticks_gastronomies garnel_klenk = 0;\n  fiddlesticks_gastronomies ballons_polygenes = 0;\n  ++global_variable;;\n  if (muzziest_treadling != 0) {;\n    ballons_polygenes = muzziest_treadling;\n    garnel_klenk = grapewise_inbreathed(ballons_polygenes);\n    kicksies_conarium(carnivalesque_paumgartner,garnel_klenk);\n  }\n}\n\nfiddlesticks_gastronomies grapewise_inbreathed(fiddlesticks_gastronomies obtested_cautio)\n{\n  ++global_variable;\n  return obtested_cautio;\n}\n\nvoid kicksies_conarium(int eachelle_solarized,fiddlesticks_gastronomies glossotype_drowsily)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *germana_frenatae = 0;\n  ++global_variable;\n  eachelle_solarized--;\n  if (eachelle_solarized > 0) {\n    trigemini_crinoids(eachelle_solarized,glossotype_drowsily);\n    return ;\n  }\n  germana_frenatae = ((char *)glossotype_drowsily);\n      \n      len = strtol(germana_frenatae,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (glossotype_drowsily != 0) \n    free(((char *)glossotype_drowsily));\nclose_printf_context();\n}\n\nvoid trigemini_crinoids(int materia_indubiously,fiddlesticks_gastronomies menazons_multicharge)\n{\n  ++global_variable;\n  kicksies_conarium(materia_indubiously,menazons_multicharge);\n}", "answer": "YES", "cwe": "476", "idx": "149652"}
{"code": "static void spapr_cpu_core_unrealizefn(DeviceState *dev, Error **errp)\n\n{\n\n    sPAPRCPUCore *sc = SPAPR_CPU_CORE(OBJECT(dev));\n\n    sPAPRCPUCoreClass *scc = SPAPR_CPU_CORE_GET_CLASS(OBJECT(dev));\n\n    size_t size = object_type_get_instance_size(scc->cpu_type);\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    int i;\n\n\n\n    for (i = 0; i < cc->nr_threads; i++) {\n\n        void *obj = sc->threads + i * size;\n\n        DeviceState *dev = DEVICE(obj);\n\n        CPUState *cs = CPU(dev);\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n\n\n        spapr_cpu_destroy(cpu);\n\n        object_unparent(cpu->intc);\n\n        cpu_remove_sync(cs);\n\n        object_unparent(obj);\n\n    }\n\n    g_free(sc->threads);\n\n}", "answer": "NO", "cwe": "0", "idx": "94ad93bd976841c26af75322301f5aad925114d6"}
{"code": "static void nvdimm_dsm_func_read_fit(AcpiNVDIMMState *state, NvdimmDsmIn *in,\n\n                                     hwaddr dsm_mem_addr)\n\n{\n\n    NvdimmFitBuffer *fit_buf = &state->fit_buf;\n\n    NvdimmFuncReadFITIn *read_fit;\n\n    NvdimmFuncReadFITOut *read_fit_out;\n\n    GArray *fit;\n\n    uint32_t read_len = 0, func_ret_status;\n\n    int size;\n\n\n\n    read_fit = (NvdimmFuncReadFITIn *)in->arg3;\n\n    le32_to_cpus(&read_fit->offset);\n\n\n\n    qemu_mutex_lock(&fit_buf->lock);\n\n    fit = fit_buf->fit;\n\n\n\n    nvdimm_debug(\"Read FIT: offset %#x FIT size %#x Dirty %s.\\n\",\n\n                 read_fit->offset, fit->len, fit_buf->dirty ? \"Yes\" : \"No\");\n\n\n\n    if (read_fit->offset > fit->len) {\n\n        func_ret_status = 3 ;\n\n        goto exit;\n\n    }\n\n\n\n    \n\n    if (!read_fit->offset) {\n\n        fit_buf->dirty = false;\n\n    } else if (fit_buf->dirty) { \n\n        func_ret_status = 0x100 ;\n\n        goto exit;\n\n    }\n\n\n\n    func_ret_status = 0 ;\n\n    read_len = MIN(fit->len - read_fit->offset,\n\n                   4096 - sizeof(NvdimmFuncReadFITOut));\n\n\n\nexit:\n\n    size = sizeof(NvdimmFuncReadFITOut) + read_len;\n\n    read_fit_out = g_malloc(size);\n\n\n\n    read_fit_out->len = cpu_to_le32(size);\n\n    read_fit_out->func_ret_status = cpu_to_le32(func_ret_status);\n\n    memcpy(read_fit_out->fit, fit->data + read_fit->offset, read_len);\n\n\n\n    cpu_physical_memory_write(dsm_mem_addr, read_fit_out, size);\n\n\n\n    g_free(read_fit_out);\n\n    qemu_mutex_unlock(&fit_buf->lock);\n\n}", "answer": "NO", "cwe": "0", "idx": "12f86b5b3e1bdf75e0a467d771c16cc42f3a1f1a"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84\n{\n\n#ifndef OMITM\n\nclass _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84G2B\n{\npublic:\n    _Relative_Path_Traversal__wchar_t_listen_socket_fopen_84G2B(wchar_t * dataCopy);\n    ~_Relative_Path_Traversal__wchar_t_listen_socket_fopen_84G2B();\n\nprivate:\n    wchar_t * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "23", "idx": "91787"}
{"code": "void YM3812UpdateOne(FM_OPL *OPL, INT16 *buffer, int length)\n\n{\n\n    int i;\n\n\tint data;\n\n\tOPLSAMPLE *buf = buffer;\n\n\tUINT32 amsCnt  = OPL->amsCnt;\n\n\tUINT32 vibCnt  = OPL->vibCnt;\n\n\tUINT8 rythm = OPL->rythm&0x20;\n\n\tOPL_CH *CH,*R_CH;\n\n\n\n\tif( (void *)OPL != cur_chip ){\n\n\t\tcur_chip = (void *)OPL;\n\n\t\t\n\n\t\tS_CH = OPL->P_CH;\n\n\t\tE_CH = &S_CH[9];\n\n\t\t\n\n\t\tSLOT7_1 = &S_CH[7].SLOT[SLOT1];\n\n\t\tSLOT7_2 = &S_CH[7].SLOT[SLOT2];\n\n\t\tSLOT8_1 = &S_CH[8].SLOT[SLOT1];\n\n\t\tSLOT8_2 = &S_CH[8].SLOT[SLOT2];\n\n\t\t\n\n\t\tamsIncr = OPL->amsIncr;\n\n\t\tvibIncr = OPL->vibIncr;\n\n\t\tams_table = OPL->ams_table;\n\n\t\tvib_table = OPL->vib_table;\n\n\t}\n\n\tR_CH = rythm ? &S_CH[6] : E_CH;\n\n    for( i=0; i < length ; i++ )\n\n\t{\n\n\t\t\n\n\t\t\n\n\t\tams = ams_table[(amsCnt+=amsIncr)>>AMS_SHIFT];\n\n\t\tvib = vib_table[(vibCnt+=vibIncr)>>VIB_SHIFT];\n\n\t\toutd[0] = 0;\n\n\t\t\n\n\t\tfor(CH=S_CH ; CH < R_CH ; CH++)\n\n\t\t\tOPL_CALC_CH(CH);\n\n\t\t\n\n\t\tif(rythm)\n\n\t\t\tOPL_CALC_RH(S_CH);\n\n\t\t\n\n\t\tdata = Limit( outd[0] , OPL_MAXOUT, OPL_MINOUT );\n\n\t\t\n\n\t\tbuf[i] = data >> OPL_OUTSB;\n\n\t}\n\n\n\n\tOPL->amsCnt = amsCnt;\n\n\tOPL->vibCnt = vibCnt;\n\n#ifdef OPL_OUTPUT_LOG\n\n\tif(opl_dbg_fp)\n\n\t{\n\n\t\tfor(opl_dbg_chip=0;opl_dbg_chip<opl_dbg_maxchip;opl_dbg_chip++)\n\n\t\t\tif( opl_dbg_opl[opl_dbg_chip] == OPL) break;\n\n\t\tfprintf(opl_dbg_fp,\"%c%c%c\",0x20+opl_dbg_chip,length&0xff,length/256);\n\n\t}\n\n#endif\n\n}", "answer": "NO", "cwe": "0", "idx": "c11e80e299e57c64934c164b231fa0d4279db445"}
{"code": "static int vfio_setup_pcie_cap(VFIOPCIDevice *vdev, int pos, uint8_t size)\n\n{\n\n    uint16_t flags;\n\n    uint8_t type;\n\n\n\n    flags = pci_get_word(vdev->pdev.config + pos + PCI_CAP_FLAGS);\n\n    type = (flags & PCI_EXP_FLAGS_TYPE) >> 4;\n\n\n\n    if (type != PCI_EXP_TYPE_ENDPOINT &&\n\n        type != PCI_EXP_TYPE_LEG_END &&\n\n        type != PCI_EXP_TYPE_RC_END) {\n\n\n\n        error_report(\"vfio: Assignment of PCIe type 0x%x \"\n\n                     \"devices is not currently supported\", type);\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!pci_bus_is_express(vdev->pdev.bus)) {\n\n        \n\n    } else if (pci_bus_is_root(vdev->pdev.bus)) {\n\n        \n\n        if (type == PCI_EXP_TYPE_ENDPOINT) {\n\n            vfio_add_emulated_word(vdev, pos + PCI_CAP_FLAGS,\n\n                                   PCI_EXP_TYPE_RC_END << 4,\n\n                                   PCI_EXP_FLAGS_TYPE);\n\n\n\n            \n\n            if (size > PCI_EXP_LNKCTL) {\n\n                vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP, 0, ~0);\n\n                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);\n\n                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA, 0, ~0);\n\n\n\n#ifndef PCI_EXP_LNKCAP2\n\n#define PCI_EXP_LNKCAP2 44\n\n#endif\n\n#ifndef PCI_EXP_LNKSTA2\n\n#define PCI_EXP_LNKSTA2 50\n\n#endif\n\n                \n\n                if (size > PCI_EXP_LNKCAP2) {\n\n                    vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP2, 0, ~0);\n\n                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL2, 0, ~0);\n\n                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA2, 0, ~0);\n\n                }\n\n            }\n\n\n\n        } else if (type == PCI_EXP_TYPE_LEG_END) {\n\n            \n\n            return 0;\n\n        }\n\n\n\n    } else {\n\n        \n\n        if (type == PCI_EXP_TYPE_RC_END) {\n\n            vfio_add_emulated_word(vdev, pos + PCI_CAP_FLAGS,\n\n                                   PCI_EXP_TYPE_ENDPOINT << 4,\n\n                                   PCI_EXP_FLAGS_TYPE);\n\n            vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP,\n\n                                   PCI_EXP_LNK_MLW_1 | PCI_EXP_LNK_LS_25, ~0);\n\n            vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);\n\n        }\n\n\n\n        \n\n        vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA,\n\n                               pci_get_word(vdev->pdev.config + pos +\n\n                                            PCI_EXP_LNKSTA),\n\n                               PCI_EXP_LNKCAP_MLW | PCI_EXP_LNKCAP_SLS);\n\n    }\n\n\n\n    pos = pci_add_capability(&vdev->pdev, PCI_CAP_ID_EXP, pos, size);\n\n    if (pos >= 0) {\n\n        vdev->pdev.exp.exp_cap = pos;\n\n    }\n\n\n\n    return pos;\n\n}", "answer": "NO", "cwe": "0", "idx": "0282abf078c3353a178ab77a115828ce333181dd"}
{"code": "static int mount_rootfs(const char *rootfs, const char *target, const char *options)\n{\n\tchar absrootfs[MAXPATHLEN];\n\tstruct stat s;\n\tint i;\n\n\ttypedef int (*rootfs_cb)(const char *, const char *, const char *);\n\n\tstruct rootfs_type {\n\t\tint type;\n\t\trootfs_cb cb;\n\t} rtfs_type[] = {\n\t\t{ S_IFDIR, mount_rootfs_dir },\n\t\t{ S_IFBLK, mount_rootfs_block },\n\t\t{ S_IFREG, mount_rootfs_file },\n\t};\n\n\tif (!realpath(rootfs, absrootfs)) {\n\t\tSYSERROR(\"failed to get real path for '%s'\", rootfs);\n\t\treturn -1;\n\t}\n\n\tif (access(absrootfs, F_OK)) {\n\t\tSYSERROR(\"'%s' is not accessible\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tif (stat(absrootfs, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", absrootfs);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sizeof(rtfs_type)/sizeof(rtfs_type[0]); i++) {\n\n\t\tif (!__S_ISTYPE(s.st_mode, rtfs_type[i].type))\n\t\t\tcontinue;\n\n\t\treturn rtfs_type[i].cb(absrootfs, target, options);\n\t}\n\n\tERROR(\"unsupported rootfs type for '%s'\", absrootfs);\n\treturn -1;\n}", "answer": "NO", "cwe": "59", "idx": "44609"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <vector>\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\nusing namespace std;\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_72\n{\n\n#ifndef OMITM\n\n\nvoid mSink(vector<char *> dataVector);\n\nvoid m()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    mSink(dataVector);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(vector<char *> dataVector);\n\nstatic void nG2B()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    \n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    nG2BSink(dataVector);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_72; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82019"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_file_w32CreateFile_52\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(char * data);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_w32CreateFile_52; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96480"}
{"code": "void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "b097cc52fc9126bd1a71dae8302b8536d28104dd"}
{"code": "static void cdxl_decode_rgb(CDXLVideoContext *c, AVFrame *frame)\n{\n    uint32_t *new_palette = (uint32_t *)frame->data[1];\n\n    memset(frame->data[1], 0, AVPALETTE_SIZE);\n    import_palette(c, new_palette);\n    import_format(c, frame->linesize[0], frame->data[0]);\n}", "answer": "NO", "cwe": "119", "idx": "63928"}
{"code": "static PHP_FUNCTION(session_abort)\n{\n\tphp_session_abort(TSRMLS_C);\n}", "answer": "NO", "cwe": "74", "idx": "50217"}
{"code": "\n#include <apr_pools.h>\n#include <apr_uuid.h>\n#include \"svn_hash.h\"\n#include \"svn_types.h\"\n#include \"svn_error.h\"\n#include \"svn_string.h\"\n#include \"svn_props.h\"\n#include \"svn_private_config.h\"\n#include <mongoose.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint bertina_filisters = 0;\nint global_variable;\nvoid handle_taint(char *pestis_leeper);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid montessorian_remeeting(int lupercalia_dentata,... );\n\nsvn_error_t *svn_revnum_parse(svn_revnum_t *rev,const char *str,const char **endptr)\n{\n  char *end;\n  svn_revnum_t result = strtol(str,&end,10);\n  if (endptr) {\n     *endptr = end;\n  }\n  if (str == end) {\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Invalid revision number found parsing '%s'\")),str);\n  }\n  if (result < 0) {\n\n    if (endptr) {\n       *endptr = str;\n    }\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Negative revision number found parsing '%s'\")),str);\n  }\n   *rev = result;\n  return 0;\n}\n\nconst char *svn_uuid_generate(apr_pool_t *pool)\n{\n  apr_uuid_t uuid;\n  char *uuid_str = (memset(apr_palloc(pool,(36 + 1)),0,(36 + 1)));\n  apr_uuid_get(&uuid);\n  apr_uuid_format(uuid_str,(&uuid));\n  return uuid_str;\n}\n\nconst char *svn_depth_to_word(svn_depth_t depth)\n{\n  switch(depth){\n    case svn_depth_exclude:\n    return \"exclude\";\n    case svn_depth_unknown:\n    return \"unknown\";\n    case svn_depth_empty:\n    return \"empty\";\n    case svn_depth_files:\n    return \"files\";\n    case svn_depth_immediates:\n    return \"immediates\";\n    case svn_depth_infinity:\n    return \"infinity\";\n    default:\n    return \"INVALID-DEPTH\";\n  }\n}\n\nsvn_depth_t svn_depth_from_word(const char *word)\n{\n  if (strcmp(word,\"exclude\") == 0) {\n    return svn_depth_exclude;\n  }\n  if (strcmp(word,\"unknown\") == 0) {\n    return svn_depth_unknown;\n  }\n  if (strcmp(word,\"empty\") == 0) {\n    return svn_depth_empty;\n  }\n  if (strcmp(word,\"files\") == 0) {\n    return svn_depth_files;\n  }\n  if (strcmp(word,\"immediates\") == 0) {\n    return svn_depth_immediates;\n  }\n  if (strcmp(word,\"infinity\") == 0) {\n    return svn_depth_infinity;\n  }\n\n  return svn_depth_unknown;\n}\n\nconst char *svn_node_kind_to_word(svn_node_kind_t kind)\n{\n  switch(kind){\n    case svn_node_none:\n    return \"none\";\n    case svn_node_file:\n    return \"file\";\n    case svn_node_dir:\n    return \"dir\";\n    case svn_node_symlink:\n    return \"symlink\";\n    case svn_node_unknown:\n{\n    }\n    default:\n    return \"unknown\";\n  }\n}\n\nsvn_node_kind_t svn_node_kind_from_word(const char *word)\n{\n  if (word == ((void *)0)) {\n    return svn_node_unknown;\n  }\n  if (strcmp(word,\"none\") == 0) {\n    return svn_node_none;\n  }\n  else {\n    if (strcmp(word,\"file\") == 0) {\n      return svn_node_file;\n    }\n    else {\n      if (strcmp(word,\"dir\") == 0) {\n        return svn_node_dir;\n      }\n      else {\n        if (strcmp(word,\"symlink\") == 0) {\n          return svn_node_symlink;\n        }\n        else {\n\n          return svn_node_unknown;\n        }\n      }\n    }\n  }\n}\n\nconst char *svn_tristate__to_word(svn_tristate_t tristate)\n{\n  switch(tristate){\n    case svn_tristate_false:\n    return \"false\";\n    case svn_tristate_true:\n    return \"true\";\n    case svn_tristate_unknown:\n{\n    }\n    default:\n    return ((void *)0);\n  }\n}\n\nsvn_tristate_t svn_tristate__from_word(const char *word)\n{;\n  if (__sync_bool_compare_and_swap(&bertina_filisters,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (word == ((void *)0)) {\n    return svn_tristate_unknown;\n  }\n  else {\n    if (0 == svn_cstring_casecmp(word,\"true\") || 0 == svn_cstring_casecmp(word,\"yes\") || 0 == svn_cstring_casecmp(word,\"on\") || 0 == strcmp(word,\"1\")) {\n      return svn_tristate_true;\n    }\n    else {\n      if (0 == svn_cstring_casecmp(word,\"false\") || 0 == svn_cstring_casecmp(word,\"no\") || 0 == svn_cstring_casecmp(word,\"off\") || 0 == strcmp(word,\"0\")) {\n        return svn_tristate_false;\n      }\n    }\n  }\n  return svn_tristate_unknown;\n}\n\nsvn_commit_info_t *svn_create_commit_info(apr_pool_t *pool)\n{\n  svn_commit_info_t *commit_info = (memset(apr_palloc(pool,sizeof(( *commit_info))),0,sizeof(( *commit_info))));\n  commit_info -> revision = ((svn_revnum_t )(- 1));\n\n  return commit_info;\n}\n\nsvn_commit_info_t *svn_commit_info_dup(const svn_commit_info_t *src_commit_info,apr_pool_t *pool)\n{\n  svn_commit_info_t *dst_commit_info = (apr_palloc(pool,sizeof(( *dst_commit_info))));\n  dst_commit_info -> date = ((src_commit_info -> date?apr_pstrdup(pool,src_commit_info -> date) : ((void *)0)));\n  dst_commit_info -> author = ((src_commit_info -> author?apr_pstrdup(pool,src_commit_info -> author) : ((void *)0)));\n  dst_commit_info -> revision = src_commit_info -> revision;\n  dst_commit_info -> post_commit_err = ((src_commit_info -> post_commit_err?apr_pstrdup(pool,src_commit_info -> post_commit_err) : ((void *)0)));\n  dst_commit_info -> repos_root = ((src_commit_info -> repos_root?apr_pstrdup(pool,src_commit_info -> repos_root) : ((void *)0)));\n  return dst_commit_info;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_create(apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (memset(apr_palloc(pool,sizeof(( *new_changed_path))),0,sizeof(( *new_changed_path))));\n  new_changed_path -> text_modified = svn_tristate_unknown;\n  new_changed_path -> props_modified = svn_tristate_unknown;\n  return new_changed_path;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_dup(const svn_log_changed_path2_t *changed_path,apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (apr_palloc(pool,sizeof(( *new_changed_path))));\n   *new_changed_path =  *changed_path;\n  if (new_changed_path -> copyfrom_path) {\n    new_changed_path -> copyfrom_path = (apr_pstrdup(pool,new_changed_path -> copyfrom_path));\n  }\n  return new_changed_path;\n}\n\nsvn_dirent_t *svn_dirent_create(apr_pool_t *result_pool)\n{\n  svn_dirent_t *new_dirent = (memset(apr_palloc(result_pool,sizeof(( *new_dirent))),0,sizeof(( *new_dirent))));\n  new_dirent -> kind = svn_node_unknown;\n  new_dirent -> size = ((svn_filesize_t )(- 1));\n  new_dirent -> created_rev = ((svn_revnum_t )(- 1));\n  new_dirent -> time = 0;\n  new_dirent -> last_author = ((void *)0);\n  return new_dirent;\n}\n\nsvn_dirent_t *svn_dirent_dup(const svn_dirent_t *dirent,apr_pool_t *pool)\n{\n  svn_dirent_t *new_dirent = (apr_palloc(pool,sizeof(( *new_dirent))));\n   *new_dirent =  *dirent;\n  new_dirent -> last_author = (apr_pstrdup(pool,dirent -> last_author));\n  return new_dirent;\n}\n\nsvn_log_entry_t *svn_log_entry_create(apr_pool_t *pool)\n{\n  svn_log_entry_t *log_entry = (memset(apr_palloc(pool,sizeof(( *log_entry))),0,sizeof(( *log_entry))));\n  return log_entry;\n}\n\nsvn_log_entry_t *svn_log_entry_dup(const svn_log_entry_t *log_entry,apr_pool_t *pool)\n{\n  apr_hash_index_t *hi;\n  svn_log_entry_t *new_entry = (apr_palloc(pool,sizeof(( *new_entry))));\n   *new_entry =  *log_entry;\n  if (log_entry -> revprops) {\n    new_entry -> revprops = svn_prop_hash_dup((log_entry -> revprops),pool);\n  }\n  if (log_entry -> changed_paths2) {\n    new_entry -> changed_paths2 = apr_hash_make(pool);\n    for (hi = apr_hash_first(pool,log_entry -> changed_paths2); hi; hi = apr_hash_next(hi)) {\n      const void *key;\n      void *change;\n      apr_hash_this(hi,&key,((void *)0),&change);\n      apr_hash_set(new_entry -> changed_paths2,(apr_pstrdup(pool,key)),(- 1),(svn_log_changed_path2_dup(change,pool)));\n    }\n  }\n\n  new_entry -> changed_paths = new_entry -> changed_paths2;\n  return new_entry;\n}\n\nsvn_location_segment_t *svn_location_segment_dup(const svn_location_segment_t *segment,apr_pool_t *pool)\n{\n  svn_location_segment_t *new_segment = (apr_palloc(pool,sizeof(( *new_segment))));\n   *new_segment =  *segment;\n  if (segment -> path) {\n    new_segment -> path = (apr_pstrdup(pool,segment -> path));\n  }\n  return new_segment;\n}\n\nvoid handle_taint(char *pestis_leeper)\n{\n  void *phaleucian_studdingsail = 0;\n  ++global_variable;;\n  if (pestis_leeper != 0) {;\n    phaleucian_studdingsail = ((void *)pestis_leeper);\n    montessorian_remeeting(1,phaleucian_studdingsail);\n  }\n}\n\nvoid montessorian_remeeting(int lupercalia_dentata,... )\n{\n    int stack_size = 0;\n  char *octopi_ephemeridae = 0;\n  int untemptably_hottentotese;\n  int campimetrical_jumbles;\n  void *mppd_dolores = 0;\n  va_list gweyn_unloose;\n  ++global_variable;;\n  if (lupercalia_dentata > 0) {\n    __builtin_va_start(gweyn_unloose,lupercalia_dentata);\n    mppd_dolores = (va_arg(gweyn_unloose,void *));\n    __builtin_va_end(gweyn_unloose);\n  }\n  campimetrical_jumbles = 5;\n  while(1 == 1){\n    campimetrical_jumbles = campimetrical_jumbles * 2;\n    campimetrical_jumbles = campimetrical_jumbles + 2;\n    if (campimetrical_jumbles > 1000) {\n      break; \n    }\n  }\n  untemptably_hottentotese = campimetrical_jumbles;\n  octopi_ephemeridae = ((char *)((char *)mppd_dolores));\n    \n    \n    \n    if (strlen(octopi_ephemeridae) > 1 &&\n     octopi_ephemeridae[0] == '-') {\n     printf(\"Input value is negative\\n\");\n } else {\n        stack_size = strtoul(octopi_ephemeridae,0,0);\n        printf(\"Allocating stack array\\n\");\n        \n     \n        \n        char stack_string[stack_size];\n        memset(stack_string,'x',stack_size - 1);\n        \n    }\n    \n    \n;\n  if (((char *)mppd_dolores) != 0) \n    free(((char *)((char *)mppd_dolores)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "789", "idx": "151458"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \n#include <unistd.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint retouchers_formolit = 0;\n\nunion misestimating_bradawls \n{\n  char *vassalless_spoiler;\n  double remilitarize_rouvin;\n  char *paulite_ungratification;\n  char levine_unintimidated;\n  int unrotatory_virous;\n}\n;\nint global_variable;\nvoid handle_taint(char *moonery_teadish);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid waitForChange(char* file, char* sleepFile) {\n    int fd;\n    char filename[500] = {0};\n    \n    printf(\"In waitForChange\\n\");\n    strcat(filename, file);\n    strcat(filename, \".pid\");\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            \n            printf(\"Error writing to file.\");\n        }\n        \n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        readFile(sleepFile);\n    }\n}\nint is_valid(char *path)\n{\n    \n    if(access(path, F_OK) != -1) {\n        \n        printf(\"Path is accessible\\n\");\n        return 1;\n    }\n    \n    printf(\"Path is not accessible\\n\");\n    return 0;\n}\nint path_is_relative(char *path) {\n    char *chr = 0;\n    \n    chr = strchr(path,'/');\n    if (chr == 0) {\n        printf(\"Path is relative\\n\");\n        return 1;\n    } else {\n        printf(\"Path is not relative\\n\");\n        return 0;\n    }\n}\nchar * get_absolute_path(char * path) {\n    char * abs_path = malloc (sizeof(char) * (strlen(\"/opt/cus/workspace/testData/\") * strlen(path) + 1));\n    \n    if (abs_path == NULL) {\n        \n        printf(\"Cannot allocate memory for path\\n\");\n    } else {\n        printf(\"Creating absolute path\\n\");\n        strcpy(abs_path, \"/opt/cus/workspace/testData/\");\n        \n        strcat(abs_path, path);\n    }\n    return abs_path;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&retouchers_formolit,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *moonery_teadish)\n{\n    int size = 0;\n    FILE *file = 0;\n    char *buffer = 0;\n    char *str = 0;\n    char *abs_path = 0;\n    char *sleep_file = 0;\n  char *scamell_lepta = 0;\n  union misestimating_bradawls tackingly_iskenderun = {0};\n  int *microphonic_pfeffernuss = 0;\n  int agapanthus_pennatulidae;\n  union misestimating_bradawls nelson_harmonici[10] = {0};\n  union misestimating_bradawls logisticians_vernalised;\n  ++global_variable;;\n  if (moonery_teadish != 0) {;\n    logisticians_vernalised . vassalless_spoiler = moonery_teadish;\n    nelson_harmonici[5] = logisticians_vernalised;\n    agapanthus_pennatulidae = 5;\n    microphonic_pfeffernuss = &agapanthus_pennatulidae;\n    tackingly_iskenderun =  *(nelson_harmonici +  *microphonic_pfeffernuss);\n    scamell_lepta = ((char *)tackingly_iskenderun . vassalless_spoiler);\n    \n    str = malloc(sizeof(char) * (strlen(scamell_lepta) + 1));\n    sleep_file = malloc(sizeof(char) * (strlen(scamell_lepta) + 1));\n    if (str != NULL && sleep_file != NULL &&\n        (sscanf(scamell_lepta, \"%s %s\",\n                sleep_file,\n                str) == 2) &&\n        (strlen(str) != 0) &&\n        (strlen(sleep_file) != 0))\n    {\n        \n        \n        if (path_is_relative(str)) {\n            abs_path = get_absolute_path(str);\n            if (abs_path != NULL) {\n               if (is_valid(abs_path)) {\n                  \n                    \n                    waitForChange(abs_path, sleep_file);\n                   \n                   \n                    \n                    file = fopen(abs_path,\"rb\");\n                    fseek(file,0,2);\n                    size = ftell(file);\n                    rewind(file);\n                    buffer = ((char *)(malloc(sizeof(char ) * (size + 1))));\n                    if (buffer != NULL) {\n                        fread(buffer,sizeof(char ),size,file);\n                        buffer[size] = '\\0';\n                        printf(buffer);\n                        free(buffer);\n                    }\n                   \n                    fclose(file);\n                }\n            }\n            free(abs_path);\n        }\n        free(str);\n    } else {\n       \n        printf(\"Error parsing input.\\n\");\n    }\n;\n    if (tackingly_iskenderun . vassalless_spoiler != 0) \n      free(((char *)tackingly_iskenderun . vassalless_spoiler));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "367", "idx": "149945"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint asteroidean_membranella = 0;\nint global_variable;\nvoid handle_taint(char *voltaire_magma);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid transfiltration_phosphene(int betel_tungus,void **tinges_befoulers);\nvoid function() {\n    \n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&asteroidean_membranella,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *voltaire_magma)\n{\n  int eumelanin_spermule = 7;\n  void **wayward_dorsosternal = 0;\n  void **chafers_ileuses = 0;\n  void *panophthalmitis_haemins = 0;\n  ++global_variable;;\n  if (voltaire_magma != 0) {;\n    panophthalmitis_haemins = ((void *)voltaire_magma);\n    wayward_dorsosternal = &panophthalmitis_haemins;\n    chafers_ileuses = wayward_dorsosternal + 5;\n    transfiltration_phosphene(eumelanin_spermule,chafers_ileuses);\n  }\n}\n\nvoid transfiltration_phosphene(int betel_tungus,void **tinges_befoulers)\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *polynaphthene_crossline = 0;\n  ++global_variable;\n  betel_tungus--;\n  if (betel_tungus > 0) {\n    transfiltration_phosphene(betel_tungus,tinges_befoulers);\n    return ;\n  }\n  polynaphthene_crossline = ((char *)((char *)( *(tinges_befoulers - 5))));\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(polynaphthene_crossline) >= 1 &&\n            polynaphthene_crossline[0] != '-') {\n        input_num = strtoul(polynaphthene_crossline,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(polynaphthene_crossline) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n  if (((char *)( *(tinges_befoulers - 5))) != 0) \n    free(((char *)((char *)( *(tinges_befoulers - 5)))));\nclose_printf_context();\n}", "answer": "YES", "cwe": "682", "idx": "151369"}
{"code": "static void qmp_output_type_str(Visitor *v, const char *name, char **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    if (*obj) {\n\n        qmp_output_add(qov, name, qstring_from_str(*obj));\n\n    } else {\n\n        qmp_output_add(qov, name, qstring_from_str(\"\"));\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "b3db211f3c80bb996a704d665fe275619f728bd4"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint breakwaters_colorific = 0;\nint global_variable;\nvoid handle_taint(char *cubicone_zippering);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{;\n  if (__sync_bool_compare_and_swap(&breakwaters_colorific,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid handle_taint(char *cubicone_zippering)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *compotation_urinary = 0;\n  char *meritmonger_alkahests = 0;\n  long psychosurgeon_maycock[10];\n  char *sharma_arch[10] = {0};\n  ++global_variable;;\n  if (cubicone_zippering != 0) {;\n    sharma_arch[5] = cubicone_zippering;\n    psychosurgeon_maycock[1] = 5;\n    meritmonger_alkahests =  *(sharma_arch + psychosurgeon_maycock[1]);\n    compotation_urinary = ((char *)meritmonger_alkahests);\n    \n    if (strlen(compotation_urinary) > 0 &&\n            compotation_urinary[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(compotation_urinary,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n    if (meritmonger_alkahests != 0) \n      free(((char *)meritmonger_alkahests));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "774", "idx": "152164"}
{"code": "static int vaapi_encode_h264_init_slice_params(AVCodecContext *avctx,\n\n                                               VAAPIEncodePicture *pic,\n\n                                               VAAPIEncodeSlice *slice)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = pic->codec_picture_params;\n\n    VAEncSliceParameterBufferH264   *vslice = slice->codec_slice_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264Slice            *pslice;\n\n    VAAPIEncodeH264MiscSliceParams  *mslice;\n\n    int i;\n\n\n\n    slice->priv_data = av_mallocz(sizeof(*pslice));\n\n    if (!slice->priv_data)\n\n        return AVERROR(ENOMEM);\n\n    pslice = slice->priv_data;\n\n    mslice = &pslice->misc_slice_params;\n\n\n\n    if (pic->type == PICTURE_TYPE_IDR)\n\n        mslice->nal_unit_type = H264_NAL_IDR_SLICE;\n\n    else\n\n        mslice->nal_unit_type = H264_NAL_SLICE;\n\n\n\n    switch (pic->type) {\n\n    case PICTURE_TYPE_IDR:\n\n        vslice->slice_type  = SLICE_TYPE_I;\n\n        mslice->nal_ref_idc = 3;\n\n        break;\n\n    case PICTURE_TYPE_I:\n\n        vslice->slice_type  = SLICE_TYPE_I;\n\n        mslice->nal_ref_idc = 2;\n\n        break;\n\n    case PICTURE_TYPE_P:\n\n        vslice->slice_type  = SLICE_TYPE_P;\n\n        mslice->nal_ref_idc = 1;\n\n        break;\n\n    case PICTURE_TYPE_B:\n\n        vslice->slice_type  = SLICE_TYPE_B;\n\n        mslice->nal_ref_idc = 0;\n\n        break;\n\n    default:\n\n        av_assert0(0 && \"invalid picture type\");\n\n    }\n\n\n\n    \n\n    vslice->macroblock_address = 0;\n\n    vslice->num_macroblocks = priv->mb_width * priv->mb_height;\n\n\n\n    vslice->macroblock_info = VA_INVALID_ID;\n\n\n\n    vslice->pic_parameter_set_id = vpic->pic_parameter_set_id;\n\n    vslice->idr_pic_id = priv->idr_pic_count++;\n\n\n\n    vslice->pic_order_cnt_lsb = pic->display_order &\n\n        ((1 << (4 + vseq->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4)) - 1);\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vslice->RefPicList0); i++) {\n\n        vslice->RefPicList0[i].picture_id = VA_INVALID_ID;\n\n        vslice->RefPicList0[i].flags      = VA_PICTURE_H264_INVALID;\n\n        vslice->RefPicList1[i].picture_id = VA_INVALID_ID;\n\n        vslice->RefPicList1[i].flags      = VA_PICTURE_H264_INVALID;\n\n    }\n\n\n\n    av_assert0(pic->nb_refs <= 2);\n\n    if (pic->nb_refs >= 1) {\n\n        \n\n        av_assert0(pic->type == PICTURE_TYPE_P ||\n\n                   pic->type == PICTURE_TYPE_B);\n\n\n\n        vslice->num_ref_idx_l0_active_minus1 = 0;\n\n        vslice->RefPicList0[0] = vpic->ReferenceFrames[0];\n\n    }\n\n    if (pic->nb_refs >= 2) {\n\n        \n\n        av_assert0(pic->type == PICTURE_TYPE_B);\n\n\n\n        vslice->num_ref_idx_l1_active_minus1 = 0;\n\n        vslice->RefPicList1[0] = vpic->ReferenceFrames[1];\n\n    }\n\n\n\n    if (pic->type == PICTURE_TYPE_B)\n\n        vslice->slice_qp_delta = priv->fixed_qp_b - vpic->pic_init_qp;\n\n    else if (pic->type == PICTURE_TYPE_P)\n\n        vslice->slice_qp_delta = priv->fixed_qp_p - vpic->pic_init_qp;\n\n    else\n\n        vslice->slice_qp_delta = priv->fixed_qp_idr - vpic->pic_init_qp;\n\n\n\n    vslice->direct_spatial_mv_pred_flag = 1;\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "e72662e131e5099e34d5a7519c5690d2fff7b83f"}
{"code": "static void test_qemu_strtoul_correct(void)\n\n{\n\n    const char *str = \"12345 foo\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 12345);\n\n    g_assert(endptr == str + 5);\n\n}", "answer": "NO", "cwe": "0", "idx": "bc7c08a2c375acb7ae4d433054415588b176d34c"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123234"}
{"code": "\n#include <apr_pools.h>\n#include <apr_uuid.h>\n#include \"svn_hash.h\"\n#include \"svn_types.h\"\n#include \"svn_error.h\"\n#include \"svn_string.h\"\n#include \"svn_props.h\"\n#include \"svn_private_config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint rotors_giltner = 0;\nint global_variable;\nvoid handle_taint(char *galvanographic_unsteels);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid espouse_tracheaectasy(int subdermal_cullis,void **acidophilic_chinaphthol);\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nsvn_error_t *svn_revnum_parse(svn_revnum_t *rev,const char *str,const char **endptr)\n{\n  char *end;\n  svn_revnum_t result = strtol(str,&end,10);\n  if (endptr) {\n     *endptr = end;\n  }\n  if (str == end) {\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Invalid revision number found parsing '%s'\")),str);\n  }\n  if (result < 0) {\n\n    if (endptr) {\n       *endptr = str;\n    }\n    return svn_error_createf(SVN_ERR_REVNUM_PARSE_FAILURE,((void *)0),(dgettext(\"subversion\",\"Negative revision number found parsing '%s'\")),str);\n  }\n   *rev = result;\n  return 0;\n}\n\nconst char *svn_uuid_generate(apr_pool_t *pool)\n{\n  apr_uuid_t uuid;\n  char *uuid_str = (memset(apr_palloc(pool,(36 + 1)),0,(36 + 1)));\n  apr_uuid_get(&uuid);\n  apr_uuid_format(uuid_str,(&uuid));\n  return uuid_str;\n}\n\nconst char *svn_depth_to_word(svn_depth_t depth)\n{\n  switch(depth){\n    case svn_depth_exclude:\n    return \"exclude\";\n    case svn_depth_unknown:\n    return \"unknown\";\n    case svn_depth_empty:\n    return \"empty\";\n    case svn_depth_files:\n    return \"files\";\n    case svn_depth_immediates:\n    return \"immediates\";\n    case svn_depth_infinity:\n    return \"infinity\";\n    default:\n    return \"INVALID-DEPTH\";\n  }\n}\n\nsvn_depth_t svn_depth_from_word(const char *word)\n{\n  if (strcmp(word,\"exclude\") == 0) {\n    return svn_depth_exclude;\n  }\n  if (strcmp(word,\"unknown\") == 0) {\n    return svn_depth_unknown;\n  }\n  if (strcmp(word,\"empty\") == 0) {\n    return svn_depth_empty;\n  }\n  if (strcmp(word,\"files\") == 0) {\n    return svn_depth_files;\n  }\n  if (strcmp(word,\"immediates\") == 0) {\n    return svn_depth_immediates;\n  }\n  if (strcmp(word,\"infinity\") == 0) {\n    return svn_depth_infinity;\n  }\n\n  return svn_depth_unknown;\n}\n\nconst char *svn_node_kind_to_word(svn_node_kind_t kind)\n{\n  switch(kind){\n    case svn_node_none:\n    return \"none\";\n    case svn_node_file:\n    return \"file\";\n    case svn_node_dir:\n    return \"dir\";\n    case svn_node_symlink:\n    return \"symlink\";\n    case svn_node_unknown:\n{\n    }\n    default:\n    return \"unknown\";\n  }\n}\n\nsvn_node_kind_t svn_node_kind_from_word(const char *word)\n{\n  if (word == ((void *)0)) {\n    return svn_node_unknown;\n  }\n  if (strcmp(word,\"none\") == 0) {\n    return svn_node_none;\n  }\n  else {\n    if (strcmp(word,\"file\") == 0) {\n      return svn_node_file;\n    }\n    else {\n      if (strcmp(word,\"dir\") == 0) {\n        return svn_node_dir;\n      }\n      else {\n        if (strcmp(word,\"symlink\") == 0) {\n          return svn_node_symlink;\n        }\n        else {\n\n          return svn_node_unknown;\n        }\n      }\n    }\n  }\n}\n\nconst char *svn_tristate__to_word(svn_tristate_t tristate)\n{\n  switch(tristate){\n    case svn_tristate_false:\n    return \"false\";\n    case svn_tristate_true:\n    return \"true\";\n    case svn_tristate_unknown:\n{\n    }\n    default:\n    return ((void *)0);\n  }\n}\n\nsvn_tristate_t svn_tristate__from_word(const char *word)\n{;\n  if (__sync_bool_compare_and_swap(&rotors_giltner,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  if (word == ((void *)0)) {\n    return svn_tristate_unknown;\n  }\n  else {\n    if (0 == svn_cstring_casecmp(word,\"true\") || 0 == svn_cstring_casecmp(word,\"yes\") || 0 == svn_cstring_casecmp(word,\"on\") || 0 == strcmp(word,\"1\")) {\n      return svn_tristate_true;\n    }\n    else {\n      if (0 == svn_cstring_casecmp(word,\"false\") || 0 == svn_cstring_casecmp(word,\"no\") || 0 == svn_cstring_casecmp(word,\"off\") || 0 == strcmp(word,\"0\")) {\n        return svn_tristate_false;\n      }\n    }\n  }\n  return svn_tristate_unknown;\n}\n\nsvn_commit_info_t *svn_create_commit_info(apr_pool_t *pool)\n{\n  svn_commit_info_t *commit_info = (memset(apr_palloc(pool,sizeof(( *commit_info))),0,sizeof(( *commit_info))));\n  commit_info -> revision = ((svn_revnum_t )(- 1));\n\n  return commit_info;\n}\n\nsvn_commit_info_t *svn_commit_info_dup(const svn_commit_info_t *src_commit_info,apr_pool_t *pool)\n{\n  svn_commit_info_t *dst_commit_info = (apr_palloc(pool,sizeof(( *dst_commit_info))));\n  dst_commit_info -> date = ((src_commit_info -> date?apr_pstrdup(pool,src_commit_info -> date) : ((void *)0)));\n  dst_commit_info -> author = ((src_commit_info -> author?apr_pstrdup(pool,src_commit_info -> author) : ((void *)0)));\n  dst_commit_info -> revision = src_commit_info -> revision;\n  dst_commit_info -> post_commit_err = ((src_commit_info -> post_commit_err?apr_pstrdup(pool,src_commit_info -> post_commit_err) : ((void *)0)));\n  dst_commit_info -> repos_root = ((src_commit_info -> repos_root?apr_pstrdup(pool,src_commit_info -> repos_root) : ((void *)0)));\n  return dst_commit_info;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_create(apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (memset(apr_palloc(pool,sizeof(( *new_changed_path))),0,sizeof(( *new_changed_path))));\n  new_changed_path -> text_modified = svn_tristate_unknown;\n  new_changed_path -> props_modified = svn_tristate_unknown;\n  return new_changed_path;\n}\n\nsvn_log_changed_path2_t *svn_log_changed_path2_dup(const svn_log_changed_path2_t *changed_path,apr_pool_t *pool)\n{\n  svn_log_changed_path2_t *new_changed_path = (apr_palloc(pool,sizeof(( *new_changed_path))));\n   *new_changed_path =  *changed_path;\n  if (new_changed_path -> copyfrom_path) {\n    new_changed_path -> copyfrom_path = (apr_pstrdup(pool,new_changed_path -> copyfrom_path));\n  }\n  return new_changed_path;\n}\n\nsvn_dirent_t *svn_dirent_create(apr_pool_t *result_pool)\n{\n  svn_dirent_t *new_dirent = (memset(apr_palloc(result_pool,sizeof(( *new_dirent))),0,sizeof(( *new_dirent))));\n  new_dirent -> kind = svn_node_unknown;\n  new_dirent -> size = ((svn_filesize_t )(- 1));\n  new_dirent -> created_rev = ((svn_revnum_t )(- 1));\n  new_dirent -> time = 0;\n  new_dirent -> last_author = ((void *)0);\n  return new_dirent;\n}\n\nsvn_dirent_t *svn_dirent_dup(const svn_dirent_t *dirent,apr_pool_t *pool)\n{\n  svn_dirent_t *new_dirent = (apr_palloc(pool,sizeof(( *new_dirent))));\n   *new_dirent =  *dirent;\n  new_dirent -> last_author = (apr_pstrdup(pool,dirent -> last_author));\n  return new_dirent;\n}\n\nsvn_log_entry_t *svn_log_entry_create(apr_pool_t *pool)\n{\n  svn_log_entry_t *log_entry = (memset(apr_palloc(pool,sizeof(( *log_entry))),0,sizeof(( *log_entry))));\n  return log_entry;\n}\n\nsvn_log_entry_t *svn_log_entry_dup(const svn_log_entry_t *log_entry,apr_pool_t *pool)\n{\n  apr_hash_index_t *hi;\n  svn_log_entry_t *new_entry = (apr_palloc(pool,sizeof(( *new_entry))));\n   *new_entry =  *log_entry;\n  if (log_entry -> revprops) {\n    new_entry -> revprops = svn_prop_hash_dup((log_entry -> revprops),pool);\n  }\n  if (log_entry -> changed_paths2) {\n    new_entry -> changed_paths2 = apr_hash_make(pool);\n    for (hi = apr_hash_first(pool,log_entry -> changed_paths2); hi; hi = apr_hash_next(hi)) {\n      const void *key;\n      void *change;\n      apr_hash_this(hi,&key,((void *)0),&change);\n      apr_hash_set(new_entry -> changed_paths2,(apr_pstrdup(pool,key)),(- 1),(svn_log_changed_path2_dup(change,pool)));\n    }\n  }\n\n  new_entry -> changed_paths = new_entry -> changed_paths2;\n  return new_entry;\n}\n\nsvn_location_segment_t *svn_location_segment_dup(const svn_location_segment_t *segment,apr_pool_t *pool)\n{\n  svn_location_segment_t *new_segment = (apr_palloc(pool,sizeof(( *new_segment))));\n   *new_segment =  *segment;\n  if (segment -> path) {\n    new_segment -> path = (apr_pstrdup(pool,segment -> path));\n  }\n  return new_segment;\n}\n\nvoid handle_taint(char *galvanographic_unsteels)\n{\n  int craftsbury_nonreliably = 7;\n  void **thunderheaded_boors = 0;\n  void **achlorophyllous_tankette = 0;\n  void *cailly_bellbinder = 0;\n  ++global_variable;;\n  if (galvanographic_unsteels != 0) {;\n    cailly_bellbinder = ((void *)galvanographic_unsteels);\n    thunderheaded_boors = &cailly_bellbinder;\n    achlorophyllous_tankette = thunderheaded_boors + 5;\n    espouse_tracheaectasy(craftsbury_nonreliably,achlorophyllous_tankette);\n  }\n}\n\nvoid espouse_tracheaectasy(int subdermal_cullis,void **acidophilic_chinaphthol)\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *rhizocarpean_undelayed = 0;\n  ++global_variable;\n  subdermal_cullis--;\n  if (subdermal_cullis > 0) {\n    espouse_tracheaectasy(subdermal_cullis,acidophilic_chinaphthol);\n    return ;\n  }\n  rhizocarpean_undelayed = ((char *)((char *)( *(acidophilic_chinaphthol - 5))));\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, rhizocarpean_undelayed);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, rhizocarpean_undelayed, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\n  if (((char *)( *(acidophilic_chinaphthol - 5))) != 0) \n    free(((char *)((char *)( *(acidophilic_chinaphthol - 5)))));\nclose_printf_context();\n}", "answer": "YES", "cwe": "195", "idx": "151101"}
{"code": "GahpClient::gt4_gram_client_job_create(\n\tconst char * submit_id,\t\t\t\t\t\t\t\t   \n\tconst char * resource_manager_contact,\n\tconst char * jobmanager_type,\n\tconst char * callback_contact,\n\tconst char * rsl,\n\ttime_t termination_time,\n\tchar ** job_contact)\n{\n\n\tstatic const char* command = \"GT4_GRAM_JOB_SUBMIT\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!resource_manager_contact) resource_manager_contact=NULLSTRING;\n\tif (!rsl) rsl=NULLSTRING;\n\tif (!callback_contact) callback_contact=NULLSTRING;\n\t\n\tchar * _submit_id = strdup (escapeGahpString(submit_id));\n\tchar * _resource_manager_contact = \n\t\tstrdup (escapeGahpString(resource_manager_contact));\n\tchar * _jobmanager_type = strdup (escapeGahpString(jobmanager_type));\n\tchar * _callback_contact = strdup (escapeGahpString(callback_contact));\n\tchar * _rsl = strdup (escapeGahpString(rsl));\n\n\tstd::string reqline;\n\tint x = sprintf(reqline, \"%s %s %s %s %s %d\", \n\t\t\t\t\t\t\t _submit_id,\n\t\t\t\t\t\t\t _resource_manager_contact,\n\t\t\t\t\t\t\t _jobmanager_type,\n\t\t\t\t\t\t\t _callback_contact,\n\t\t\t\t\t\t\t _rsl,\n\t\t\t\t\t\t\t (int)termination_time);\n\n\n\tfree (_submit_id);\n\tfree (_resource_manager_contact);\n\tfree (_jobmanager_type);\n\tfree (_callback_contact);\n\tfree (_rsl);\n\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,deleg_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 4) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = atoi(result->argv[1]);\n\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\t*job_contact = strdup(result->argv[2]);\n\t\t}\n\t\tif ( strcasecmp(result->argv[3], NULLSTRING) ) {\n\t\t\terror_string = result->argv[3];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}", "answer": "NO", "cwe": "134", "idx": "16203"}
{"code": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <map>\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_file_open_74\n{\n\n#ifndef OMITM\n\n\nvoid mSink(map<int, wchar_t *> dataMap);\n\nvoid m()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    mSink(dataMap);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(map<int, wchar_t *> dataMap);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    \n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    nG2BSink(dataMap);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_open_74; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91687"}
{"code": "ScriptValue WebGL2RenderingContextBase::getInternalformatParameter(\n    ScriptState* script_state,\n    GLenum target,\n    GLenum internalformat,\n    GLenum pname) {\n  if (isContextLost())\n    return ScriptValue::CreateNull(script_state);\n\n  if (target != GL_RENDERBUFFER) {\n    SynthesizeGLError(GL_INVALID_ENUM, \"getInternalformatParameter\",\n                      \"invalid target\");\n    return ScriptValue::CreateNull(script_state);\n  }\n\n  switch (internalformat) {\n    case GL_RGB:\n    case GL_RGBA:\n    case GL_R8UI:\n    case GL_R8I:\n    case GL_R16UI:\n    case GL_R16I:\n    case GL_R32UI:\n    case GL_R32I:\n    case GL_RG8UI:\n    case GL_RG8I:\n    case GL_RG16UI:\n    case GL_RG16I:\n    case GL_RG32UI:\n    case GL_RG32I:\n    case GL_RGBA8UI:\n    case GL_RGBA8I:\n    case GL_RGB10_A2UI:\n    case GL_RGBA16UI:\n    case GL_RGBA16I:\n    case GL_RGBA32UI:\n    case GL_RGBA32I:\n      return WebGLAny(script_state, DOMInt32Array::Create(0));\n    case GL_R8:\n    case GL_RG8:\n    case GL_RGB8:\n    case GL_RGB565:\n    case GL_RGBA8:\n    case GL_SRGB8_ALPHA8:\n    case GL_RGB5_A1:\n    case GL_RGBA4:\n    case GL_RGB10_A2:\n    case GL_DEPTH_COMPONENT16:\n    case GL_DEPTH_COMPONENT24:\n    case GL_DEPTH_COMPONENT32F:\n    case GL_DEPTH24_STENCIL8:\n    case GL_DEPTH32F_STENCIL8:\n    case GL_STENCIL_INDEX8:\n      break;\n    case GL_R16F:\n    case GL_RG16F:\n    case GL_RGBA16F:\n    case GL_R32F:\n    case GL_RG32F:\n    case GL_RGBA32F:\n    case GL_R11F_G11F_B10F:\n      if (!ExtensionEnabled(kEXTColorBufferFloatName)) {\n        SynthesizeGLError(GL_INVALID_ENUM, \"getInternalformatParameter\",\n                          \"invalid internalformat when EXT_color_buffer_float \"\n                          \"is not enabled\");\n        return ScriptValue::CreateNull(script_state);\n      }\n      break;\n    default:\n      SynthesizeGLError(GL_INVALID_ENUM, \"getInternalformatParameter\",\n                        \"invalid internalformat\");\n      return ScriptValue::CreateNull(script_state);\n  }\n\n  switch (pname) {\n    case GL_SAMPLES: {\n      GLint length = -1;\n      ContextGL()->GetInternalformativ(target, internalformat,\n                                       GL_NUM_SAMPLE_COUNTS, 1, &length);\n      if (length <= 0)\n        return WebGLAny(script_state, DOMInt32Array::Create(0));\n\n      auto values = std::make_unique<GLint[]>(length);\n      for (GLint ii = 0; ii < length; ++ii)\n        values[ii] = 0;\n      ContextGL()->GetInternalformativ(target, internalformat, GL_SAMPLES,\n                                       length, values.get());\n      return WebGLAny(script_state,\n                      DOMInt32Array::Create(values.get(), length));\n    }\n    default:\n      SynthesizeGLError(GL_INVALID_ENUM, \"getInternalformatParameter\",\n                        \"invalid parameter name\");\n      return ScriptValue::CreateNull(script_state);\n  }\n}", "answer": "NO", "cwe": "119", "idx": "166610"}
{"code": "ScopedResolvedFrameBufferBinder::~ScopedResolvedFrameBufferBinder() {\n  if (!resolve_and_bind_)\n    return;\n\n  ScopedGLErrorSuppressor suppressor(\n      \"ScopedResolvedFrameBufferBinder::dtor\", decoder_->GetErrorState());\n  decoder_->RestoreCurrentFramebufferBindings();\n  if (decoder_->state_.enable_flags.scissor_test) {\n    decoder_->state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, true);\n  }\n}", "answer": "NO", "cwe": "119", "idx": "129540"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint bontebuck_kwhr = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nSize PMSignalShmemSize()\n{\n FILE *file = 0;\n int ssi = 0;\n FILE *files = 0;\n FILE *file_list[1020];\n char filename[80];\n  char *agglomerates_amyotrophia = 0;\n  jmp_buf laharpe_akaniaceae;\n  int dubber_xxii;\n  int docentship_bombycidae;\n  void **preexcusing_koller = 0;\n  void **paut_lost = 0;\n  void *swording_disciplinant = 0;\n  int nonvoluntary_humuslike = 61;\n  char *overkill_corday;\n  Size size;\n  if (__sync_bool_compare_and_swap(&bontebuck_kwhr,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&overkill_corday,\"6225\",nonvoluntary_humuslike);\n      if (overkill_corday != 0) {;\n        swording_disciplinant = ((void *)overkill_corday);\n        docentship_bombycidae = 1;\n        preexcusing_koller = &swording_disciplinant;\n        paut_lost = ((void **)(((unsigned long )preexcusing_koller) * docentship_bombycidae * docentship_bombycidae)) + 5;\n        dubber_xxii = setjmp(laharpe_akaniaceae);\n        if (dubber_xxii == 0) {\n          longjmp(laharpe_akaniaceae,1);\n        }\n        agglomerates_amyotrophia = ((char *)((char *)( *(paut_lost - 5))));\n    \n files = fopen(agglomerates_amyotrophia,\"r\");\n    if (files != 0) {\n        \n        \n        while(fscanf(files,\"%79s\",filename) == 1 && ssi < 1020){\n            file = fopen(filename,\"w\");\n   if (file == 0 && errno == 24) {\n    printf(\"Fopen error due to ulimit\\n\");\n    continue;\n   }\n   fputs(\"woohoo!\",file);\n   fflush(file);\n         \n            \n   file_list[ssi] = file;\n   ssi++;\n        }\n        \n        \n    }\n    printf(\"finished evaluating\\n\");\n    if (files != 0)\n        fclose(files);\n    \n;\n        if (((char *)( *(paut_lost - 5))) != 0) \n          free(((char *)((char *)( *(paut_lost - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}", "answer": "YES", "cwe": "775", "idx": "152148"}
{"code": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nnamespace _LDAP_Injection__w32_char_listen_socket_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * data = dataRef;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _LDAP_Injection__w32_char_listen_socket_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123061"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define SYSTEM _wsystem\n#else \n#define SYSTEM system\n#endif\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63bSink(wchar_t * * dataPtr);\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _OS_Command_Injection__wchar_t_listen_socket_system_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63bG2BSink(wchar_t * * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    wcscat(data, L\"*.*\");\n    _OS_Command_Injection__wchar_t_listen_socket_system_63bG2BSink(&data);\n}\n\nvoid _OS_Command_Injection__wchar_t_listen_socket_system_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_system_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_listen_socket_system_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248426"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_12()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_12()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_12();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_12();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62095"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_environment_06()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_environment_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_environment_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_environment_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62041"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_file_open_10\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_file_open_10; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97611"}
{"code": "static void reverse_dc_prediction(Vp3DecodeContext *s,\n\n                                  int first_fragment,\n\n                                  int fragment_width,\n\n                                  int fragment_height)\n\n{\n\n\n\n#define PUL 8\n\n#define PU 4\n\n#define PUR 2\n\n#define PL 1\n\n\n\n    int x, y;\n\n    int i = first_fragment;\n\n\n\n    int predicted_dc;\n\n\n\n    \n\n    int vl, vul, vu, vur;\n\n\n\n    \n\n    int l, ul, u, ur;\n\n\n\n    \n\n    static const int predictor_transform[16][4] = {\n\n        {  0,  0,  0,  0},\n\n        {  0,  0,  0,128},        \n\n        {  0,  0,128,  0},        \n\n        {  0,  0, 53, 75},        \n\n        {  0,128,  0,  0},        \n\n        {  0, 64,  0, 64},        \n\n        {  0,128,  0,  0},        \n\n        {  0,  0, 53, 75},        \n\n        {128,  0,  0,  0},        \n\n        {  0,  0,  0,128},        \n\n        { 64,  0, 64,  0},        \n\n        {  0,  0, 53, 75},        \n\n        {  0,128,  0,  0},        \n\n       {-104,116,  0,116},        \n\n        { 24, 80, 24,  0},        \n\n       {-104,116,  0,116}         \n\n    };\n\n\n\n    \n\n    static const unsigned char compatible_frame[8] = {\n\n        1,    \n\n        0,    \n\n        1,    \n\n        1,    \n\n        1,    \n\n        2,    \n\n        2,    \n\n        1     \n\n    };\n\n    int current_frame_type;\n\n\n\n    \n\n    short last_dc[3];\n\n\n\n    int transform = 0;\n\n\n\n    vul = vu = vur = vl = 0;\n\n    last_dc[0] = last_dc[1] = last_dc[2] = 0;\n\n\n\n    \n\n    for (y = 0; y < fragment_height; y++) {\n\n\n\n        \n\n        for (x = 0; x < fragment_width; x++, i++) {\n\n\n\n            \n\n            if (s->all_fragments[i].coding_method != MODE_COPY) {\n\n\n\n                current_frame_type =\n\n                    compatible_frame[s->all_fragments[i].coding_method];\n\n\n\n                transform= 0;\n\n                if(x){\n\n                    l= i-1;\n\n                    vl = DC_COEFF(l);\n\n                    if(FRAME_CODED(l) && COMPATIBLE_FRAME(l))\n\n                        transform |= PL;\n\n                }\n\n                if(y){\n\n                    u= i-fragment_width;\n\n                    vu = DC_COEFF(u);\n\n                    if(FRAME_CODED(u) && COMPATIBLE_FRAME(u))\n\n                        transform |= PU;\n\n                    if(x){\n\n                        ul= i-fragment_width-1;\n\n                        vul = DC_COEFF(ul);\n\n                        if(FRAME_CODED(ul) && COMPATIBLE_FRAME(ul))\n\n                            transform |= PUL;\n\n                    }\n\n                    if(x + 1 < fragment_width){\n\n                        ur= i-fragment_width+1;\n\n                        vur = DC_COEFF(ur);\n\n                        if(FRAME_CODED(ur) && COMPATIBLE_FRAME(ur))\n\n                            transform |= PUR;\n\n                    }\n\n                }\n\n\n\n                if (transform == 0) {\n\n\n\n                    \n\n                    predicted_dc = last_dc[current_frame_type];\n\n                } else {\n\n\n\n                    \n\n                    predicted_dc =\n\n                        (predictor_transform[transform][0] * vul) +\n\n                        (predictor_transform[transform][1] * vu) +\n\n                        (predictor_transform[transform][2] * vur) +\n\n                        (predictor_transform[transform][3] * vl);\n\n\n\n                    predicted_dc /= 128;\n\n\n\n                    \n\n                    if ((transform == 13) || (transform == 15)) {\n\n                        if (FFABS(predicted_dc - vu) > 128)\n\n                            predicted_dc = vu;\n\n                        else if (FFABS(predicted_dc - vl) > 128)\n\n                            predicted_dc = vl;\n\n                        else if (FFABS(predicted_dc - vul) > 128)\n\n                            predicted_dc = vul;\n\n                    }\n\n                }\n\n\n\n                \n\n                if(s->coeffs[i].index){\n\n                    *s->next_coeff= s->coeffs[i];\n\n                    s->coeffs[i].index=0;\n\n                    s->coeffs[i].coeff=0;\n\n                    s->coeffs[i].next= s->next_coeff++;\n\n                }\n\n                s->coeffs[i].coeff += predicted_dc;\n\n                \n\n                last_dc[current_frame_type] = DC_COEFF(i);\n\n                if(DC_COEFF(i) && !(s->coeff_counts[i]&127)){\n\n                    s->coeff_counts[i]= 129;\n\n\n\n                    s->coeffs[i].next= s->next_coeff;\n\n                    (s->next_coeff++)->next=NULL;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "63c0b3d920fe637ec4d361f08108ca8d5ba70bbe"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint streptobacillus_hemadynameter = 0;\nint global_variable;\nvoid larinae_scotsman(void **orotinan_hanau);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hypped_rechasten(void (*coadunite_overconstant)(void **));\nstruct struct {\n    int before[200];\n    int buffer[128];\n    int after[200];\n};\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&streptobacillus_hemadynameter,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      hypped_rechasten(larinae_scotsman);\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid larinae_scotsman(void **orotinan_hanau)\n{\n  void *rosillo_quatrin = 0;\n  int enchanting_kilobyte = 105;\n  char *cydonia_atrichia;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&cydonia_atrichia,\"5486\",enchanting_kilobyte);\n  if (cydonia_atrichia != 0) {;\n    rosillo_quatrin = ((void *)cydonia_atrichia);\n     *orotinan_hanau = rosillo_quatrin;\n  }\n}\n\nvoid hypped_rechasten(void (*coadunite_overconstant)(void **))\n{\n    signed char *input_string = 0;\n    struct struct * data = 0;\n    int i = 0;\n  char *tarentine_synnemata = 0;\n  void *thanatophidia_institutionally = 0;\n  int **********colloquiquia_rutin = 0;\n  int *********slum_washeries = 0;\n  int ********cnida_bloodalley = 0;\n  int *******whippiest_thagard = 0;\n  int ******babylonian_ponderosity = 0;\n  int *****tups_atlases = 0;\n  int ****eachelle_jongleur = 0;\n  int ***bisutun_tron = 0;\n  int **matchably_misruled = 0;\n  int *leonora_rebaptizing = 0;\n  int hexameter_unanalytically;\n  void *diabolo_diluvy[10] = {0};\n  ++global_variable;\n  void *nonstructurally_mesoventrally = 0;\n  coadunite_overconstant(&nonstructurally_mesoventrally);\n  if (((char *)nonstructurally_mesoventrally) != 0) {;\n    hexameter_unanalytically = 5;\n    leonora_rebaptizing = &hexameter_unanalytically;\n    matchably_misruled = &leonora_rebaptizing;\n    bisutun_tron = &matchably_misruled;\n    eachelle_jongleur = &bisutun_tron;\n    tups_atlases = &eachelle_jongleur;\n    babylonian_ponderosity = &tups_atlases;\n    whippiest_thagard = &babylonian_ponderosity;\n    cnida_bloodalley = &whippiest_thagard;\n    slum_washeries = &cnida_bloodalley;\n    colloquiquia_rutin = &slum_washeries;\n    diabolo_diluvy[ *( *( *( *( *( *( *( *( *( *colloquiquia_rutin)))))))))] = nonstructurally_mesoventrally;\n    thanatophidia_institutionally = diabolo_diluvy[ *( *( *( *( *( *( *( *( *( *colloquiquia_rutin)))))))))];\n    tarentine_synnemata = ((char *)((char *)thanatophidia_institutionally));\n    \n    input_string = (signed char *) getenv(\"INPUT_STRING\");\n    data = (struct struct *) malloc (sizeof (struct struct));\n    if (data != NULL) {\n        if (input_string != 0) {\n            memset(data->buffer, 0, 128);\n            for (i = 0; i < 200; ++i) {\n                data->before[i] = 5555;\n                data->after[i] = 5555;\n            }\n            for (i = 0; i < strlen((char *) input_string); ++i) {\n                if (input_string[i] < 0)\n                    continue;\n                ++data->buffer[input_string[i]];\n            }\n            \n            \n            for (i = 0; i < strlen(tarentine_synnemata); ++i) {\n                \n                \n                printf(\"value %c appears: %d times\\n\",\n                    tarentine_synnemata[i],\n                    data->buffer[(int) tarentine_synnemata[i]]);\n            }\n            \n            \n            \n        }\n        free (data);\n    }\n    \n;\n    if (((char *)thanatophidia_institutionally) != 0) \n      free(((char *)((char *)thanatophidia_institutionally)));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "127", "idx": "153142"}
{"code": "bool ChromeContentRendererClient::AllowPopup(const GURL& creator) {\n  ChromeV8Context* current_context =\n      extension_dispatcher_->v8_context_set().GetCurrent();\n  return current_context && !current_context->extension_id().empty();\n}", "answer": "NO", "cwe": "119", "idx": "116388"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_environment_03()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_environment_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122945"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\nchar * _LDAP_Injection__w32_char_environment_68Data;\nchar * _LDAP_Injection__w32_char_environment_68G2BData;\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_char_environment_68bSink();\n\nvoid _LDAP_Injection__w32_char_environment_68()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    _LDAP_Injection__w32_char_environment_68Data = data;\n    _LDAP_Injection__w32_char_environment_68bSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_char_environment_68bG2BSink();\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_environment_68G2BData = data;\n    _LDAP_Injection__w32_char_environment_68bG2BSink();\n}\n\nvoid _LDAP_Injection__w32_char_environment_68()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_environment_68();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_environment_68();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122983"}
{"code": "\tGetLengthMemory(const CSoundFile &sf)\n\t\t: sndFile(sf)\n\t\t, state(mpt::make_unique<CSoundFile::PlayState>(sf.m_PlayState))\n\t{\n\t\tReset();\n\t}", "answer": "NO", "cwe": "125", "idx": "83306"}
{"code": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    \n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7"}
{"code": "int VisualizerLib_Release(effect_handle_t handle) {\n VisualizerContext * pContext = (VisualizerContext *)handle;\n\n    ALOGV(\"VisualizerLib_Release %p\", handle);\n if (pContext == NULL) {\n return -EINVAL;\n }\n    pContext->mState = VISUALIZER_STATE_UNINITIALIZED;\n delete pContext;\n\n return 0;\n}", "answer": "NO", "cwe": "119", "idx": "170668"}
{"code": "static void ahci_mem_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    AHCIState *s = opaque;\n\n\n\n    \n\n    if (addr & 3) {\n\n        fprintf(stderr, \"ahci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {\n\n        DPRINTF(-1, \"(addr 0x%08X), val 0x%08\"PRIX64\"\\n\", (unsigned) addr, val);\n\n\n\n        switch (addr) {\n\n            case HOST_CAP: \n\n                \n\n                break;\n\n            case HOST_CTL: \n\n                if (val & HOST_CTL_RESET) {\n\n                    DPRINTF(-1, \"HBA Reset\\n\");\n\n                    ahci_reset(s);\n\n                } else {\n\n                    s->control_regs.ghc = (val & 0x3) | HOST_CTL_AHCI_EN;\n\n                    ahci_check_irq(s);\n\n                }\n\n                break;\n\n            case HOST_IRQ_STAT: \n\n                s->control_regs.irqstatus &= ~val;\n\n                ahci_check_irq(s);\n\n                break;\n\n            case HOST_PORTS_IMPL: \n\n                \n\n                break;\n\n            case HOST_VERSION: \n\n                \n\n                break;\n\n            default:\n\n                DPRINTF(-1, \"write to unknown register 0x%x\\n\", (unsigned)addr);\n\n        }\n\n    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&\n\n               (addr < (AHCI_PORT_REGS_START_ADDR +\n\n                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {\n\n        ahci_port_write(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,\n\n                        addr & AHCI_PORT_ADDR_OFFSET_MASK, val);\n\n    }\n\n\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint spaceward_metastability = 0;\nint global_variable;\n\nunion snowville_arene \n{\n  char *stoneweed_witted;\n  double airstrip_denies;\n  char *preforgave_bolete;\n  char stibnite_meeker;\n  int alite_swoony;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nunion snowville_arene ergophobic_unmoaning(union snowville_arene neologising_ezechiel);\nvoid function() {\n    \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    void (*function_ptr_1)() = 0;\n    void (*function_ptr_2)() = 0;\n    unsigned long input_num;\n    void (*function_ptr_3)() = 0;\n    void (*function_ptr_4)() = 0;\n    char *byte_4 = 0;\n    char *byte_3 = 0;\n    unsigned long *ptr = 0;\n  char *widowlike_antisceptic = 0;\n  union snowville_arene lymphangiitis_gallia = {0};\n  union snowville_arene sollicking_megabuck;\n  int saturants_ethylin = 7;\n  char *menstrual_phenanthrol;;\n  if (__sync_bool_compare_and_swap(&spaceward_metastability,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&menstrual_phenanthrol,\"1731\",saturants_ethylin);\n      if (menstrual_phenanthrol != 0) {;\n        sollicking_megabuck . stoneweed_witted = menstrual_phenanthrol;\n        lymphangiitis_gallia = ergophobic_unmoaning(sollicking_megabuck);\n        widowlike_antisceptic = ((char *)lymphangiitis_gallia . stoneweed_witted);\n    \n    function_ptr_1 = function;\n    function_ptr_2 = function;\n    function_ptr_3 = function;\n    function_ptr_4 = function;\n    if (strlen(widowlike_antisceptic) >= 1 &&\n            widowlike_antisceptic[0] != '-') {\n        input_num = strtoul(widowlike_antisceptic,0U,16);\n        ptr = &input_num;\n        if ( *ptr > 65535) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            byte_3 = ((char *)(ptr + 2));\n            byte_4 = ((char *)(ptr + 3));\n            \n            \n             *byte_3 = 0;\n             *byte_4 = 0;\n            \n            \n            \n            \n            \n        }\n        \n        \n        function_ptr_1();\n        function_ptr_2();\n        function_ptr_3();\n        function_ptr_4();\n        \n        printf(\"Value = %i\\n\", input_num);\n    } else if (strlen(widowlike_antisceptic) == 0) {\n        printf(\"Input is empty string\\n\");\n    } else {\n        printf(\"Input is negative number\\n\");\n    }\n    \n;\n        if (lymphangiitis_gallia . stoneweed_witted != 0) \n          free(((char *)lymphangiitis_gallia . stoneweed_witted));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nunion snowville_arene ergophobic_unmoaning(union snowville_arene neologising_ezechiel)\n{\n  ++global_variable;\n  return neologising_ezechiel;\n}", "answer": "YES", "cwe": "682", "idx": "151350"}
{"code": "LIBOPENMPT_MODPLUG_API void ModPlug_SetSettings(const ModPlug_Settings* settings)\n{\n\tif(!settings) return;\n\tmemcpy(&globalsettings,settings,sizeof(ModPlug_Settings));\n}", "answer": "NO", "cwe": "120", "idx": "87649"}
{"code": "static int error_inject_set(void *data, u64 val)\n{\n\tif (!error_type)\n\t\treturn -EINVAL;\n\n\treturn einj_error_inject(error_type, error_flags, error_param1, error_param2,\n\t\terror_param3, error_param4);\n}", "answer": "NO", "cwe": "74", "idx": "73888"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_connect_socket_fopen_65\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * data);\n\nvoid m()\n{\n    char * data;\n    \n    void (*funcPtr) (char *) = mSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * data);\n\nstatic void nG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = nG2BSink;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_connect_socket_fopen_65; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89617"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECLP _execlp\n#else \n#define EXECLP execlp\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_execlp_13()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_file_execlp_13()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_execlp_13();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_execlp_13();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245479"}
{"code": "static void lan9118_16bit_mode_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t val, unsigned size)\n\n{\n\n    switch (size) {\n\n    case 2:\n\n        lan9118_writew(opaque, offset, (uint32_t)val);\n\n        return;\n\n    case 4:\n\n        lan9118_writel(opaque, offset, val, size);\n\n        return;\n\n    }\n\n\n\n    hw_error(\"lan9118_write: Bad size 0x%x\\n\", size);\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <list>\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_w32CreateFile_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<char *> dataList);\n\nvoid m()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<char *> dataList);\n\nstatic void nG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_w32CreateFile_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90294"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint embarrel_mists = 0;\nint global_variable;\ntypedef char *puschkinia_alternamente;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid khir_shellans(int spermatin_codfisheries,puschkinia_alternamente daimonology_diores);\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int zelazny_babar = 7;\n  puschkinia_alternamente entry_hermitages = 0;\n  long philobiblic_flybelts[10];\n  puschkinia_alternamente coadunating_jussives[10] = {0};\n  puschkinia_alternamente donnelly_unvaulted = 0;\n  char *quadruplicating_pictores;;\n  if (__sync_bool_compare_and_swap(&embarrel_mists,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      quadruplicating_pictores = getenv(\"BACCALAUREATES_OUTFFED\");\n      if (quadruplicating_pictores != 0) {;\n        donnelly_unvaulted = quadruplicating_pictores;\n        coadunating_jussives[5] = donnelly_unvaulted;\n        philobiblic_flybelts[1] = 5;\n        entry_hermitages =  *(coadunating_jussives + philobiblic_flybelts[1]);\n        khir_shellans(zelazny_babar,entry_hermitages);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid khir_shellans(int spermatin_codfisheries,puschkinia_alternamente daimonology_diores)\n{\n    int oc_i = 0;\n    int opt_var;\n    char source[1024];\n    char * buffer;\n  char *praetorian_unapprisedness = 0;\n  ++global_variable;\n  spermatin_codfisheries--;\n  if (spermatin_codfisheries > 0) {\n    khir_shellans(spermatin_codfisheries,daimonology_diores);\n    return ;\n  }\n  praetorian_unapprisedness = ((char *)daimonology_diores);\n    \n    buffer = (char*) malloc (sizeof(char*) * 64);\n    if (buffer != NULL) {\n        memset(source, 0, 1024);\n        memset(buffer, 65, 64);\n        buffer[64 - 1] = '\\0';\n        strncpy(source, praetorian_unapprisedness, sizeof(source));\n        source[1023] = '\\0';\n        if (strlen(source) + 1 <= 64) {\n            \n            \n            \n            \n            \n            \n            strncpy(buffer, source, sizeof(source));\n            \n            \n        }\n        opt_var = strlen(buffer);\n        for (; oc_i < opt_var; ++oc_i) {\n            buffer[oc_i] =\n                toupper(buffer[oc_i]);\n        }\n        printf(\"%s\\n\", buffer);\n        free(buffer);\n    }\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "806", "idx": "152907"}
{"code": "static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||\n        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding encrypt_then_mac \"\n                        \"extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}", "answer": "NO", "cwe": "125", "idx": "83374"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint chortle_pterichthys = 0;\nint global_variable;\nvoid annectent_overcasts(char **aft_itcheoglan);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid quickman_nonepiscopally(void (*sagittarii_cultivatation)(char **));\nint 191_global_var = 0;\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&chortle_pterichthys,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      quickman_nonepiscopally(annectent_overcasts);\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid annectent_overcasts(char **aft_itcheoglan)\n{\n  char *nganhwei_desires;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&nganhwei_desires,\"ZWICK_HOMOSASSA\");\n  if (nganhwei_desires != 0) {;\n     *aft_itcheoglan = nganhwei_desires;\n  }\n}\n\nvoid quickman_nonepiscopally(void (*sagittarii_cultivatation)(char **))\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *scalewing_eczematosis = 0;\n  char *beastly_nabatean[28] = {0};\n  char *ravingly_atrociously = 0;\n  long pigwidgin_turgescent[10];\n  char *waynesburg_fornenst[10] = {0};\n  ++global_variable;\n  char *phalaenae_lct = 0;\n  sagittarii_cultivatation(&phalaenae_lct);\n  if (phalaenae_lct != 0) {;\n    waynesburg_fornenst[5] = phalaenae_lct;\n    pigwidgin_turgescent[1] = 5;\n    ravingly_atrociously =  *(waynesburg_fornenst + pigwidgin_turgescent[1]);\n    beastly_nabatean[6] = ravingly_atrociously;\n    scalewing_eczematosis = ((char *)beastly_nabatean[6]);\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(scalewing_eczematosis, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\n    if (beastly_nabatean[6] != 0) \n      free(((char *)beastly_nabatean[6]));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "191", "idx": "150970"}
{"code": "void PasswordAutofillAgent::PasswordValueGatekeeper::RegisterElement(\n    WebInputElement* element) {\n  if (was_user_gesture_seen_)\n    ShowValue(element);\n  else\n    elements_.push_back(*element);\n}", "answer": "NO", "cwe": "125", "idx": "150330"}
{"code": "gotoLabel(char *label)\n{\n    Buffer *buf;\n    Anchor *al;\n    int i;\n\n    al = searchURLLabel(Currentbuf, label);\n    if (al == NULL) {\n\t\n\tdisp_message(Sprintf(\"%s is not found\", label)->ptr, TRUE);\n\treturn;\n    }\n    buf = newBuffer(Currentbuf->width);\n    copyBuffer(buf, Currentbuf);\n    for (i = 0; i < MAX_LB; i++)\n\tbuf->linkBuffer[i] = NULL;\n    buf->currentURL.label = allocStr(label, -1);\n    pushHashHist(URLHist, parsedURL2Str(&buf->currentURL)->ptr);\n    (*buf->clone)++;\n    pushBuffer(buf);\n    gotoLine(Currentbuf, al->start.line);\n    if (label_topline)\n\tCurrentbuf->topLine = lineSkip(Currentbuf, Currentbuf->topLine,\n\t\t\t\t       Currentbuf->currentLine->linenumber\n\t\t\t\t       - Currentbuf->topLine->linenumber,\n\t\t\t\t       FALSE);\n    Currentbuf->pos = al->start.pos;\n    arrangeCursor(Currentbuf);\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n    return;\n}", "answer": "NO", "cwe": "59", "idx": "84504"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_w32CreateFile_63\n{\n\n#ifndef OMITM\n\n\nvoid mSink(char * * dataPtr);\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink(char * * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n    \n    strcat(data, \"/tmp/file.txt\");\n#endif\n    nG2BSink(&data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_w32CreateFile_63; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96725"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECV _wexecv\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_console_w32_execv_14()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_console_w32_execv_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_console_w32_execv_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_console_w32_execv_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247032"}
{"code": "static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "856d72454f03aea26fd61c728762ef9cd1d71512"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_fopen_03\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_fopen_03; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89822"}
{"code": "static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    char attr_dir[PATH_MAX];\n\n    char *tmp_path = g_strdup(path);\n\n\n\n    snprintf(attr_dir, PATH_MAX, \"%s/%s/%s\",\n\n             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);\n\n\n\n    err = mkdir(attr_dir, 0700);\n\n    if (err < 0 && errno == EEXIST) {\n\n        err = 0;\n\n    }\n\n    g_free(tmp_path);\n\n    return err;\n\n}", "answer": "NO", "cwe": "0", "idx": "4fa4ce7107c6ec432f185307158c5df91ce54308"}
{"code": "\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint yeargain_archsaint = 0;\nint global_variable;\nvoid handle_taint(char *pennigerous_gemellione);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nunsigned int avdevice_version()\n{;\n  if (__sync_bool_compare_and_swap(&yeargain_archsaint,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/cus/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lpthread -l:libmongoose.so.1 -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\nvoid handle_taint(char *pennigerous_gemellione)\n{\n int ss_i = 0;\n  char *soutar_coverts = 0;\n  ++global_variable;;\n  if (pennigerous_gemellione != 0) {;\n    if (pennigerous_gemellione != 0) {\n      goto imbrangling_dfrf;\n    }\n    ++global_variable;\n    imbrangling_dfrf:;\n    soutar_coverts = ((char *)pennigerous_gemellione);\n \n    printf(\"checking input\\n\");\n    \n    \n    \n while(ss_i < strlen(soutar_coverts)){\n  \n        if (soutar_coverts[ss_i] >= 48) {\n   \n   ++ss_i;\n        }\n    }\n    \n    \n   printf(\"finished evaluating\\n\");\n    \n;\n    if (pennigerous_gemellione != 0) \n      free(((char *)pennigerous_gemellione));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "835", "idx": "152049"}
{"code": "static int virtio_ccw_set_vqs(SubchDev *sch, VqInfoBlock *info,\n\n                              VqInfoBlockLegacy *linfo)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n    uint16_t index = info ? info->index : linfo->index;\n\n    uint16_t num = info ? info->num : linfo->num;\n\n    uint64_t desc = info ? info->desc : linfo->queue;\n\n\n\n    if (index >= VIRTIO_CCW_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    \n\n    if (linfo && desc && (linfo->align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (info) {\n\n        virtio_queue_set_rings(vdev, index, desc, info->avail, info->used);\n\n    } else {\n\n        virtio_queue_set_addr(vdev, index, desc);\n\n    }\n\n    if (!desc) {\n\n        virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);\n\n    } else {\n\n        if (info) {\n\n            \n\n            if (virtio_queue_get_max_num(vdev, index) < num) {\n\n                \n\n                return -EINVAL;\n\n            }\n\n            virtio_queue_set_num(vdev, index, num);\n\n        } else if (virtio_queue_get_num(vdev, index) > num) {\n\n            \n\n            return -EINVAL;\n\n        }\n\n        \n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    \n\n    vdev->config_vector = VIRTIO_CCW_QUEUE_MAX;\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "b1914b824ade1706847428e64ef5637ffc0ae238"}
{"code": "download_action(struct parsed_tagarg *arg)\n{\n    DownloadList *d;\n    pid_t pid;\n\n    for (; arg; arg = arg->next) {\n\tif (!strncmp(arg->arg, \"stop\", 4)) {\n\t    pid = (pid_t) atoi(&arg->arg[4]);\n#ifndef __MINGW32_VERSION\n\t    kill(pid, SIGKILL);\n#endif\n\t}\n\telse if (!strncmp(arg->arg, \"ok\", 2))\n\t    pid = (pid_t) atoi(&arg->arg[2]);\n\telse\n\t    continue;\n\tfor (d = FirstDL; d; d = d->next) {\n\t    if (d->pid == pid) {\n\t\tunlink(d->lock);\n\t\tif (d->prev)\n\t\t    d->prev->next = d->next;\n\t\telse\n\t\t    FirstDL = d->next;\n\t\tif (d->next)\n\t\t    d->next->prev = d->prev;\n\t\telse\n\t\t    LastDL = d->prev;\n\t\tbreak;\n\t    }\n\t}\n    }\n    ldDL();\n}", "answer": "NO", "cwe": "59", "idx": "84489"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_console_06()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (256-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123140"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint vivipary_anomatheca = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid depend_linalools(int prosses_outswagger,... );\nvoid corncutter_beetlers(void *dermatoplasm_hansoms);\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  void *periosteous_jujubes = 0;\n  char *compatibleness_lipocardiac;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&vivipary_anomatheca,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      compatibleness_lipocardiac = getenv(\"PRELIBERALLY_XYLOBALSAMUM\");\n      if (compatibleness_lipocardiac != 0) {;\n        periosteous_jujubes = ((void *)compatibleness_lipocardiac);\n        depend_linalools(1,periosteous_jujubes);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid depend_linalools(int prosses_outswagger,... )\n{\n  void (*witchingly_footings)(void *) = corncutter_beetlers;\n  void *rotenones_obarni = 0;\n  va_list rout_recense;\n  ++global_variable;;\n  if (prosses_outswagger > 0) {\n    __builtin_va_start(rout_recense,prosses_outswagger);\n    rotenones_obarni = (va_arg(rout_recense,void *));\n    __builtin_va_end(rout_recense);\n  }\n  witchingly_footings(rotenones_obarni);\n}\n\nvoid corncutter_beetlers(void *dermatoplasm_hansoms)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *springeing_canapes = 0;\n  ++global_variable;;\n  springeing_canapes = ((char *)((char *)dermatoplasm_hansoms));\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(springeing_canapes); ++i) {\n        if (springeing_canapes[i] == ';') {\n          if (i == 0 || springeing_canapes[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,springeing_canapes);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "88", "idx": "152497"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\nnamespace _Absolute_Path_Traversal__char_file_w32CreateFile_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_file_w32CreateFile_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96466"}
{"code": "warning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}", "answer": "NO", "cwe": "120", "idx": "93206"}
{"code": "static int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n#if 1\n\n    int frame_duration = av_rescale(track->timescale, track->enc->time_base.num, track->enc->time_base.den);\n\n    int nb_frames = ROUNDED_DIV(track->enc->time_base.den, track->enc->time_base.num);\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    if (nb_frames > 255) {\n\n        av_log(NULL, AV_LOG_ERROR, \"fps %d is too large\\n\", nb_frames);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_wb32(pb, 0); \n\n    ffio_wfourcc(pb, \"tmcd\");               \n\n    avio_wb32(pb, 0);                       \n\n    avio_wb32(pb, 1);                       \n\n    avio_wb32(pb, 0);                       \n\n    avio_wb32(pb, track->timecode_flags);   \n\n    avio_wb32(pb, track->timescale);        \n\n    avio_wb32(pb, frame_duration);          \n\n    avio_w8(pb, nb_frames);                 \n\n    avio_w8(pb, 0);                         \n\n\n\n    if (track->st)\n\n        t = av_dict_get(track->st->metadata, \"reel_name\", NULL, 0);\n\n\n\n    if (t && utf8len(t->value))\n\n        mov_write_source_reference_tag(pb, track, t->value);\n\n    else\n\n        avio_wb16(pb, 0); \n\n#else\n\n\n\n    avio_wb32(pb, 0); \n\n    ffio_wfourcc(pb, \"tmcd\");               \n\n    avio_wb32(pb, 0);                       \n\n    avio_wb32(pb, 1);                       \n\n    if (track->enc->extradata_size)\n\n        avio_write(pb, track->enc->extradata, track->enc->extradata_size);\n\n#endif\n\n    return update_size(pb, pos);\n\n}", "answer": "NO", "cwe": "0", "idx": "b4dcd351ec50caaa484bc5c66b4a8d5557a0f1ea"}
{"code": "LIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentRow(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_row(file->mod);\n}", "answer": "NO", "cwe": "120", "idx": "87629"}
{"code": "void s390_pci_sclp_configure(SCCB *sccb)\n\n{\n\n    PciCfgSccb *psccb = (PciCfgSccb *)sccb;\n\n    S390PCIBusDevice *pbdev = s390_pci_find_dev_by_fid(be32_to_cpu(psccb->aid));\n\n    uint16_t rc;\n\n\n\n    if (be16_to_cpu(sccb->h.length) < 16) {\n\n        rc = SCLP_RC_INSUFFICIENT_SCCB_LENGTH;\n\n        goto out;\n\n    }\n\n\n\n    if (pbdev) {\n\n        if (pbdev->configured) {\n\n            rc = SCLP_RC_NO_ACTION_REQUIRED;\n\n        } else {\n\n            pbdev->configured = true;\n\n            rc = SCLP_RC_NORMAL_COMPLETION;\n\n        }\n\n    } else {\n\n        DPRINTF(\"sclp config no dev found\\n\");\n\n        rc = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;\n\n    }\n\nout:\n\n    psccb->header.response_code = cpu_to_be16(rc);\n\n}", "answer": "NO", "cwe": "0", "idx": "5d1abf234462d13bef3617cc2c55b6815703ddf2"}
{"code": "static int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    \n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t\n\tif (dest != *path) {\n\t    rc = fsmRename(*path, dest);\n\t    if (!rc && nsuffix) {\n\t\tchar * opath = fsmFsPath(fi, NULL);\n\t\trpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t       opath, dest);\n\t\tfree(opath);\n\t    }\n\t    free(*path);\n\t    *path = dest;\n\t}\n    }\n\n    return rc;\n}", "answer": "NO", "cwe": "59", "idx": "67488"}
{"code": "compare_table(struct rc_search_table *a, struct rc_search_table *b)\n{\n    return strcmp(a->param->name, b->param->name);\n}", "answer": "NO", "cwe": "59", "idx": "84553"}
{"code": "base::Time AnHourAgo() {\n  return base::Time::Now() - base::TimeDelta::FromHours(1);\n}", "answer": "NO", "cwe": "125", "idx": "167328"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__wchar_t_console_ofstream_54\n{\n\n#ifndef OMITM\n\n\nvoid mSink_b(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mSink_b(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSink_b(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BSink_b(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_ofstream_54; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91148"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint squirearch_pseudoovally = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    char *result = 0;\n    int random_int = 0;\n  char *contends_guttering = 0;\n  int phalangiidae_pasterns;\n  int chiefage_cavillatory;\n  char **lovelass_aerodynamics = 0;\n  char **hederiferous_uncustomed = 0;\n  int westernize_pinta = 73;\n  char *rontgenized_nonspecie;;\n  if (__sync_bool_compare_and_swap(&squirearch_pseudoovally,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&rontgenized_nonspecie,\"6956\",westernize_pinta);\n      if (rontgenized_nonspecie != 0) {;\n        lovelass_aerodynamics = &rontgenized_nonspecie;\n        hederiferous_uncustomed = lovelass_aerodynamics + 5;\n        chiefage_cavillatory = 5;\n        while(1 == 1){\n          chiefage_cavillatory = chiefage_cavillatory * 2;\n          chiefage_cavillatory = chiefage_cavillatory + 2;\n          if (chiefage_cavillatory > 1000) {\n            break; \n          }\n        }\n        phalangiidae_pasterns = chiefage_cavillatory;\n        contends_guttering = ((char *)( *(hederiferous_uncustomed - 5)));\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  srand(time(NULL));\n  random_int = (rand() % 1000) + 100;\n        snprintf(query,1000,\"INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');\", random_int, contends_guttering);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != PGRES_COMMAND_OK) {\n            \n            printf(\"%s: %s\\n\",\"INSERT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n  result = PQcmdTuples(res);\n        printf(\"Query OK, %s rows affected\\n\",result);\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\n        if ( *(hederiferous_uncustomed - 5) != 0) \n          free(((char *)( *(hederiferous_uncustomed - 5))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}", "answer": "YES", "cwe": "89", "idx": "152305"}
{"code": "find_c_packed_planar_out_funcs(SwsContext *c,\n\n                               yuv2planar1_fn *yuv2yuv1,    yuv2planarX_fn *yuv2yuvX,\n\n                               yuv2packed1_fn *yuv2packed1, yuv2packed2_fn *yuv2packed2,\n\n                               yuv2packedX_fn *yuv2packedX)\n\n{\n\n    enum PixelFormat dstFormat = c->dstFormat;\n\n\n\n    if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) {\n\n        *yuv2yuvX     = yuv2nv12X_c;\n\n    } else if (is16BPS(dstFormat)) {\n\n        *yuv2yuvX     = isBE(dstFormat) ? yuv2yuvX16BE_c  : yuv2yuvX16LE_c;\n\n    } else if (is9_OR_10BPS(dstFormat)) {\n\n        if (av_pix_fmt_descriptors[dstFormat].comp[0].depth_minus1 == 8) {\n\n            *yuv2yuvX = isBE(dstFormat) ? yuv2yuvX9BE_c :  yuv2yuvX9LE_c;\n\n        } else {\n\n            *yuv2yuvX = isBE(dstFormat) ? yuv2yuvX10BE_c : yuv2yuvX10LE_c;\n\n        }\n\n    } else {\n\n        *yuv2yuv1     = yuv2yuv1_c;\n\n        *yuv2yuvX     = yuv2yuvX_c;\n\n    }\n\n    if(c->flags & SWS_FULL_CHR_H_INT) {\n\n        switch (dstFormat) {\n\n            case PIX_FMT_RGBA:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2rgba32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2rgba32_full_X_c;\n\n                } else\n\n#endif \n\n                {\n\n                    *yuv2packedX = yuv2rgbx32_full_X_c;\n\n                }\n\n#endif \n\n                break;\n\n            case PIX_FMT_ARGB:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2argb32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2argb32_full_X_c;\n\n                } else\n\n#endif \n\n                {\n\n                    *yuv2packedX = yuv2xrgb32_full_X_c;\n\n                }\n\n#endif \n\n                break;\n\n            case PIX_FMT_BGRA:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2bgra32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2bgra32_full_X_c;\n\n                } else\n\n#endif \n\n                {\n\n                    *yuv2packedX = yuv2bgrx32_full_X_c;\n\n                }\n\n#endif \n\n                break;\n\n            case PIX_FMT_ABGR:\n\n#if CONFIG_SMALL\n\n                *yuv2packedX = yuv2abgr32_full_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packedX = yuv2abgr32_full_X_c;\n\n                } else\n\n#endif \n\n                {\n\n                    *yuv2packedX = yuv2xbgr32_full_X_c;\n\n                }\n\n#endif \n\n                break;\n\n            case PIX_FMT_RGB24:\n\n            *yuv2packedX = yuv2rgb24_full_X_c;\n\n            break;\n\n        case PIX_FMT_BGR24:\n\n            *yuv2packedX = yuv2bgr24_full_X_c;\n\n            break;\n\n        }\n\n    } else {\n\n        switch (dstFormat) {\n\n        case PIX_FMT_GRAY16BE:\n\n            *yuv2packed1 = yuv2gray16BE_1_c;\n\n            *yuv2packed2 = yuv2gray16BE_2_c;\n\n            *yuv2packedX = yuv2gray16BE_X_c;\n\n            break;\n\n        case PIX_FMT_GRAY16LE:\n\n            *yuv2packed1 = yuv2gray16LE_1_c;\n\n            *yuv2packed2 = yuv2gray16LE_2_c;\n\n            *yuv2packedX = yuv2gray16LE_X_c;\n\n            break;\n\n        case PIX_FMT_MONOWHITE:\n\n            *yuv2packed1 = yuv2monowhite_1_c;\n\n            *yuv2packed2 = yuv2monowhite_2_c;\n\n            *yuv2packedX = yuv2monowhite_X_c;\n\n            break;\n\n        case PIX_FMT_MONOBLACK:\n\n            *yuv2packed1 = yuv2monoblack_1_c;\n\n            *yuv2packed2 = yuv2monoblack_2_c;\n\n            *yuv2packedX = yuv2monoblack_X_c;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            *yuv2packed1 = yuv2yuyv422_1_c;\n\n            *yuv2packed2 = yuv2yuyv422_2_c;\n\n            *yuv2packedX = yuv2yuyv422_X_c;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            *yuv2packed1 = yuv2uyvy422_1_c;\n\n            *yuv2packed2 = yuv2uyvy422_2_c;\n\n            *yuv2packedX = yuv2uyvy422_X_c;\n\n            break;\n\n        case PIX_FMT_RGB48LE:\n\n            \n\n            \n\n            \n\n            \n\n        case PIX_FMT_RGB48BE:\n\n            *yuv2packed1 = yuv2rgb48be_1_c;\n\n            *yuv2packed2 = yuv2rgb48be_2_c;\n\n            *yuv2packedX = yuv2rgb48be_X_c;\n\n            break;\n\n        case PIX_FMT_BGR48LE:\n\n            \n\n            \n\n            \n\n            \n\n        case PIX_FMT_BGR48BE:\n\n            *yuv2packed1 = yuv2bgr48be_1_c;\n\n            *yuv2packed2 = yuv2bgr48be_2_c;\n\n            *yuv2packedX = yuv2bgr48be_X_c;\n\n            break;\n\n        case PIX_FMT_RGB32:\n\n        case PIX_FMT_BGR32:\n\n#if CONFIG_SMALL\n\n            *yuv2packed1 = yuv2rgb32_1_c;\n\n            *yuv2packed2 = yuv2rgb32_2_c;\n\n            *yuv2packedX = yuv2rgb32_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packed1 = yuv2rgba32_1_c;\n\n                    *yuv2packed2 = yuv2rgba32_2_c;\n\n                    *yuv2packedX = yuv2rgba32_X_c;\n\n                } else\n\n#endif \n\n                {\n\n                    *yuv2packed1 = yuv2rgbx32_1_c;\n\n                    *yuv2packed2 = yuv2rgbx32_2_c;\n\n                    *yuv2packedX = yuv2rgbx32_X_c;\n\n                }\n\n#endif \n\n            break;\n\n        case PIX_FMT_RGB32_1:\n\n        case PIX_FMT_BGR32_1:\n\n#if CONFIG_SMALL\n\n                *yuv2packed1 = yuv2rgb32_1_1_c;\n\n                *yuv2packed2 = yuv2rgb32_1_2_c;\n\n                *yuv2packedX = yuv2rgb32_1_X_c;\n\n#else\n\n#if CONFIG_SWSCALE_ALPHA\n\n                if (c->alpPixBuf) {\n\n                    *yuv2packed1 = yuv2rgba32_1_1_c;\n\n                    *yuv2packed2 = yuv2rgba32_1_2_c;\n\n                    *yuv2packedX = yuv2rgba32_1_X_c;\n\n                } else\n\n#endif \n\n                {\n\n                    *yuv2packed1 = yuv2rgbx32_1_1_c;\n\n                    *yuv2packed2 = yuv2rgbx32_1_2_c;\n\n                    *yuv2packedX = yuv2rgbx32_1_X_c;\n\n                }\n\n#endif \n\n                break;\n\n        case PIX_FMT_RGB24:\n\n            *yuv2packed1 = yuv2rgb24_1_c;\n\n            *yuv2packed2 = yuv2rgb24_2_c;\n\n            *yuv2packedX = yuv2rgb24_X_c;\n\n            break;\n\n        case PIX_FMT_BGR24:\n\n            *yuv2packed1 = yuv2bgr24_1_c;\n\n            *yuv2packed2 = yuv2bgr24_2_c;\n\n            *yuv2packedX = yuv2bgr24_X_c;\n\n            break;\n\n        case PIX_FMT_RGB565:\n\n        case PIX_FMT_BGR565:\n\n            *yuv2packed1 = yuv2rgb16_1_c;\n\n            *yuv2packed2 = yuv2rgb16_2_c;\n\n            *yuv2packedX = yuv2rgb16_X_c;\n\n            break;\n\n        case PIX_FMT_RGB555:\n\n        case PIX_FMT_BGR555:\n\n            *yuv2packed1 = yuv2rgb15_1_c;\n\n            *yuv2packed2 = yuv2rgb15_2_c;\n\n            *yuv2packedX = yuv2rgb15_X_c;\n\n            break;\n\n        case PIX_FMT_RGB444:\n\n        case PIX_FMT_BGR444:\n\n            *yuv2packed1 = yuv2rgb12_1_c;\n\n            *yuv2packed2 = yuv2rgb12_2_c;\n\n            *yuv2packedX = yuv2rgb12_X_c;\n\n            break;\n\n        case PIX_FMT_RGB8:\n\n        case PIX_FMT_BGR8:\n\n            *yuv2packed1 = yuv2rgb8_1_c;\n\n            *yuv2packed2 = yuv2rgb8_2_c;\n\n            *yuv2packedX = yuv2rgb8_X_c;\n\n            break;\n\n        case PIX_FMT_RGB4:\n\n        case PIX_FMT_BGR4:\n\n            *yuv2packed1 = yuv2rgb4_1_c;\n\n            *yuv2packed2 = yuv2rgb4_2_c;\n\n            *yuv2packedX = yuv2rgb4_X_c;\n\n            break;\n\n        case PIX_FMT_RGB4_BYTE:\n\n        case PIX_FMT_BGR4_BYTE:\n\n            *yuv2packed1 = yuv2rgb4b_1_c;\n\n            *yuv2packed2 = yuv2rgb4b_2_c;\n\n            *yuv2packedX = yuv2rgb4b_X_c;\n\n            break;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "dff5a8353266641311827a4bbdd940f7ad08c8b6"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint fausant_upliftingness = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *biogeographer_ransom = 0;\n  int cardale_pearmain;\n  int guilandina_excresce;\n  char **molybdosis_lpf = 0;\n  char *unriddles_elatives[5] = {0};\n  char *granulet_standby;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&fausant_upliftingness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&granulet_standby,\"AETIOLOGIES_NEUROPARALYTIC\");\n      if (granulet_standby != 0) {;\n        unriddles_elatives[0] = granulet_standby;\n        molybdosis_lpf = unriddles_elatives;\n        guilandina_excresce = 5;\n        while(1 == 1){\n          guilandina_excresce = guilandina_excresce * 2;\n          guilandina_excresce = guilandina_excresce + 2;\n          if (guilandina_excresce > 1000) {\n            break; \n          }\n        }\n        cardale_pearmain = guilandina_excresce;\n        biogeographer_ransom = ((char *)molybdosis_lpf[0]);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(biogeographer_ransom); ++i) {\n        if (biogeographer_ransom[i] == ';') {\n          if (i == 0 || biogeographer_ransom[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,biogeographer_ransom);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n        if (molybdosis_lpf[0] != 0) \n          free(((char *)molybdosis_lpf[0]));\nclose_printf_context();\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}", "answer": "YES", "cwe": "88", "idx": "152301"}
{"code": "static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}", "answer": "NO", "cwe": "0", "idx": "b854bc196f5c4b4e3299c0b0ee63cf828ece9e77"}
{"code": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}", "answer": "NO", "cwe": "0", "idx": "d20a580bc0eac9d489884f6d2ed28105880532b6"}
{"code": "test_bson_append_bool (void)\n{\n   bson_t *b;\n   bson_t *b2;\n\n   b = bson_new ();\n   BSON_ASSERT (bson_append_bool (b, \"bool\", -1, true));\n   b2 = get_bson (\"test19.bson\");\n   BSON_ASSERT_BSON_EQUAL (b, b2);\n   bson_destroy (b);\n   bson_destroy (b2);\n}", "answer": "NO", "cwe": "125", "idx": "77874"}
{"code": "void __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}", "answer": "NO", "cwe": "119", "idx": "19599"}
{"code": "static int coroutine_fn raw_co_pwrite_zeroes(BlockDriverState *bs,\n\n                                             int64_t offset, int count,\n\n                                             BdrvRequestFlags flags)\n\n{\n\n    return bdrv_co_pwrite_zeroes(bs->file->bs, offset, count, flags);\n\n}", "answer": "NO", "cwe": "0", "idx": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e"}
{"code": "static int __init nf_nat_snmp_basic_init(void)\n{\n\tBUG_ON(nf_nat_snmp_hook != NULL);\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, help);\n\n\treturn nf_conntrack_helper_register(&snmp_trap_helper);\n}", "answer": "NO", "cwe": "129", "idx": "91198"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_18()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123056"}
{"code": "static int ivi_mc(ivi_mc_func mc, int16_t *buf, const int16_t *ref_buf,\n\n                  int offs, int mv_x, int mv_y, uint32_t pitch,\n\n                  int mc_type)\n\n{\n\n    int ref_offs = offs + mv_y * pitch + mv_x;\n\n\n\n    if (offs < 0 || ref_offs < 0 || !ref_buf)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    mc(buf + offs, ref_buf + ref_offs, pitch, mc_type);\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "25a6666f6c07c6ac8449a63d7fbce0dfd29c54cd"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <semaphore.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint tuberculoses_outfelt = 0;\nint global_variable;\nvoid corsned_snobol(char **cuyapo_exemplificator);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid hydrostatician_anatifer(void (*dactylographic_possessory)(char **));\nsem_t sem;\npthread_t t0, t1;\nchar *global_str;\nint isspace(char c) {\n    return (c == ' ' || c == '\\t' || c == '\\n');\n}\nvoid *replaceSpace () {\n    int i = 0;\n    printf(\"Replacing spaces\\n\");\n    \n    \n    \n    sem_wait(&sem); \n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (isspace(global_str[i]) != 0) {\n            global_str[i] = '_';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\nvoid *toCap () {\n    int i = 0;\n    \n    \n    printf(\"Capitalizing input\\n\");\n    sem_wait(&sem);\n    \n    while(global_str[i] != '\\0') {\n        if (global_str[i] > 'a' && global_str[i] < 'z') {\n            global_str[i] -= 'a' - 'A';\n        }\n        i++;\n    }\n    sem_post(&sem);\n    return NULL;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&tuberculoses_outfelt,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      hydrostatician_anatifer(corsned_snobol);\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid corsned_snobol(char **cuyapo_exemplificator)\n{\n  int chanhassen_coglorious = 24;\n  char *prototypic_chindee;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&prototypic_chindee,\"8353\",chanhassen_coglorious);\n  if (prototypic_chindee != 0) {;\n     *cuyapo_exemplificator = prototypic_chindee;\n  }\n}\n\nvoid hydrostatician_anatifer(void (*dactylographic_possessory)(char **))\n{\n    int hasSpaces = 0;\n    int i = 0;\n  char *prevalescent_immaneness = 0;\n  char **gullying_washitas[91] = {0};\n  int agh_umest;\n  char **codicilic_metazoon = 0;\n  char **kapote_fruitages = 0;\n  ++global_variable;\n  char *intravalvular_conglomerations = 0;\n  dactylographic_possessory(&intravalvular_conglomerations);\n  if (intravalvular_conglomerations != 0) {;\n    agh_umest = 1;\n    codicilic_metazoon = &intravalvular_conglomerations;\n    kapote_fruitages = ((char **)(((unsigned long )codicilic_metazoon) * agh_umest * agh_umest)) + 5;\n    gullying_washitas[74] = kapote_fruitages;\n    prevalescent_immaneness = ((char *)( *(gullying_washitas[74] - 5)));\n    \n    sem_init(&sem, 0, 1);\n    while(prevalescent_immaneness[i] != '\\0') { \n        if (isspace(prevalescent_immaneness[i++]) != 0) { \n            hasSpaces = 1;\n        }\n    }\n    \n    global_str = malloc(sizeof(char) * strlen(prevalescent_immaneness) + 1);\n    strcpy(global_str, prevalescent_immaneness);\n    if (hasSpaces == 1) {\n        \n        \n        if (pthread_create(&t0, NULL, replaceSpace, NULL) != 0) {\n            printf(\"Thread 0 failed to spawn.\");\n        }\n        \n    }\n    if (pthread_create(&t1, NULL, toCap, NULL) != 0) {\n        printf(\"Thread 1 failed to spawn.\");\n    }\n    if (hasSpaces == 1) {\n        pthread_join(t0, NULL);\n    }\n    pthread_join(t1, NULL);\n    \n;\n    if ( *(gullying_washitas[74] - 5) != 0) \n      free(((char *)( *(gullying_washitas[74] - 5))));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "764", "idx": "150243"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _execl\n#else \n#define EXECL execl\n#endif\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_file_execl_04()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_file_execl_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_file_execl_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_file_execl_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245422"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66bSink(char * dataArray[]);\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    \n    dataArray[2] = data;\n    _OS_Command_Injection__char_console_w32_spawnv_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    dataArray[2] = data;\n    _OS_Command_Injection__char_console_w32_spawnv_66bG2BSink(dataArray);\n}\n\nvoid _OS_Command_Injection__char_console_w32_spawnv_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32_spawnv_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32_spawnv_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244841"}
{"code": "void msix_write_config(PCIDevice *dev, uint32_t addr,\n\n                       uint32_t val, int len)\n\n{\n\n    unsigned enable_pos = dev->msix_cap + MSIX_CONTROL_OFFSET;\n\n    if (addr + len <= enable_pos || addr > enable_pos)\n\n        return;\n\n\n\n    if (msix_enabled(dev))\n\n        qemu_set_irq(dev->irq[0], 0);\n\n}", "answer": "NO", "cwe": "0", "idx": "5b5cb08683b6715a2aca5314168e68ff0665912b"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _execl\n#else \n#define EXECL execl\n#endif\n\nnamespace _OS_Command_Injection__char_environment_execl_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    {\n        char * data = dataRef;\n        \n        \n        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    {\n        char * data = dataRef;\n        \n        \n        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _OS_Command_Injection__char_environment_execl_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244969"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66bSink(wchar_t * dataArray[]);\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66bG2BSink(wchar_t * dataArray[]);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    dataArray[2] = data;\n    _LDAP_Injection__w32_wchar_t_listen_socket_66bG2BSink(dataArray);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123317"}
{"code": "  tt_cmap2_get_info( TT_CMap       cmap,\n                     TT_CMapInfo  *cmap_info )\n  {\n    FT_Byte*  p = cmap->data + 4;\n\n\n    cmap_info->format   = 2;\n    cmap_info->language = (FT_ULong)TT_PEEK_USHORT( p );\n\n    return FT_Err_Ok;\n  }", "answer": "NO", "cwe": "125", "idx": "6972"}
{"code": "static int unpriv_assign_nic(struct lxc_netdev *netdev, pid_t pid)\n{\n\tpid_t child;\n\tint bytes, pipefd[2];\n\tchar *token, *saveptr = NULL;\n\tchar buffer[MAX_BUFFER_SIZE];\n\tchar netdev_link[IFNAMSIZ+1];\n\n\tif (netdev->type != LXC_NET_VETH) {\n\t\tERROR(\"nic type %d not support for unprivileged use\",\n\t\t\tnetdev->type);\n\t\treturn -1;\n\t}\n\n\tif(pipe(pipefd) < 0) {\n\t\tSYSERROR(\"pipe failed\");\n\t\treturn -1;\n\t}\n\n\tif ((child = fork()) < 0) {\n\t\tSYSERROR(\"fork\");\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn -1;\n\t}\n\n\tif (child == 0) { \n\t\t\n\t\tclose(pipefd[0]);\n\t\t\n\t\tdup2(pipefd[1], STDOUT_FILENO);\n\t\t\n\t\tclose(pipefd[1]);\n\n\t\tchar pidstr[20];\n\t\tif (netdev->link) {\n\t\t\tstrncpy(netdev_link, netdev->link, IFNAMSIZ);\n\t\t} else {\n\t\t\tstrncpy(netdev_link, \"none\", IFNAMSIZ);\n\t\t}\n\t\tchar *args[] = {LXC_USERNIC_PATH, pidstr, \"veth\", netdev_link, netdev->name, NULL };\n\t\tsnprintf(pidstr, 19, \"%lu\", (unsigned long) pid);\n\t\tpidstr[19] = '\\0';\n\t\texecvp(args[0], args);\n\t\tSYSERROR(\"execvp lxc-user-nic\");\n\t\texit(1);\n\t}\n\n\t\n\tclose(pipefd[1]);\n\n\tbytes = read(pipefd[0], &buffer, MAX_BUFFER_SIZE);\n\tif (bytes < 0) {\n\t\tSYSERROR(\"read failed\");\n\t}\n\tbuffer[bytes - 1] = '\\0';\n\n\tif (wait_for_pid(child) != 0) {\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\t\n\tclose(pipefd[0]);\n\n\t\n\ttoken = strtok_r(buffer, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\tnetdev->name = malloc(IFNAMSIZ+1);\n\tif (!netdev->name) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tmemset(netdev->name, 0, IFNAMSIZ+1);\n\tstrncpy(netdev->name, token, IFNAMSIZ);\n\n\t\n\ttoken = strtok_r(NULL, \":\", &saveptr);\n\tif (!token)\n\t\treturn -1;\n\tnetdev->priv.veth_attr.pair = strdup(token);\n\tif (!netdev->priv.veth_attr.pair) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "answer": "NO", "cwe": "59", "idx": "44661"}
{"code": "read_object (FILE *in)\n{\n    Attr *attr = NULL;\n\n    \n    int tmp_char = fgetc(in);\n    if (tmp_char == -1) return NULL;\n    ungetc(tmp_char, in);\n\n    attr = attr_read (in);\n\n    return attr;\n}", "answer": "NO", "cwe": "125", "idx": "68240"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint premious_tanbark = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid herbary_mystacocete(char *suppliants_throop);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n#define RUNOLOGY_CHOPPER(x) herbary_mystacocete((char *) x)\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  char *astrolatry_plang;;\n  if (__sync_bool_compare_and_swap(&premious_tanbark,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&astrolatry_plang,\"TOASTERS_BAI\");\n      if (astrolatry_plang != 0) {;\n\tRUNOLOGY_CHOPPER(astrolatry_plang);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid herbary_mystacocete(char *suppliants_throop)\n{\n long long check_val = 2LL;\n long long in_val;\n int prime = 1;\n  char *antigene_trachycarpous = 0;\n  ++global_variable;;\n  antigene_trachycarpous = ((char *)suppliants_throop);\n    \n    in_val = atoll(antigene_trachycarpous);\n    if (in_val > 1) {\n        printf(\"Checking for primality\\n\");\n        \n        \n        \n        for (; check_val <= in_val - 1; ++check_val){\n            \n            \n            if (in_val % check_val == 0) {\n                prime = 0;\n                break;\n            }\n        }\n        \n        \n        if (prime) {\n            printf(\"%lld is prime\\n\", in_val);\n        } else {\n            printf(\"%lld is composite\\n\", in_val);\n        }\n    } else {\n        printf(\"Input value is less than or equal to 1\\n\");\n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n  if (suppliants_throop != 0) \n    free(((char *)suppliants_throop));\nclose_printf_context();\n}", "answer": "YES", "cwe": "834", "idx": "151512"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint malproportioned_pharyngoxerosis = 0;\n\nstruct mechanicsville_apomixes \n{\n  char *dumky_linder;\n  double sintering_opalesce;\n  char *serratodentate_inblowing;\n  char dispense_unattacked;\n  int kalis_oxalemia;\n}\n;\nint global_variable;\nvoid handle_taint(char *daylights_astromeda);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid crfc_unbullying(struct mechanicsville_apomixes **satisfactional_cyclical);\nvoid concocter_ciconiid(struct mechanicsville_apomixes **autarchies_rabbanite);\nvoid urlDecode(char *src, char *dst) {\n    char a, b;\n    while (*src) {\n        if ((*src == '%') &&\n                ((a = src[1]) && (b = src[2])) &&\n                (isxdigit(a) && isxdigit(b))) {\n            if (a >= 'a')\n                a -= 'a'-'A';\n            if (a >= 'A')\n                a -= ('A' - 10);\n            else\n                a -= '0';\n            if (b >= 'a')\n                b -= 'a'-'A';\n            if (b >= 'A')\n                b -= ('A' - 10);\n            else\n                b -= '0';\n            *dst++ = 16*a+b;\n            src+=3;\n        } else {\n            *dst++ = *src++;\n        }\n    }\n    *dst++ = '\\0';\n}\nint isValid(char *src) {\n    int i = 0;\n    while (src[i] != '\\0') {\n        if(src[i] == ';') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        else if(src[i] == '|') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        else if(src[i] == '&') {\n            if (i == 0 || src[i-1] != '\\\\') {\n                return 0;\n            }\n        }\n        i++;\n    }\n    return 1;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&malproportioned_pharyngoxerosis,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid handle_taint(char *daylights_astromeda)\n{\n  struct mechanicsville_apomixes **ballocks_armhoop = 0;\n  struct mechanicsville_apomixes *mensurational_willable = 0;\n  struct mechanicsville_apomixes enfettered_badenite = {0};\n  struct mechanicsville_apomixes tailband_celeuthea;\n  ++global_variable;;\n  if (daylights_astromeda != 0) {;\n    tailband_celeuthea . dumky_linder = ((char *)daylights_astromeda);\n    mensurational_willable = &tailband_celeuthea;\n    ballocks_armhoop = &mensurational_willable;\n    crfc_unbullying(ballocks_armhoop);\n  }\n}\n\nvoid crfc_unbullying(struct mechanicsville_apomixes **satisfactional_cyclical)\n{\n  ++global_variable;;\n  concocter_ciconiid(satisfactional_cyclical);\n}\n\nvoid concocter_ciconiid(struct mechanicsville_apomixes **autarchies_rabbanite)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char *parsed_input;\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *filch_delawarean = 0;\n  ++global_variable;;\n  filch_delawarean = ((char *)( *( *autarchies_rabbanite)) . dumky_linder);\n    \n    if (strlen(filch_delawarean) < 1000 - strlen(command_str)) {\n        \n        \n        \n        if (isValid(filch_delawarean) == 1) {\n            parsed_input = malloc((strlen(filch_delawarean)+1) * sizeof(char));\n            urlDecode(filch_delawarean, parsed_input);\n            snprintf(command_buffer, 1000, \"%s%s\",command_str, parsed_input);\n            \n            \n            \n            \n            fpipe = popen(command_buffer,\"r\");\n            if (fpipe != 0) {\n                while(fgets(buffer,100,fpipe) != 0) {\n                    printf(buffer);\n                }\n                pclose(fpipe);\n            }\n        }\n        \n    }\n    \n;\n  if (( *( *autarchies_rabbanite)) . dumky_linder != 0) \n    free(((char *)( *( *autarchies_rabbanite)) . dumky_linder));\nclose_printf_context();\n}", "answer": "YES", "cwe": "78", "idx": "152450"}
{"code": "static int ipvideo_decode_block_opcode_0x2(IpvideoContext *s)\n\n{\n\n    unsigned char B;\n\n    int x, y;\n\n\n\n    \n\n    CHECK_STREAM_PTR(s->stream_ptr, s->stream_end, 1);\n\n    B = *s->stream_ptr++;\n\n\n\n    if (B < 56) {\n\n        x = 8 + (B % 7);\n\n        y = B / 7;\n\n    } else {\n\n        x = -14 + ((B - 56) % 29);\n\n        y =   8 + ((B - 56) / 29);\n\n    }\n\n\n\n    debug_interplay (\"    motion byte = %d, (x, y) = (%d, %d)\\n\", B, x, y);\n\n    return copy_from(s, &s->second_last_frame, x, y);\n\n}", "answer": "NO", "cwe": "0", "idx": "dcfb0cad687ec89d3c7fe21a014c58f283050283"}
{"code": "vrrp_sg_tracking_weight_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tvgroup->sgroup_tracking_weight = true;\n}", "answer": "NO", "cwe": "59", "idx": "76031"}
{"code": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  \n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  \n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  } ", "answer": "NO", "cwe": "125", "idx": "48272"}
{"code": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            const uint8_t *buf, int buf_size)\n\n{\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n;\n\n    short *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    uint8_t *dstu8;\n\n    int16_t *dst_int16_t;\n\n    int32_t *dst_int32_t;\n\n    int64_t *dst_int64_t;\n\n    uint16_t *dst_uint16_t;\n\n    uint32_t *dst_uint32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    \n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        \n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n        return -1;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n    *data_size=0;\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; \n\n          *samples++ = ff_reverse[(v >> 8) & 0xff] +\n\n                       (ff_reverse[v & 0xff] << 8);\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++)\n\n                *samples++ = bytestream_get_le16(&src2[c]);\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        dstu8= (uint8_t*)samples;\n\n        for(;n>0;n--) {\n\n            *dstu8++ = *src++ + 128;\n\n        }\n\n        samples= (short*)dstu8;\n\n        break;\n\n#if WORDS_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif \n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples = (short*)((uint8_t*)data + n*sample_size);\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            *samples++ = x << 8;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            *samples++ = s->table[*src++];\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n            break;\n\n        }\n\n        samples = (short *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}", "answer": "NO", "cwe": "0", "idx": "469f5f251dc3acbb4c4fd12c597d57768119af4a"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\nnamespace _Relative_Path_Traversal__wchar_t_file_fopen_08\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_file_fopen_08; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91507"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_45\n{\n\nstatic wchar_t * mData;\nstatic wchar_t * nG2BData;\n\n#ifndef OMITM\n\nstatic void mSink()\n{\n    wchar_t * data = mData;\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    mData = data;\n    mSink();\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink()\n{\n    wchar_t * data = nG2BData;\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    nG2BData = data;\n    nG2BSink();\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_45; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91000"}
{"code": "data_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 354) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing DATA cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}", "answer": "NO", "cwe": "59", "idx": "75930"}
{"code": "static void php_session_reset(TSRMLS_D) \n{\n\tif (PS(session_status) == php_session_active) {\n\t\tphp_session_initialize(TSRMLS_C);\n\t}\n}\n", "answer": "NO", "cwe": "74", "idx": "50223"}
{"code": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL))\n\n        prio = 50;\n\n\n\n    fd = open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    \n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    close(fd);\n\nout:\n\n    return prio;\n\n}", "answer": "NO", "cwe": "0", "idx": "e17408283562be359f16a7e12ddfee7509d6fe11"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_04()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_04()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_04();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_04();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81981"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <stdarg.h> \n#include <libpq-fe.h> \n#include <cus/trace.h> \n#include <dlfcn.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint aqueity_semimagically = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid tinkered_kuantan(int cinemactic_fulfulde,... );\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  char *nonstably_disenthrone[49] = {0};\n  int graziers_theroid = 30;\n  char *costin_kaingang;;\n  if (__sync_bool_compare_and_swap(&aqueity_semimagically,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&costin_kaingang,\"3917\",graziers_theroid);\n      if (costin_kaingang != 0) {;\n        nonstably_disenthrone[46] = costin_kaingang;\n        tinkered_kuantan(1,nonstably_disenthrone);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid tinkered_kuantan(int cinemactic_fulfulde,... )\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int nFields;\n    int i;\n    int j = 0;\n  char *glisk_meconophagist = 0;\n  int oversaturates_uncarpentered;\n  int geothlypis_prefreeze;\n  char **hircine_fixures = 0;\n  va_list orograph_steens;\n  ++global_variable;;\n  if (cinemactic_fulfulde > 0) {\n    __builtin_va_start(orograph_steens,cinemactic_fulfulde);\n    hircine_fixures = (va_arg(orograph_steens,char **));\n    __builtin_va_end(orograph_steens);\n  }\n  geothlypis_prefreeze = 5;\n  while(1 == 1){\n    geothlypis_prefreeze = geothlypis_prefreeze * 2;\n    geothlypis_prefreeze = geothlypis_prefreeze + 2;\n    if (geothlypis_prefreeze > 1000) {\n      break; \n    }\n  }\n  oversaturates_uncarpentered = geothlypis_prefreeze;\n  glisk_meconophagist = ((char *)hircine_fixures[46]);\n    \n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    \n    \n    \n    \n    \n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            \n            printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", glisk_meconophagist);\n        \n        \n        \n        \n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            \n            printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        \n        \n        nFields = PQnfields(res);\n        for (i = 0; i < nFields; i++)\n            printf(\"%-15s\", PQfname(res, i));\n        printf(\"\\n\\n\");\n        \n        for (i = 0; i < PQntuples(res); i++)\n        {\n            for (j = 0; j < nFields; j++)\n                printf(\"%-15s\", PQgetvalue(res, i, j));\n            printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    \n;\n  if (hircine_fixures[46] != 0) \n    free(((char *)hircine_fixures[46]));\nclose_printf_context();\n}", "answer": "YES", "cwe": "89", "idx": "152378"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <cus/trace.h> \nint spiffing_tilyer = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n    int ss_i = 0;\n    char* heap_buff_64;\n    int buff_size;\n  char *lamentedly_geulincx = 0;\n  char *talco_matfellon = 0;\n  long autoantibody_penalizes[10];\n  char *lorrimor_stereoed[10] = {0};\n  int intertissue_preemptor = 596;\n  char *yucking_gelatinised;;\n  if (__sync_bool_compare_and_swap(&spiffing_tilyer,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&yucking_gelatinised,\"5575\",intertissue_preemptor);\n      if (yucking_gelatinised != 0) {;\n        lorrimor_stereoed[5] = yucking_gelatinised;\n        autoantibody_penalizes[1] = 5;\n        talco_matfellon =  *(lorrimor_stereoed + autoantibody_penalizes[1]);\n        if (talco_matfellon != 0) {\n          goto unaway_armbruster;\n        }\n        ++global_variable;\n        unaway_armbruster:;\n        lamentedly_geulincx = ((char *)talco_matfellon);\n    \n    heap_buff_64 = (char*) malloc(64 * sizeof(char));\n    \n    if (heap_buff_64 != NULL) {\n        memset(heap_buff_64,'A',63);\n        heap_buff_64[63] = '\\0';\n        \n        buff_size = ((int )(strlen(lamentedly_geulincx)));\n        strncpy(heap_buff_64, lamentedly_geulincx, 64);\n        \n        \n        \n        for (; ss_i < buff_size; ++ss_i){\n            \n            \n            printf(\"%02x\",heap_buff_64[ss_i]);\n        }\n        \n        \n        \n        printf(\"\\n\");\n        free( heap_buff_64);\n        \n        \n    }\n;\n        if (talco_matfellon != 0) \n          free(((char *)talco_matfellon));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}", "answer": "YES", "cwe": "126", "idx": "153002"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _open\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__char_console_open_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_console_open_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "89972"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_console_15()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_console_15()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_console_15();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_console_15();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62290"}
{"code": "static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    \n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    \n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            \n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint rossing_remaindered = 0;\n\nunion closelipped_outright \n{\n  char *chefang_stiacciato;\n  double dietist_embroil;\n  char *cessative_exoascus;\n  char interlocutors_tiphany;\n  int songcraft_astigmia;\n}\n;\nint global_variable;\nvoid hystericus_semiwild(union closelipped_outright *kompeni_mastoscirrhus);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid caseweed_bradoon(void (*lahar_unprovidenced)(union closelipped_outright *));\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{;\n  if (__sync_bool_compare_and_swap(&rossing_remaindered,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      caseweed_bradoon(hystericus_semiwild);\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid hystericus_semiwild(union closelipped_outright *kompeni_mastoscirrhus)\n{\n  union closelipped_outright retrencher_thisness;\n  char *megnetosphere_pondwort;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&megnetosphere_pondwort,\"UNEMOLUMENTED_NETTLEBED\");\n  if (megnetosphere_pondwort != 0) {;\n    retrencher_thisness . chefang_stiacciato = megnetosphere_pondwort;\n     *kompeni_mastoscirrhus = retrencher_thisness;\n  }\n}\n\nvoid caseweed_bradoon(void (*lahar_unprovidenced)(union closelipped_outright *))\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *irresolvedly_barnhardtite = 0;\n  union closelipped_outright underplain_haliplankton = {0};\n  int *jacky_lutherist = 0;\n  int hemielytra_corporate;\n  union closelipped_outright rakeful_hibernia[10] = {0};\n  ++global_variable;\n  union closelipped_outright levelland_overtechnical = {0};\n  lahar_unprovidenced(&levelland_overtechnical);\n  if (levelland_overtechnical . chefang_stiacciato != 0) {;\n    rakeful_hibernia[5] = levelland_overtechnical;\n    hemielytra_corporate = 5;\n    jacky_lutherist = &hemielytra_corporate;\n    underplain_haliplankton =  *(rakeful_hibernia +  *jacky_lutherist);\n    irresolvedly_barnhardtite = ((char *)underplain_haliplankton . chefang_stiacciato);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(irresolvedly_barnhardtite); ++i) {\n        if (irresolvedly_barnhardtite[i] == ';') {\n          if (i == 0 || irresolvedly_barnhardtite[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,irresolvedly_barnhardtite);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\n    if (underplain_haliplankton . chefang_stiacciato != 0) \n      free(((char *)underplain_haliplankton . chefang_stiacciato));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "88", "idx": "152199"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND L\"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND L\"ls \"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\n#ifdef _WIN32\n#define POPEN _wpopen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_31()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            FILE *pipe;\n            \n            pipe = POPEN(data, L\"w\");\n            if (pipe != NULL)\n            {\n                PCLOSE(pipe);\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    \n    wcscat(data, L\"*.*\");\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            FILE *pipe;\n            \n            pipe = POPEN(data, L\"w\");\n            if (pipe != NULL)\n            {\n                PCLOSE(pipe);\n            }\n        }\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_popen_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_popen_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246479"}
{"code": "PHP_FUNCTION(locale_get_display_name)\n{\n    get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}", "answer": "NO", "cwe": "125", "idx": "9560"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_char_file_31()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            HMODULE hModule;\n            \n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n\nvoid _Process_Control__w32_char_file_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_file_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_file_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62104"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <math.h> \n#include <signal.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint fictionalizing_altin = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nint SIZE = 50;\nchar *playful_platypus;\nstruct data {\n    char *data;\n};\nstruct data *cusData;\nint comp (const void * a, const void * b)\n{\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b)\n{\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid sig_handler (int sig) {\n    printf(\"In sig_handler\\n\");\n    \n    \n    \n    \n    \n    if (playful_platypus[0] != '\\0') { \n        printf(playful_platypus);\n    }\n    \n}\nvoid waitForSig(char *sleepFile) {\n    int fd;\n    char outStr[25] = {0};\n    char filename[500] = {0};\n    \n    printf(\"In waitForSig\\n\");\n    sprintf(outStr, \"%d.pid\", getpid());\n    strcat(filename, \"/opt/cus/workspace/testData/\");\n    strcat(filename, outStr);\n    if ((fd = open(filename, O_CREAT|O_WRONLY, 0666)) == -1) {\n        \n        printf(\"Error opening file.\");\n    }\n    else {\n        if (write(fd, \"q\", sizeof(char)) == -1) {\n            \n            printf(\"Error writing to file.\");\n        }\n        if (close(fd) == -1) {\n            \n            printf(\"Error closing file.\");\n        }\n        \n        readFile(sleepFile);\n    }\n}\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n    int i;\n    char *temp;\n    char *sleepFile;\n  char *ingurgitated_vulgarians = 0;\n  void **unanointed_gauntlets = 0;\n  void **kecksy_mesitylenic = 0;\n  void *hoccleve_imap = 0;\n  char *worminess_endicott;;\n  if (__sync_bool_compare_and_swap(&fictionalizing_altin,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&worminess_endicott,\"FAGGOTING_METACENTRICITY\");\n      if (worminess_endicott != 0) {;\n        hoccleve_imap = ((void *)worminess_endicott);\n        unanointed_gauntlets = &hoccleve_imap;\n        kecksy_mesitylenic = unanointed_gauntlets + 5;\n        if (((char *)( *(kecksy_mesitylenic - 5))) != 0) {\n          goto enmeshments_carioca;\n        }\n        ++global_variable;\n        enmeshments_carioca:;\n        ingurgitated_vulgarians = ((char *)((char *)( *(kecksy_mesitylenic - 5))));\n    \n    cusData = malloc(sizeof(struct data));\n    if (cusData) {\n        sleepFile = malloc(sizeof(char) * (strlen(ingurgitated_vulgarians) + 1));\n        cusData->data = malloc(sizeof(char) * (strlen(ingurgitated_vulgarians) + 1));\n        if (cusData->data) {\n            if ((sscanf(ingurgitated_vulgarians, \"%s %s\",\n                        sleepFile,\n                        cusData->data) == 2) &&\n                (strlen(cusData->data) != 0) &&\n                (strlen(sleepFile) != 0))\n            {\n                \n                \n                if (signal(SIGUSR1, sig_handler) == SIG_ERR) {\n                    \n                    printf (\"Error catching SIGNUSR1!\\n\");\n                }\n                playful_platypus = malloc(sizeof(char) * (SIZE + 1));\n                i = 0;\n                while (cusData->data[i] != '\\0') { \n                    if (i < SIZE) {\n                        playful_platypus[i] = cusData->data[i];\n                        i++;\n                    } else { \n                        playful_platypus[SIZE] = '\\0';\n                        \n                        \n                        SIZE *= 2;\n                        temp = malloc(sizeof(char) * SIZE);\n                        strcpy(temp, playful_platypus);\n                        free(playful_platypus);\n                        playful_platypus = NULL; \n                        \n                        waitForSig(sleepFile);\n                        \n                        playful_platypus = temp;\n                        \n                    }\n                }\n                free (playful_platypus);\n                signal(SIGUSR1, SIG_IGN); \n            } else {\n                \n                printf(\"Error parsing data\\n\");\n            }\n            free(cusData->data);\n        }\n        free (cusData);\n    }\n    \n;\n        if (((char *)( *(kecksy_mesitylenic - 5))) != 0) \n          free(((char *)((char *)( *(kecksy_mesitylenic - 5)))));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n#endif", "answer": "YES", "cwe": "828", "idx": "150086"}
{"code": "static int find_stream_index(AVFormatContext *s)\n\n{\n\n    int i;\n\n    AVStream *st;\n\n\n\n    if (s->nb_streams <= 0)\n\n        return -1;\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n        if (st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n            return i;\n\n        }\n\n    }\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "b754978a3b0aa17e7794f64c69bf4491762797fd"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nint apozema_relicensing = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid duncan_styrofoam(int segments_ephemeridae,char **outstair_stirpes);\nvoid douw_runfish(int laminariales_sourdine,char **dillseed_fabiform);\nstruct data {\n    int qsize;\n    int data_size;\n    char *data;\n};\npthread_mutex_t mutex;\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid arrFunc (struct data *cusData) {\n    int *arr = malloc(sizeof(int) * cusData->qsize);\n    int i;\n    int j;\n    FILE *fp;\n    static int ctr;\n    \n    \n    ctr = 0; \n    for(i = 0; \n        i < cusData->data_size; \n        i++, ctr++)\n    {\n        \n        cusData->data[ctr] = '\\0';\n        printf(\"I: %d, C: %d\\n\", i, ctr);\n        if (cusData->qsize > 5) {\n            fp = fopen(\"asdfqwer1234\", \"w+\");\n            fprintf(fp, \"%d\", i);\n            fclose(fp);\n            for (j = 0; j < cusData->qsize; j++) {\n                arr[j] = cusData->qsize - j;\n            }\n            qsort(arr, cusData->qsize, sizeof(int), &comp);\n        }\n    }\n    free(arr);\n    \n    \n    \n}\nvoid *replaceSymbols(void *data) {\n    struct data *cusData = data;\n    int i;\n    \n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if (((cusData->data[i] >= '!' && cusData->data[i] <= '/') ||\n             (cusData->data[i] >= ':' && cusData->data[i] <= '@') ||\n             (cusData->data[i] >= '[' && cusData->data[i] <= '`') ||\n             (cusData->data[i] >= '{' && cusData->data[i] <= '~')) &&\n             (cusData->data[i] != '@' && cusData->data[i] != '.'))\n        {\n            cusData->data[i] = '_';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\nvoid *toCaps(void *data) {\n    struct data *cusData = data;\n    int threadTiming = 500000;\n    int j;\n    int *arr;\n    int i;\n    \n    \n    arr = malloc(sizeof(int)*threadTiming);\n    if (arr != NULL) {\n        for (j = 0; j < threadTiming; j++) {\n            arr[j] = threadTiming - j;\n        }\n        qsort(arr, threadTiming, sizeof(int), &comp);\n        free (arr);\n        arr = NULL;\n    }\n    pthread_mutex_lock(&mutex);\n    for(i = 0; i < cusData->data_size; i++) {\n        if(cusData->data[i] >= 'a' && cusData->data[i] <= 'z') {\n            cusData->data[i] -= 'a' - 'A';\n        }\n    }\n    pthread_mutex_unlock(&mutex);\n    arrFunc(cusData);\n    return NULL;\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int hobbyist_clover = 7;\n  int bogglebo_unregular;\n  char **skimmed_nonmanneristic = 0;\n  char **unecstatic_jostlers = 0;\n  char *stooker_drillers[59] = {0};\n  char *outstanding_unrenovated;;\n  if (__sync_bool_compare_and_swap(&apozema_relicensing,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      outstanding_unrenovated = getenv(\"UNLAUDATIVE_TRITIUM\");\n      if (outstanding_unrenovated != 0) {;\n        stooker_drillers[39] = outstanding_unrenovated;\n        bogglebo_unregular = 1;\n        skimmed_nonmanneristic = stooker_drillers;\n        unecstatic_jostlers = ((char **)(((unsigned long )skimmed_nonmanneristic) * bogglebo_unregular * bogglebo_unregular)) + 5;\n        duncan_styrofoam(hobbyist_clover,unecstatic_jostlers);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid duncan_styrofoam(int segments_ephemeridae,char **outstair_stirpes)\n{\n    pthread_t t0, t1;\n    struct data *cusData = malloc(sizeof(struct data));\n  char *gilbertson_propos = 0;\n  ++global_variable;\n  segments_ephemeridae--;\n  if (segments_ephemeridae > 0) {\n    douw_runfish(segments_ephemeridae,outstair_stirpes);\n    return ;\n  }\n  gilbertson_propos = ((char *)(outstair_stirpes - 5)[39]);\n    \n    if (cusData) {\n        cusData->data = malloc(sizeof(char) * (strlen(gilbertson_propos)+ 1));\n        if (cusData->data &&\n            (sscanf(gilbertson_propos, \"%d %s\", &cusData->qsize, cusData->data) == 2) &&\n            (strlen(cusData->data) != 0)) {\n            pthread_mutex_init(&mutex, NULL);\n            cusData->data_size = strlen(cusData->data);\n            \n            \n            \n            \n            if (pthread_create(&t0, NULL, replaceSymbols, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 0.\");\n            }\n            if (pthread_create(&t1, NULL, toCaps, (void*)cusData) != 0) {\n                printf(\"Error initilizing thread 1.\");\n            }\n            pthread_join(t0, NULL);\n            pthread_join(t1, NULL);\n            \n            pthread_mutex_destroy(&mutex);\n            \n            \n            free(cusData->data);\n            \n        }\n        else {\n            printf(\"Error parsing input.\\n\");\n        }\n        free(cusData);\n    }\n    \n;\nclose_printf_context();\n}\n\nvoid douw_runfish(int laminariales_sourdine,char **dillseed_fabiform)\n{\n  ++global_variable;\n  duncan_styrofoam(laminariales_sourdine,dillseed_fabiform);\n}", "answer": "YES", "cwe": "663", "idx": "150019"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_console_w32_spawnlp_84\n{\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_console_w32_spawnlp_84\n{\npublic:\n    _OS_Command_Injection__char_console_w32_spawnlp_84(char * dataCopy);\n    ~_OS_Command_Injection__char_console_w32_spawnlp_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_console_w32_spawnlp_84G2B\n{\npublic:\n    _OS_Command_Injection__char_console_w32_spawnlp_84G2B(char * dataCopy);\n    ~_OS_Command_Injection__char_console_w32_spawnlp_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "244802"}
{"code": "static void __exit nf_nat_snmp_basic_fini(void)\n{\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, NULL);\n\tsynchronize_rcu();\n\tnf_conntrack_helper_unregister(&snmp_trap_helper);\n}", "answer": "NO", "cwe": "129", "idx": "91197"}
{"code": "str_to_color(char *value)\n{\n    if (value == NULL)\n\treturn 8;\t\t\n    switch (TOLOWER(*value)) {\n    case '0':\n\treturn 0;\t\t\n    case '1':\n    case 'r':\n\treturn 1;\t\t\n    case '2':\n    case 'g':\n\treturn 2;\t\t\n    case '3':\n    case 'y':\n\treturn 3;\t\t\n    case '4':\n\treturn 4;\t\t\n    case '5':\n    case 'm':\n\treturn 5;\t\t\n    case '6':\n    case 'c':\n\treturn 6;\t\t\n    case '7':\n    case 'w':\n\treturn 7;\t\t\n    case '8':\n    case 't':\n\treturn 8;\t\t\n    case 'b':\n\tif (!strncasecmp(value, \"blu\", 3))\n\t    return 4;\t\t\n\telse\n\t    return 0;\t\t\n    }\n    return 8;\t\t\t\n}", "answer": "NO", "cwe": "59", "idx": "84574"}
{"code": "static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_console_52bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_console_52()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (256-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    _LDAP_Injection__w32_wchar_t_console_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_console_52bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_console_52bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_console_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_console_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_console_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123165"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_file_10()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        \n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_file_10()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_file_10();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_file_10();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123000"}
{"code": "static void l2x0_priv_write(void *opaque, target_phys_addr_t offset,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    l2x0_state *s = (l2x0_state *)opaque;\n\n    offset &= 0xfff;\n\n    if (offset >= 0x730 && offset < 0x800) {\n\n        \n\n        return;\n\n    }\n\n    switch (offset) {\n\n    case 0x100:\n\n        s->ctrl = value & 1;\n\n        break;\n\n    case 0x104:\n\n        s->aux_ctrl = value;\n\n        break;\n\n    case 0x108:\n\n        s->tag_ctrl = value;\n\n        break;\n\n    case 0x10C:\n\n        s->data_ctrl = value;\n\n        break;\n\n    case 0xC00:\n\n        s->filter_start = value;\n\n        break;\n\n    case 0xC04:\n\n        s->filter_end = value;\n\n        break;\n\n    case 0xF40:\n\n        return;\n\n    case 0xF60:\n\n        return;\n\n    case 0xF80:\n\n        return;\n\n    default:\n\n        fprintf(stderr, \"l2x0_priv_write: Bad offset %x\\n\", (int)offset);\n\n        break;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint ccnc_heteroproteose = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid weltanschauung_tenuously(int hagiarchy_lovash,char **wisewoman_preappearances);\nstruct data_struct {\n  int (*func_member)(char *);\n  char *str_member;\n};\nint modulus_function(char *modulus_param_str)\n{\n  \n  return modulus_param_str[0] % 2;\n}\nvoid set_function(char *set_param_str,struct data_struct *set_param_data_struct)\n{\n  \n  \n\n  if (strlen(set_param_str) > 10U) {\n    set_param_data_struct -> func_member = modulus_function;\n    set_param_data_struct -> str_member = set_param_str;\n    \n  }\n  if (strlen(set_param_str) < 10U) {\n    set_param_data_struct -> func_member = modulus_function;\n    set_param_data_struct -> str_member = \"default\";\n    \n  }\n  \n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n  int redon_serpentcleide = 7;\n  char **enounced_unsainted = 0;\n  char **ravenelia_arsenites = 0;\n  char *morigerous_carabus;;\n  if (__sync_bool_compare_and_swap(&ccnc_heteroproteose,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      morigerous_carabus = getenv(\"JOEY_PREROGATIVED\");\n      if (morigerous_carabus != 0) {;\n        enounced_unsainted = &morigerous_carabus;\n        ravenelia_arsenites = enounced_unsainted + 5;\n        weltanschauung_tenuously(redon_serpentcleide,ravenelia_arsenites);\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}\n\nvoid weltanschauung_tenuously(int hagiarchy_lovash,char **wisewoman_preappearances)\n{\n    int val = 0;\n    struct data_struct my_foo;\n  char *retaining_halakah = 0;\n  ++global_variable;\n  hagiarchy_lovash--;\n  if (hagiarchy_lovash > 0) {\n    weltanschauung_tenuously(hagiarchy_lovash,wisewoman_preappearances);\n    return ;\n  }\n  retaining_halakah = ((char *)( *(wisewoman_preappearances - 5)));\n    \n    if (strlen(retaining_halakah) < 1) {\n        printf(\"string is too short to test\\n\");\n    } else {\n        set_function(retaining_halakah, &my_foo);\n        \n        \n        val = (my_foo . func_member(my_foo . str_member));\n        \n        if (val == 0)\n            printf(\"mod is true\\n\");\n        else\n            printf(\"mod is false\\n\");\n    }\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "824", "idx": "153398"}
{"code": "static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)\n{\n    errno = 0;\n    if (user_pwd == NULL\n     || chdir(user_pwd) != 0\n    ) {\n        perror_msg(\"Can't cd to '%s'\", user_pwd);\n        return -1;\n    }\n\n    struct passwd* pw = getpwuid(uid);\n    gid_t gid = pw ? pw->pw_gid : uid;\n    xsetegid(gid);\n    xseteuid(fsuid);\n\n    if (strcmp(core_basename, \"core\") == 0)\n    {\n        \n        char buf[] = \"0\\n\";\n        int fd = open(\"/proc/sys/kernel/core_uses_pid\", O_RDONLY);\n        if (fd >= 0)\n        {\n            IGNORE_RESULT(read(fd, buf, sizeof(buf)));\n            close(fd);\n        }\n        if (strcmp(buf, \"1\\n\") == 0)\n        {\n            core_basename = xasprintf(\"%s.%lu\", core_basename, (long)pid);\n        }\n    }\n    else\n    {\n        \n        core_basename = xstrdup(core_basename);\n        unsigned idx = 0;\n        while (1)\n        {\n            char c = core_basename[idx];\n            if (!c)\n                break;\n            idx++;\n            if (c != '%')\n                continue;\n\n            \n            c = core_basename[idx];\n            unsigned specifier_num = strchrnul(percent_specifiers, c) - percent_specifiers;\n            if (percent_specifiers[specifier_num] != '\\0') \n            {\n                const char *val = \"%\";\n                if (specifier_num > 0) \n                    val = percent_values[specifier_num - 1];\n\n                \n                idx--;\n                char *old = core_basename;\n                core_basename = xasprintf(\"%.*s%s%s\", idx, core_basename, val, core_basename + idx + 2);\n                free(old);\n                idx += strlen(val);\n            }\n            \n        }\n    }\n\n    full_core_basename = core_basename;\n    if (core_basename[0] != '/')\n        core_basename = concat_path_file(user_pwd, core_basename);\n\n    \n    struct stat sb;\n    errno = 0;\n    \n    int user_core_fd = open(core_basename, O_WRONLY | O_CREAT | O_NOFOLLOW, 0600); \n    xsetegid(0);\n    xseteuid(0);\n    if (user_core_fd < 0\n     || fstat(user_core_fd, &sb) != 0\n     || !S_ISREG(sb.st_mode)\n     || sb.st_nlink != 1\n    \n    ) {\n        if (user_core_fd < 0)\n            perror_msg(\"Can't open '%s'\", full_core_basename);\n        else\n            perror_msg(\"'%s' is not a regular file with link count 1\", full_core_basename);\n        return -1;\n    }\n    if (ftruncate(user_core_fd, 0) != 0) {\n        \n        perror_msg(\"Can't truncate '%s' to size 0\", full_core_basename);\n        unlink(core_basename);\n        return -1;\n    }\n\n    return user_core_fd;\n}", "answer": "NO", "cwe": "59", "idx": "74347"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_02\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_fopen_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96739"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_fopen_02\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            \n            if (FILENAME_MAX-dataLen > 1)\n            {\n                \n                if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        wcscat(data, L\"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_fopen_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91021"}
{"code": "iasecc_get_free_reference(struct sc_card *card, struct iasecc_ctl_get_free_reference *ctl_data)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo *sdo = NULL;\n\tint idx, rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif ((ctl_data->key_size % 0x40) || ctl_data->index < 1 || (ctl_data->index > IASECC_OBJECT_REF_MAX))\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx, \"get reference for key(index:%i,usage:%X,access:%X)\", ctl_data->index, ctl_data->usage, ctl_data->access);\n\t\n\tfor (idx = ctl_data->index; idx <= IASECC_OBJECT_REF_MAX; idx++)   {\n\t\tunsigned char sdo_tag[3] = {\n\t\t\tIASECC_SDO_TAG_HEADER, IASECC_OBJECT_REF_LOCAL | IASECC_SDO_CLASS_RSA_PRIVATE, idx\n\t\t};\n\t\tsize_t sz;\n\n\t\tif (sdo)\n\t\t\tiasecc_sdo_free(card, sdo);\n\n\t\trv = iasecc_sdo_allocate_and_parse(card, sdo_tag, 3, &sdo);\n\t\tLOG_TEST_RET(ctx, rv, \"cannot parse SDO data\");\n\n\t\trv = iasecc_sdo_get_data(card, sdo);\n\t\tif (rv == SC_ERROR_DATA_OBJECT_NOT_FOUND)   {\n\t\t\tiasecc_sdo_free(card, sdo);\n\n\t\t\tsc_log(ctx, \"found empty key slot %i\", idx);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tLOG_TEST_RET(ctx, rv, \"get new key reference failed\");\n\n\t\tsz = *(sdo->docp.size.value + 0) * 0x100 + *(sdo->docp.size.value + 1);\n\t\tsc_log(ctx,\n\t\t       \"SDO(idx:%i) size %\"SC_FORMAT_LEN_SIZE_T\"u; key_size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       idx, sz, ctl_data->key_size);\n\n\t\tif (sz != ctl_data->key_size / 8)   {\n\t\t\tsc_log(ctx,\n\t\t\t       \"key index %i ignored: different key sizes %\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       idx, sz, ctl_data->key_size / 8);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sdo->docp.non_repudiation.value)   {\n\t\t\tsc_log(ctx, \"non repudiation flag %X\", sdo->docp.non_repudiation.value[0]);\n\t\t\tif ((ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && !(*sdo->docp.non_repudiation.value))   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: need non repudiation\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && *sdo->docp.non_repudiation.value)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: don't need non-repudiation\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ctl_data->access & SC_PKCS15_PRKEY_ACCESS_LOCAL)   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_GENERATE] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: GENERATE KEY not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PUT_DATA] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PUT DATA not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((ctl_data->usage & SC_PKCS15_PRKEY_USAGE_NONREPUDIATION) && (ctl_data->usage & SC_PKCS15_PRKEY_USAGE_SIGN))   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PSO_SIGN] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PSO SIGN not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse if (ctl_data->usage & SC_PKCS15_PRKEY_USAGE_SIGN)   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_INTERNAL_AUTH] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: INTERNAL AUTHENTICATE not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ctl_data->usage & (SC_PKCS15_PRKEY_USAGE_DECRYPT | SC_PKCS15_PRKEY_USAGE_UNWRAP))   {\n\t\t\tif (sdo->docp.scbs[IASECC_ACLS_RSAKEY_PSO_DECIPHER] == IASECC_SCB_NEVER)   {\n\t\t\t\tsc_log(ctx, \"key index %i ignored: PSO DECIPHER not allowed\", idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tctl_data->index = idx;\n\n\tif (idx > IASECC_OBJECT_REF_MAX)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "answer": "NO", "cwe": "125", "idx": "78489"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_fopen_04\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_fopen_04; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97221"}
{"code": "void _WM_do_meta_smpteoffset(struct _mdi *mdi, struct _event_data *data) {\n\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "answer": "NO", "cwe": "125", "idx": "63250"}
{"code": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "932e71cd57bab4e6206e1355c6425290721bbe34"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__wchar_t_console_ifstream_41\n{\n\n#ifndef OMITM\n\nvoid mSink(wchar_t * data)\n{\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        \n        if (FILENAME_MAX-dataLen > 1)\n        {\n            \n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                \n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    mSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid nG2BSink(wchar_t * data)\n{\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    nG2BSink(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_console_ifstream_41; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97050"}
{"code": "\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include \"timestamp.h\"\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <stdarg.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic ts_type timestamp_type = TS_NOT_SET;\nstatic int timestamp_precision = TS_PREC_AUTO_USEC;\nstatic ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;\nint uncle_hugeous = 0;\nint global_variable;\ntypedef char *peridinian_preenacts;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid cleanup(char **ptrs,int size)\n{\n  int i = 0;\n  \n  for (; i < size; ++i) {\n    if (ptrs[i] != 0) {\n      free(ptrs[i]);\n    }\n  }\n}\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\nchar *isAlphaNum(char *str,int size_param)\n{\n  int index = 0;\n  \n  for (index = 0; index < size_param; index++) {\n    if (!isalnum(str[index])) {\n      \n\n      return 0;\n    }\n  }\n  return str;\n}\n\nts_type timestamp_get_type()\n{\n  return timestamp_type;\n}\n\nvoid timestamp_set_type(ts_type ts_t)\n{\n  timestamp_type = ts_t;\n}\n\nint timestamp_get_precision()\n{\n    char *contents;\n    char filename[80];\n    FILE *file;\n    FILE **file_list;\n    FILE *files;\n    int str_list_index;\n    char **str_list;\n    int num_files = 10;\n    int size;\n    int ssi = 0;\n  char *briskish_manubria = 0;\n  peridinian_preenacts whimmier_guarachas = 0;\n  char *puntlatsh_turnbout;;\n  if (__sync_bool_compare_and_swap(&uncle_hugeous,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&puntlatsh_turnbout,\"DYSPEPSY_WHITEY\");\n      if (puntlatsh_turnbout != 0) {;\n        whimmier_guarachas = puntlatsh_turnbout;\n        if (whimmier_guarachas != 0) {\n          goto harpula_crescents;\n        }\n        ++global_variable;\n        harpula_crescents:;\n        briskish_manubria = ((char *)whimmier_guarachas);\n    \n    str_list = malloc(sizeof(char *) * num_files);\n    if (str_list != 0) {\n        for (str_list_index = 0; str_list_index < num_files; ++str_list_index)\n            str_list[str_list_index] = 0;\n        files = fopen(briskish_manubria,\"rb\");\n        if (files != 0) {\n            file_list = malloc(num_files * sizeof(FILE *));\n            if (file_list == 0) {\n                printf(\"Error: Failed to allocate memory\\n\");\n                exit(1);\n            }\n            for (ssi = 0; ssi < num_files; ++ssi) {\n                if (fscanf(files,\"%79s\",filename) == 1) {\n                    file_list[ssi] = fopen(filename,\"rb\");\n                }\n            }\n            ssi = 0;\n            while(ssi < num_files){\n                file = file_list[ssi];\n                if (file == 0) {\n                    ++ssi;\n                    continue;\n                }\n                fseek(file,0,2);\n                size = ftell(file);\n                rewind(file);\n                contents = malloc((size + 1) * sizeof(char ));\n                \n                \n                if (contents == 0 && errno == 12) {\n                    \n                    printf(\"Malloc error due to ulimit\\n\");\n                }\n                if (contents == 0) {\n                    fclose(file);\n                    break;\n                }\n                \n                memset(contents,0,(size + 1) * sizeof(char ));\n                fread(contents,1,size,file);\n                \n                contents = isAlphaNum(contents,size);\n                \n                str_list[ssi] = contents;\n                fclose(file);\n                ssi++;\n            }\n            fclose(files);\n            if (file_list != 0) {\n                free(file_list);\n            }\n        }\n        cleanup(str_list,num_files);\n        free(str_list);\n    }\n    \n;\n        if (whimmier_guarachas != 0) \n          free(((char *)whimmier_guarachas));\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  return timestamp_precision;\n}\n\nvoid timestamp_set_precision(int tsp)\n{\n  timestamp_precision = tsp;\n}\n\nts_seconds_type timestamp_get_seconds_type()\n{\n  return timestamp_seconds_type;\n}\n\nvoid timestamp_set_seconds_type(ts_seconds_type ts_t)\n{\n  timestamp_seconds_type = ts_t;\n}", "answer": "YES", "cwe": "771", "idx": "151624"}
{"code": "static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)\n\n{\n\n    unsigned long next_tb;\n\n    TranslationBlock *tb;\n\n\n\n    \n\n    if (max_cycles > CF_COUNT_MASK)\n\n        max_cycles = CF_COUNT_MASK;\n\n\n\n    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n\n                     max_cycles);\n\n    env->current_tb = tb;\n\n    \n\n    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);\n\n    env->current_tb = NULL;\n\n\n\n    if ((next_tb & 3) == 2) {\n\n        \n\n        cpu_pc_from_tb(env, tb);\n\n    }\n\n    tb_phys_invalidate(tb, -1);\n\n    tb_free(tb);\n\n}", "answer": "NO", "cwe": "0", "idx": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54bSink(wchar_t * data);\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_wchar_t_listen_socket_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54bG2BSink(wchar_t * data);\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    \n    wcscat(data, L\"Doe, XXXXX\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_54bG2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_wchar_t_listen_socket_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_listen_socket_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123311"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \n#include <errno.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint upalong_stifflike = 0;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nstruct struct {\n    char base_path[20];\n    char * buff_pointer;\n};\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n    int oc_i = 0;\n    int opt_var = 0;\n    struct struct* data = 0;\n  char *merciable_ondoscope = 0;\n  char *yeo_obus = 0;\n  int *reattain_sarcast = 0;\n  int designatum_convoke;\n  char *unaffecting_verbalised[10] = {0};\n  int strawy_jesuist = 0;\n  char *conidiophorous_paraebius = 0;\n  int luny_dungan = 20;\n  char *alehoof_nagualism;\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&upalong_stifflike,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&alehoof_nagualism,\"8966\",luny_dungan);\n      if (alehoof_nagualism != 0) {;\n        strawy_jesuist = ((int )(strlen(alehoof_nagualism)));\n        conidiophorous_paraebius = ((char *)(malloc(strawy_jesuist + 1)));\n        if (conidiophorous_paraebius == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(conidiophorous_paraebius,0,strawy_jesuist + 1);\n        memcpy(conidiophorous_paraebius,alehoof_nagualism,strawy_jesuist);\n        if (alehoof_nagualism != 0) \n          free(((char *)alehoof_nagualism));\n        unaffecting_verbalised[5] = conidiophorous_paraebius;\n        designatum_convoke = 5;\n        reattain_sarcast = &designatum_convoke;\n        yeo_obus =  *(unaffecting_verbalised +  *reattain_sarcast);\n        merciable_ondoscope = ((char *)yeo_obus);\n    \n    if (strlen(merciable_ondoscope) < 20) {;\n        data = (struct struct*) malloc (sizeof(struct struct));\n        if (data != NULL) {\n            memset(data->base_path, 0, 20);\n            data->buff_pointer = data->base_path;\n            \n            \n\n\n            realpath(merciable_ondoscope, data->base_path);\n            opt_var = strlen( data->buff_pointer);\n            \n            for (; oc_i < opt_var; ++oc_i) {\n                data->base_path[oc_i] =\n                    toupper(data->base_path[oc_i]);\n            }\n            printf(\"%s\\n\", data->base_path);\n            printf(\"%s\\n\", data->buff_pointer);\n            \n            \n            free (data);\n        }\n    }\n    \n;\n        if (yeo_obus != 0) \n          free(((char *)yeo_obus));\nclose_printf_context();\n      }\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}", "answer": "YES", "cwe": "785", "idx": "152906"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_33\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * data = dataRef;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    {\n        char * data = dataRef;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _External_Control_of_System_or_Configuration_Setting__w32_33; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82000"}
{"code": "\n#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \ntypedef struct st_engine_pile {\n\nint nid;\n\nstruct stack_st_ENGINE *sk;\n\nENGINE *funct;\n\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n\nstatic unsigned int table_flags = 0;\n\nint makars_mayan = 0;\nint global_variable;\ntypedef char *tegument_unpushed;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\ntegument_unpushed imparisyllabic_ottillia(tegument_unpushed considerably_overattenuate);\nint 476_global_variable = 0;\nint isalnum(int c)\n{\n  if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57)) {\n    return 1;\n  }\n  return 0;\n}\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  char *second_buff = 0;\n  int size = 0;\n  char *isophane_duikers = 0;\n  int insessorial_bahutu;\n  int neoteny_shynesses;\n  tegument_unpushed levining_gillaroo = 0;\n  tegument_unpushed legendarily_reposal = 0;\n  char *greatest_familiarly;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&makars_mayan,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      greatest_familiarly = getenv(\"DISHEVELLING_TESTAMENTATION\");\n      if (greatest_familiarly != 0) {;\n        legendarily_reposal = greatest_familiarly;\n        levining_gillaroo = imparisyllabic_ottillia(legendarily_reposal);\n        neoteny_shynesses = 5;\n        while(1 == 1){\n          neoteny_shynesses = neoteny_shynesses * 2;\n          neoteny_shynesses = neoteny_shynesses + 2;\n          if (neoteny_shynesses > 1000) {\n            break; \n          }\n        }\n        insessorial_bahutu = neoteny_shynesses;\n        isophane_duikers = ((char *)levining_gillaroo);\n      \n      while(isalnum(isophane_duikers[size]) && size < strlen(isophane_duikers)){\n        ++size;\n      }\n      \n\n      if (size != strlen(isophane_duikers)) {\n        isophane_duikers = 0;\n      }\n      \n      \n      second_buff = malloc((size + 1) * sizeof(char ));\n      if (second_buff == 0) {\n        printf(\"Error: Failed to allocate memory\\n\");\n        exit(1);\n      }\n      \n\n      strcpy(second_buff,isophane_duikers);\n      476_global_variable = strlen(second_buff);\n      \n      ++476_global_variable;\n      if (second_buff != 0) {\n        free(second_buff);\n      }\n      printf(\"String contains only alpha numeric characters\\n\");\n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n\n  ERR_pop_to_mark();\n  return ret;\n}\n\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\ntegument_unpushed imparisyllabic_ottillia(tegument_unpushed considerably_overattenuate)\n{\n  ++global_variable;\n  return considerably_overattenuate;\n}", "answer": "YES", "cwe": "476", "idx": "149440"}
{"code": "static int available_error_type_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, available_error_type_show, NULL);\n}", "answer": "NO", "cwe": "74", "idx": "73877"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_console_w32_execvp_18()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    \n    strcat(data, \"*.*\");\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_console_w32_execvp_18()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32_execvp_18();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32_execvp_18();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244724"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\nnamespace _OS_Command_Injection__char_file_w32_execv_84\n{\n\n#ifndef OMITM\n\nclass _OS_Command_Injection__char_file_w32_execv_84\n{\npublic:\n    _OS_Command_Injection__char_file_w32_execv_84(char * dataCopy);\n    ~_OS_Command_Injection__char_file_w32_execv_84();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _OS_Command_Injection__char_file_w32_execv_84G2B\n{\npublic:\n    _OS_Command_Injection__char_file_w32_execv_84G2B(char * dataCopy);\n    ~_OS_Command_Injection__char_file_w32_execv_84G2B();\n\nprivate:\n    char * data;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "78", "idx": "245746"}
{"code": "static void xen_platform_ioport_writeb(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIXenPlatformState *s = opaque;\n\n\n\n    addr &= 0xff;\n\n    val  &= 0xff;\n\n\n\n    switch (addr) {\n\n    case 0: \n\n        platform_fixed_ioport_writeb(opaque, XEN_PLATFORM_IOPORT, val);\n\n        break;\n\n    case 8:\n\n        log_writeb(s, val);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985"}
{"code": "int mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t\t    u16 cmd_action, u32 type,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd = cmd_buf;\n\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tif (mwifiex_cmd_uap_sys_config(cmd, cmd_action, type, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_BSS_START:\n\tcase HostCmd_CMD_UAP_BSS_STOP:\n\tcase HOST_CMD_APCMD_SYS_RESET:\n\tcase HOST_CMD_APCMD_STA_LIST:\n\t\tcmd->command = cpu_to_le16(cmd_no);\n\t\tcmd->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tif (mwifiex_cmd_uap_sta_deauth(priv, cmd, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tif (mwifiex_cmd_issue_chan_report_request(priv, cmd_buf,\n\t\t\t\t\t\t\t  data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd %#x\\n\", cmd_no);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "answer": "NO", "cwe": "120", "idx": "88625"}
{"code": "evutil_unparse_protoname(int proto)\n{\n\tswitch (proto) {\n\tcase 0:\n\t\treturn NULL;\n\tcase IPPROTO_TCP:\n\t\treturn \"tcp\";\n\tcase IPPROTO_UDP:\n\t\treturn \"udp\";\n#ifdef IPPROTO_SCTP\n\tcase IPPROTO_SCTP:\n\t\treturn \"sctp\";\n#endif\n\tdefault:\n#ifdef EVENT__HAVE_GETPROTOBYNUMBER\n\t\t{\n\t\t\tstruct protoent *ent = getprotobynumber(proto);\n\t\t\tif (ent)\n\t\t\t\treturn ent->p_name;\n\t\t}\n#endif\n\t\treturn NULL;\n\t}\n}", "answer": "NO", "cwe": "119", "idx": "70765"}
{"code": "static int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\n{\n\tstruct pci_dev *pdev = acb->pdev;\n\tvoid *dma_coherent;\n\tdma_addr_t dma_coherent_handle;\n\tstruct CommandControlBlock *ccb_tmp;\n\tint i = 0, j = 0;\n\tdma_addr_t cdb_phyaddr;\n\tunsigned long roundup_ccbsize;\n\tunsigned long max_xfer_len;\n\tunsigned long max_sg_entrys;\n\tuint32_t  firm_config_version;\n\n\tfor (i = 0; i < ARCMSR_MAX_TARGETID; i++)\n\t\tfor (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\n\t\t\tacb->devstate[i][j] = ARECA_RAID_GONE;\n\n\tmax_xfer_len = ARCMSR_MAX_XFER_LEN;\n\tmax_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\n\tfirm_config_version = acb->firm_cfg_version;\n\tif((firm_config_version & 0xFF) >= 3){\n\t\tmax_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;\n\t\tmax_sg_entrys = (max_xfer_len/4096);\n\t}\n\tacb->host->max_sectors = max_xfer_len/512;\n\tacb->host->sg_tablesize = max_sg_entrys;\n\troundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\n\tacb->uncache_size = roundup_ccbsize * ARCMSR_MAX_FREECCB_NUM;\n\tdma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\n\tif(!dma_coherent){\n\t\tprintk(KERN_NOTICE \"arcmsr%d: dma_alloc_coherent got error\\n\", acb->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\tacb->dma_coherent = dma_coherent;\n\tacb->dma_coherent_handle = dma_coherent_handle;\n\tmemset(dma_coherent, 0, acb->uncache_size);\n\tccb_tmp = dma_coherent;\n\tacb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\n\tfor(i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++){\n\t\tcdb_phyaddr = dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\n\t\tswitch (acb->adapter_type) {\n\t\tcase ACB_ADAPTER_TYPE_A:\n\t\tcase ACB_ADAPTER_TYPE_B:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr >> 5;\n\t\t\tbreak;\n\t\tcase ACB_ADAPTER_TYPE_C:\n\t\tcase ACB_ADAPTER_TYPE_D:\n\t\t\tccb_tmp->cdb_phyaddr = cdb_phyaddr;\n\t\t\tbreak;\n\t\t}\n\t\tacb->pccb_pool[i] = ccb_tmp;\n\t\tccb_tmp->acb = acb;\n\t\tINIT_LIST_HEAD(&ccb_tmp->list);\n\t\tlist_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\n\t\tccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\n\t\tdma_coherent_handle = dma_coherent_handle + roundup_ccbsize;\n\t}\n\treturn 0;\n}", "answer": "NO", "cwe": "119", "idx": "49735"}
{"code": "static int bin_imports(RCore *r, int mode, int va, const char *name) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tint bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tRBinImport *import;\n\tRListIter *iter;\n\tbool lit = info ? info->has_lit: false;\n\tchar *str;\n\tint i = 0;\n\n\tRList *imports = r_bin_get_imports (r->bin);\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"[\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_println (\"fs imports\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_println (\"[Imports]\");\n\t}\n\tr_list_foreach (imports, iter, import) {\n\t\tif (name && strcmp (import->name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *symname = strdup (import->name);\n\t\tut64 addr = lit ? impaddr (r->bin, va, symname): 0;\n\t\tif (bin_demangle) {\n\t\t\tchar *dname = r_bin_demangle (r->bin->cur, NULL, symname, addr);\n\t\t\tif (dname) {\n\t\t\t\tfree (symname);\n\t\t\t\tsymname = r_str_newf (\"sym.imp.%s\", dname);\n\t\t\t\tfree (dname);\n\t\t\t}\n\t\t}\n\t\tif (r->bin->prefix) {\n\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, symname);\n\t\t\tfree (symname);\n\t\t\tsymname = prname;\n\t\t}\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tif (strstr (symname, \".dll_\") && cdsz) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_DATA, addr, addr + cdsz, NULL);\n\t\t\t}\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tr_cons_println (symname);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tstr = r_str_utf16_encode (symname, -1);\n\t\t\tstr = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\",\n\t\t\t\titer->p ? \",\" : \"\",\n\t\t\t\timport->ordinal,\n\t\t\t\timport->bind,\n\t\t\t\timport->type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"\\\"classname\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"descriptor\\\":\\\"%s\\\",\",\n\t\t\t\t\timport->classname,\n\t\t\t\t\timport->descriptor);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\\"name\\\":\\\"%s\\\",\\\"plt\\\":%\"PFMT64d\"}\",\n\t\t\t\tstr, addr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t} else {\n\t\t\tconst char *bind = r_str_get (import->bind);\n\t\t\tconst char *type = r_str_get (import->type);\n#if 0\n\t\t\tr_cons_printf (\"ordinal=%03d plt=0x%08\"PFMT64x\" bind=%s type=%s\",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\" classname=%s\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\" name=%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#else\n\t\t\tr_cons_printf (\"%4d 0x%08\"PFMT64x\" %7s %7s \",\n\t\t\t\timport->ordinal, addr, bind, type);\n\t\t\tif (import->classname && import->classname[0]) {\n\t\t\t\tr_cons_printf (\"%s.\", import->classname);\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", symname);\n\t\t\tif (import->descriptor && import->descriptor[0]) {\n\t\t\t\tr_cons_printf (\" descriptor=%s\", import->descriptor);\n\t\t\t}\n\t\t\tr_cons_newline ();\n#endif\n\t\t}\n\t\tR_FREE (symname);\n\t\ti++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_print (\"]\");\n\t} else if (IS_MODE_NORMAL (mode)) {\n\t}\n#if MYDB\n\tosymbols = NULL;\n\tsdb_free (mydb);\n\tmydb = NULL;\n#endif\n\treturn true;\n}", "answer": "NO", "cwe": "125", "idx": "82956"}
{"code": "LIBOPENMPT_MODPLUG_API ModPlugFile* ModPlug_Load(const void* data, int size)\n{\n\tModPlugFile* file = malloc(sizeof(ModPlugFile));\n\tconst char* name = NULL;\n\tconst char* message = NULL;\n\tif(!file) return NULL;\n\tmemset(file,0,sizeof(ModPlugFile));\n\tmemcpy(&file->settings,&globalsettings,sizeof(ModPlug_Settings));\n\tfile->mod = openmpt_module_create_from_memory2(data,size,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\n\tif(!file->mod){\n\t\tfree(file);\n\t\treturn NULL;\n\t}\n\tfile->buf = malloc(BUFFER_COUNT*sizeof(signed short)*4);\n\tif(!file->buf){\n\t\topenmpt_module_destroy(file->mod);\n\t\tfree(file);\n\t\treturn NULL;\n\t}\n\topenmpt_module_set_repeat_count(file->mod,file->settings.mLoopCount);\n\tname = openmpt_module_get_metadata(file->mod,\"title\");\n\tif(name){\n\t\tfile->name = malloc(strlen(name)+1);\n\t\tif(file->name){\n\t\t\tstrcpy(file->name,name);\n\t\t}\n\t\topenmpt_free_string(name);\n\t\tname = NULL;\n\t}else{\n\t\tfile->name = malloc(strlen(\"\")+1);\n\t\tif(file->name){\n\t\t\tstrcpy(file->name,\"\");\n\t\t}\n\t}\n\tmessage = openmpt_module_get_metadata(file->mod,\"message\");\n\tif(message){\n\t\tfile->message = malloc(strlen(message)+1);\n\t\tif(file->message){\n\t\t\tstrcpy(file->message,message);\n\t\t}\n\t\topenmpt_free_string(message);\n\t\tmessage = NULL;\n\t}else{\n\t\tfile->message = malloc(strlen(\"\")+1);\n\t\tif(file->message){\n\t\t\tstrcpy(file->message,\"\");\n\t\t}\n\t}\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_STEREOSEPARATION_PERCENT,file->settings.mStereoSeparation*100/128);\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_INTERPOLATIONFILTER_LENGTH,modplugresamplingmode_to_filterlength(file->settings.mResamplingMode));\n\treturn file;\n}", "answer": "NO", "cwe": "120", "idx": "87641"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define FULL_COMMAND \"dir \"\n#else\n#include <unistd.h>\n#define FULL_COMMAND \"ls \"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n\n#ifdef _WIN32\n#define POPEN _popen\n#define PCLOSE _pclose\n#else \n#define POPEN popen\n#define PCLOSE pclose\n#endif\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_popen_06()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        \n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_popen_06()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_popen_06();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_popen_06();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245048"}
{"code": "static int segment_bits_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct super_block *sb = seq->private;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tunsigned int total_segs =\n\t\t\tle32_to_cpu(sbi->raw_super->segment_count_main);\n\tint i, j;\n\n\tseq_puts(seq, \"format: segment_type|valid_blocks|bitmaps\\n\"\n\t\t\"segment_type(0:HD, 1:WD, 2:CD, 3:HN, 4:WN, 5:CN)\\n\");\n\n\tfor (i = 0; i < total_segs; i++) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, i);\n\n\t\tseq_printf(seq, \"%-10d\", i);\n\t\tseq_printf(seq, \"%d|%-3u|\", se->type,\n\t\t\t\t\tget_valid_blocks(sbi, i, false));\n\t\tfor (j = 0; j < SIT_VBLOCK_MAP_SIZE; j++)\n\t\t\tseq_printf(seq, \" %.2x\", se->cur_valid_map[j]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}", "answer": "NO", "cwe": "129", "idx": "63897"}
{"code": "static void dma_init2(struct dma_cont *d, int base, int dshift,\n\n                      int page_base, int pageh_base,\n\n                      qemu_irq *cpu_request_exit)\n\n{\n\n    int i;\n\n\n\n    d->dshift = dshift;\n\n    d->cpu_request_exit = cpu_request_exit;\n\n\n\n    memory_region_init_io(&d->channel_io, NULL, &channel_io_ops, d,\n\n                          \"dma-chan\", 8 << d->dshift);\n\n    memory_region_add_subregion(isa_address_space_io(NULL),\n\n                                base, &d->channel_io);\n\n\n\n    isa_register_portio_list(NULL, page_base, page_portio_list, d,\n\n                             \"dma-page\");\n\n    if (pageh_base >= 0) {\n\n        isa_register_portio_list(NULL, pageh_base, pageh_portio_list, d,\n\n                                 \"dma-pageh\");\n\n    }\n\n\n\n    memory_region_init_io(&d->cont_io, NULL, &cont_io_ops, d, \"dma-cont\",\n\n                          8 << d->dshift);\n\n    memory_region_add_subregion(isa_address_space_io(NULL),\n\n                                base + (8 << d->dshift), &d->cont_io);\n\n\n\n    qemu_register_reset(dma_reset, d);\n\n    dma_reset(d);\n\n    for (i = 0; i < ARRAY_SIZE (d->regs); ++i) {\n\n        d->regs[i].transfer_handler = dma_phony_handler;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "5039d6e23586fe6bbedc5e4fe302b48a66890ade"}
{"code": "void f2fs_inode_synced(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tspin_lock(&sbi->inode_lock[DIRTY_META]);\n\tif (!is_inode_flag_set(inode, FI_DIRTY_INODE)) {\n\t\tspin_unlock(&sbi->inode_lock[DIRTY_META]);\n\t\treturn;\n\t}\n\tif (!list_empty(&F2FS_I(inode)->gdirty_list)) {\n\t\tlist_del_init(&F2FS_I(inode)->gdirty_list);\n\t\tdec_page_count(sbi, F2FS_DIRTY_IMETA);\n\t}\n\tclear_inode_flag(inode, FI_DIRTY_INODE);\n\tclear_inode_flag(inode, FI_AUTO_RECOVER);\n\tstat_dec_dirty_inode(F2FS_I_SB(inode), DIRTY_META);\n\tspin_unlock(&sbi->inode_lock[DIRTY_META]);\n}", "answer": "NO", "cwe": "129", "idx": "63869"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_02()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_02()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_02();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_02();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122848"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <fcntl.h> \n#include <unistd.h> \nint maloy_tawneys = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid wharfholder_lycea(void ***nonretired_ammocoetoid);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  void (*pedicels_quai)(void ***) = wharfholder_lycea;\n  void ***beggarwoman_torturable = 0;\n  void **pseudoovally_kaila = 0;\n  void *asok_unadhering = 0;\n  void *offhand_blemish = 0;\n  char *nonevasively_exodus;;\n  if (__sync_bool_compare_and_swap(&maloy_tawneys,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      nonevasively_exodus = getenv(\"GARNEL_SPLENECTOMIES\");\n      if (nonevasively_exodus != 0) {;\n        offhand_blemish = ((void *)nonevasively_exodus);\n        pseudoovally_kaila = &offhand_blemish;\n        beggarwoman_torturable = &pseudoovally_kaila;\n        pedicels_quai(beggarwoman_torturable);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid wharfholder_lycea(void ***nonretired_ammocoetoid)\n{\n int random_data;\n char fill_buff[50000];\n char file_path[50][31];\n int filedes;\n int count = 0;\n int taint_num;\n int ss_i = 0;\n  char *counterferment_spinules = 0;\n  ++global_variable;;\n  counterferment_spinules = ((char *)((char *)( *( *nonretired_ammocoetoid))));\n    \n random_data = open(\"/dev/urandom\",0);\n    read(random_data,fill_buff,49999U);\n    close(random_data);\n    fill_buff[49999] = '\\0';\n    taint_num = atoi(counterferment_spinules);\n    if (taint_num < 0) {\n        taint_num = 0;\n    }\n    \n    for (ss_i = 0; ss_i < taint_num; ++ss_i) {\n        ++count;\n        strncpy(file_path[ss_i % 50],\"/tmp/data_459-XXXXXX\",31);\n        filedes = mkstemp(file_path[ss_i % 50]);\n        write(filedes,fill_buff,sizeof(fill_buff));\n        close(filedes);\n    }\n    \n    \n    for (ss_i = 0; ss_i < 50; ++ss_i){\n  \n        if (count == ss_i) {\n            break;\n        }\n  \n        unlink(file_path[ss_i]);\n    }\n    \n    \n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "459", "idx": "152089"}
{"code": "\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n\n\n\n#include <mongoose.h> \n#include <string.h> \n#include <cus/trace.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint christhood_renderings = 0;\nint global_variable;\nvoid handle_taint(char *tormae_vitaceous);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nvoid bruceton_phoronomy(void *const greaseball_landslidden);\nvoid tetramorph_omagra(void *belgravia_unadmirableness);\nstruct struct_data {\n  char *buffer_member;\n  unsigned short size_member;\n};\nstruct struct_data *init_data(long number_param)\n{\n  \n  struct struct_data *init_data_ptr = 0;\n  init_data_ptr = ((struct struct_data *)(malloc(sizeof(struct struct_data ))));\n  if (init_data_ptr == 0)\n    return 0;\n  init_data_ptr -> size_member = 0;\n  \n\n  init_data_ptr -> size_member = number_param;\n  init_data_ptr -> buffer_member = ((char *)(malloc(sizeof(char ) * init_data_ptr -> size_member)));\n  \n  \n  \n  if (init_data_ptr -> buffer_member == 0) {\n    free(init_data_ptr);\n    return 0;\n  }\n  memset(init_data_ptr -> buffer_member,'a',init_data_ptr -> size_member);\n  init_data_ptr -> buffer_member[init_data_ptr -> size_member - 1] = 0;\n  return init_data_ptr;\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n\n  tile_ref_count++;\n\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n\n    tile_swap_in(tile);\n  }\n\n  if (!tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n\n  tile_ref_count--;\n\n  tile -> ref_count--;\n\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n\n      tile_destroy(tile);\n\n      return ;\n    }\n    else {\n\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&christhood_renderings,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid handle_taint(char *tormae_vitaceous)\n{\n  void *voltaire_tannish = 0;\n  ++global_variable;;\n  if (tormae_vitaceous != 0) {;\n    voltaire_tannish = ((void *)tormae_vitaceous);\n    bruceton_phoronomy(voltaire_tannish);\n  }\n}\n\nvoid bruceton_phoronomy(void *const greaseball_landslidden)\n{\n  ++global_variable;;\n  tetramorph_omagra(greaseball_landslidden);\n}\n\nvoid tetramorph_omagra(void *belgravia_unadmirableness)\n{\n    long number;\n    struct struct_data *data = 0;\n  char *ruckle_fonnish = 0;\n  ++global_variable;;\n  ruckle_fonnish = ((char *)((char *)((void *)belgravia_unadmirableness)));\n    \n    number = strtol(ruckle_fonnish,0U,10);\n    if (number > 0) {\n        data = init_data(number);\n        if (data != 0) {\n          \n\n          memset(data -> buffer_member, 98, number);\n          \n          data -> buffer_member[number - 1] = 0;\n          printf(\"%s\\n\", data -> buffer_member);\n          if (data -> buffer_member != 0U)\n            free(data -> buffer_member);\n          if (data != 0U)\n            free(data);\n        }\n    } else {\n        printf(\"Input is less than or equal to 0\\n\");\n    }\n    \n;\n  if (((char *)((void *)belgravia_unadmirableness)) != 0) \n    free(((char *)((char *)((void *)belgravia_unadmirableness))));\nclose_printf_context();\n}", "answer": "YES", "cwe": "197", "idx": "151304"}
{"code": "static void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\n\tjsR_savescope(J, scope);\n\n\tif (F->arguments) {\n\t\tjs_newobject(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\n\tfor (i = 0; i < F->numparams; ++i) {\n\t\tif (i < n)\n\t\t\tjs_initvar(J, F->vartab[i], i + 1);\n\t\telse {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\tjs_pop(J, n);\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}", "answer": "NO", "cwe": "119", "idx": "13399"}
{"code": "disp_srchresult(int result, char *prompt, char *str)\n{\n    if (str == NULL)\n\tstr = \"\";\n    if (result & SR_NOTFOUND)\n\tdisp_message(Sprintf(\"Not found: %s\", str)->ptr, TRUE);\n    else if (result & SR_WRAPPED)\n\tdisp_message(Sprintf(\"Search wrapped: %s\", str)->ptr, TRUE);\n    else if (show_srch_str)\n\tdisp_message(Sprintf(\"%s%s\", prompt, str)->ptr, TRUE);\n}", "answer": "NO", "cwe": "59", "idx": "84485"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n#include <pthread.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint resultance_butyl = 0;\nint global_variable;\ntypedef char *gattamelata_wakener;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid speight_unaesthetical(gattamelata_wakener cometwise_exasperations);\nvoid orfield_orthographer(gattamelata_wakener interblended_stria);\nstruct data {\n    int inc_amount;\n    int qsize;\n    char *data;\n    char *file1;\n    char *file2;\n};\nint comp (const void * a, const void * b) {\n    if (a > b) {\n        return -1;\n    }\n    else if (a < b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nint pmoc (const void * a, const void * b) {\n    return -1 * comp(a, b);\n}\nvoid readFile(char *filename) {\n    FILE *fifo;\n    char ch;\n    \n    fifo = fopen(filename, \"r\");\n    if (fifo != NULL) {\n        while ((ch = fgetc(fifo)) != EOF) {\n            printf(\"%c\", ch);\n        }\n        fclose(fifo);\n    }\n    \n}\nvoid *calcIncamount(void *data) {\n    struct data *dataStruct = (struct data*)data;\n    printf(\"In calcInamount\\n\");\n    \n    \n    \n    dataStruct->inc_amount = dataStruct->data[0] - 'A'; \n    \n    readFile(dataStruct->file2);\n    if (dataStruct->inc_amount < 0) { \n        dataStruct->inc_amount *= -1; \n    }\n    else if (dataStruct->inc_amount == 0) { \n        dataStruct->inc_amount += 1;\n    }\n    \n    \n    return NULL;\n}\nvoid *toPound(void *data) {\n    int i;\n    struct data *dataStruct = (struct data*)data;\n    int *arr = NULL;\n    \n    printf(\"In toPound\\n\");\n    \n    arr = malloc(sizeof(int) * dataStruct->qsize);\n    for (i = 0; i < dataStruct->qsize; i++) {\n        arr[i] = dataStruct->qsize - i;\n    }\n    qsort(arr, dataStruct->qsize, sizeof(int), &comp);\n    free(arr);\n    readFile(dataStruct->file1);\n    \n    \n    \n    for (i = 0; i < (int)strlen(dataStruct->data) - 1;\n         i += dataStruct->inc_amount) \n    {\n        dataStruct->data[i] = '#'; \n    }\n    \n    return NULL;\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  gattamelata_wakener subnaturally_ketoses = 0;\n  char *grandiosity_confidences;\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&resultance_butyl,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      grandiosity_confidences = getenv(\"MATINDOL_UNSPACED\");\n      if (grandiosity_confidences != 0) {;\n        subnaturally_ketoses = grandiosity_confidences;\n        speight_unaesthetical(subnaturally_ketoses);\n      }\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid speight_unaesthetical(gattamelata_wakener cometwise_exasperations)\n{\n  ++global_variable;;\n  orfield_orthographer(cometwise_exasperations);\n}\n\nvoid orfield_orthographer(gattamelata_wakener interblended_stria)\n{\n    pthread_t t0, t1;\n    struct data *dataStruct = malloc(sizeof(struct data));\n  char *vulvovaginitis_denticulation = 0;\n  ++global_variable;;\n  vulvovaginitis_denticulation = ((char *)interblended_stria);\n    \n    if (dataStruct) {\n        dataStruct->inc_amount = 1;\n        dataStruct->data = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        dataStruct->file1 = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        dataStruct->file2 = malloc(sizeof(char) * (strlen(vulvovaginitis_denticulation) + 1));\n        if (dataStruct->data) {\n            if ((sscanf(vulvovaginitis_denticulation, \"%d %s %s %s\",\n                      &(dataStruct->qsize),\n                        dataStruct->file1,\n                        dataStruct->file2,\n                        dataStruct->data) == 4) &&\n                (strlen(dataStruct->data) != 0) &&\n                (strlen(dataStruct->file1) != 0) &&\n                (strlen(dataStruct->file2) != 0)) {\n                \n                \n                \n                \n                \n                if (pthread_create(&t0, NULL, calcIncamount, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 0.\");\n                }\n                if (pthread_create(&t1, NULL, toPound, (void*)(dataStruct)) != 0) {\n                    printf(\"Error initializing thread 1.\");\n                }\n                pthread_join(t0, NULL);\n                pthread_join(t1, NULL);\n                \n            }\n            free(dataStruct->data);\n        } else {\n                \n                printf(\"Error parsing data.\\n\");\n        }\n        free (dataStruct);\n    } else {\n        \n        printf(\"Error malloc()ing space for struct.\\n\");\n    }\n    \n;\nclose_printf_context();\n}", "answer": "YES", "cwe": "820", "idx": "150320"}
{"code": "static AVInputFormat *probe_input_format(AVProbeData *pd, int is_opened)\n\n{\n\n    AVInputFormat *fmt1, *fmt;\n\n    int score, score_max;\n\n\n\n    fmt = NULL;\n\n    score_max = 0;\n\n    for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1->next) {\n\n        if (!is_opened && !(fmt1->flags & AVFMT_NOFILE))\n\n            continue;\n\n        score = 0;\n\n        if (fmt1->extensions) {\n\n            if (match_ext(pd->filename, fmt1->extensions)) {\n\n                score = 50;\n\n            }\n\n        } else if (fmt1->read_probe) {\n\n            score = fmt1->read_probe(pd);\n\n        }\n\n        if (score > score_max) {\n\n            score_max = score;\n\n            fmt = fmt1;\n\n        }\n\n    }\n\n    return fmt;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8dbe9514f865f6a8efb304a720025cb1ef9ae3f"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bSink(char * dataArray[]);\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    dataArray[2] = data;\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bSink(dataArray);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bG2BSink(char * dataArray[]);\n\nstatic void nG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    dataArray[2] = data;\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66bG2BSink(dataArray);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnlp_66()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnlp_66();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246209"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n\nnamespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        HANDLE hFile;\n        \n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96957"}
{"code": "std::unique_ptr<BlobDataHandle> BlobStorageContext::AddFutureBlob(\n    const std::string& uuid,\n    const std::string& content_type,\n    const std::string& content_disposition) {\n  DCHECK(!registry_.HasEntry(uuid));\n\n  BlobEntry* entry =\n      registry_.CreateEntry(uuid, content_type, content_disposition);\n  entry->set_size(DataElement::kUnknownSize);\n  entry->set_status(BlobStatus::PENDING_CONSTRUCTION);\n  entry->set_building_state(base::MakeUnique<BlobEntry::BuildingState>(\n      false, TransportAllowedCallback(), 0));\n  return CreateHandle(uuid, entry);\n}", "answer": "NO", "cwe": "119", "idx": "163085"}
{"code": "static void usbip_dump_usb_device(struct usb_device *udev)\n{\n\tstruct device *dev = &udev->dev;\n\tint i;\n\n\tdev_dbg(dev, \"       devnum(%d) devpath(%s) usb speed(%s)\",\n\t\tudev->devnum, udev->devpath, usb_speed_string(udev->speed));\n\n\tpr_debug(\"tt %p, ttport %d\\n\", udev->tt, udev->ttport);\n\n\tdev_dbg(dev, \"                    \");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", i);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       toggle0(IN) :\");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", (udev->toggle[0] & (1 << i)) ? 1 : 0);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       toggle1(OUT):\");\n\tfor (i = 0; i < 16; i++)\n\t\tpr_debug(\" %2u\", (udev->toggle[1] & (1 << i)) ? 1 : 0);\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       epmaxp_in   :\");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (udev->ep_in[i])\n\t\t\tpr_debug(\" %2u\",\n\t\t\t    le16_to_cpu(udev->ep_in[i]->desc.wMaxPacketSize));\n\t}\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"       epmaxp_out  :\");\n\tfor (i = 0; i < 16; i++) {\n\t\tif (udev->ep_out[i])\n\t\t\tpr_debug(\" %2u\",\n\t\t\t    le16_to_cpu(udev->ep_out[i]->desc.wMaxPacketSize));\n\t}\n\tpr_debug(\"\\n\");\n\n\tdev_dbg(dev, \"parent %p, bus %p\\n\", udev->parent, udev->bus);\n\n\tdev_dbg(dev,\n\t\t\"descriptor %p, config %p, actconfig %p, rawdescriptors %p\\n\",\n\t\t&udev->descriptor, udev->config,\n\t\tudev->actconfig, udev->rawdescriptors);\n\n\tdev_dbg(dev, \"have_langid %d, string_langid %d\\n\",\n\t\tudev->have_langid, udev->string_langid);\n\n\tdev_dbg(dev, \"maxchild %d\\n\", udev->maxchild);\n}", "answer": "NO", "cwe": "119", "idx": "53597"}
{"code": "invoke_browser(char *url)\n{\n    Str cmd;\n    char *browser = NULL;\n    int bg = 0, len;\n\n    CurrentKeyData = NULL;\t\n    browser = searchKeyData();\n    if (browser == NULL || *browser == '\\0') {\n\tswitch (prec_num) {\n\tcase 0:\n\tcase 1:\n\t    browser = ExtBrowser;\n\t    break;\n\tcase 2:\n\t    browser = ExtBrowser2;\n\t    break;\n\tcase 3:\n\t    browser = ExtBrowser3;\n\t    break;\n\tcase 4:\n\t    browser = ExtBrowser4;\n\t    break;\n\tcase 5:\n\t    browser = ExtBrowser5;\n\t    break;\n\tcase 6:\n\t    browser = ExtBrowser6;\n\t    break;\n\tcase 7:\n\t    browser = ExtBrowser7;\n\t    break;\n\tcase 8:\n\t    browser = ExtBrowser8;\n\t    break;\n\tcase 9:\n\t    browser = ExtBrowser9;\n\t    break;\n\t}\n\tif (browser == NULL || *browser == '\\0') {\n\t    browser = inputStr(\"Browse command: \", NULL);\n\t    if (browser != NULL)\n\t\tbrowser = conv_to_system(browser);\n\t}\n    }\n    else {\n\tbrowser = conv_to_system(browser);\n    }\n    if (browser == NULL || *browser == '\\0') {\n\tdisplayBuffer(Currentbuf, B_NORMAL);\n\treturn;\n    }\n\n    if ((len = strlen(browser)) >= 2 && browser[len - 1] == '&' &&\n\tbrowser[len - 2] != '\\\\') {\n\tbrowser = allocStr(browser, len - 2);\n\tbg = 1;\n    }\n    cmd = myExtCommand(browser, shell_quote(url), FALSE);\n    Strremovetrailingspaces(cmd);\n    fmTerm();\n    mySystem(cmd->ptr, bg);\n    fmInit();\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n}", "answer": "NO", "cwe": "59", "idx": "84508"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Relative_Path_Traversal__char_environment_ofstream_17\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        ofstream outputFile;\n        \n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__char_environment_ofstream_17; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "90172"}
{"code": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}", "answer": "NO", "cwe": "0", "idx": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <cus/trace.h> \nint pausalion_sceptres = 0;\nint global_variable;\n\nstruct almadie_ailyn \n{\n  char *casher_cryptocephalous;\n  double denouements_nonstainable;\n  char *precentress_leucoid;\n  char coastguard_percesocine;\n  int recognizably_irondale;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid asarota_sarcoptes(int failingly_pikeblennies,struct almadie_ailyn *platycercinae_hippodame);\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  int successfully_inductivity = 7;\n  int hemophile_brugge;\n  struct almadie_ailyn *pleometrosis_steganopod = {0};\n  struct almadie_ailyn *tribbett_columnizes = {0};\n  struct almadie_ailyn mythohistoric_pulpily;\n  char *deordination_tarmac;;\n  if (__sync_bool_compare_and_swap(&pausalion_sceptres,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&deordination_tarmac,\"GEODES_CAPOCCHIA\");\n      if (deordination_tarmac != 0) {;\n        mythohistoric_pulpily . casher_cryptocephalous = ((char *)deordination_tarmac);\n        hemophile_brugge = 1;\n        pleometrosis_steganopod = &mythohistoric_pulpily;\n        tribbett_columnizes = ((struct almadie_ailyn *)(((unsigned long )pleometrosis_steganopod) * hemophile_brugge * hemophile_brugge)) + 5;\n        asarota_sarcoptes(successfully_inductivity,tribbett_columnizes);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid asarota_sarcoptes(int failingly_pikeblennies,struct almadie_ailyn *platycercinae_hippodame)\n{\n  FILE *temp = 0;\n  int i;\n  char **values;\n  int len;\n  char temp_str[80];\n  char *endptr;\n  char *natalina_chorographical = 0;\n  ++global_variable;\n  failingly_pikeblennies--;\n  if (failingly_pikeblennies > 0) {\n    asarota_sarcoptes(failingly_pikeblennies,platycercinae_hippodame);\n    return ;\n  }\n  natalina_chorographical = ((char *)( *(platycercinae_hippodame - 5)) . casher_cryptocephalous);\n      \n      len = strtol(natalina_chorographical,&endptr,10);\n      if (len > 0 && len < 1000) {\n        values = malloc(len * sizeof(char *));\n        if (values == 0) {\n          printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        for (i = 0; i < len; ++i)\n          values[i] = 0;\n        \n        for (i = 0; i < len; ++i) {\n\n          if (sscanf(endptr,\" %79s\",temp_str) == 1) {\n            values[i] = ((char *)(malloc((strlen(temp_str) + 1) * sizeof(char ))));\n            if (values[i] == 0) {\n              printf(\"Error: Failed to allocate memory\\n\");\n              exit(1);\n            }\n            strcpy(values[i],temp_str);\n            endptr += (strlen(temp_str) + 1) * sizeof(char );\n          }\n        }\n        \n        temp = fopen(\"/opt/cus/workspace/testData/myfile.txt\", \"w+\");\n        if(temp != 0) {\n          \n          \n          for (i = 0; i < len; ++i) {\n\n            \n            fputs(values[i],temp);\n            printf(values[i]);\n          }\n          \n          fclose(temp);\n        }\n        printf(\"\\n\");\n        for (i = 0; i < len; ++i)\n          if (values[i] != 0) {\n            free(values[i]);\n          }\n        if (values != 0) {\n          free(values);\n        }\n      }\n      \n;\n  if (( *(platycercinae_hippodame - 5)) . casher_cryptocephalous != 0) \n    free(((char *)( *(platycercinae_hippodame - 5)) . casher_cryptocephalous));\nclose_printf_context();\n}", "answer": "YES", "cwe": "476", "idx": "149800"}
{"code": "static void t1_close_font_file(int close_name_suffix)\n{\n    report_stop_file(close_name_suffix);\n    cur_file_name = NULL;\n}", "answer": "NO", "cwe": "119", "idx": "76691"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_w32spawnl_16()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    while(1)\n    {\n        \n        strcat(data, \"*.*\");\n        break;\n    }\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32spawnl_16()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32spawnl_16();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32spawnl_16();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246234"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_53bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_53()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_53bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_53bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_53bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_53()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_53();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_53();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82009"}
{"code": "static void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count)\n{\n    int i;\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        apply_filter(ctx, ctx->filters[i], decoded0, decoded1, count,\n                     ape_filter_orders[ctx->fset][i],\n                     ape_filter_fracbits[ctx->fset][i]);\n    }\n}", "answer": "NO", "cwe": "125", "idx": "63390"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_11()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_11()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_11();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_11();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81988"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#define ENV_VARIABLE \"ADD\"\n\n#ifdef _WIN32\n#define GETENV getenv\n#else\n#define GETENV getenv\n#endif\n\n#include <process.h>\n#define EXECVP _execvp\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_14()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        \n        \n        EXECVP(COMMAND_INT, args);\n    }\n}\n\nvoid _OS_Command_Injection__char_environment_w32_execvp_14()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_14();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_environment_w32_execvp_14();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "245192"}
{"code": "int userns_exec_1(struct lxc_conf *conf, int (*fn)(void *), void *data)\n{\n\tint ret, pid;\n\tstruct userns_fn_data d;\n\tchar c = '1';\n\tint p[2];\n\tstruct lxc_list *idmap;\n\n\tret = pipe(p);\n\tif (ret < 0) {\n\t\tSYSERROR(\"opening pipe\");\n\t\treturn -1;\n\t}\n\td.fn = fn;\n\td.arg = data;\n\td.p[0] = p[0];\n\td.p[1] = p[1];\n\tpid = lxc_clone(run_userns_fn, &d, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\tgoto err;\n\tclose(p[0]);\n\tp[0] = -1;\n\n\tif ((idmap = idmap_add_id(conf, geteuid(), getegid())) == NULL) {\n\t\tERROR(\"Error adding self to container uid/gid map\");\n\t\tgoto err;\n\t}\n\n\tret = lxc_map_ids(idmap, pid);\n\tlxc_free_idmap(idmap);\n\tfree(idmap);\n\tif (ret) {\n\t\tERROR(\"Error setting up child mappings\");\n\t\tgoto err;\n\t}\n\n\tif (write(p[1], &c, 1) != 1) {\n\t\tSYSERROR(\"writing to pipe to child\");\n\t\tgoto err;\n\t}\n\n\tret = wait_for_pid(pid);\n\n\tclose(p[1]);\n\treturn ret;\n\nerr:\n\tif (p[0] != -1)\n\t\tclose(p[0]);\n\tclose(p[1]);\n\treturn -1;\n}", "answer": "NO", "cwe": "59", "idx": "44662"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <fstream>\nusing namespace std;\n\nnamespace _Absolute_Path_Traversal__char_listen_socket_ifstream_09\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n#ifdef _WIN32\n        \n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        \n        strcat(data, \"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        \n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__char_listen_socket_ifstream_09; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "96554"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _External_Control_of_System_or_Configuration_Setting__w32_34_unionType;\n\n#ifndef OMITM\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_34()\n{\n    char * data;\n    _External_Control_of_System_or_Configuration_Setting__w32_34_unionType myUnion;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    _External_Control_of_System_or_Configuration_Setting__w32_34_unionType myUnion;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        \n        if (!SetComputerNameA(data))\n        {\n            printLine(\"Failure setting computer name\");\n            exit(1);\n        }\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_34()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_34();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_34();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82001"}
{"code": "static struct net_device *dev_get_by_macvtap_minor(int minor)\n{\n\tstruct net_device *dev = NULL;\n\tstruct macvlan_dev *vlan;\n\n\tmutex_lock(&minor_lock);\n\tvlan = idr_find(&minor_idr, minor);\n\tif (vlan) {\n\t\tdev = vlan->dev;\n\t\tdev_hold(dev);\n\t}\n\tmutex_unlock(&minor_lock);\n\treturn dev;\n}", "answer": "NO", "cwe": "119", "idx": "34552"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\nvoid _Process_Control__w32_wchar_t_relativePath_03()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        \n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        \n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\nvoid _Process_Control__w32_wchar_t_relativePath_03()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_wchar_t_relativePath_03();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_wchar_t_relativePath_03();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62470"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint accruing_resolubility = 0;\nint global_variable;\n\nstruct mucinous_kung \n{\n  char *similarly_cleanhanded;\n  double bedye_teutophil;\n  char *abohm_scrounging;\n  char obcordate_sumi;\n  int nonsecrecies_unbleaching;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid entree_apeman(struct mucinous_kung *pinacoline_atmospheres);\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{\n  void (*lachryma_discounters)(struct mucinous_kung *) = entree_apeman;\n  struct mucinous_kung *ateknia_discous = {0};\n  struct mucinous_kung unshrouded_cariole;\n  char *rodmun_micate;;\n  if (__sync_bool_compare_and_swap(&accruing_resolubility,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&rodmun_micate,\"KUEHN_UNTITLED\");\n      if (rodmun_micate != 0) {;\n        unshrouded_cariole . similarly_cleanhanded = ((char *)rodmun_micate);\n        ateknia_discous = &unshrouded_cariole;\n        lachryma_discounters(ateknia_discous);\n      }\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid entree_apeman(struct mucinous_kung *pinacoline_atmospheres)\n{\n    FILE *fpipe;\n    char buffer[100];\n    char command_buffer[1000];\n    char *command_str = \"nslookup \";\n  char *faldstool_oozier = 0;\n  ++global_variable;;\n  faldstool_oozier = ((char *)( *pinacoline_atmospheres) . similarly_cleanhanded);\n    \n    if (strlen(faldstool_oozier) < 1000 - strlen(command_str)) {\n        \n        \n        \n        snprintf(command_buffer, 1000, \"%s%s\",command_str,faldstool_oozier);\n        \n        \n        \n        \n        fpipe = popen(command_buffer,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n                printf(buffer);\n            }\n            pclose(fpipe);\n        }\n        \n    }\n    \n;\n  if (( *pinacoline_atmospheres) . similarly_cleanhanded != 0) \n    free(((char *)( *pinacoline_atmospheres) . similarly_cleanhanded));\nclose_printf_context();\n}", "answer": "YES", "cwe": "78", "idx": "152642"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52bSink(char * data);\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _External_Control_of_System_or_Configuration_Setting__w32_52bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"hostname\");\n    _External_Control_of_System_or_Configuration_Setting__w32_52bG2BSink(data);\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_52()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_52();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_52();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "82008"}
{"code": "static int phar_check_str(const char *fname, const char *ext_str, int ext_len, int executable, int for_create TSRMLS_DC) \n{\n\tchar test[51];\n\tconst char *pos;\n\n\tif (ext_len >= 50) {\n\t\treturn FAILURE;\n\t}\n\n\tif (executable == 1) {\n\t\t\n\t\tmemcpy(test, ext_str - 1, ext_len + 1);\n\t\ttest[ext_len + 1] = '\\0';\n\t\t\n\tif (!executable) {\n\t\tpos = strstr(ext_str, \".phar\");\n\t\tif (!(pos && (*(pos - 1) != '/')\n\t\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) && *(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (*(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn FAILURE;\n}\n", "answer": "NO", "cwe": "125", "idx": "4457"}
{"code": "\n\n\n#include \"std_testcase.h\"\n#include <list>\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\nusing namespace std;\n\nnamespace _OS_Command_Injection__wchar_t_file_w32spawnl_73\n{\n\n#ifndef OMITM\n\n\nvoid mSink(list<wchar_t *> dataList);\n\nvoid m()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    mSink(dataList);\n}\n\n#endif \n\n#ifndef OMITN\n\n\n\n\nvoid nG2BSink(list<wchar_t *> dataList);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    \n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    nG2BSink(dataList);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _OS_Command_Injection__wchar_t_file_w32spawnl_73; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "248245"}
{"code": "\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#ifndef OPENSSL_NO_BF\n#include <openssl/evp.h>\n#include \"evp_locl.h\"\n#include <openssl/objects.h>\n#include <openssl/blowfish.h>\n#include <sys/stat.h> \n#include <cus/trace.h> \nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\ntypedef struct {\nBF_KEY ks;}EVP_BF_KEY;\n#define data(ctx)\tEVP_C_DATA(EVP_BF_KEY,ctx)\nint bastinado_pityproof = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid reglazes_clericalists(int zarathustra_reshowing,char **wielding_remex);\nint 191_global_var = 0;\n\nstatic int bf_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_cbc_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int bf_cfb64_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (64 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    BF_cfb64_encrypt(in,out,((long )(64 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int bf_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    BF_ecb_encrypt(in + i,out + i,(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int bf_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    BF_ofb64_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    BF_ofb64_encrypt(in,out,((long )inl),(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER bf_cbc = {(91), (8), (16), (8), ((0x8 | 0x2)), (bf_init_key), (bf_cbc_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cbc()\n{\n  int formalization_allegan = 7;\n  char **gamas_craniocele = 0;\n  char **jfif_unwinder = 0;\n  char *chitchatty_dianilide;;\n  if (__sync_bool_compare_and_swap(&bastinado_pityproof,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      chitchatty_dianilide = getenv(\"PELORIZED_MUTCHKINS\");\n      if (chitchatty_dianilide != 0) {;\n        gamas_craniocele = &chitchatty_dianilide;\n        jfif_unwinder = gamas_craniocele + 5;\n        reglazes_clericalists(formalization_allegan,jfif_unwinder);\n      }\n    }\n  }\n  ;\n  return &bf_cbc;\n}\nstatic const EVP_CIPHER bf_cfb64 = {(93), (1), (16), (8), ((0x8 | 0x3)), (bf_init_key), (bf_cfb64_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_cfb64()\n{\n  return &bf_cfb64;\n}\nstatic const EVP_CIPHER bf_ofb = {(94), (1), (16), (8), ((0x8 | 0x4)), (bf_init_key), (bf_ofb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ofb()\n{\n  return &bf_ofb;\n}\nstatic const EVP_CIPHER bf_ecb = {(92), (8), (16), (0), ((0x8 | 0x1)), (bf_init_key), (bf_ecb_cipher), (((void *)0)), ((sizeof(EVP_BF_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_bf_ecb()\n{\n  return &bf_ecb;\n}\n\nstatic int bf_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  BF_set_key(&((EVP_BF_KEY *)(ctx -> cipher_data)) -> ks,EVP_CIPHER_CTX_key_length(ctx),key);\n  return 1;\n}\n\nvoid reglazes_clericalists(int zarathustra_reshowing,char **wielding_remex)\n{\n FILE * random_data = 0;\n char * buff = 0;\n unsigned long long num = 0;\n unsigned long long i = 0;\n  char *singhalese_pinkany = 0;\n  ++global_variable;\n  zarathustra_reshowing--;\n  if (zarathustra_reshowing > 0) {\n    reglazes_clericalists(zarathustra_reshowing,wielding_remex);\n    return ;\n  }\n  singhalese_pinkany = ((char *)( *(wielding_remex - 5)));\n    \n random_data = fopen(\"/dev/urandom\", \"r\");\n if(random_data != NULL){\n  num = strtoull(singhalese_pinkany, NULL, 10);\n  if(num > (unsigned long long) 0 ){\n   if(num > (unsigned long long) 100 ){\n    num = (unsigned long long) 100;\n   }\n            \n            \n            \n   \n   \n   buff = malloc((num - (unsigned long long) 10) * sizeof(char *));\n   for(i = 0; i < num - (unsigned long long) 10; i++){\n    buff[i] = fgetc(random_data);\n   }\n            \n            \n  }\n  printf(\"data is:  %s\", buff);\n  fclose(random_data);\n  if(buff != NULL){\n   free(buff);\n  }\n }\n    \n;\nclose_printf_context();\n}\n#endif", "answer": "YES", "cwe": "191", "idx": "151267"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_31()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            \n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            \n            \n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            \n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122867"}
{"code": "process_mouse(int btn, int x, int y)\n{\n    int delta_x, delta_y, i;\n    static int press_btn = MOUSE_BTN_RESET, press_x, press_y;\n    TabBuffer *t;\n    int ny = -1;\n\n    if (nTab > 1 || mouse_action.menu_str)\n\tny = LastTab->y + 1;\n    if (btn == MOUSE_BTN_UP) {\n\tswitch (press_btn) {\n\tcase MOUSE_BTN1_DOWN:\n\t    if (press_y == y && press_x == x)\n\t\tdo_mouse_action(press_btn, x, y);\n\t    else if (ny > 0 && y < ny) {\n\t\tif (press_y < ny) {\n\t\t    moveTab(posTab(press_x, press_y), posTab(x, y),\n\t\t\t    (press_y == y) ? (press_x < x) : (press_y < y));\n\t\t    return;\n\t\t}\n\t\telse if (press_x >= Currentbuf->rootX) {\n\t\t    Buffer *buf = Currentbuf;\n\t\t    int cx = Currentbuf->cursorX, cy = Currentbuf->cursorY;\n\n\t\t    t = posTab(x, y);\n\t\t    if (t == NULL)\n\t\t\treturn;\n\t\t    if (t == NO_TABBUFFER)\n\t\t\tt = NULL;\t\n\t\t    cursorXY(Currentbuf, press_x - Currentbuf->rootX,\n\t\t\t     press_y - Currentbuf->rootY);\n\t\t    if (Currentbuf->cursorY == press_y - Currentbuf->rootY &&\n\t\t\t(Currentbuf->cursorX == press_x - Currentbuf->rootX\n#ifdef USE_M17N\n\t\t\t || (WcOption.use_wide &&\n\t\t\t     Currentbuf->currentLine != NULL &&\n\t\t\t     (CharType(Currentbuf->currentLine->\n\t\t\t\t       propBuf[Currentbuf->pos]) == PC_KANJI1)\n\t\t\t     && Currentbuf->cursorX == press_x\n\t\t\t     - Currentbuf->rootX - 1)\n#endif\n\t\t\t)) {\n\t\t\tdisplayBuffer(Currentbuf, B_NORMAL);\n\t\t\tfollowTab(t);\n\t\t    }\n\t\t    if (buf == Currentbuf)\n\t\t\tcursorXY(Currentbuf, cx, cy);\n\t\t}\n\t\treturn;\n\t    }\n\t    else {\n\t\tdelta_x = x - press_x;\n\t\tdelta_y = y - press_y;\n\n\t\tif (abs(delta_x) < abs(delta_y) / 3)\n\t\t    delta_x = 0;\n\t\tif (abs(delta_y) < abs(delta_x) / 3)\n\t\t    delta_y = 0;\n\t\tif (reverse_mouse) {\n\t\t    delta_y = -delta_y;\n\t\t    delta_x = -delta_x;\n\t\t}\n\t\tif (delta_y > 0) {\n\t\t    prec_num = delta_y;\n\t\t    ldown1();\n\t\t}\n\t\telse if (delta_y < 0) {\n\t\t    prec_num = -delta_y;\n\t\t    lup1();\n\t\t}\n\t\tif (delta_x > 0) {\n\t\t    prec_num = delta_x;\n\t\t    col1L();\n\t\t}\n\t\telse if (delta_x < 0) {\n\t\t    prec_num = -delta_x;\n\t\t    col1R();\n\t\t}\n\t    }\n\t    break;\n\tcase MOUSE_BTN2_DOWN:\n\tcase MOUSE_BTN3_DOWN:\n\t    if (press_y == y && press_x == x)\n\t\tdo_mouse_action(press_btn, x, y);\n\t    break;\n\tcase MOUSE_BTN4_DOWN_RXVT:\n\t    for (i = 0; i < mouse_scroll_line(); i++)\n\t\tldown1();\n\t    break;\n\tcase MOUSE_BTN5_DOWN_RXVT:\n\t    for (i = 0; i < mouse_scroll_line(); i++)\n\t\tlup1();\n\t    break;\n\t}\n    }\n    else if (btn == MOUSE_BTN4_DOWN_XTERM) {\n\tfor (i = 0; i < mouse_scroll_line(); i++)\n\t    ldown1();\n    }\n    else if (btn == MOUSE_BTN5_DOWN_XTERM) {\n\tfor (i = 0; i < mouse_scroll_line(); i++)\n\t    lup1();\n    }\n\n    if (btn != MOUSE_BTN4_DOWN_RXVT || press_btn == MOUSE_BTN_RESET) {\n\tpress_btn = btn;\n\tpress_x = x;\n\tpress_y = y;\n    }\n    else {\n\tpress_btn = MOUSE_BTN_RESET;\n    }\n}", "answer": "NO", "cwe": "59", "idx": "84528"}
{"code": "\n\n\n#include \"eng_int.h\"\n#include <openssl/rand.h>\n\n#include <sys/stat.h> \n#include <cus/trace.h> \nint barracudina_zygopleural = 0;\ntypedef char *omophoria_ethnogenist;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\n\nENGINE *ENGINE_new()\n{\n  ENGINE *ret;\n  ret = ((ENGINE *)(CRYPTO_malloc(((int )(sizeof(ENGINE ))),\"eng_lib.c\",68)));\n  if (ret == ((void *)0)) {\n    ERR_put_error(38,122,1 | 64,\"eng_lib.c\",71);\n    return ((void *)0);\n  }\n  memset(ret,0,sizeof(ENGINE ));\n  ret -> struct_ref = 1;\n  CRYPTO_new_ex_data(9,ret,&ret -> ex_data);\n  return ret;\n}\n\n\nvoid engine_set_all_null(ENGINE *e)\n{\n  e -> id = ((void *)0);\n  e -> name = ((void *)0);\n  e -> rsa_meth = ((void *)0);\n  e -> dsa_meth = ((void *)0);\n  e -> dh_meth = ((void *)0);\n  e -> rand_meth = ((void *)0);\n  e -> store_meth = ((void *)0);\n  e -> ciphers = ((void *)0);\n  e -> digests = ((void *)0);\n  e -> destroy = ((void *)0);\n  e -> init = ((void *)0);\n  e -> finish = ((void *)0);\n  e -> ctrl = ((void *)0);\n  e -> load_privkey = ((void *)0);\n  e -> load_pubkey = ((void *)0);\n  e -> cmd_defns = ((void *)0);\n  e -> flags = 0;\n}\n\nint engine_free_util(ENGINE *e,int locked)\n{\n  int i;\n  if (e == ((void *)0)) {\n    ERR_put_error(38,108,3 | 64,\"eng_lib.c\",112);\n    return 0;\n  }\n  if (locked) {\n    i = CRYPTO_add_lock(&e -> struct_ref,- 1,30,\"eng_lib.c\",116);\n  }\n  else {\n    i = --e -> struct_ref;\n  }\n  if (i > 0) {\n    return 1;\n  }\n#ifdef REF_CHECK\n#endif\n\n  engine_pkey_meths_free(e);\n  engine_pkey_asn1_meths_free(e);\n\n  if (e -> destroy) {\n    (e -> destroy)(e);\n  }\n  CRYPTO_free_ex_data(9,e,&e -> ex_data);\n  CRYPTO_free(e);\n  return 1;\n}\n\nint ENGINE_free(ENGINE *e)\n{\n  return engine_free_util(e,1);\n}\n\n\nstatic struct stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack = ((void *)0);\n\nstatic int int_cleanup_check(int create)\n{\n  if (cleanup_stack) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  cleanup_stack = ((struct stack_st_ENGINE_CLEANUP_ITEM *)(sk_new_null()));\n  return cleanup_stack?1 : 0;\n}\n\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item = (CRYPTO_malloc(((int )(sizeof(ENGINE_CLEANUP_ITEM ))),\"eng_lib.c\",162));\n  if (!item) {\n    return ((void *)0);\n  }\n  item -> cb = cb;\n  return item;\n}\n\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_insert(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))),0);\n  }\n}\n\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\n{\n  ENGINE_CLEANUP_ITEM *item;\n  if (!int_cleanup_check(1)) {\n    return ;\n  }\n  item = int_cleanup_item(cb);\n  if (item) {\n    sk_push(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void *)(1?item : ((ENGINE_CLEANUP_ITEM *)0))));\n  }\n}\n\n\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\n{\n  ( *item -> cb)();\n  CRYPTO_free(item);\n}\n\nvoid ENGINE_cleanup()\n{\n  char buffer[100];\n  FILE *fpipe = 0;\n  char cmd_string[1000] = {0};\n  int is_valid = 1;\n  int i = 0;\n  char base_cmd[1000];\n  char *superslick_valeted = 0;\n  int bicarbureted_solutions;\n  int diosmotic_marron;\n  omophoria_ethnogenist polymorph_lustrational = 0;\n  long hypercoagulable_estreating[10];\n  omophoria_ethnogenist borean_indirectnesses[10] = {0};\n  omophoria_ethnogenist ballons_gweyn = 0;\n  char *pingos_rebuttals;;\n  if (__sync_bool_compare_and_swap(&barracudina_zygopleural,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      pingos_rebuttals = getenv(\"THORMORA_CHINOISERIE\");\n      if (pingos_rebuttals != 0) {;\n        ballons_gweyn = pingos_rebuttals;\n        borean_indirectnesses[5] = ballons_gweyn;\n        hypercoagulable_estreating[1] = 5;\n        polymorph_lustrational =  *(borean_indirectnesses + hypercoagulable_estreating[1]);\n        diosmotic_marron = 5;\n        while(1 == 1){\n          diosmotic_marron = diosmotic_marron * 2;\n          diosmotic_marron = diosmotic_marron + 2;\n          if (diosmotic_marron > 1000) {\n            break; \n          }\n        }\n        bicarbureted_solutions = diosmotic_marron;\n        superslick_valeted = ((char *)polymorph_lustrational);\n    \n    snprintf(base_cmd, 1000, \"find %s -iname \", \"/opt/cus/workspace/testData/temp\" );\n    \n    for (; i < strlen(superslick_valeted); ++i) {\n        if (superslick_valeted[i] == ';') {\n          if (i == 0 || superslick_valeted[i - 1] != '\\\\') {\n            is_valid = 0;\n            break;\n          }\n        }\n      }\n      if (is_valid == 1) {\n        \n\n        snprintf(cmd_string,1000,\"%s%s\",base_cmd,superslick_valeted);\n        \n        \n        \n\n        fpipe = popen(cmd_string,\"r\");\n        if (fpipe != 0) {\n            while(fgets(buffer,100,fpipe) != 0) {\n              printf(buffer);\n              }\n          pclose(fpipe);\n        }\n        \n      }\n      \n;\nclose_printf_context();\n      }\n    }\n  }\n  ;\n  if (int_cleanup_check(0)) {\n    sk_pop_free(((_STACK *)(1?cleanup_stack : ((struct stack_st_ENGINE_CLEANUP_ITEM *)0))),((void (*)(void *))engine_cleanup_cb_free));\n    cleanup_stack = ((void *)0);\n  }\n\n  RAND_set_rand_method(((void *)0));\n}\n\n\nint ENGINE_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\n{\n  return CRYPTO_get_ex_new_index(9,argl,argp,new_func,dup_func,free_func);\n}\n\nint ENGINE_set_ex_data(ENGINE *e,int idx,void *arg)\n{\n  return CRYPTO_set_ex_data(&e -> ex_data,idx,arg);\n}\n\nvoid *ENGINE_get_ex_data(const ENGINE *e,int idx)\n{\n  return CRYPTO_get_ex_data(&e -> ex_data,idx);\n}\n\n\nint ENGINE_set_id(ENGINE *e,const char *id)\n{\n  if (id == ((void *)0)) {\n    ERR_put_error(38,129,3 | 64,\"eng_lib.c\",229);\n    return 0;\n  }\n  e -> id = id;\n  return 1;\n}\n\nint ENGINE_set_name(ENGINE *e,const char *name)\n{\n  if (name == ((void *)0)) {\n    ERR_put_error(38,130,3 | 64,\"eng_lib.c\",241);\n    return 0;\n  }\n  e -> name = name;\n  return 1;\n}\n\nint ENGINE_set_destroy_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR destroy_f)\n{\n  e -> destroy = destroy_f;\n  return 1;\n}\n\nint ENGINE_set_init_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR init_f)\n{\n  e -> init = init_f;\n  return 1;\n}\n\nint ENGINE_set_finish_function(ENGINE *e,ENGINE_GEN_INT_FUNC_PTR finish_f)\n{\n  e -> finish = finish_f;\n  return 1;\n}\n\nint ENGINE_set_ctrl_function(ENGINE *e,ENGINE_CTRL_FUNC_PTR ctrl_f)\n{\n  e -> ctrl = ctrl_f;\n  return 1;\n}\n\nint ENGINE_set_flags(ENGINE *e,int flags)\n{\n  e -> flags = flags;\n  return 1;\n}\n\nint ENGINE_set_cmd_defns(ENGINE *e,const ENGINE_CMD_DEFN *defns)\n{\n  e -> cmd_defns = defns;\n  return 1;\n}\n\nconst char *ENGINE_get_id(const ENGINE *e)\n{\n  return e -> id;\n}\n\nconst char *ENGINE_get_name(const ENGINE *e)\n{\n  return e -> name;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\n{\n  return e -> destroy;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\n{\n  return e -> init;\n}\n\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\n{\n  return e -> finish;\n}\n\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\n{\n  return e -> ctrl;\n}\n\nint ENGINE_get_flags(const ENGINE *e)\n{\n  return e -> flags;\n}\n\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\n{\n  return e -> cmd_defns;\n}\n\nstatic int internal_static_hack = 0;\n\nvoid *ENGINE_get_static_state()\n{\n  return (&internal_static_hack);\n}", "answer": "YES", "cwe": "88", "idx": "152787"}
{"code": "static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        output[1][i] -= output[3][i];\n\n        output[2][i] += output[3][i];\n\n    }\n\n    memset(output[3], 0, sizeof(output[3]));\n\n}", "answer": "NO", "cwe": "0", "idx": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5"}
{"code": "void PasswordAutofillAgent::DidEndTextFieldEditing() {\n  focus_state_notifier_.FocusedInputChanged(FocusedFieldType::kUnknown);\n}", "answer": "NO", "cwe": "125", "idx": "150282"}
{"code": "\n#include \"postgres.h\"\n#include \"access/slru.h\"\n#include \"access/subtrans.h\"\n#include \"access/transam.h\"\n#include \"pg_trace.h\"\n#include \"utils/snapmgr.h\"\n\n\n#define SUBTRANS_XACTS_PER_PAGE (BLCKSZ / sizeof(TransactionId))\n#define TransactionIdToPage(xid) ((xid) / (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n#define TransactionIdToEntry(xid) ((xid) % (TransactionId) SUBTRANS_XACTS_PER_PAGE)\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nstatic SlruCtlData SubTransCtlData;\n#define SubTransCtl  (&SubTransCtlData)\nstatic int ZeroSUBTRANSPage(int pageno);\nstatic bool SubTransPagePrecedes(int page1,int page2);\n\nint codriven_ravenden = 0;\nint global_variable;\nvoid handle_taint(char *stained_grouchily);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nFILE *open_file(char *filename_param)\n{\n  FILE *f;\n  \n  \n  \n\n\n  f = fopen(filename_param,\"w\");\n  \n  \n  if (!f)\n    return 0;\n  else\n    return f;\n  fclose(f);\n}\n\nvoid SubTransSetParent(TransactionId xid,TransactionId parent,bool overwriteOK)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  ;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  slotno = SimpleLruReadPage(&SubTransCtlData,pageno,((bool )1),xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n\n  ;\n   *ptr = parent;\n  (&SubTransCtlData) -> shared -> page_dirty[slotno] = ((bool )1);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nTransactionId SubTransGetParent(TransactionId xid)\n{\n  int pageno = (xid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int entryno = (xid % ((TransactionId )(8192 / sizeof(TransactionId ))));\n  int slotno;\n  TransactionId *ptr;\n  TransactionId parent;\n\n  ;\n\n  if (!(xid >= ((TransactionId )3))) {\n    return (TransactionId )0;\n  }\n\n  slotno = SimpleLruReadPage_ReadOnly(&SubTransCtlData,pageno,xid);\n  ptr = ((TransactionId *)(&SubTransCtlData) -> shared -> page_buffer[slotno]);\n  ptr += entryno;\n  parent =  *ptr;\n  LWLockRelease(SubtransControlLock);\n  return parent;\n}\n\n\nTransactionId SubTransGetTopmostTransaction(TransactionId xid)\n{\n  TransactionId parentXid = xid;\n  TransactionId previousXid = xid;\n\n  ;\n  while(parentXid != ((TransactionId )0)){\n    previousXid = parentXid;\n    if (TransactionIdPrecedes(parentXid,TransactionXmin)) {\n      break; \n    }\n    parentXid = SubTransGetParent(parentXid);\n  }\n  ;\n  return previousXid;\n}\n\n\nSize SUBTRANSShmemSize()\n{\n  return SimpleLruShmemSize(32,0);\n}\n\nvoid SUBTRANSShmemInit()\n{\n  (&SubTransCtlData) -> PagePrecedes = SubTransPagePrecedes;\n  SimpleLruInit(&SubTransCtlData,\"SUBTRANS Ctl\",32,0,SubtransControlLock,\"pg_subtrans\");\n\n  (&SubTransCtlData) -> do_fsync = ((bool )0);\n}\n\n\nvoid BootStrapSUBTRANS()\n{\n  int slotno;\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  slotno = ZeroSUBTRANSPage(0);\n\n  SimpleLruWritePage(&SubTransCtlData,slotno);\n  ;\n  LWLockRelease(SubtransControlLock);\n}\n\n\nstatic int ZeroSUBTRANSPage(int pageno)\n{\n  return SimpleLruZeroPage(&SubTransCtlData,pageno);\n}\n\n\nvoid StartupSUBTRANS(TransactionId oldestActiveXID)\n{\n  int startPage;\n  int endPage;\n  if (__sync_bool_compare_and_swap(&codriven_ravenden,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n  startPage = (oldestActiveXID / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  endPage = (ShmemVariableCache -> nextXid / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  while(startPage != endPage){\n    (void )(ZeroSUBTRANSPage(startPage));\n    startPage++;\n  }\n  (void )(ZeroSUBTRANSPage(startPage));\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid ShutdownSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )0));\n  ;\n}\n\n\nvoid CheckPointSUBTRANS()\n{\n\n  ;\n  SimpleLruFlush(&SubTransCtlData,((bool )1));\n  ;\n}\n\n\nvoid ExtendSUBTRANS(TransactionId newestXact)\n{\n  int pageno;\n\n  if (newestXact % ((TransactionId )(8192 / sizeof(TransactionId ))) != 0 && !(newestXact == ((TransactionId )3))) {\n    return ;\n  }\n  pageno = (newestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  LWLockAcquire(SubtransControlLock,LW_EXCLUSIVE);\n\n  ZeroSUBTRANSPage(pageno);\n  LWLockRelease(SubtransControlLock);\n}\n\n\nvoid TruncateSUBTRANS(TransactionId oldestXact)\n{\n  int cutoffPage;\n\n  cutoffPage = (oldestXact / ((TransactionId )(8192 / sizeof(TransactionId ))));\n  SimpleLruTruncate(&SubTransCtlData,cutoffPage);\n}\n\n\nstatic bool SubTransPagePrecedes(int page1,int page2)\n{\n  TransactionId xid1;\n  TransactionId xid2;\n  xid1 = (((TransactionId )page1) * (8192 / sizeof(TransactionId )));\n  xid1 += ((TransactionId )3);\n  xid2 = (((TransactionId )page2) * (8192 / sizeof(TransactionId )));\n  xid2 += ((TransactionId )3);\n  return TransactionIdPrecedes(xid1,xid2);\n}\n\nvoid handle_taint(char *stained_grouchily)\n{\n char * filename = 0;\n int filename_len = 0;\n unsigned int num_files;\n FILE **filearray;\n int i;\n  char *almeta_ellington = 0;\n  int stipels_hallow;\n  int fleuron_nonpreservative;\n  char **thieveries_editorializers = 0;\n  char **iconometry_antiphlogistic = 0;\n  ++global_variable;;\n  if (stained_grouchily != 0) {;\n    thieveries_editorializers = &stained_grouchily;\n    iconometry_antiphlogistic = thieveries_editorializers + 5;\n    fleuron_nonpreservative = 5;\n    while(1 == 1){\n      fleuron_nonpreservative = fleuron_nonpreservative * 2;\n      fleuron_nonpreservative = fleuron_nonpreservative + 2;\n      if (fleuron_nonpreservative > 1000) {\n        break; \n      }\n    }\n    stipels_hallow = fleuron_nonpreservative;\n    almeta_ellington = ((char *)( *(iconometry_antiphlogistic - 5)));\n    \n    if (strlen(almeta_ellington) > 0 &&\n            almeta_ellington[0] == '-') {\n        printf(\"Input value is negative\\n\");\n    } else {\n        printf(\"Getting input value\\n\");\n        num_files = strtoul(almeta_ellington,0,16);\n        if (num_files > 0xffff)\n            num_files = 0;\n        filearray = ((FILE **)(malloc(num_files * sizeof(FILE *))));\n        filename_len = strlen(\"/opt/cus/workspace/testData/temp\") + 10;\n        filename = (char*) malloc(filename_len * sizeof(char));\n        if (filearray != 0) {\n            for (i = 0; i < num_files; ++i)\n                filearray[i] = 0;\n            printf(\"Creating files\\n\");\n            for (i = 0; i < num_files; ++i) {\n                snprintf(filename,filename_len,\"%s_%08x\", \"/opt/cus/workspace/testData/temp\", i);\n                filearray[i] = open_file(filename);\n                if (filearray[i] == 0)\n                    break;\n            }\n            if (i < num_files)\n                printf(\"No Throttle File Descriptors: Did not create all files successfully.\\n\");\n            for (i = 0; i < num_files; ++i)\n                if (filearray[i] != 0)\n                    fclose(filearray[i]);\n            free(filearray);\n            free(filename);\n        }\n    }\n    \n;\n    if ( *(iconometry_antiphlogistic - 5) != 0) \n      free(((char *)( *(iconometry_antiphlogistic - 5))));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "774", "idx": "151930"}
{"code": "\n#include \"svn_private_config.h\"\n#include \"private/svn_mutex.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdarg.h> \n#include <setjmp.h> \n#include <cus/trace.h> \nint salientian_ramblingness = 0;\nint global_variable;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid shamble_vagile(int pregnability_remonetizing,... );\nint returnChunkSize(void *dest,void *src)\n{\n  \n  if (strlen(dest) < strlen(src)) {\n\n    return -1;\n  }\n  return strlen(dest);\n}\n\nsvn_error_t *svn_mutex__init(svn_mutex__t **mutex_p,svn_boolean_t mutex_required,apr_pool_t *result_pool)\n{\n\n   *mutex_p = ((void *)0);\n#if APR_HAS_THREADS\n  if (mutex_required) {\n    apr_thread_mutex_t *apr_mutex;\n    apr_status_t status = apr_thread_mutex_create(&apr_mutex,0,result_pool);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't create mutex\")));\n    }\n     *mutex_p = apr_mutex;\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__lock(svn_mutex__t *mutex)\n{\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_lock(mutex);\n    if (status) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't lock mutex\")));\n    }\n  }\n#endif\n  return 0;\n}\n\nsvn_error_t *svn_mutex__unlock(svn_mutex__t *mutex,svn_error_t *err)\n{\n  void *bottlebird_cynurus = 0;\n  int acceleration_moonway = 45;\n  char *somaplasm_mounds;;\n  if (__sync_bool_compare_and_swap(&salientian_ramblingness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&somaplasm_mounds,\"1386\",acceleration_moonway);\n      if (somaplasm_mounds != 0) {;\n        bottlebird_cynurus = ((void *)somaplasm_mounds);\n        shamble_vagile(1,bottlebird_cynurus);\n      }\n    }\n  }\n  ;\n#if APR_HAS_THREADS\n  if (mutex) {\n    apr_status_t status = apr_thread_mutex_unlock(mutex);\n    if (status && !err) {\n      return svn_error_wrap_apr(status,(dgettext(\"subversion\",\"Can't unlock mutex\")));\n    }\n  }\n#endif\n  return err;\n}\n\nvoid shamble_vagile(int pregnability_remonetizing,... )\n{\n    const int MAXLEN = 16;\n    char dest[MAXLEN];\n    size_t size_var = 0;\n  char *unspiritually_heracleum = 0;\n  jmp_buf stelliscript_tatta;\n  int cert_radiotelegraphy;\n  void *rocky_chiropter = 0;\n  va_list curney_eleventeenth;\n  ++global_variable;;\n  if (pregnability_remonetizing > 0) {\n    __builtin_va_start(curney_eleventeenth,pregnability_remonetizing);\n    rocky_chiropter = (va_arg(curney_eleventeenth,void *));\n    __builtin_va_end(curney_eleventeenth);\n  }\n  cert_radiotelegraphy = setjmp(stelliscript_tatta);\n  if (cert_radiotelegraphy == 0) {\n    longjmp(stelliscript_tatta,1);\n  }\n  unspiritually_heracleum = ((char *)((char *)rocky_chiropter));\n    \n    memset(dest,'x',MAXLEN);\n    dest[MAXLEN - 1] = '\\0';\n    \n    size_var = returnChunkSize(dest, unspiritually_heracleum);\n    \n    \n    \n\n    if (size_var > 0)\n        memcpy(dest, unspiritually_heracleum, size_var);\n    printf(\"%s\\n\",dest);\n    \n    \n;\n  if (((char *)rocky_chiropter) != 0) \n    free(((char *)((char *)rocky_chiropter)));\nclose_printf_context();\n}", "answer": "YES", "cwe": "195", "idx": "150833"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_environment_open_14\n{\n\n#ifndef OMITM\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            \n            if (environment != NULL)\n            {\n                \n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n#ifdef _WIN32\n        \n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        \n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_environment_open_14; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97375"}
{"code": "mwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_wep_key *wep_key;\n\tu16 cmd_size = *param_size;\n\tint i;\n\tu8 *tlv = *tlv_buf;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tif (bss_cfg->wep_cfg[i].length &&\n\t\t    (bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||\n\t\t     bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {\n\t\t\twep_key = (struct host_cmd_tlv_wep_key *)tlv;\n\t\t\twep_key->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WEP_KEY);\n\t\t\twep_key->header.len =\n\t\t\t\tcpu_to_le16(bss_cfg->wep_cfg[i].length + 2);\n\t\t\twep_key->key_index = bss_cfg->wep_cfg[i].key_index;\n\t\t\twep_key->is_default = bss_cfg->wep_cfg[i].is_default;\n\t\t\tmemcpy(wep_key->key, bss_cfg->wep_cfg[i].key,\n\t\t\t       bss_cfg->wep_cfg[i].length);\n\t\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t\ttlv += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t}\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}", "answer": "NO", "cwe": "120", "idx": "88622"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <mongoose.h> \n#include <mysql.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint placoderm_gynecomaniac = 0;\n\nunion subrogating_nonlevel \n{\n  char *lambitive_uredos;\n  double pending_paeonin;\n  char *adieu_cappadocian;\n  char obli_gammiest;\n  int unseductively_modigliani;\n}\n;\nint global_variable;\nvoid handle_taint(char *camises_subaxillar);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{;\n  if (__sync_bool_compare_and_swap(&placoderm_gynecomaniac,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid handle_taint(char *camises_subaxillar)\n{\n  MYSQL_ROW row;\n  unsigned int num_fields;\n  my_ulonglong num_rows;\n  MYSQL_RES *result;\n  int i;\n  int status;\n  char query_buffer[1000];\n  MYSQL *conn;\n  unsigned int dbport = 0;\n  char *dbpassword = 0;\n  char *dbuser = 0;\n  char *dbhost = 0;\n  char * dbdatabase = 0;\n  char use_str[150] = {0};\n  int random_int = 0;\n  char *crewet_dutchmen = 0;\n  union subrogating_nonlevel britannically_jesu;\n  ++global_variable;;\n  if (camises_subaxillar != 0) {;\n    britannically_jesu . lambitive_uredos = camises_subaxillar;\n    crewet_dutchmen = ((char *)britannically_jesu . lambitive_uredos);\n      \n      dbhost = getenv(\"DBMYSQLHOST\");\n      dbuser = getenv(\"DBMYSQLUSER\");\n      dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      \n      \n      \n      \n      \n      if (dbhost != 0 && dbport != 0 && (dbuser != 0 && dbpassword != 0)) {\n          conn = mysql_init(0);\n          if (conn != 0) {\n            if (mysql_real_connect(conn,dbhost,dbuser,dbpassword,0,dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(use_str,150,\"USE %s;\", dbdatabase);\n              if (mysql_query(conn, use_str) == 0) {\n                \n\n    srand(time(NULL));\n    random_int = (rand() % 1000) + 100;\n                snprintf(query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", random_int, crewet_dutchmen);\n    \n                \n                \n\n                if (mysql_query(conn,query_buffer)) {\n                  printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n    } else {\n      printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(conn));\n                }\n                \n              }\n              else {\n                \n                printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(conn),mysql_error(conn));\n              }\n              mysql_close(conn);\n            }\n            else {\n              \n              printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(conn),mysql_error(conn));\n            }\n          }\n          else {\n            \n            printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(conn),mysql_error(conn));\n          }\n      }\n      \n;\n    if (britannically_jesu . lambitive_uredos != 0) \n      free(((char *)britannically_jesu . lambitive_uredos));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "89", "idx": "152478"}
{"code": "\n#include \"postgres.h\"\n#include \"access/hash.h\"\n\n#include <mongoose.h> \n#include <cus/trace.h> \n#include <sys/stat.h> \nint isothermally_sourcefulness = 0;\nint global_variable;\nvoid handle_taint(char *laborite_inequally);\nvoid* printf_context;\nvoid setup_printf_context() {\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    \n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid close_printf_context() {\n}\nstatic int exit_flag = 0;\nstatic int ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            \n            data_size = mg_get_var(conn, \"data\", tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(tainted_buff);\n        }\n        printf_context = conn;\n        handle_taint(tainted_buff);\n        \n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid read_taint(void) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *server = mg_create_server(NULL, ev_handler);\n    mg_set_option(server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(server, 1000) == 0 && exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&server);\n  }\n}\nint 190_global_var = 0;\n\nuint32 string_hash(const void *key,Size keysize)\n{\n\n  Size s_len = strlen(((const char *)key));\n  s_len = (s_len < keysize - 1?s_len : keysize - 1);\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )s_len)))) & 0xffffffff);\n}\n\n\nuint32 tag_hash(const void *key,Size keysize)\n{\n  return (uint32 )(((Datum )(hash_any(((const unsigned char *)key),((int )keysize)))) & 0xffffffff);\n}\n\n\nuint32 oid_hash(const void *key,Size keysize)\n{;\n  if (__sync_bool_compare_and_swap(&isothermally_sourcefulness,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      read_taint();\n    }\n  }\n  ;\n  ;\n  return (uint32 )(((Datum )(hash_uint32(((uint32 )( *((const Oid *)key)))))) & 0xffffffff);\n}\n\n\nuint32 bitmap_hash(const void *key,Size keysize)\n{\n  ;\n  return bms_hash_value( *((const Bitmapset *const *)key));\n}\n\n\nint bitmap_match(const void *key1,const void *key2,Size keysize)\n{\n  ;\n  return !bms_equal( *((const Bitmapset *const *)key1), *((const Bitmapset *const *)key2));\n}\n\nvoid handle_taint(char *laborite_inequally)\n{\n    int tainted_int = 0;\n    int output_counter = 0;\n  char *xenicus_lawsuiting = 0;\n  jmp_buf overdeferential_vert;\n  int lackeyed_dipyramid;\n  int rattinet_prosphoron;\n  char **almury_undisobedient = 0;\n  char **excursionists_vagotonia = 0;\n  ++global_variable;;\n  if (laborite_inequally != 0) {;\n    rattinet_prosphoron = 1;\n    almury_undisobedient = &laborite_inequally;\n    excursionists_vagotonia = ((char **)(((unsigned long )almury_undisobedient) * rattinet_prosphoron * rattinet_prosphoron)) + 5;\n    lackeyed_dipyramid = setjmp(overdeferential_vert);\n    if (lackeyed_dipyramid == 0) {\n      longjmp(overdeferential_vert,1);\n    }\n    xenicus_lawsuiting = ((char *)( *(excursionists_vagotonia - 5)));\n    \n    tainted_int = atoi(xenicus_lawsuiting);\n    if (tainted_int > 0) {\n        \n\n        tainted_int = tainted_int * tainted_int;\n        \n        \n        \n        while (tainted_int != 0) {\n\n            if (tainted_int != INT_MIN) {\n                tainted_int--;\n            }\n            \n            if (output_counter == 0) {\n                printf(\"evaluating input\\n\");\n            }\n            output_counter++;\n            if (output_counter == 1000000) {\n                output_counter = 0;\n            }\n            ++190_global_var;\n            if (190_global_var >= INT_MAX) {\n                190_global_var = 0;\n            }\n        }\n        \n    }\n    printf(\"finished evaluating\\n\");\n    \n;\n    if ( *(excursionists_vagotonia - 5) != 0) \n      free(((char *)( *(excursionists_vagotonia - 5))));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "190", "idx": "150749"}
{"code": "int session_activate(Session *s) {\n        int r;\n\n        assert(s);\n\n        if (s->vtnr < 0)\n                return -ENOTSUP;\n\n        if (!s->seat)\n                return -ENOTSUP;\n\n        if (s->seat->active == s)\n                return 0;\n\n        assert(seat_is_vtconsole(s->seat));\n\n        r = chvt(s->vtnr);\n        if (r < 0)\n                return r;\n\n        return seat_set_active(s->seat, s);\n}", "answer": "NO", "cwe": "59", "idx": "16100"}
{"code": "void WebGLRenderingContextBase::SetVertexAttribType(\n    GLuint index,\n    VertexAttribValueType type) {\n  if (index < max_vertex_attribs_)\n    vertex_attrib_type_[index] = type;\n}", "answer": "NO", "cwe": "119", "idx": "146375"}
{"code": "static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}", "answer": "NO", "cwe": "0", "idx": "8607f5c3072caeebbe0217df28651fffd3a79fd9"}
{"code": "\n#include \"libavutil/avstring.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <cus/trace.h> \ntypedef struct {\nenum AVCodecID id;\nconst char *str;}IdStrMap;\nstatic const IdStrMap img_tags[] = {{(AV_CODEC_ID_MJPEG), (\"jpeg\")}, {(AV_CODEC_ID_MJPEG), (\"jpg\")}, {(AV_CODEC_ID_MJPEG), (\"jps\")}, {(AV_CODEC_ID_LJPEG), (\"ljpg\")}, {(AV_CODEC_ID_JPEGLS), (\"jls\")}, {(AV_CODEC_ID_PNG), (\"png\")}, {(AV_CODEC_ID_PNG), (\"pns\")}, {(AV_CODEC_ID_PNG), (\"mng\")}, {(AV_CODEC_ID_PPM), (\"ppm\")}, {(AV_CODEC_ID_PPM), (\"pnm\")}, {(AV_CODEC_ID_PGM), (\"pgm\")}, {(AV_CODEC_ID_PGMYUV), (\"pgmyuv\")}, {(AV_CODEC_ID_PBM), (\"pbm\")}, {(AV_CODEC_ID_PAM), (\"pam\")}, {(AV_CODEC_ID_MPEG1VIDEO), (\"mpg1-img\")}, {(AV_CODEC_ID_MPEG2VIDEO), (\"mpg2-img\")}, {(AV_CODEC_ID_MPEG4), (\"mpg4-img\")}, {(AV_CODEC_ID_FFV1), (\"ffv1-img\")}, {(AV_CODEC_ID_RAWVIDEO), (\"y\")}, {(AV_CODEC_ID_RAWVIDEO), (\"raw\")}, {(AV_CODEC_ID_BMP), (\"bmp\")}, {(AV_CODEC_ID_GIF), (\"gif\")}, {(AV_CODEC_ID_TARGA), (\"tga\")}, {(AV_CODEC_ID_TIFF), (\"tiff\")}, {(AV_CODEC_ID_TIFF), (\"tif\")}, {(AV_CODEC_ID_SGI), (\"sgi\")}, {(AV_CODEC_ID_PTX), (\"ptx\")}, {(AV_CODEC_ID_PCX), (\"pcx\")}, {(AV_CODEC_ID_BRENDER_PIX), (\"pix\")}, {(AV_CODEC_ID_SUNRAST), (\"sun\")}, {(AV_CODEC_ID_SUNRAST), (\"ras\")}, {(AV_CODEC_ID_SUNRAST), (\"rs\")}, {(AV_CODEC_ID_SUNRAST), (\"im1\")}, {(AV_CODEC_ID_SUNRAST), (\"im8\")}, {(AV_CODEC_ID_SUNRAST), (\"im24\")}, {(AV_CODEC_ID_SUNRAST), (\"im32\")}, {(AV_CODEC_ID_SUNRAST), (\"sunras\")}, {(AV_CODEC_ID_JPEG2000), (\"j2c\")}, {(AV_CODEC_ID_JPEG2000), (\"j2k\")}, {(AV_CODEC_ID_JPEG2000), (\"jp2\")}, {(AV_CODEC_ID_JPEG2000), (\"jpc\")}, {(AV_CODEC_ID_DPX), (\"dpx\")}, {(AV_CODEC_ID_EXR), (\"exr\")}, {(AV_CODEC_ID_PICTOR), (\"pic\")}, {(AV_CODEC_ID_V210X), (\"yuv10\")}, {(AV_CODEC_ID_XBM), (\"xbm\")}, {(AV_CODEC_ID_XFACE), (\"xface\")}, {(AV_CODEC_ID_XWD), (\"xwd\")}, {(AV_CODEC_ID_NONE), (((void *)0))}};\nint featherwood_cornuting = 0;\nint global_variable;\n\nstruct rompish_siddons \n{\n  char *crackbrained_mia;\n  double subtrapezoidal_excellency;\n  char *punkeys_bioclimatician;\n  char foliiform_homomorphism;\n  int openly_lallans;\n}\n;\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* envKey, int shmsz) {\n    int shmid;\n key_t key;\n char *shm, *s;\n char* envSize = NULL;\n *tainted_buff = NULL;\n    if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(envKey != NULL) {\n            if(sscanf(envKey, \"%d\", &key) > 0) {\n                if ((shmid = shmget(key, shmsz, 0666)) >= 0) {\n                    if ((shm = shmat(shmid, NULL, 0)) != (char *) -1) {\n                        *tainted_buff = (char*)calloc(shmsz, sizeof(char));\n                        \n                        for (s = shm; *s != (char)0; s++) {\n                            (*tainted_buff)[s - shm] = *s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid prepurchases_szeged(struct rompish_siddons *unelbowed_bassia);\n\nstatic enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)\n{\n  void (*branchiopoda_mismeets)(struct rompish_siddons *) = prepurchases_szeged;\n  struct rompish_siddons *predivide_scrappler = {0};\n  struct rompish_siddons sigillation_phalaenae;\n  int hypercalcaemia_semijuridical = 125;\n  char *alkoran_slipcases;;\n  if (__sync_bool_compare_and_swap(&featherwood_cornuting,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      setup_printf_context();\n      read_taint(&alkoran_slipcases,\"8625\",hypercalcaemia_semijuridical);\n      if (alkoran_slipcases != 0) {;\n        sigillation_phalaenae . crackbrained_mia = ((char *)alkoran_slipcases);\n        predivide_scrappler = &sigillation_phalaenae;\n        branchiopoda_mismeets(predivide_scrappler);\n      }\n    }\n  }\n  ;\n  str = (strrchr(str,'.'));\n  if (!str) {\n    return AV_CODEC_ID_NONE;\n  }\n  str++;\n  while(tags -> id){\n    if (!av_strcasecmp(str,tags -> str)) {\n      return tags -> id;\n    }\n    tags++;\n  }\n  return AV_CODEC_ID_NONE;\n}\n\nenum AVCodecID ff_guess_image2_codec(const char *filename)\n{\n  return av_str2id(img_tags,filename);\n}\n\nvoid prepurchases_szeged(struct rompish_siddons *unelbowed_bassia)\n{\n  char *skip_malloc_buffer = 0;\n  char *paralgesia_phren = 0;\n  ++global_variable;;\n  paralgesia_phren = ((char *)( *unelbowed_bassia) . crackbrained_mia);\n      \n      \n\n      if (strlen(paralgesia_phren) < 63) {\n        skip_malloc_buffer = malloc(strlen(paralgesia_phren + 1));\n      }\n      \n      \n      \n\n      strcpy(skip_malloc_buffer,paralgesia_phren);\n      printf(\"Buffer is %s\\n\",skip_malloc_buffer);\n      \n      if (skip_malloc_buffer != 0) {\n        free(skip_malloc_buffer);\n      }\n      \n;\n  if (( *unelbowed_bassia) . crackbrained_mia != 0) \n    free(((char *)( *unelbowed_bassia) . crackbrained_mia));\nclose_printf_context();\n}", "answer": "YES", "cwe": "476", "idx": "149311"}
{"code": "static int list_readers(void)\n{\n\tunsigned int i, rcount = sc_ctx_get_reader_count(ctx);\n\n\tif (rcount == 0) {\n\t\tprintf(\"No smart card readers found.\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"# Detected readers (%s)\\n\", ctx->reader_driver->short_name);\n\tprintf(\"Nr.  Card  Features  Name\\n\");\n\tfor (i = 0; i < rcount; i++) {\n\t\tsc_reader_t *reader = sc_ctx_get_reader(ctx, i);\n\t\tint state = sc_detect_card_presence(reader);\n\t\tprintf(\"%-5d%-6s%-10s%s\\n\", i, state & SC_READER_CARD_PRESENT ? \"Yes\":\"No\",\n\t\t      reader->capabilities & SC_READER_CAP_PIN_PAD ? \"PIN pad\":\"\",\n\t\t      reader->name);\n\t\tif (state & SC_READER_CARD_PRESENT && verbose) {\n\t\t\tstruct sc_card *card;\n\t\t\tint r;\n\t\t\tchar tmp[SC_MAX_ATR_SIZE*3];\n\t\t\tsc_bin_to_hex(reader->atr.value, reader->atr.len, tmp, sizeof(tmp) - 1, ':');\n\n\t\t\tif (state & SC_READER_CARD_EXCLUSIVE)\n\t\t\t\tprintf(\"     %s [EXCLUSIVE]\\n\", tmp);\n\t\t\telse {\n\t\t\t\tif ((r = sc_connect_card(reader, &card)) != SC_SUCCESS) {\n\t\t\t\t\tfprintf(stderr, \"     failed: %s\\n\", sc_strerror(r));\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"     %s %s %s\\n\", tmp, card->name ? card->name : \"\", state & SC_READER_CARD_INUSE ? \"[IN USE]\" : \"\");\n\t\t\t\t\tsc_disconnect_card(card);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "answer": "NO", "cwe": "125", "idx": "78733"}
{"code": "void sd_write_data(SDState *sd, uint8_t value)\n\n{\n\n    int i;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return;\n\n\n\n    if (sd->state != sd_receivingdata_state) {\n\n        fprintf(stderr, \"sd_write_data: not in Receiving-Data state\\n\");\n\n        return;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 24:\t\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            \n\n            sd->state = sd_programming_state;\n\n            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);\n\n            sd->blk_written ++;\n\n            sd->csd[14] |= 0x40;\n\n            \n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 25:\t\n\n        if (sd->data_offset == 0) {\n\n            \n\n            if (sd->data_start + sd->blk_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n            if (sd_wp_addr(sd, sd->data_start)) {\n\n                sd->card_status |= WP_VIOLATION;\n\n                break;\n\n            }\n\n        }\n\n        sd->data[sd->data_offset++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            \n\n            sd->state = sd_programming_state;\n\n            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);\n\n            sd->blk_written++;\n\n            sd->data_start += sd->blk_len;\n\n            sd->data_offset = 0;\n\n            sd->csd[14] |= 0x40;\n\n\n\n            \n\n            sd->state = sd_receivingdata_state;\n\n        }\n\n        break;\n\n\n\n    case 26:\t\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sizeof(sd->cid)) {\n\n            \n\n            sd->state = sd_programming_state;\n\n            for (i = 0; i < sizeof(sd->cid); i ++)\n\n                if ((sd->cid[i] | 0x00) != sd->data[i])\n\n                    sd->card_status |= CID_CSD_OVERWRITE;\n\n\n\n            if (!(sd->card_status & CID_CSD_OVERWRITE))\n\n                for (i = 0; i < sizeof(sd->cid); i ++) {\n\n                    sd->cid[i] |= 0x00;\n\n                    sd->cid[i] &= sd->data[i];\n\n                }\n\n            \n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 27:\t\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sizeof(sd->csd)) {\n\n            \n\n            sd->state = sd_programming_state;\n\n            for (i = 0; i < sizeof(sd->csd); i ++)\n\n                if ((sd->csd[i] | sd_csd_rw_mask[i]) !=\n\n                    (sd->data[i] | sd_csd_rw_mask[i]))\n\n                    sd->card_status |= CID_CSD_OVERWRITE;\n\n\n\n            \n\n            if (sd->csd[14] & ~sd->data[14] & 0x60)\n\n                sd->card_status |= CID_CSD_OVERWRITE;\n\n\n\n            if (!(sd->card_status & CID_CSD_OVERWRITE))\n\n                for (i = 0; i < sizeof(sd->csd); i ++) {\n\n                    sd->csd[i] |= sd_csd_rw_mask[i];\n\n                    sd->csd[i] &= sd->data[i];\n\n                }\n\n            \n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 42:\t\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            \n\n            sd->state = sd_programming_state;\n\n            sd_lock_command(sd);\n\n            \n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    case 56:\t\n\n        sd->data[sd->data_offset ++] = value;\n\n        if (sd->data_offset >= sd->blk_len) {\n\n            APP_WRITE_BLOCK(sd->data_start, sd->data_offset);\n\n            sd->state = sd_transfer_state;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_write_data: unknown command\\n\");\n\n        break;\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "static void json_emit_element(QJSON *json, const char *name)\n\n{\n\n    \n\n    if (json->omit_comma) {\n\n        json->omit_comma = false;\n\n    } else {\n\n        qstring_append(json->str, \", \");\n\n    }\n\n\n\n    if (name) {\n\n        qstring_append(json->str, \"\\\"\");\n\n        qstring_append(json->str, name);\n\n        qstring_append(json->str, \"\\\" : \");\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "17b74b98676aee5bc470b173b1e528d2fce2cf18"}
{"code": "void WebGLRenderingContextBase::linkProgram(WebGLProgram* program) {\n  if (isContextLost() || !ValidateWebGLObject(\"linkProgram\", program))\n    return;\n\n  if (program->ActiveTransformFeedbackCount() > 0) {\n    SynthesizeGLError(\n        GL_INVALID_OPERATION, \"linkProgram\",\n        \"program being used by one or more active transform feedback objects\");\n    return;\n  }\n\n  ContextGL()->LinkProgram(ObjectOrZero(program));\n  program->IncreaseLinkCount();\n}", "answer": "NO", "cwe": "119", "idx": "146529"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic char * mSource(char * data)\n{\n    if(mStatic)\n    {\n        {\n            \n            size_t dataLen = strlen(data);\n            \n            if (100-dataLen > 1)\n            {\n                \n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    \n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    \n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    return data;\n}\n\nvoid _OS_Command_Injection__char_console_w32spawnl_21()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic char * nG2B1Source(char * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n\nstatic char * nG2B2Source(char * data)\n{\n    if(nG2B2Static)\n    {\n        \n        strcat(data, \"*.*\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    \n    \n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__char_console_w32spawnl_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32spawnl_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32spawnl_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244917"}
{"code": " LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)\n{\n\tint c;\n\tint r;\n\tint numr;\n\tint numc;\n\tModPlugNote note;\n\tif(!file) return NULL;\n\tif(numrows){\n\t\t*numrows = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\t}\n\tif(pattern<0||pattern>=openmpt_module_get_num_patterns(file->mod)){\n\t\treturn NULL;\n\t}\n\tif(!file->patterns){\n\t\tfile->patterns = malloc(sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t\tif(!file->patterns) return NULL;\n\t\tmemset(file->patterns,0,sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t}\n\tif(!file->patterns[pattern]){\n\t\tfile->patterns[pattern] = malloc(sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t\tif(!file->patterns[pattern]) return NULL;\n\t\tmemset(file->patterns[pattern],0,sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t}\n\tnumr = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\tnumc = openmpt_module_get_num_channels(file->mod);\n\tfor(r=0;r<numr;r++){\n\t\tfor(c=0;c<numc;c++){\n\t\t\tmemset(&note,0,sizeof(ModPlugNote));\n\t\t\tnote.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);\n\t\t\tnote.Instrument = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_INSTRUMENT);\n\t\t\tnote.VolumeEffect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUMEEFFECT);\n\t\t\tnote.Effect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_EFFECT);\n\t\t\tnote.Volume = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUME);\n\t\t\tnote.Parameter = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_PARAMETER);\n\t\t\tmemcpy(&file->patterns[pattern][r*numc+c],&note,sizeof(ModPlugNote));\n\t\t}\n\t}\n\treturn file->patterns[pattern];\n}", "answer": "NO", "cwe": "120", "idx": "87637"}
{"code": "int pcm_read_seek(AVFormatContext *s,\n\n                  int stream_index, int64_t timestamp, int flags)\n\n{\n\n    AVStream *st;\n\n    int block_align, byte_rate;\n\n    int64_t pos;\n\n\n\n    st = s->streams[0];\n\n\n\n    block_align = st->codec->block_align ? st->codec->block_align :\n\n        (av_get_bits_per_sample(st->codec->codec_id) * st->codec->channels) >> 3;\n\n    byte_rate = st->codec->bit_rate ? st->codec->bit_rate >> 3 :\n\n        block_align * st->codec->sample_rate;\n\n\n\n    if (block_align <= 0 || byte_rate <= 0)\n\n        return -1;\n\n\n\n    \n\n    pos = av_rescale_rnd(timestamp * byte_rate,\n\n                         st->time_base.num,\n\n                         st->time_base.den * (int64_t)block_align,\n\n                         (flags & AVSEEK_FLAG_BACKWARD) ? AV_ROUND_DOWN : AV_ROUND_UP);\n\n    pos *= block_align;\n\n\n\n    \n\n    st->cur_dts = av_rescale(pos, st->time_base.den, byte_rate * (int64_t)st->time_base.num);\n\n    url_fseek(s->pb, pos + s->data_offset, SEEK_SET);\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "d701934bef6ff6868c0a2179b7b9105c7a49b41f"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_open_62\n{\n\n#ifndef OMITM\n\n\nvoid mSource(wchar_t * &data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    mSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid nG2BSource(wchar_t * &data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    nG2BSource(data);\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_open_62; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91198"}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_channels(file->mod);\n}", "answer": "NO", "cwe": "120", "idx": "87642"}
{"code": "\n#include \"postgres.h\"\n#include <signal.h>\n#include <unistd.h>\n#include \"miscadmin.h\"\n#include \"postmaster/postmaster.h\"\n#include \"replication/walsender.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/shmem.h\"\n\n#define PM_CHILD_UNUSED\t\t0\t\n#define PM_CHILD_ASSIGNED\t1\n#define PM_CHILD_ACTIVE\t\t2\n#define PM_CHILD_WALSENDER\t3\n\n#include <sys/stat.h> \n#include <cus/trace.h> \n\nstruct PMSignalData \n{\n\n  sig_atomic_t PMSignalFlags[NUM_PMSIGNALS];\n\n\n  int num_child_flags;\n\n  int next_child_flag;\n\n  sig_atomic_t PMChildFlags[1];\n}\n;\nstatic volatile PMSignalData *PMSignalState = ((void *)0);\n\nint closet_padegs = 0;\nint global_variable;\nvoid frontenac_spurs(char **oki_akmudar);\nvoid* printf_context = NULL;\nvoid setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (printf_context == NULL) {\n        printf_context = stderr;\n    }\n}\nvoid printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(printf_context, format, argptr);\n    va_end(argptr);\n    fflush(printf_context);\n}\nvoid close_printf_context() {\n    if (printf_context != NULL &&\n        printf_context != stderr) {\n        fclose(printf_context);\n    }\n}\nvoid read_taint(char** tainted_buff, char* env_var_name) {\n  if (getenv(\"DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* tainted_file_name = 0;\n        FILE * tainted_file = 0;\n        size_t result = 0;\n        long lsize = 0;\n        tainted_file_name = getenv(env_var_name);\n        tainted_file = fopen(tainted_file_name,\"rb\");\n        if (tainted_file != 0) {\n            fseek(tainted_file,0L,2);\n            lsize = ftell(tainted_file);\n            rewind(tainted_file);\n            *tainted_buff = ((char *)(malloc(sizeof(char ) * (lsize + 1))));\n            if (*tainted_buff != 0) {\n                \n                result = fread(*tainted_buff,1,lsize,tainted_file);\n                (*tainted_buff)[lsize] = '\\0';\n            }\n        }\n        if (tainted_file != 0) {\n            fclose(tainted_file);\n        }\n    } else {\n        *tainted_buff = NULL;\n    }\n}\nvoid inclinatory_antikenotoxin(void (*acondylous_meconophagist)(char **));\nstruct struct {\n    char base_path[20];\n    char * buff_pointer;\n};\nint toupper(int c)\n{\n  if (c >= 97 && c <= 122) {\n    return c - 32;\n  }\n  return c;\n}\n\nSize PMSignalShmemSize()\n{\n  Size size;\n  if (__sync_bool_compare_and_swap(&closet_padegs,0,1)) {;\n    if (mkdir(\"/opt/cus/workspace/lockDir\",509U) == 0) {;\n      \n      inclinatory_antikenotoxin(frontenac_spurs);\n    }\n  }\n  size = ((size_t )(&((PMSignalData *)0) -> PMChildFlags));\n  size = add_size(size,mul_size((MaxLivePostmasterChildren()),sizeof(sig_atomic_t )));\n  return size;\n}\n\n\nvoid PMSignalShmemInit()\n{\n  bool found;\n  PMSignalState = ((PMSignalData *)(ShmemInitStruct(\"PMSignalState\",PMSignalShmemSize(),&found)));\n  if (!found) {\n    do {\n      void *_vstart = (void *)PMSignalState;\n      int _val = 0;\n      Size _len = PMSignalShmemSize();\n      if ((((intptr_t )_vstart) & sizeof(long ) - 1) == 0 && (_len & sizeof(long ) - 1) == 0 && _val == 0 && _len <= 1024 && 1024 != 0) {\n        long *_start = (long *)_vstart;\n        long *_stop = (long *)(((char *)_start) + _len);\n        while(_start < _stop)\n           *(_start++) = 0;\n      }\n      else {\n        memset(_vstart,_val,_len);\n      }\n    }while (0);\n    PMSignalState -> num_child_flags = MaxLivePostmasterChildren();\n  }\n}\n\n\nvoid SendPostmasterSignal(PMSignalReason reason)\n{\n\n  if (!IsUnderPostmaster) {\n    return ;\n  }\n\n  PMSignalState -> PMSignalFlags[reason] = ((bool )1);\n\n  kill(PostmasterPid,10);\n}\n\n\nbool CheckPostmasterSignal(PMSignalReason reason)\n{\n\n  if (PMSignalState -> PMSignalFlags[reason]) {\n    PMSignalState -> PMSignalFlags[reason] = ((bool )0);\n    return (bool )1;\n  }\n  return (bool )0;\n}\n\n\nint AssignPostmasterChildSlot()\n{\n  int slot = PMSignalState -> next_child_flag;\n  int n;\n\n  for (n = PMSignalState -> num_child_flags; n > 0; n--) {\n    if (--slot < 0) {\n      slot = PMSignalState -> num_child_flags - 1;\n    }\n    if (PMSignalState -> PMChildFlags[slot] == 0) {\n      PMSignalState -> PMChildFlags[slot] = 1;\n      PMSignalState -> next_child_flag = slot;\n      return slot + 1;\n    }\n  }\n\n  (elog_start(\"pmsignal.c\",173,__func__) , elog_finish(21,\"no free slots in PMChildFlags array\"));\n\n  return 0;\n}\n\n\nbool ReleasePostmasterChildSlot(int slot)\n{\n  bool result;\n  ;\n  slot--;\n\n  result = (PMSignalState -> PMChildFlags[slot] == 1);\n  PMSignalState -> PMChildFlags[slot] = 0;\n  return result;\n}\n\n\nbool IsPostmasterChildWalSender(int slot)\n{\n  ;\n  slot--;\n  if (PMSignalState -> PMChildFlags[slot] == 3) {\n    return (bool )1;\n  }\n  else {\n    return (bool )0;\n  }\n}\n\n\nvoid MarkPostmasterChildActive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 2;\n}\n\n\nvoid MarkPostmasterChildWalSender()\n{\n  int slot = MyPMChildSlot;\n  ;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 3;\n}\n\n\nvoid MarkPostmasterChildInactive()\n{\n  int slot = MyPMChildSlot;\n  ;\n  slot--;\n  ;\n  PMSignalState -> PMChildFlags[slot] = 1;\n}\n\n\nbool PostmasterIsAlive()\n{\n#ifndef WIN32\n  char c;\n  ssize_t rc;\n  rc = read(postmaster_alive_fds[0],(&c),1);\n  if (rc < 0) {\n    if ( *__errno_location() == 11 ||  *__errno_location() == 11) {\n      return (bool )1;\n    }\n    else {\n      (elog_start(\"pmsignal.c\",284,__func__) , elog_finish(21,\"read on postmaster death monitoring pipe failed: %m\"));\n    }\n  }\n  else {\n    if (rc > 0) {\n      (elog_start(\"pmsignal.c\",287,__func__) , elog_finish(21,\"unexpected data in postmaster death monitoring pipe\"));\n    }\n  }\n  return (bool )0;\n#else\t\t\t\t\t\t\t\n#endif   \n}\n\nvoid frontenac_spurs(char **oki_akmudar)\n{\n  char *sowing_lurched;\n  ++global_variable;;\n  setup_printf_context();\n  read_taint(&sowing_lurched,\"IMPRESSIBLE_ALMAGRA\");\n  if (sowing_lurched != 0) {;\n     *oki_akmudar = sowing_lurched;\n  }\n}\n\nvoid inclinatory_antikenotoxin(void (*acondylous_meconophagist)(char **))\n{\n    int oc_i = 0;\n    int opt_var = 0;\n    struct struct* data = 0;\n  char *drexel_boanthropy = 0;\n  ++global_variable;\n  char *interplait_transformance = 0;\n  acondylous_meconophagist(&interplait_transformance);\n  if (interplait_transformance != 0) {;\n    drexel_boanthropy = ((char *)interplait_transformance);\n    \n    if (strlen(drexel_boanthropy) < 20) {;\n        data = (struct struct*) malloc (sizeof(struct struct));\n        if (data != NULL) {\n            memset(data->base_path, 0, 20);\n            data->buff_pointer = data->base_path;\n            \n            \n\n\n            realpath(drexel_boanthropy, data->base_path);\n            opt_var = strlen( data->buff_pointer);\n            \n            for (; oc_i < opt_var; ++oc_i) {\n                data->base_path[oc_i] =\n                    toupper(data->base_path[oc_i]);\n            }\n            printf(\"%s\\n\", data->base_path);\n            printf(\"%s\\n\", data->buff_pointer);\n            \n            \n            free (data);\n        }\n    }\n    \n;\n    if (interplait_transformance != 0) \n      free(((char *)interplait_transformance));\nclose_printf_context();\n  }\n}", "answer": "YES", "cwe": "785", "idx": "153649"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#include <windows.h>\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_wchar_t_file_05()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            \n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            \n            if (256-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    \n                    if (fgetws(data+dataLen, (int)(256-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        \n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        \n        wcscat(data, L\"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        \n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_wchar_t_file_05()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_wchar_t_file_05();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_wchar_t_file_05();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123235"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#define FILENAME \"C:\\\\temp\\\\file.txt\"\n#else\n#define FILENAME \"/tmp/file.txt\"\n#endif\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_execl_44()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        \n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                \n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    \n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    \n    \n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    funcPtr(data);\n}\n\nvoid _OS_Command_Injection__wchar_t_file_execl_44()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_file_execl_44();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_file_execl_44();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "247806"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Absolute_Path_Traversal__wchar_t_listen_socket_open_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    \n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    \n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Absolute_Path_Traversal__wchar_t_listen_socket_open_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "36", "idx": "97869"}
{"code": "pgp_put_data(sc_card_t *card, unsigned int tag, const u8 *buf, size_t buf_len)\n{\n\tstruct pgp_priv_data *priv = DRVDATA(card);\n\tpgp_blob_t *affected_blob = NULL;\n\tstruct do_info *dinfo = NULL;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t\n\tif (priv->current->id != tag)\n\t\taffected_blob = pgp_find_blob(card, tag);\n\n\t\n\tif (affected_blob == NULL)\n\t\tdinfo = pgp_get_info_by_tag(card, tag);\n\telse\n\t\tdinfo = affected_blob->info;\n\n\tif (dinfo == NULL) {\n\t\tsc_log(card->ctx, \"The DO %04X does not exist.\", tag);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\telse if ((dinfo->access & WRITE_MASK) == WRITE_NEVER) {\n\t\tsc_log(card->ctx, \"DO %04X is not writable.\", tag);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_ALLOWED);\n\t}\n\n\t\n\tif (tag == DO_CERT && buf_len > priv->max_cert_size) {\n\t\tsc_log(card->ctx,\n\t\t       \"Data size %\"SC_FORMAT_LEN_SIZE_T\"u exceeds DO size limit %\"SC_FORMAT_LEN_SIZE_T\"u.\",\n\t\t       buf_len, priv->max_cert_size);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_WRONG_LENGTH);\n\t}\n\n\tif (tag == DO_CERT && card->type == SC_CARD_TYPE_OPENPGP_GNUK) {\n\t\t\n\t\tr = gnuk_write_certificate(card, buf, buf_len);\n\t}\n\telse {\n\t\tr = pgp_put_data_plain(card, tag, buf, buf_len);\n\t}\n\n\t\n\tif (r == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Please verify PIN first.\");\n\t}\n\tLOG_TEST_RET(card->ctx, r, \"PUT DATA returned error\");\n\n\tif (affected_blob) {\n\t\t\n\t\tsc_log(card->ctx, \"Updating the corresponding blob data\");\n\t\tr = pgp_set_blob(affected_blob, buf, buf_len);\n\t\tif (r < 0)\n\t\t\tsc_log(card->ctx, \"Failed to update blob %04X. Error %d.\", affected_blob->id, r);\n\t\t\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, (int)buf_len);\n}", "answer": "NO", "cwe": "125", "idx": "78603"}
{"code": "static void f2fs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(f2fs_inode_cachep, F2FS_I(inode));\n}", "answer": "NO", "cwe": "129", "idx": "63867"}
{"code": "static void DispatchEditableContentChangedEvents(Element* start_root,\n                                                 Element* end_root) {\n  if (start_root)\n    start_root->DispatchEvent(\n        Event::Create(EventTypeNames::webkitEditableContentChanged));\n  if (end_root && end_root != start_root)\n    end_root->DispatchEvent(\n        Event::Create(EventTypeNames::webkitEditableContentChanged));\n}", "answer": "NO", "cwe": "119", "idx": "135547"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\nnamespace _External_Control_of_System_or_Configuration_Setting__w32_81\n{\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_81_base\n{\npublic:\n    \n    virtual void action(char * data) const = 0;\n};\n\n#ifndef OMITM\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_81 : public _External_Control_of_System_or_Configuration_Setting__w32_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n#ifndef OMITN\n\nclass _External_Control_of_System_or_Configuration_Setting__w32_81G2B : public _External_Control_of_System_or_Configuration_Setting__w32_81_base\n{\npublic:\n    void action(char * data) const;\n};\n\n#endif \n\n}", "answer": "YES", "cwe": "15", "idx": "82022"}
{"code": "static int rtmp_server_handshake(URLContext *s, RTMPContext *rt)\n\n{\n\n    uint8_t buffer[RTMP_HANDSHAKE_PACKET_SIZE];\n\n    uint32_t hs_epoch;\n\n    uint32_t hs_my_epoch;\n\n    uint8_t hs_c1[RTMP_HANDSHAKE_PACKET_SIZE];\n\n    uint8_t hs_s1[RTMP_HANDSHAKE_PACKET_SIZE];\n\n    uint32_t zeroes;\n\n    uint32_t temp       = 0;\n\n    int randomidx       = 0;\n\n    int inoutsize       = 0;\n\n    int ret;\n\n\n\n    inoutsize = ffurl_read_complete(rt->stream, buffer, 1);       \n\n    if (inoutsize <= 0) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to read handshake\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    \n\n    if (buffer[0] != 3) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP protocol version mismatch\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (ffurl_write(rt->stream, buffer, 1) <= 0) {                 \n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Unable to write answer - RTMP S0\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    \n\n    ret = rtmp_receive_hs_packet(rt, &hs_epoch, &zeroes, hs_c1,\n\n                                 RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake C1 Error\\n\");\n\n        return ret;\n\n    }\n\n    if (zeroes)\n\n        av_log(s, AV_LOG_WARNING, \"Erroneous C1 Message zero != 0\\n\");\n\n    \n\n    \n\n    hs_my_epoch = hs_epoch;\n\n    \n\n    for (randomidx = 0; randomidx < (RTMP_HANDSHAKE_PACKET_SIZE);\n\n         randomidx += 4)\n\n        AV_WB32(hs_s1 + 8 + randomidx, av_get_random_seed());\n\n\n\n    ret = rtmp_send_hs_packet(rt, hs_my_epoch, 0, hs_s1,\n\n                              RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake S1 Error\\n\");\n\n        return ret;\n\n    }\n\n    \n\n    ret = rtmp_send_hs_packet(rt, hs_epoch, 0, hs_c1,\n\n                              RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake S2 Error\\n\");\n\n        return ret;\n\n    }\n\n    \n\n    ret = rtmp_receive_hs_packet(rt, &temp, &zeroes, buffer,\n\n                                 RTMP_HANDSHAKE_PACKET_SIZE);\n\n    if (ret) {\n\n        av_log(s, AV_LOG_ERROR, \"RTMP Handshake C2 Error\\n\");\n\n        return ret;\n\n    }\n\n    if (temp != hs_my_epoch)\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"Erroneous C2 Message epoch does not match up with C1 epoch\\n\");\n\n    if (memcmp(buffer + 8, hs_s1 + 8,\n\n               RTMP_HANDSHAKE_PACKET_SIZE - 8))\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"Erroneous C2 Message random does not match up\\n\");\n\n\n\n    return 0;\n\n}", "answer": "NO", "cwe": "0", "idx": "5a75924dfd432c0ada79a9f489889dc92d53b481"}
{"code": "static int save_crashing_binary(pid_t pid, struct dump_dir *dd)\n{\n    char buf[sizeof(\"/proc/%lu/exe\") + sizeof(long)*3];\n\n    sprintf(buf, \"/proc/%lu/exe\", (long)pid);\n    int src_fd_binary = open(buf, O_RDONLY); \n    if (src_fd_binary < 0)\n    {\n        log_notice(\"Failed to open an image of crashing binary\");\n        return 0;\n    }\n\n    int dst_fd = openat(dd->dd_fd, FILENAME_BINARY, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC, DEFAULT_DUMP_DIR_MODE);\n    if (dst_fd < 0)\n    {\n        log_notice(\"Failed to create file '\"FILENAME_BINARY\"' at '%s'\", dd->dd_dirname);\n        close(src_fd_binary);\n        return -1;\n    }\n\n    IGNORE_RESULT(fchown(dst_fd, dd->dd_uid, dd->dd_gid));\n\n    off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);\n    close(src_fd_binary);\n\n    return fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0;\n}", "answer": "NO", "cwe": "59", "idx": "42899"}
{"code": "void ff_fix_long_mvs(MpegEncContext * s, uint8_t *field_select_table, int field_select, \n\n                     int16_t (*mv_table)[2], int f_code, int type, int truncate)\n\n{\n\n    MotionEstContext * const c= &s->me;\n\n    int y, h_range, v_range;\n\n\n\n    \n\n    int range = (((s->out_format == FMT_MPEG1) ? 8 : 16) << f_code);\n\n\n\n    if(s->msmpeg4_version) range= 16;\n\n    if(c->avctx->me_range && range > c->avctx->me_range) range= c->avctx->me_range;\n\n\n\n    h_range= range;\n\n    v_range= field_select_table ? range>>1 : range;\n\n\n\n    \n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= y*s->mb_stride;\n\n        for(x=0; x<s->mb_width; x++){\n\n            if (s->mb_type[xy] & type){    \n\n                if(field_select_table==NULL || field_select_table[xy] == field_select){\n\n                    if(   mv_table[xy][0] >=h_range || mv_table[xy][0] <-h_range\n\n                       || mv_table[xy][1] >=v_range || mv_table[xy][1] <-v_range){\n\n\n\n                        if(truncate){\n\n                            if     (mv_table[xy][0] > h_range-1) mv_table[xy][0]=  h_range-1;\n\n                            else if(mv_table[xy][0] < -h_range ) mv_table[xy][0]= -h_range;\n\n                            if     (mv_table[xy][1] > v_range-1) mv_table[xy][1]=  v_range-1;\n\n                            else if(mv_table[xy][1] < -v_range ) mv_table[xy][1]= -v_range;\n\n                        }else{\n\n                            s->mb_type[xy] &= ~type;\n\n                            s->mb_type[xy] |= CANDIDATE_MB_TYPE_INTRA;\n\n                            mv_table[xy][0]=\n\n                            mv_table[xy][1]= 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            xy++;\n\n        }\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "2f300f8965793c3bb9f9d753fcd4542f94f4c58a"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            _spawnvp(_P_WAIT, COMMAND_INT, args);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        \n        strcat(data, \"*.*\");\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            \n            \n            _spawnvp(_P_WAIT, COMMAND_INT, args);\n        }\n    }\n}\n\nvoid _OS_Command_Injection__char_listen_socket_w32_spawnvp_32()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_32();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_listen_socket_w32_spawnvp_32();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246336"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#define FOPEN _wfopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_console_fopen_61\n{\n\n#ifndef OMITM\n\n\nwchar_t * mSource(wchar_t * data);\n\nvoid m()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = mSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nwchar_t * nG2BSource(wchar_t * data);\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = nG2BSource(data);\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_console_fopen_61; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91053"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH L\"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH L\"/tmp/\"\n#endif\n\n#define ENV_VARIABLE L\"ADD\"\n\n#ifdef _WIN32\n#define GETENV _wgetenv\n#else\n#define GETENV getenv\n#endif\n\n#ifdef _WIN32\n#define OPEN _wopen\n#define CLOSE _close\n#else\n#include <unistd.h>\n#define OPEN open\n#define CLOSE close\n#endif\n\nnamespace _Relative_Path_Traversal__wchar_t_environment_open_44\n{\n\n#ifndef OMITM\n\nstatic void mSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nvoid m()\n{\n    wchar_t * data;\n    \n    void (*funcPtr) (wchar_t *) = mSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        \n        if (environment != NULL)\n        {\n            \n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    \n    funcPtr(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2BSink(wchar_t * data)\n{\n    {\n        int fileDesc;\n        \n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = nG2BSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    wcscat(data, L\"file.txt\");\n    funcPtr(data);\n}\n\nvoid n()\n{\n    nG2B();\n}\n\n#endif \n\n} \n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace _Relative_Path_Traversal__wchar_t_environment_open_44; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    n();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    m();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "23", "idx": "91431"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH \"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT \"cmd.exe\"\n#define COMMAND_ARG1 \"/c\"\n#define COMMAND_ARG2 \"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH \"/bin/sh\"\n#define COMMAND_INT \"sh\"\n#define COMMAND_ARG1 \"-c\"\n#define COMMAND_ARG2 \"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITM\n\n\nvoid _OS_Command_Injection__char_console_w32spawnl_54bSink(char * data);\n\nvoid _OS_Command_Injection__char_console_w32spawnl_54()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        \n        size_t dataLen = strlen(data);\n        \n        if (100-dataLen > 1)\n        {\n            \n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                \n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                \n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    _OS_Command_Injection__char_console_w32spawnl_54bSink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _OS_Command_Injection__char_console_w32spawnl_54bG2BSink(char * data);\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    strcat(data, \"*.*\");\n    _OS_Command_Injection__char_console_w32spawnl_54bG2BSink(data);\n}\n\nvoid _OS_Command_Injection__char_console_w32spawnl_54()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__char_console_w32spawnl_54();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__char_console_w32spawnl_54();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "244931"}
{"code": "static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) {\n\n    int num_pos_channels = 0;\n\n    int first_cpe = 0;\n\n    int sce_parity = 0;\n\n    int i;\n\n    for (i = *current; i < tags; i++) {\n\n        if (layout_map[i][2] != pos)\n\n            break;\n\n        if (layout_map[i][0] == TYPE_CPE) {\n\n            if (sce_parity) {\n\n                if (pos == AAC_CHANNEL_FRONT || !first_cpe) {\n\n                    sce_parity = 0;\n\n                } else {\n\n                    return -1;\n\n                }\n\n            }\n\n            num_pos_channels += 2;\n\n            first_cpe = 1;\n\n        } else {\n\n            num_pos_channels++;\n\n            sce_parity ^= 1;\n\n        }\n\n    }\n\n    if (sce_parity &&\n\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n\n            return -1;\n\n    *current = i;\n\n    return num_pos_channels;\n\n}", "answer": "NO", "cwe": "0", "idx": "a8d67efa53dae1d14614e3a7bd4e77e4eab066ab"}
{"code": "size_t iov_memset(const struct iovec *iov, const unsigned int iov_cnt,\n\n                 size_t iov_off, int fillc, size_t size)\n\n{\n\n    size_t iovec_off, buf_off;\n\n    unsigned int i;\n\n\n\n    iovec_off = 0;\n\n    buf_off = 0;\n\n    for (i = 0; i < iov_cnt && size; i++) {\n\n        if (iov_off < (iovec_off + iov[i].iov_len)) {\n\n            size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);\n\n\n\n            memset(iov[i].iov_base + (iov_off - iovec_off), fillc, len);\n\n\n\n            buf_off += len;\n\n            iov_off += len;\n\n            size -= len;\n\n        }\n\n        iovec_off += iov[i].iov_len;\n\n    }\n\n    return buf_off;\n\n}", "answer": "NO", "cwe": "0", "idx": "2278a69e7020d86a8c73a28474e7709d3e7d5081"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_listen_socket_09()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcat(data, \"Doe, XXXXX\");\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_listen_socket_09()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_listen_socket_09();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_listen_socket_09();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "123047"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#include <Winldap.h>\n\n#pragma comment(lib, \"wldap32\")\n\n#ifndef OMITM\n\nvoid _LDAP_Injection__w32_char_connect_socket_41Sink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_41()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    _LDAP_Injection__w32_char_connect_socket_41Sink(data);\n}\n\n#endif \n\n#ifndef OMITN\n\nvoid _LDAP_Injection__w32_char_connect_socket_41G2BSink(char * data)\n{\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        char filter[256];\n        \n        _snprintf(filter, 256-1, \"(cn=%s)\", data);\n        pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sA(\n                            pLdapConnection,\n                            \"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        \n        \n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        \n        ldap_unbind(pLdapConnection);\n    }\n}\n\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    \n    strcat(data, \"Doe, XXXXX\");\n    _LDAP_Injection__w32_char_connect_socket_41G2BSink(data);\n}\n\nvoid _LDAP_Injection__w32_char_connect_socket_41()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _LDAP_Injection__w32_char_connect_socket_41();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _LDAP_Injection__w32_char_connect_socket_41();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "90", "idx": "122871"}
{"code": "static int available_error_type_show(struct seq_file *m, void *v)\n{\n\tint rc;\n\tu32 available_error_type = 0;\n\n\trc = einj_get_available_error_type(&available_error_type);\n\tif (rc)\n\t\treturn rc;\n\tif (available_error_type & 0x0001)\n\t\tseq_printf(m, \"0x00000001\\tProcessor Correctable\\n\");\n\tif (available_error_type & 0x0002)\n\t\tseq_printf(m, \"0x00000002\\tProcessor Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0004)\n\t\tseq_printf(m, \"0x00000004\\tProcessor Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0008)\n\t\tseq_printf(m, \"0x00000008\\tMemory Correctable\\n\");\n\tif (available_error_type & 0x0010)\n\t\tseq_printf(m, \"0x00000010\\tMemory Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0020)\n\t\tseq_printf(m, \"0x00000020\\tMemory Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0040)\n\t\tseq_printf(m, \"0x00000040\\tPCI Express Correctable\\n\");\n\tif (available_error_type & 0x0080)\n\t\tseq_printf(m, \"0x00000080\\tPCI Express Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0100)\n\t\tseq_printf(m, \"0x00000100\\tPCI Express Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0200)\n\t\tseq_printf(m, \"0x00000200\\tPlatform Correctable\\n\");\n\tif (available_error_type & 0x0400)\n\t\tseq_printf(m, \"0x00000400\\tPlatform Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0800)\n\t\tseq_printf(m, \"0x00000800\\tPlatform Uncorrectable fatal\\n\");\n\n\treturn 0;\n}", "answer": "NO", "cwe": "74", "idx": "73878"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else \n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#include <process.h>\n#define EXECL _wexecl\n#else \n#define EXECL execl\n#endif\n\n#ifndef OMITM\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_execl_31()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        \n        \n        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic void nG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    \n    wcscat(data, L\"*.*\");\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        \n        \n        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid _OS_Command_Injection__wchar_t_connect_socket_execl_31()\n{\n    nG2B();\n}\n\n#endif \n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_execl_31();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _OS_Command_Injection__wchar_t_connect_socket_execl_31();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "78", "idx": "246383"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32\")\n\n#define LISTEN_PORT 999\n#define LISTEN_BACKLOG 5\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nstatic int mStatic = 0;\n\nstatic char * mSource(char * data)\n{\n    if(mStatic)\n    {\n        {\n            WSADATA wsaData;\n            BOOL wsaDataInit = FALSE;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            struct sockaddr_in service;\n            int recvResult;\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(LISTEN_PORT);\n                if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n                {\n                    break;\n                }\n                if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, data, 100 - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                data[recvResult] = '\\0';\n            }\n            while (0);\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    return data;\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_21()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    mStatic = 1; \n    data = mSource(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n#endif \n\n#ifndef OMITN\n\n\nstatic int nG2B1Static = 0;\nstatic int nG2B2Static = 0;\n\n\nstatic char * nG2B1Source(char * data)\n{\n    if(nG2B1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    return data;\n}\n\nstatic void nG2B1()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2B1Static = 0; \n    data = nG2B1Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\n\nstatic char * nG2B2Source(char * data)\n{\n    if(nG2B2Static)\n    {\n        \n        strcpy(data, \"hostname\");\n    }\n    return data;\n}\n\nstatic void nG2B2()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    nG2B2Static = 1; \n    data = nG2B2Source(data);\n    \n    if (!SetComputerNameA(data))\n    {\n        printLine(\"Failure setting computer name\");\n        exit(1);\n    }\n}\n\nvoid _External_Control_of_System_or_Configuration_Setting__w32_21()\n{\n    nG2B1();\n    nG2B2();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_21();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _External_Control_of_System_or_Configuration_Setting__w32_21();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "15", "idx": "81996"}
{"code": "void ide_bus_reset(IDEBus *bus)\n\n{\n\n    bus->unit = 0;\n\n    bus->cmd = 0;\n\n    ide_reset(&bus->ifs[0]);\n\n    ide_reset(&bus->ifs[1]);\n\n    ide_clear_hob(bus);\n\n\n\n    \n\n    if (bus->dma->aiocb) {\n\n#ifdef DEBUG_AIO\n\n        printf(\"aio_cancel\\n\");\n\n#endif\n\n        bdrv_aio_cancel(bus->dma->aiocb);\n\n        bus->dma->aiocb = NULL;\n\n    }\n\n\n\n    \n\n    if (bus->dma->ops->reset) {\n\n        bus->dma->ops->reset(bus->dma);\n\n    }\n\n}", "answer": "NO", "cwe": "0", "idx": "4be746345f13e99e468c60acbd3a355e8183e3ce"}
{"code": "void HTMLMediaElement::durationChanged() {\n  BLINK_MEDIA_LOG << \"durationChanged(\" << (void*)this << \")\";\n\n  CHECK(m_webMediaPlayer);\n  double newDuration = m_webMediaPlayer->duration();\n\n  durationChanged(newDuration, currentPlaybackPosition() > newDuration);\n}", "answer": "NO", "cwe": "119", "idx": "139976"}
{"code": "char *get_rundir()\n{\n\tchar *rundir;\n\tconst char *homedir;\n\n\tif (geteuid() == 0) {\n\t\trundir = strdup(RUNTIME_PATH);\n\t\treturn rundir;\n\t}\n\n\trundir = getenv(\"XDG_RUNTIME_DIR\");\n\tif (rundir) {\n\t\trundir = strdup(rundir);\n\t\treturn rundir;\n\t}\n\n\tINFO(\"XDG_RUNTIME_DIR isn't set in the environment.\");\n\thomedir = getenv(\"HOME\");\n\tif (!homedir) {\n\t\tERROR(\"HOME isn't set in the environment.\");\n\t\treturn NULL;\n\t}\n\n\trundir = malloc(sizeof(char) * (17 + strlen(homedir)));\n\tsprintf(rundir, \"%s/.cache/lxc/run/\", homedir);\n\n\treturn rundir;\n}", "answer": "NO", "cwe": "59", "idx": "44674"}
{"code": "xmit_seg(E1000State *s)\n\n{\n\n    uint16_t len;\n\n    unsigned int frames = s->tx.tso_frames, css, sofar;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (tp->props.tse && tp->props.cptse) {\n\n        css = tp->props.ipcss;\n\n        DBGOUT(TXSUM, \"frames %d size %d ipcss %d\\n\",\n\n               frames, tp->size, css);\n\n        if (tp->props.ip) {    \n\n            stw_be_p(tp->data+css+2, tp->size - css);\n\n            stw_be_p(tp->data+css+4,\n\n                     lduw_be_p(tp->data + css + 4) + frames);\n\n        } else {         \n\n            stw_be_p(tp->data+css+4, tp->size - css);\n\n        }\n\n        css = tp->props.tucss;\n\n        len = tp->size - css;\n\n        DBGOUT(TXSUM, \"tcp %d tucss %d len %d\\n\", tp->props.tcp, css, len);\n\n        if (tp->props.tcp) {\n\n            sofar = frames * tp->props.mss;\n\n            stl_be_p(tp->data+css+4, ldl_be_p(tp->data+css+4)+sofar); \n\n            if (tp->props.paylen - sofar > tp->props.mss) {\n\n                tp->data[css + 13] &= ~9;    \n\n            } else if (frames) {\n\n                e1000x_inc_reg_if_not_full(s->mac_reg, TSCTC);\n\n            }\n\n        } else    \n\n            stw_be_p(tp->data+css+4, len);\n\n        if (tp->props.sum_needed & E1000_TXD_POPTS_TXSM) {\n\n            unsigned int phsum;\n\n            \n\n            void *sp = tp->data + tp->props.tucso;\n\n\n\n            phsum = lduw_be_p(sp) + len;\n\n            phsum = (phsum >> 16) + (phsum & 0xffff);\n\n            stw_be_p(sp, phsum);\n\n        }\n\n        tp->tso_frames++;\n\n    }\n\n\n\n    if (tp->props.sum_needed & E1000_TXD_POPTS_TXSM) {\n\n        putsum(tp->data, tp->size, tp->props.tucso,\n\n               tp->props.tucss, tp->props.tucse);\n\n    }\n\n    if (tp->props.sum_needed & E1000_TXD_POPTS_IXSM) {\n\n        putsum(tp->data, tp->size, tp->props.ipcso,\n\n               tp->props.ipcss, tp->props.ipcse);\n\n    }\n\n    if (tp->vlan_needed) {\n\n        memmove(tp->vlan, tp->data, 4);\n\n        memmove(tp->data, tp->data + 4, 8);\n\n        memcpy(tp->data + 8, tp->vlan_header, 4);\n\n        e1000_send_packet(s, tp->vlan, tp->size + 4);\n\n    } else {\n\n        e1000_send_packet(s, tp->data, tp->size);\n\n    }\n\n\n\n    e1000x_inc_reg_if_not_full(s->mac_reg, TPT);\n\n    e1000x_grow_8reg_if_not_full(s->mac_reg, TOTL, s->tx.size);\n\n    s->mac_reg[GPTC] = s->mac_reg[TPT];\n\n    s->mac_reg[GOTCL] = s->mac_reg[TOTL];\n\n    s->mac_reg[GOTCH] = s->mac_reg[TOTH];\n\n}", "answer": "NO", "cwe": "0", "idx": "7d08c73e7bdc39b10e5f2f5acdce700f17ffe962"}
{"code": "\n\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#include <windows.h>\n\n#ifndef OMITM\n\n\nvoid _Process_Control__w32_char_relativePath_63bSink(char * * dataPtr);\n\nvoid _Process_Control__w32_char_relativePath_63()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"winsrv.dll\");\n    _Process_Control__w32_char_relativePath_63bSink(&data);\n}\n\n#endif \n\n#ifndef OMITN\n\n\nvoid _Process_Control__w32_char_relativePath_63bG2BSink(char * * data);\n\nstatic void nG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    \n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    _Process_Control__w32_char_relativePath_63bG2BSink(&data);\n}\n\nvoid _Process_Control__w32_char_relativePath_63()\n{\n    nG2B();\n}\n\n#endif \n\n\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITN\n    printLine(\"Calling n()...\");\n    _Process_Control__w32_char_relativePath_63();\n    printLine(\"Finished n()\");\n#endif \n#ifndef OMITM\n    printLine(\"Calling m()...\");\n    _Process_Control__w32_char_relativePath_63();\n    printLine(\"Finished m()\");\n#endif \n    return 0;\n}\n\n#endif", "answer": "YES", "cwe": "114", "idx": "62215"}
